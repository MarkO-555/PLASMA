include "inc/cmdsys.plh"
include "inc/fileio.plh"
include "dhgr.tk/inc/dhgrlib.plh"
include "dhgr.tk/inc/dhgrutils.plh"

const page1m = $C054
const page1x = $C055
//
// Font type bits
//
const FONT_MONO   = $00
const FONT_PROP   = $80
const FONT_BITMAP = $00
const FONT_PIXMAP = $40
//
// Font header
//
struc t_font
  byte[] fnt_typelen
  char   fnt_name[16]
  byte   fnt_first
  byte   fnt_last
  byte   fnt_width
  byte   fnt_height
  var    fnt_glyptrs[]
end
//
// Variable pitch glyphs
//
struc t_glyph
  var  gly_left
  var  gly_top
  byte gly_width
  byte gly_height
  byte gly_adv
  byte gly_strike[]
end
//
// Apple //e hires character font
//
byte[] Apple2Glyphs
byte = $00,$00,$00,$00,$00,$00,$00,$00,$08,$08,$08,$08,$08,$00,$08,$00
byte = $14,$14,$14,$00,$00,$00,$00,$00,$14,$14,$3E,$14,$3E,$14,$14,$00
byte = $08,$3C,$0A,$1C,$28,$1E,$08,$00,$06,$26,$10,$08,$04,$32,$30,$00
byte = $04,$0A,$0A,$04,$2A,$12,$2C,$00,$08,$08,$08,$00,$00,$00,$00,$00
byte = $08,$04,$02,$02,$02,$04,$08,$00,$08,$10,$20,$20,$20,$10,$08,$00
byte = $08,$2A,$1C,$08,$1C,$2A,$08,$00,$00,$08,$08,$3E,$08,$08,$00,$00
byte = $00,$00,$00,$00,$08,$08,$04,$00,$00,$00,$00,$3E,$00,$00,$00,$00
byte = $00,$00,$00,$00,$00,$00,$08,$00,$00,$20,$10,$08,$04,$02,$00,$00
byte = $1C,$22,$32,$2A,$26,$22,$1C,$00,$08,$0C,$08,$08,$08,$08,$1C,$00
byte = $1C,$22,$20,$18,$04,$02,$3E,$00,$3E,$20,$10,$18,$20,$22,$1C,$00
byte = $10,$18,$14,$12,$3E,$10,$10,$00,$3E,$02,$1E,$20,$20,$22,$1C,$00
byte = $38,$04,$02,$1E,$22,$22,$1C,$00,$3E,$20,$10,$08,$04,$04,$04,$00
byte = $1C,$22,$22,$1C,$22,$22,$1C,$00,$1C,$22,$22,$3C,$20,$10,$0E,$00
byte = $00,$00,$08,$00,$08,$00,$00,$00,$00,$00,$08,$00,$08,$08,$04,$00
byte = $10,$08,$04,$02,$04,$08,$10,$00,$00,$00,$3E,$00,$3E,$00,$00,$00
byte = $04,$08,$10,$20,$10,$08,$04,$00,$1C,$22,$10,$08,$08,$00,$08,$00
byte = $1C,$22,$2A,$3A,$1A,$02,$3C,$00,$08,$14,$22,$22,$3E,$22,$22,$00
byte = $1E,$22,$22,$1E,$22,$22,$1E,$00,$1C,$22,$02,$02,$02,$22,$1C,$00
byte = $1E,$22,$22,$22,$22,$22,$1E,$00,$3E,$02,$02,$1E,$02,$02,$3E,$00
byte = $3E,$02,$02,$1E,$02,$02,$02,$00,$3C,$02,$02,$02,$32,$22,$3C,$00
byte = $22,$22,$22,$3E,$22,$22,$22,$00,$1C,$08,$08,$08,$08,$08,$1C,$00
byte = $20,$20,$20,$20,$20,$22,$1C,$00,$22,$12,$0A,$06,$0A,$12,$22,$00
byte = $02,$02,$02,$02,$02,$02,$3E,$00,$22,$36,$2A,$2A,$22,$22,$22,$00
byte = $22,$22,$26,$2A,$32,$22,$22,$00,$1C,$22,$22,$22,$22,$22,$1C,$00
byte = $1E,$22,$22,$1E,$02,$02,$02,$00,$1C,$22,$22,$22,$2A,$12,$2C,$00
byte = $1E,$22,$22,$1E,$0A,$12,$22,$00,$1C,$22,$02,$1C,$20,$22,$1C,$00
byte = $3E,$08,$08,$08,$08,$08,$08,$00,$22,$22,$22,$22,$22,$22,$1C,$00
byte = $22,$22,$22,$22,$22,$14,$08,$00,$22,$22,$22,$2A,$2A,$36,$22,$00
byte = $22,$22,$14,$08,$14,$22,$22,$00,$22,$22,$14,$08,$08,$08,$08,$00
byte = $3E,$20,$10,$08,$04,$02,$3E,$00,$3E,$06,$06,$06,$06,$06,$3E,$00
byte = $00,$02,$04,$08,$10,$20,$00,$00,$3E,$30,$30,$30,$30,$30,$3E,$00
byte = $00,$00,$08,$14,$22,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$7F
byte = $04,$08,$10,$00,$00,$00,$00,$00,$00,$00,$1C,$20,$3C,$22,$3C,$00
byte = $02,$02,$1E,$22,$22,$22,$1E,$00,$00,$00,$3C,$02,$02,$02,$3C,$00
byte = $20,$20,$3C,$22,$22,$22,$3C,$00,$00,$00,$1C,$22,$3E,$02,$3C,$00
byte = $18,$24,$04,$1E,$04,$04,$04,$00,$00,$00,$1C,$22,$22,$3C,$20,$1C
byte = $02,$02,$1E,$22,$22,$22,$22,$00,$08,$00,$0C,$08,$08,$08,$1C,$00
byte = $10,$00,$18,$10,$10,$10,$12,$0C,$02,$02,$22,$12,$0E,$12,$22,$00
byte = $0C,$08,$08,$08,$08,$08,$1C,$00,$00,$00,$36,$2A,$2A,$22,$22,$00
byte = $00,$00,$1E,$22,$22,$22,$22,$00,$00,$00,$1C,$22,$22,$22,$1C,$00
byte = $00,$00,$1E,$22,$22,$1E,$02,$02,$00,$00,$3C,$22,$22,$3C,$20,$20
byte = $00,$00,$3A,$06,$02,$02,$02,$00,$00,$00,$3C,$02,$1C,$20,$1E,$00
byte = $04,$04,$1E,$04,$04,$24,$18,$00,$00,$00,$22,$22,$22,$32,$2C,$00
byte = $00,$00,$22,$22,$22,$14,$08,$00,$00,$00,$22,$22,$2A,$2A,$36,$00
byte = $00,$00,$22,$14,$08,$14,$22,$00,$00,$00,$22,$22,$22,$3C,$20,$1C
byte = $00,$00,$3E,$10,$08,$04,$3E,$00,$38,$0C,$0C,$06,$0C,$0C,$38,$00
byte = $08,$08,$08,$08,$08,$08,$08,$08,$0E,$18,$18,$30,$18,$18,$0E,$00
byte = $00,$2C,$1A,$00,$00,$00,$00,$00,$00,$2A,$14,$2A,$14,$2A,$00,$00
//
// Default wide font header
//
export byte[] fontDefWide
char[16] = "Default Wide"
byte = 32, 127 // first, last
byte = 7, 8 // width, height
var  = @Apple2Glyphs
//
// Default narrow font header (unallocated)
//
export byte[] fontDefThin
char[16] = "Default Thin"
byte = 32, 127 // first, last
byte = 4, 8 // width, height
var  = NULL
//
// Current font
//
var fontPtr = @fontDefWide
//
// Function pointers
//
export asm dcgrStr(x, y, strptr)#2
        JMP     $2000
end
//
// Utility functions
//
export def dhgrAllocBl7Mem(w, h)#2
    word memblk, span

    span   = (w+13)/14 << 3
    memblk = heapalloc(span * h)
    return memblk, span
end
def bitMonoGlyphStr(x, y, strptr)#2
    byte first, last, width, height, size, i, ch
    var strikes

    first   = fontPtr->fnt_first
    last    = fontPtr->fnt_last
    width   = fontPtr->fnt_width
    height  = fontPtr->fnt_height
    strikes = fontPtr=>fnt_glyptrs
    size    = (width + 7) / 8 * height
    for i = 1 to ^strptr
        ch = ^(strptr + i)
        if ch >= first and ch <= last
            dcgrBitmap(x, y, width, height, strikes + (^(strptr + i) - first) * size)
            x = x + width
        else
            when ch
                is '\n'
                    x = 0
                    y = y + fontPtr->fnt_height
                    break
                is '\t'
                    x = x + (fontPtr->fnt_width * 8)
                    break
            wend
        fin
    next
    return x, y
end
def pixPropGlyphStr(x, y, strptr)#2
    var glyptrs, glyph
    byte first, last, i, ch

    dhgrOp(OP_XOR)
    first   = fontPtr->fnt_first
    last    = fontPtr->fnt_last
    glyptrs = fontPtr + fnt_glyptrs
    for i = 1 to ^strptr
        ch = ^(strptr + i)
        if ch >= first and ch <= last
            glyph  = glyptrs=>[ch - first]
            dcgrPixmap((x + glyph=>gly_left) / 4, \
                        y + glyph=>gly_top,       \
                        glyph->gly_width,         \
                        glyph->gly_height,        \
                        glyph + gly_strike)
            x = x + glyph->gly_adv
        else
            when ch
                is '\n'
                    x = 0
                    y = y + fontPtr->fnt_height
                    break
                is '\t'
                    x = x + (fontPtr->fnt_width * 8)
                    break
            wend
        fin
    next
    return x, y
end

def bitPropGlyphStr(x, y, strptr)#2
    var glyptrs, glyph
    byte first, last, i, ch

    dhgrOp(OP_SRC)
    first   = fontPtr->fnt_first
    last    = fontPtr->fnt_last
    glyptrs = fontPtr + fnt_glyptrs
    for i = 1 to ^strptr
        ch = ^(strptr + i)
        if ch >= first and ch <= last
            glyph  = glyptrs=>[ch - first]
            dcgrBitmap(x + glyph=>gly_left, \
                       y + glyph=>gly_top,  \
                       glyph->gly_width,    \
                       glyph->gly_height,   \
                       glyph + gly_strike)
            x = x + glyph->gly_adv
        else
            when ch
                is '\n'
                    x = 0
                    y = y + fontPtr->fnt_height
                    break
                is '\t'
                    x = x + (fontPtr->fnt_width * 4)
                    break
            wend
        fin
    next
    return x, y
end
export def dcgrBoldStr(clr, x, y, strptr)#2
    byte h, v

    for v = y - 1 to y + 1
        for h = x - 1 to x + 1
            dcgrStr(h, v, strptr)
        next
    next
    dcgrColor(clr)
    return dcgrStr(x, y, strptr)
end
export def dcgrFont(font)#0
    var  rows, pWide, pThin
    byte bits

    if font
        if font == @fontDefThin
            if not fontDefThin:fnt_glyptrs
                pWide = @Apple2Glyphs
                pThin = heapalloc(96*8)
                fontDefThin:fnt_glyptrs = pThin
                for rows = 0 to 96*8
                    bits =        (^pWide                            ) & $02
                    bits = bits | (^pWide | ^pWide >> 1 | ^pWide >> 2) & $04
                    bits = bits | (                       ^pWide >> 2) & $08
                    ^pThin = bits
                    pThin++
                    pWide++
                next
            fin
        fin
        fontPtr = font
        if fontPtr->fnt_typelen & FONT_PROP
            if fontPtr->fnt_typelen & FONT_PIXMAP
                dcgrStr:1 = @pixPropGlyphStr
            else
                dcgrStr:1 = @bitPropGlyphStr
            fin
        else // FONT_MONO
            dcgrStr:1 = @bitMonoGlyphStr
        fin
    fin
end
export def fontRead(filename)#1
    var glyph, strksize, left, top
    byte refnum, num, i, width, height, adv
    byte roundup, pixbyte
    var font_header, gly_ptr

    font_header = NULL
    if filename and ^filename
        refnum = fileio:open(filename)
        if refnum
            font_header = heapalloc(t_font)
            fileio:read(refnum, font_header, t_font)
            num = font_header->fnt_last - font_header->fnt_first
            if font_header->fnt_typelen & FONT_PROP
                gly_ptr = heapalloc(num * 2) // Allocate glyph ptrs right after
                if font_header->fnt_typelen & FONT_PIXMAP
                    roundup = 1
                    pixbyte = 2
                else
                    roundup = 7
                    pixbyte = 8
                fin
                for i = 1 to num
                    fileio:read(refnum, @left,   1); left = sext(left)
                    fileio:read(refnum, @top,    1); top  = sext(top)
                    fileio:read(refnum, @width,  1)
                    fileio:read(refnum, @height, 1)
                    fileio:read(refnum, @adv,    1)
                    strksize = (width + roundup) / pixbyte * height
                    if strksize
                        *gly_ptr = heapalloc(strksize + t_glyph)
                        glyph = *gly_ptr
                        if glyph and fileio:read(refnum, glyph + gly_strike, strksize) == strksize
                            glyph=>gly_left   = left
                            glyph=>gly_top    = top
                            glyph->gly_width  = width
                            glyph->gly_height = height
                            glyph->gly_adv    = adv
                        else
                            heaprelease(font_header)
                            font_header = NULL
                            break
                        fin
                    else
                        *gly_ptr = NULL
                    fin
                    gly_ptr = gly_ptr + 2
                next
            fin
            fileio:close(refnum)
        fin
    fin
    return font_header
end
export def dcgrRect(x, y, w, h)#0
    byte x2, y2, v

    x2 = x + w - 1
    y2 = y + h - 1
    for v = y to y2
        dcgrHLin(x, x2, v)
    next
end
export def dcgrGetPixMap(x, y, w, h)#1
    var pixmap, pixptr
    byte i, j

    pixmap = heapalloc((w + 1)/2 * h)
    pixptr = pixmap
    w--; h--
    for j = 0 to h
        for i = 0 to w step 2
            ^pixptr = dcgrGetPixel(i+x,j+y)|(dcgrGetPixel(i+x+1,j+y)<<4)
            pixptr++
        next
    next
    return pixmap
end
export def dcgrEncPixMap(w, h, pixmap, rlemap)#1
    var rleptr
    byte i, j, run, pixrun

    rleptr = rlemap
    w--; h--
    for j = 0 to h
        run = 0
        for i = 0 to w step 2
            if run and ^pixmap == pixrun
                run++
            else
                if run
                    *rleptr = run*2 | (pixrun << 8)
                    //puth(*rleptr); putc(',')
                    rleptr  = rleptr + 2
                fin
                run    = 1
                pixrun = ^pixmap
            fin
            pixmap++
        next
        *rleptr = run*2 | (pixrun << 8)
        //puth(*rleptr); putln
        rleptr  = rleptr + 2
    next
    return rleptr - rlemap
end
export def spriteRead(filestr)#5
    var sprptr, sprsize, xorg, yorg
    byte refnum, width, height

    width  = 0
    height = 0
    sprptr = 0
    refnum = fileio:open(filestr)
    if refnum
        fileio:read(refnum, @xorg,   1); xorg = sext(xorg)
        fileio:read(refnum, @yorg,   1); yorg = sext(yorg)
        fileio:read(refnum, @width,  1)
        fileio:read(refnum, @height, 1)
        if width <= 40 and height <= 48
            sprsize = (width + 1) / 2 * height
            sprptr = heapalloc(sprsize)
            if sprptr
                if fileio:read(refnum, sprptr,  sprsize) <> sprsize
                    heaprelease(sprptr)
                    sprptr = NULL
                fin
            fin
        fin
        fileio:close(refnum)
    fin
    return xorg, yorg, width, height, sprptr
end
export def spriteWrite(filestr, xorg, yorg, width, height, sprptr)#1
    var sprsize
    byte refnum, i, result

    sprsize = (width + 1) / 2 * height
    fileio:destroy(filestr)
    result = fileio:create(filestr, $06, $0000)
    if result == FILE_ERR_OK
        refnum = fileio:open(filestr)
        if refnum
            fileio:write(refnum, @xorg,   1)
            fileio:write(refnum, @yorg,   1)
            fileio:write(refnum, @width,  1)
            fileio:write(refnum, @height, 1)
            sprsize = (width + 1) / 2 * height
            fileio:write(refnum, sprptr,  sprsize)
            result = perr
            fileio:close(refnum)
        else
            result = perr
        fin
    fin
    return result
end
export def screenRead(filestr)#1
    byte refnum

    refnum = fileio:open(filestr)
    if refnum
        ^page1x // Read AUX bytes
        fileio:read(refnum, $2000, $2000)
        ^page1m // Read MAIN bytes
        fileio:read(refnum, $2000, $2000)
        fileio:close(refnum)
    fin
    return perr
end
export def screenWrite(filestr)#1
    byte refnum, result

    fileio:destroy(filestr)
    result = fileio:create(filestr, $06, $2000)
    if result == FILE_ERR_OK
        refnum = fileio:open(filestr)
        if refnum
            ^page1x // Write AUX bytes
            if fileio:write(refnum, $2000, $2000) == $2000
                ^page1m // Write MAIN bytes
                fileio:write(refnum, $2000, $2000)
            fin
            result = perr
            fileio:close(refnum)
        else
            result = perr
        fin
    fin
    return result
end

//
// Fixups
//
dcgrStr:1 = @bitMonoGlyphStr
done
