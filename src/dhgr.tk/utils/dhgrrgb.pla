include "inc/cmdsys.plh"
include "inc/args.plh"
include "inc/fileio.plh"
include "inc/int32.plh"
include "dhgr.tk/inc/dhgrlib.plh"
include "dhgr.tk/inc/dhgrutils.plh"

sysflags resxtxt1|reshgr1|resxhgr1

const RED = 0
const GRN = 1
const BLU = 2
const MAX_RGB = 512
const MIN_RGB = -256

byte[] ntscChroma
// Imperical 0-255     R    G    B
byte[]              =  64,  51, 125 // BLUE
byte[]              =   0, 108,  64 // GREEN
byte[]              =  64,  77,   3 // BROWN
byte[]              = 128,  20,  64 // RED
// Calculated 0-255     R    G    B
byte[]              =  32,  46, 120 // BLUE
byte[]              =   8, 126,  32 // GREEN
byte[]              =  96,  82,   8 // BROWN
byte[]              = 120,   2,  96 // RED
// Idealized 0-255     R    G    B
byte[]              =  64,  48, 128 // BLUE
byte[]              =  16, 112,  64 // GREEN
byte[]              =  64,  80,   0 // BROWN
byte[]              = 112,  16,  64 // RED
byte[12] ntscCycle
byte[256+3] gamma
var rgbErr // Running color error array
byte errDiv = 3
var arg

def dist(x1, y1, z1, x2, y2, z2)#2
  res[t_i32] xx, yy

  x2 = x2 - x1
  y2 = y2 - y1
  z2 = z2 - z1
  loadi16(x2)
  muli16(x2)
  store32(@xx)
  loadi16(y2)
  muli16(y2)
  store32(@yy)
  loadi16(z2)
  muli16(z2)
  add32(@yy)
  add32(@xx)
  store32(@xx)
  return xx:[0], xx:[1]
end

def rgbPix(r, g, b, nr, ng, nb, x, y)#0
  var errptr
  var pr, pg, pb
  var lr, lg, lb
  var cr, cg, cb, cx
  byte i
  res[t_i32] pd, cd, nd

  // Error propogation
  errptr = rgbErr + x * 3 * 2
  if errDiv
    r = r + errptr=>[RED] / errDiv
    g = g + errptr=>[GRN] / errDiv
    b = b + errptr=>[BLU] / errDiv
  fin
  pr = 0
  pg = 0
  pb = 0
  // Previous 3/4 chroma cycle
  for cx = x - 1 downto x - 3
    i  = (cx & 3) * 3
    pr = pr + ntscCycle[i+RED]
    pg = pg + ntscCycle[i+GRN]
    pb = pb + ntscCycle[i+BLU]
  next
  pd:[0], pd:[1] = dist(r, g, b, pr, pg, pb)
  // Look ahead in chroma cycle for possible better match for next RGB pixel
  i  = ((x + 1) & 3) * 3
  lr = pr - ntscCycle[i+RED] + ntscChroma[i+RED]
  lg = pg - ntscCycle[i+GRN] + ntscChroma[i+GRN]
  lb = pb - ntscCycle[i+BLU] + ntscChroma[i+BLU]
  if errDiv
    nr = nr + (errptr=>[3+RED] + r - lr) / errDiv
    ng = ng + (errptr=>[3+GRN] + g - lg) / errDiv
    nb = nb + (errptr=>[3+BLU] + b - lb) / errDiv
  fin
  nd:[0], nd:[1] = dist(nr, ng, nb, lr, lg, lb)
  // Current 1/4 chroma color
  i  = (x & 3) * 3
  cr = pr + ntscChroma[i+RED]
  cg = pg + ntscChroma[i+GRN]
  cb = pb + ntscChroma[i+BLU]
  cd:[0], cd:[1] = dist(r, g, b, cr, cg, cb)
  load32(@cd)
  if islt32(@pd) and islt32(@nd)
    // RGB better matched with current 1/4 chroma color
    nr = r - cr
    ng = g - cg
    nb = b - cb
    ntscCycle[i+RED] = ntscChroma[i+RED]
    ntscCycle[i+GRN] = ntscChroma[i+GRN]
    ntscCycle[i+BLU] = ntscChroma[i+BLU]
    dhgrSet(x, y)
  else
    // RGB closer to black
    nr = r - pr
    ng = g - pg
    nb = b - pb
    ntscCycle[i+RED] = 0
    ntscCycle[i+GRN] = 0
    ntscCycle[i+BLU] = 0
  fin
  // Propogate error down and forward
  errptr=>[RED] = nr
  errptr=>[GRN] = ng
  errptr=>[BLU] = nb
  errptr = errptr + 6
  errptr=>[RED] = nr + errptr=>[RED]
  errptr=>[GRN] = ng + errptr=>[GRN]
  errptr=>[BLU] = nb + errptr=>[BLU]
  // Map dark grey to light grey
  if (x & 3) == 3 and dcgrGetPixel(x >> 2, y) == 5
    dhgrOp(OP_SRC)
    dcgrColor(10)
    dcgrPixel(x >> 2, y)
  fin
end

def rgbInit#0
  var i

  if not gamma[1]
    for i = 0 to 255
      loadi16(i)
      muli16(i)
      addi16(127)
      divi16(255)
      store32(@gamma + i)
    next
  else
    for i = 0 to 255
      gamma[i] = i
    next
  fin
  dhgrMode(DHGR_COLOR_MODE)
  // Init error propogation array
  rgbErr = heapalloc(561 * 3 * 2)
  memset(rgberr, 0, 561 * 3 * 2)
  rgberr=>[RED] = -1
  rgberr=>[GRN] = -1
  rgberr=>[BLU] = -1
end

def rgbExit#0
  heaprelease(rgbErr)
  dhgrMode(DHGR_TEXT_MODE)
end

def rgbImportExport(rgbfile, dhgrfile)#0
  byte refnum, r, g, b, nxtr, nxtg, nxtb
  var i, j
  var rgbScanline, rgbptr

  refnum = fileio:open(rgbfile)
  if refnum
    rgbScanline = heapalloc(560 * 3)
    if rgbScanline
      rgbInit
      for j = 0 to 191
        fileio:read(refnum, rgbScanline,  560 * 3)
        rgbptr = rgbScanline
        nxtr = gamma[rgbptr->RED]
        nxtg = gamma[rgbptr->GRN]
        nxtb = gamma[rgbptr->BLU]
        for i = 0 to 559
          r = nxtr
          g = nxtg
          b = nxtb
          rgbptr = rgbptr + 3
          nxtr = gamma[rgbptr->RED]
          nxtg = gamma[rgbptr->GRN]
          nxtb = gamma[rgbptr->BLU]
          rgbPix(r, g, b, nxtr, nxtg, nxtb, i, j)
        next
        if ^$C000 == $83
          break
        fin
      next
      fileio:close(refnum)
      if ^dhgrfile
        screenWrite(dhgrfile)
      fin
      getc
      rgbExit
    fin
  else
    puts("Unable to read: "); puts(arg); putln
  fin
end

arg = argNext(argFirst)
if ^arg
  while ^(arg + 1) == '-'
    when toupper(^(arg + 2))
      is 'L' // Use linear RGB transfer instead of gama
        gamma[1] = 1
        break
      is 'E' // Set error strength
        if ^arg > 2
          errDiv = ^(arg + 3) - '0'
          if ^arg > 3
            errDiv = errDiv * 10 + ^(arg + 4) - '0'
          fin
        fin
        break
      is 'C' // Use calculated chroma values
        for gamma = 0 to 11
          ntscChroma[gamma] = ntscChroma[gamma + 12]
        next
        break
      is 'I' // Use idealized chroma values
        for gamma = 0 to 11
          ntscChroma[gamma] = ntscChroma[gamma + 24]
        next
        break
    wend
    arg = argNext(arg)
  loop
  if ^arg
    rgbImportExport(arg, argNext(arg))
  fin
  return 0
fin
puts("Usage: DHGRRGB [-T] [-L] [-E##] RGBFILE [DHGRFILE]\n")
done
