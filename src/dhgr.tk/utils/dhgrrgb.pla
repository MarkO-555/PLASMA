include "inc/cmdsys.plh"
include "inc/args.plh"
include "inc/fileio.plh"
include "dhgr.tk/inc/dhgrlib.plh"
include "dhgr.tk/inc/dhgrutils.plh"

sysflags resxtxt1|reshgr1|resxhgr1

const RED = 0
const GRN = 1
const BLU = 2
const RGB_MAX = 63
const ERR_MAX = 32
byte errDiv = 2

byte[] ntscChroma
// Imperical 0-255       R    G    B
//byte[]              =  64,  51, 127 // BLUE
//byte[]              =   0, 108,  64 // GREEN
//byte[]              =  64,  77,   1 // BROWN
//byte[]              = 128,  20,  64 // RED
// Imperical 0-63        R   G   B
byte[]              = 16, 12, 32 // BLUE
byte[]              =  0, 28, 16 // GREEN
byte[]              = 16, 20,  0 // BROWN
byte[]              = 32,  4, 16 // RED
// Calculated 0-255       R    G    B
//byte[]              =  32,  46, 120 // BLUE
//byte[]              =   8, 126,  32 // GREEN
//byte[]              =  96,  82,   8 // BROWN
//byte[]              = 120,   2,  96 // RED
// Calculated 0-63        R   G   B
//byte[]              =  8, 12, 30 // BLUE
//byte[]              =  2, 32,  8 // GREEN
//byte[]              = 24, 20,  2 // BROWN
//byte[]              = 30,  0, 24 // RED
// Ideal/simplified 0-63 R   G   B
//byte[]                = 16, 16, 32 // BLUE
//byte[]                =  0, 32, 16 // GREEN
//byte[]                = 16, 16,  0 // BROWN
//byte[]                = 32,  0, 16 // RED
// Test             0-63 R   G   B
//byte[]              = 12, 10, 24 // BLUE 872
//byte[]              =  8, 26, 16 // GREEN 996
//byte[]              = 20, 22,  8 // BROWN 872
//byte[]              = 24,  6, 16 // RED 868
byte[12] ntscCycle
byte[256] gamma
var rgbErr // Running color error array
var arg

def abs(n)
  return n < 0 ?? -n :: n
end

def max(a, b)
  return a < b ?? b :: a
end

def min(a, b)
  return a < b ?? a :: b
end

def dist(x1, y1, z1, x2, y2, z2)
    x2 = x2 - x1
    y2 = y2 - y1
    z2 = z2 - z1
    return x2*x2 + y2*y2 + z2*z2
end

def dotprod(x1, y1, z1, x2, y2, z2)
  return x1*x2 + y1*y2 + z1*z2
end

def rgbPix(r, g, b, x, y)#0
  var errptr
  var pr, pg, pb
  var nr, ng, nb
  var cr, cg, cb, cx
  var pd, cd, nd
  byte i

  // Error propogation
  errptr = rgbErr + x * 3 * 2
  if errDiv
    r = r + errptr=>[RED] / errDiv
    g = g + errptr=>[GRN] / errDiv
    b = b + errptr=>[BLU] / errDiv
  fin
  pr = 0
  pg = 0
  pb = 0
  // Project RGB on previous 3/4 chroma cycle
  for cx = x - 1 downto x - 3
    i  = (cx & 3) * 3
    pr = pr + ntscCycle[i+RED]
    pg = pg + ntscCycle[i+GRN]
    pb = pb + ntscCycle[i+BLU]
  next
  pd = dist(r, g, b, pr, pg, pb)
  // Look ahead for possible better match
  i  = ((x + 1) & 3) * 3
  nr = pr - ntscCycle[i+RED] + ntscChroma[i+RED]
  ng = pg - ntscCycle[i+GRN] + ntscChroma[i+GRN]
  nb = pb - ntscCycle[i+BLU] + ntscChroma[i+BLU]
  if errDiv
    nr = nr - errptr=>[3+RED] / errDiv
    ng = ng - errptr=>[3+GRN] / errDiv
    nb = nb - errptr=>[3+BLU] / errDiv
  fin
  nd = dist(r, g, b, nr, ng, nb)
  // Add current 1/4 chroma color
  i  = (x & 3) * 3
  cr = pr + ntscChroma[i+RED]
  cg = pg + ntscChroma[i+GRN]
  cb = pb + ntscChroma[i+BLU]
  cd = dist(r, g, b, cr, cg, cb)
  if cd < pd and cd < nd
    // RGB better matched with current 1/4 chroma color
    r = (r - cr + 1) / 2
    g = (g - cg + 1) / 2
    b = (b - cb + 1) / 2
    ntscCycle[i+RED] = ntscChroma[i+RED]
    ntscCycle[i+GRN] = ntscChroma[i+GRN]
    ntscCycle[i+BLU] = ntscChroma[i+BLU]
    dhgrSet(x, y)
  else
    // RGB closer to black
    r = (r - pr + 1) / 2
    g = (g - pg + 1) / 2
    b = (b - pb + 1) / 2
    ntscCycle[i+RED] = 0
    ntscCycle[i+GRN] = 0
    ntscCycle[i+BLU] = 0
  fin
  // Propogate error down and forward
  errptr=>[RED] = r
  errptr=>[GRN] = g
  errptr=>[BLU] = b
  errptr = errptr + 6
  errptr=>[RED] = r + errptr=>[RED]
  errptr=>[GRN] = g + errptr=>[GRN]
  errptr=>[BLU] = b + errptr=>[BLU]
  // Map dark grey to light grey
  if (x & 3) == 3 and dcgrGetPixel(x >> 2, y) == 5
    dhgrOp(OP_SRC)
    dcgrColor(10)
    dcgrPixel(x >> 2, y)
  fin
end

def rgbInit#0
  var i

  if not gamma
    for i = 0 to 255
      gamma[i] = (i / 4) * (i / 4) / 63
    next
  else
    for i = 0 to 255
      gamma[i] = i / 4
    next
  fin
  dhgrMode(DHGR_COLOR_MODE)
  // Init error propogation array
  rgbErr = heapalloc(561 * 3 * 2)
  memset(rgberr, 0, 561 * 3 * 2)
  rgberr=>[RED] = -1
  rgberr=>[GRN] = -1
  rgberr=>[BLU] = -1
end

def rgbExit#0
  heaprelease(rgbErr)
  dhgrMode(DHGR_TEXT_MODE)
end

def rgb3Spans(rs, gs, bs, re, ge, be, rm, gm, bm, y)#0
  var i, j

  memset(@ntscCycle, 0, 12)
  for j = y to y + 2
    for i = 0 to 63
      rgbPix((i>>rs)|re, (i>>gs)|ge, (i>>bs)|be, i, j)
    next
    for i = 64 to 127
      rgbPix(rm, gm, bm, i, j)
    next
  next
end

def rgbTest#0
  var i

  rgbInit
  rgb3Spans(0,5,5,  0, 0, 0, 63, 0, 0, 0)
  rgb3Spans(5,0,5,  0, 0, 0,  0,63, 0, 3)
  rgb3Spans(5,5,0,  0, 0, 0,  0, 0,63, 6)
  rgb3Spans(0,0,0,  0, 0, 0, 63,63,63, 9)
  rgb3Spans(0,1,1,  0, 0, 0, 63,31,31, 12)
  rgb3Spans(1,0,1,  0, 0, 0, 31,63,31, 15)
  rgb3Spans(1,1,0,  0, 0, 0, 31,31,63, 18)
  rgb3Spans(5,5,5, 16,16,16, 16,16,16, 21)
  rgb3Spans(5,5,5, 32,32,32, 32,32,32, 24)
  rgb3Spans(5,5,5, 48,48,48, 48,48,48, 27)
  rgb3Spans(5,5,5, 63,63,63, 63,63,63, 30)
  getc
  rgbExit
end

def rgbImportExport(rgbfile, dhgrfile)#0
  byte refnum, r, g, b
  var i, j
  var rgbScanline, rgbptr

  refnum = fileio:open(rgbfile)
  if refnum
    rgbScanline = heapalloc(560 * 3)
    if rgbScanline
      rgbInit
      for j = 0 to 191
        fileio:read(refnum, rgbScanline,  560 * 3)
        rgbptr = rgbScanline
        for i = 0 to 559
          r = gamma[rgbptr->RED]
          g = gamma[rgbptr->GRN]
          b = gamma[rgbptr->BLU]
          rgbptr = rgbptr + 3
          rgbPix(r, g, b, i, j)
        next
        if ^$C000 == $83
          break
        fin
      next
      fileio:close(refnum)
      if ^dhgrfile
        screenWrite(dhgrfile)
      fin
      getc
      rgbExit
    fin
  else
    puts("Unable to read: "); puts(arg); putln
  fin
end

arg = argNext(argFirst)
if ^arg
  while ^(arg + 1) == '-'
    when toupper(^(arg + 2))
      is 'T' // Run color test
        rgbTest
        break
      is 'L' // Use linear RGB transfer instead of gama
        gamma = 1
        break
      is 'E' // Set error divisor
        if ^arg > 2
          errDiv = ^(arg + 3) - '0'
          if ^arg > 3
            errDiv = errDiv * 10 + ^(arg + 4) - '0'
          fin
        fin
        break
    wend
    arg = argNext(arg)
  loop
  if ^arg
    rgbImportExport(arg, argNext(arg))
  fin
  return 0
fin
puts("Usage: DHGRRGB [-T] [-L] [-E##] RGBFILE [DHGRFILE]\n")
done
