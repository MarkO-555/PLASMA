include "inc/cmdsys.plh"
include "inc/conio.plh"
sysflags nojitc // Keep tone() from compiling and sounding different
//
// Handy constants.
//
const FULLMODE     = 0
const MIXMODE      = 1
//
// Apple II ZP locations.
//
const a2rndnum = $4E // ZP location of RND
const a2rndl   = $4E
const a2rndh   = $4F
//
// Apple II hardware constants.
//
const WNDLEFT      = $20
const WNDWIDTH     = $21
const WNDTOP       = $22
const WNDBOTTOM    = $23
const CURSH        = $24
const CURSV        = $25
const TBASE        = $28
const CSW          = $36
const KSW          = $38
const CURSH80      = $057B
const store80dis   = $C000
const store80ena   = $C001
const showgraphics = $C050
const showtext     = $C051
const showfull     = $C052
const showmix      = $C053
const showpage1    = $C054
const showpage2    = $C055
const page1m       = $C054
const page1x       = $C055
const showlores    = $C056
const showhires    = $C057
const IOUdis       = $C07E
const IOUena       = $C07F
const keyboard     = $C000
const keystrobe    = $C010
const pushbttn1    = $C061
const pushbttn2    = $C062
const pushbttn3    = $C063
const speaker      = $C030
//
// Apple III hardware constants.
//
const ENV_REG      = $FFDF
//
// Predefined functions.
//
predef a2keypressed,a2getkey,a2putchars(cnt,chrs), a2ctrl(code,param)
predef a2clear(clr),a2gotoxy(x,y),a2viewport(left, top, width, height)
predef a2textmode(cols),a2grmode(mix),a2grcolor(color),a2grplot(x,y)
predef a2tone(duration, delay),a2rnd
//
// Exported function table.
//
word conio[]
//
// Function pointers.
//
word = @a2keypressed
word = @a2getkey
word = @a2putchars
word = @a2clear
word = @a2gotoxy
word = @a2viewport
word = @a2ctrl
word = @a2textmode
word = @a2grmode
word = @a2grcolor
word = @a2grplot
word = @a2tone
word = @a2rnd
//
// Screen row address arrays.
//
word txt1scrn[]     = $0400,$0480,$0500,$0580,$0600,$0680,$0700,$0780
word                = $0428,$04A8,$0528,$05A8,$0628,$06A8,$0728,$07A8
word                = $0450,$04D0,$0550,$05D0,$0650,$06D0,$0750,$07D0
word txt2scrn[]     = $0800,$0880,$0900,$0980,$0A00,$0A80,$0B00,$0B80
word                = $0828,$08A8,$0928,$09A8,$0A28,$0AA8,$0B28,$0BA8
word                = $0850,$08D0,$0950,$09D0,$0A50,$0AD0,$0B50,$0BD0
//
// Flags for current mode
//
const showcurs  = $01
const shiftlock = $02
const echo      = $04
const txt80     = $08
const uppercase = $80
byte flags
//
// Apple 2 disable 80 column string
//
char disable80[] = 5, 13, 26, '1', 13, 21
//
// Apple 2 KSW snd CSW values
//
word kswsave, cswsave
//
// Apple 3 console codes.
//
byte textbwmode[]   = 2, 16, 0
byte textclrmode[]  = 2, 16, 1
byte grcharset[]    = 1, 0, $7F, $7F, $7F, $7F, $00, $00, $00, $00
byte a3keyqueue     = 0
byte a3echoflag     = $80
byte a3noechoflag   = $00
byte curschar       = ' '
//
// Random number for Apple 1 and III.
//
word randnum = 12345
//
// Native  routines.
//
asm equates
    !SOURCE "vmsrc/plvmzp.inc"
end
//
// def grscrn(rowaddrs)
//
asm a2grscrn(rowaddrs)
GRSCRN  =   $26
GRSCRNL =   GRSCRN
GRSCRNH =   GRSCRNL+1
    LDA ESTKL,X
    STA GRSCRNL
    LDA ESTKH,X
    STA GRSCRNH
    RTS
end
//
// def grcolor(color)
//
asm a2grcolor(color)
GRCLR   =   $30
    LDA #$0F
    AND ESTKL,X
    STA GRCLR
    ASL
    ASL
    ASL
    ASL
    ORA GRCLR
    STA GRCLR
    RTS
end
//
// def grplot(x, y)
//
asm a2grplot(x, y)
    STY IPY
    LDA ESTKL,X
    AND #$FE
    CMP ESTKL,X
    TAY
    LDA (GRSCRN),Y
    STA DSTL
    INY
    LDA (GRSCRN),Y
    STA DSTH
    LDY ESTKL+1,X
    LDA (DST),Y
    EOR GRCLR
    STA TMPL
    LDA #$FF
    ADC #$00
    EOR #$F0
    AND TMPL
    EOR GRCLR
    STA (DST),Y
    LDY IPY
    INX
    RTS
end
//def a2putchars(cnt, chrs)
//    byte c
//
//    if cnt
//        if chrs & $FF00
//            for c = 0 to cnt-1; putc(^(chrs + c)); next
//        else
//            for c = 0 to cnt-1; putc(chrs); next
//        fin
//    fin
//    return ^CURSH
//end
asm a2putchars(cnt, chrs)
LCRDEN  =       $C080
LCWTEN  =       $C081
ROMEN   =       $C082
LCRWEN  =       $C083
LCBNK2  =       $00
LCBNK1  =       $08
COUT    =       $FDED
        LDA     ESTKL+1,X       ; CNT
        BEQ     EXA2PC
        BIT     ROMEN
        LDA     ESTKH,X
        BEQ     ++
        STA     SRCH            ; SRC = CHRPTR
        LDA     ESTKL,X
        STA     SRCL
        LDY     #$00
-       STY     ESTKH+1,X
        TYA
        CMP     ESTKL+1,X
        BEQ     EXA2PC
        LDA     (SRC),Y
        ORA     #$80
        JSR     COUT
        LDY     ESTKH+1,X
        INY
        BNE     -
++
-       LDA     ESTKL,X         ; CHR
        ORA     #$80
        JSR     COUT
        DEC     ESTKL+1,X
        BNE     -
EXA2PC  INX
        LDA     #$00
        STA     ESTKL,X
        STA     ESTKH,X
        BIT     LCRDEN+LCBNK2
        RTS
end
asm a2putuprchars(cnt, chrs)
TXTATTR =       $32
        LDA     ESTKL+1,X       ; CNT
        BEQ     EXA2PC
        BIT     ROMEN
        LDA     ESTKH,X
        BEQ     ++
        STA     SRCH            ; SRC = CHRPTR
        LDA     ESTKL,X
        STA     SRCL
        LDY     #$00
-       STY     ESTKH+1,X
        TYA
        CMP     ESTKL+1,X
        BEQ     EXA2UPC
        LDA     TXTATTR
        PHA
        LDA     (SRC),Y
        ORA     #$80
        CMP     #'a'+$80
        BCC     +
        CMP     #'z'+$81
        BCS     +
        SBC     #$1F
        PHA
        LDA     #$3F            ; OUTPUT LC AS INV
        STA     TXTATTR
        PLA
+       JSR     COUT
        PLA
        STA     TXTATTR
        LDY     ESTKH+1,X
        INY
        BNE     -
++      LDA     TXTATTR
        PHA
        LDA     ESTKL,X         ; CHR
        ORA     #$80
        CMP     #'a'+$80
        BCC     +
        CMP     #'z'+$81
        BCS     +
        SBC     #$1F
        PHA
        LDA     #$3F
        STA     TXTATTR
        PLA
+
-       PHA
        JSR     COUT
        PLA
        DEC     ESTKL+1,X
        BNE     -
        PLA
        STA     TXTATTR
EXA2UPC INX
        LDA     #$00
        STA     ESTKL,X
        STA     ESTKH,X
        BIT     LCRDEN+LCBNK2
        RTS
end
asm vidcpy(dstrow, srcrow)#0
WNDLFT  =       $20
WNDWID  =       $21
        LDA     WNDLFT
        CLC
        ADC     ESTKL+1,X
        STA     DSTL
        LDA     #$00
        ADC     ESTKH+1,X
        STA     DSTH
        LDA     WNDLFT
        CLC
        ADC     ESTKL,X
        STA     SRCL
        LDA     #$00
        ADC     ESTKH,X
        STA     SRCH
        LDY     WNDWID
        DEY
-       LDA     (SRC),Y
        STA     (DST),Y
        DEY
        BPL     -
        INX
        INX
        RTS
end
asm vidxcpy(dstrow, srcrow)#0
PAGE1M  =       $C054
PAGE1X =        $C055
        LDA     WNDLFT
        LSR
        ADC     ESTKL+1,X
        STA     DSTL
        LDA     #$00
        ADC     ESTKH+1,X
        STA     DSTH
        LDA     WNDLFT
        LSR
        ADC     ESTKL,X
        STA     SRCL
        LDA     #$00
        ADC     ESTKH,X
        STA     SRCH
        LDA     WNDWID
        LSR
        ADC     #$00
        PHA
        TAY
        DEY
        STA     PAGE1X
-       LDA     (SRC),Y
        STA     (DST),Y
        DEY
        BPL     -
        PLA
        TAY
        DEY
        STA     PAGE1M
-       LDA     (SRC),Y
        STA     (DST),Y
        DEY
        BPL     -
        INX
        INX
        RTS
end
//
// Apple 1 routines.
//
def a1keypressed
    return ^$D011 >= 128 ?? ^$D011 :: 0
end
def a1getkey
    while not a1keypressed
        randnum = randnum + 123
    loop
    return getc()
end
def a1putchars(cnt, chrs)
    byte c

    if chrs < 256
        for c = 1 to cnt
            putc(chrs)
        next
    else
        for c = 0 to cnt-1
            putc(chrs->[c])
        next
    fin
    return cnt
end
def a1clear(clr)
    byte l
    when clr
        is cleol
            break
        is cleos
        is cls
            for l = 0 to 23
                putln
            next
            break
    wend
    return 0
end
def a1gotoxy(x, y)
    //curshpos = x
    //cursvpos = y
    putln
    while x
        putc(' ')
        x = x - 1
    loop
    return 0
end
def a1viewport(left, top, width, height)
    return 0
end
def a1ctrl(code, param)#1
    return FALSE
end
def a1textmode(columns)
    return 40
end
def a1grmode(mix)
    return 0 // not supported
end
def a1tone(duration, delay)
    byte i

    while duration
        for i = delay downto 0; next
        duration--
    loop
    return 0
end
//
// Apple II routines.
//
def a2keypressed
    return ^keyboard >= 128 ?? ^keyboard :: 0
end
def a2getkey
    byte key

    repeat
        key = ^keyboard
        if key == $80 | keyctrll
            ^keystrobe
            flags = flags ^ shiftlock
            key   = 0
        fin
    until key >= 128
    ^keystrobe
    when key
        is $80 | keyctrln
            key = $DB // '['
            break
        is $9E // SHIFT+CTRL+N
            key = $FE // '~'
            break
        is $80 | keyctrlp
            key = $DC // '\'
            break
        is $80 // SHIFT+CTRL+P -> CTRL+@
            key = $FC // '|'
            break
        is $80 | keyctrlg
            key = $DF // '_'
            break
        is $80 | keyarrowleft
            if ^pushbttn3 < 128
                key = keydelete
            fin
            break
        is $80 | keyarrowright
            if ^pushbttn3 < 128
                key = keytab
            fin
            break
        otherwise
            if key >= $C0 and flags < shiftlock
                if ^pushbttn3 < 128
                    when key
                        is $C0
                            key = $D0 // P
                            break
                        is $DD
                            key = $CD // M
                            break
                        is $DE
                            key = $CE // N
                    wend
                else
                   key = key | $E0
                fin
            fin
    wend
    return (pushbttn2 & $80) | (key & $7F)
end
def a2egetkey
    byte key

    repeat
        key = ^keyboard
    until key >= 128
    ^keystrobe
    return (^pushbttn2 & $80) | (key & $7F)
end
def a2cgetkey
    byte key

    ^$C079 = 0 // IOU enable and clear VBL int on //c
    ^$C05B = 0 // Enable VBL Ints on //c
    key = a2egetkey
    ^$C05A = 0 // Disable VBL Ints on //c
    ^$C078 = 0 // IOU disable on //c
    return key
end
def a2clear(clr)
    when clr
        is cleol // clear EOL
            call($FC9C, 0, 0, 0, 0) // CLEOL
            break
        is cls // home
            call($FC58, 0, 0, 0, 0) // HOME
            break
        is cleos // clear OES
            call($FC42, 0, 0, 0, 0) // CLREOP
            break
    wend
    return 0
end
def a2clear80e(clr)
    when clr
        is cleol // clear EOL
            putc(29) // GS
            break
        is cls // home
            putc(12) // FF
            break
        is cleos // clear OES
            putc(11) // VT
            break
    wend
    return 0
    putc(12) // Form Feed
    return 0
end
def a2clear80v(clr)
    when clr
        is cleol // clear EOL
            break
        is cls
            putc(12) // FF
            break
        is cleos // clear OES
            putc(11) // VT
            break
    wend
    return 0
end
def a2gotoxy(x, y)
    ^CURSH = x
    return call($FB5B, y + ^WNDTOP, 0, 0, 0) // TABV
end
def a2gotoxy80e(x, y)
    ^CURSH80 = x
    return call($FB5B, y + ^WNDTOP, 0, 0, 0) // TABV
end
def a2gotoxy80v(x, y)
    putc(30); putc(x + ' '); putc(y + ' ')
    return 0
end
def a2viewport(left, top, width, height)
    if !width or !height
        left   = 0
        top    = 0
        width  = 40
        height = 24
    fin
    ^WNDLEFT   = left
    ^WNDWIDTH  = width
    ^WNDTOP    = top
    ^WNDBOTTOM = height + top - 1
    return conio:gotoxy(0, 0)
end
def a2ctrl(code, param)#1
    word handled
    byte row

    handled = FALSE
    when code
        is ctrlattr
            ^$32 = param
            handled = TRUE
             break
        is ctrlecho
            if param
                flags = flags | echo
            else
                flags = flags & ~echo
            fin
            handled = TRUE
            break
        is ctrlcursor
            if param
                flags = flags | showcurs
            else
                flags = flags & ~showcurs
            fin
            handled = TRUE
            break
        is ctrlscroll
            if param > 0
                for row = ^WNDTOP to ^WNDBOTTOM - param - 1
                    vidcpy(txt1scrn[row], txt1scrn[row + param])
                next
            elsif param < 0
                for row = ^WNDBOTTOM downto ^WNDTOP - param
                    vidcpy(txt1scrn[row], txt1scrn[row + param])
                next
            fin
            handled = TRUE
            break
        is ctrlcase
            if not (flags & txt80)
                flags = flags ^ uppercase
                if flags & uppercase
                    conio:putchars = flags & uppercase ?? @a2putuprchars :: @a2putchars
                fin
            fin
            handled = TRUE
            break
    wend
    return handled
end
def a2ctrl80e(code, param)#1
    word handled
    byte row

    handled = FALSE
    when code
        is ctrlattr
            ^$32 = param
            handled = TRUE
             break
        is ctrlecho
            if param
                flags = flags | echo
            else
                flags = flags & ~echo
            fin
            handled = TRUE
            break
        is ctrlcursor
            if param
                flags = flags | showcurs
            else
                flags = flags & ~showcurs
            fin
            handled = TRUE
            break
        is ctrlscroll
            ^IOUdis     = 0
            ^store80ena = 0
            if param > 0
                for row = ^WNDTOP to ^WNDBOTTOM - param - 1
                    vidxcpy(txt1scrn[row], txt1scrn[row + param])
                next
            elsif param < 0
                for row = ^WNDBOTTOM downto ^WNDTOP - param
                    vidxcpy(txt1scrn[row], txt1scrn[row + param])
                next
            fin
            ^store80dis = 0
            ^IOUena     = 0
            handled = TRUE
            break
    wend
    return handled
end
def a2ctrl80v(code, param)#1
    word handled
    byte row

    handled = FALSE
    when code
        is ctrlattr
            break
        is ctrlecho
            if param
                flags = flags | echo
            else
                flags = flags & ~echo
            fin
            handled = TRUE
            break
        is ctrlcursor
            if param
                flags = flags | showcurs
            else
                flags = flags & ~showcurs
            fin
            handled = TRUE
            break
        is ctrlscroll
            break
    wend
    return handled
end
def a2textmode(columns)
    call($FB39, 0, 0, 0, 0) // textmode()
    if columns > 40 and MACHID & MACHID_80COL
        cswsave = *CSW
        kswsave = *KSW
        call($C300, 0, 0, 0,  0)
        if MACHID & $C0 == MACHID_IIE
            conio:clear      = @a2clear80e
            conio:gotoxy     = @a2gotoxy80e
            conio:textctrl   = @a2ctrl80e
        else
            conio:clear      = @a2clear80v
            conio:gotoxy     = @a2gotoxy80v
            conio:textctrl   = @a2ctrl80v
            conio:putchars   = @a2putchars
        fin
        flags            = flags | txt80
    else
        if flags & txt80
            if MACHID & $C0 == MACHID_IIE
                puts(@disable80)
            else // Videx disable
                ^$C058
                *CSW = cswsave
                *KSW = kswsave
                a2viewport(0, 0, 40, 24)
                if flags & uppercase
                    conio:putchars = @a2putuprchars
                fin
            fin
        fin
        conio:clear      = @a2clear
        conio:gotoxy     = @a2gotoxy
        conio:textctrl   = @a2ctrl
        flags            = flags & ~txt80
        a2clear(cls)
    fin
    return flags & txt80 ?? 80 :: 40
end
def a2grmode(mix)
    a2textmode(40)
    call($FB2F, 0, 0, 0, 0) // initmode()
    call($FB40, 0, 0, 0, 0) // grmode()
    if !mix
        ^showfull
    fin
    a2clear(cls)
    return a2grscrn(@txt1scrn) // point to lo-res screen
end
def a2tone(duration, delay)
    byte i

    while duration
        ^speaker // toggle speaker
        for i = delay downto 0; next
        duration--
    loop
    return 0
end
def a2rnd
    *a2rndnum = (*a2rndnum << 1) + *a2rndnum + 123
    return *a2rndnum & $7FFF
end
//
// Apple III routines.
//
def dev_control(devnum, code, list)
    byte params[5]

    params.0 = 3
    params.1 = devnum
    params.2 = code
    params:3 = list
    return syscall($83, @params)
end
def dev_status(devnum, code, list)
    byte params[5]

    params.0 = 3
    params.1 = devnum
    params.2 = code
    params:3 = list
    return syscall($82, @params)
end
def cons_keyavail
    byte params[5]
    byte count

    params.0 = 3
    params.1 = cmdsys.devcons
    params.2 = 5
    params:3 = @count
    return syscall($82, @params) ?? 0 :: count
end
def cons_keyread
    byte params[8]
    byte key

    params.0 = 4
    params.1 = cmdsys.refcons
    params:2 = @key
    params:4 = 1
    params:6 = 0
    syscall($CA, @params)
    return params:6 ?? key :: 0
end
def a3keypressed
    byte count

    dev_status(cmdsys.devcons, 5, @count)
    if count
        a3keyqueue = getc
    fin
    return a3keyqueue ?? a3keyqueue | $80 :: 0
end
def a3getkey
    byte keycode
    repeat
        randnum = randnum + 123
        a3keypressed
        keycode = a3keyqueue
    until keycode
    a3keyqueue = 0
    return keycode
end
def a3putchars(cnt, chrs)
    byte c

    if chrs < 256
        for c = 1 to cnt
            putc(chrs)
        next
    else
        for c = 0 to cnt-1
            putc(chrs->[c])
        next
    fin
    return cnt
end
def a3clear(clr)
    when clr
        is cleol // clear EOL
            break
        is cls
            putc(28) // FF
            break
        is cleos // clear OES
            putc(11) // VT
            break
    wend
    return 0
end
def a3gotoxy(x, y)
    putc(24)
    putc(x)
    putc(25)
    putc(y)
    return 0
end
def a3viewport(left, top, width, height)
    if !width or !height
        //
        // Reset the full-screen viewport
        //
        left   = 0
        top    = 0
        width  = 40//textcols
        height = 24
    fin
    putc(1) // Reset viewport
    putc(26)
    putc(left)
    putc(top)
    putc(2)
    putc(26)
    putc(left + width  - 1)
    putc(top  + height - 1)
    putc(3)
    return a3gotoxy(0, 0)
end
def a3ctrl(code, param)#1
    word handled

    handled = FALSE
    when code
        is ctrlattr
            break
        is ctrlecho
            dev_control(cmdsys.devcons, 11, param ?? @a3echoflag :: @a3noechoflag)
            handled = TRUE
            break
        is ctrlcursor
            break
    wend
    return handled
end
def a3textmode(columns)
    puts(@textbwmode)
    if columns > 40
        a3viewport(0, 0, 80, 24)
    else
        a3viewport(0, 0, 40, 24)
    fin
    putc(28)
    return 0
end
def a3grmode(mix)
    byte i
    if mix
        mix = 19
    else
        mix = 23
    fin
    puts(@textclrmode)
    dev_control(cmdsys.devcons, 17, @grcharset)
    a3viewport(0, 20, 40, 4)
    putc(28)
    for i = 0 to mix
        memset(txt1scrn[i], $0000, 40) // text  screen
        memset(txt2scrn[i], $0000, 40) // color screen
    next
    return a2grscrn(@txt2scrn) // point to color screen
end
def a3tone(duration, pitch)
    byte env

    env = ^ENV_REG
    ^ENV_REG = env | $C0
    a2tone(duration, pitch)
    ^ENV_REG = env
    return 0
end
//
// Apple 1 and III combined routines.
//
def a13rnd
    randnum = (randnum << 1) + randnum + 123
    return randnum & $7FFF
end
//
// Machine specific initialization.
//
when MACHID & MACHID_MODEL
    is MACHID_III
        conio:keypressed = @a3keypressed
        conio:getkey     = @a3getkey
        conio:putchars   = @a3putchars
        conio:clear      = @a3clear
        conio:gotoxy     = @a3gotoxy
        conio:viewport   = @a3viewport
        conio:textctrl   = @a3ctrl
        conio:textmode   = @a3textmode
        conio:grmode     = @a3grmode
        conio:tone       = @a3tone
        conio:rnd        = @a13rnd
        break
    is MACHID_IIE
        conio:getkey     = @a2egetkey
        break
    is MACHID_IIC
        conio:getkey     = @a2cgetkey
        break
    is MACHID_II
        flags            = flags | uppercase
        conio:putchars   = @a2putuprchars
        break
    is MACHID_I
        conio:keypressed = @a1keypressed
        conio:getkey     = @a1getkey
        conio:putchars   = @a1putchars
        conio:clear      = @a1clear
        conio:gotoxy     = @a1gotoxy
        conio:viewport   = @a1viewport
        conio:textctrl   = @a1ctrl
        conio:textmode   = @a1textmode
        conio:grmode     = @a1grmode
        conio:tone       = @a1tone
        conio:rnd        = @a13rnd
        break
wend
//
// Keep module in memory
//
return modkeep
done
