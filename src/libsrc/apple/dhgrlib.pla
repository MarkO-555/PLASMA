include "inc/cmdsys.plh"
include "inc/lines.plh"

sysflags resxtxt1|reshgr1|resxhgr1

const OP_SRC    = 0
const OP_XOR    = 1
const OP_AND    = 2
const OP_OR     = 3
//
// Test sprite
//
byte[] sprite   = $55,$55,$00,$00,$00,$00,$55,$55
byte[]          = $55,$55,$00,$00,$00,$00,$55,$55
byte[]          = $55,$00,$00,$AA,$AA,$00,$00,$55
byte[]          = $55,$00,$AA,$AA,$AA,$AA,$00,$55
byte[]          = $00,$00,$AA,$FF,$FF,$AA,$00,$00
byte[]          = $00,$AA,$FF,$FF,$FF,$FF,$AA,$00
byte[]          = $00,$AA,$1F,$12,$12,$F2,$AA,$00
byte[]          = $00,$AA,$2F,$21,$21,$F1,$AA,$00
byte[]          = $00,$AA,$1F,$12,$12,$F2,$AA,$00
byte[]          = $00,$AA,$2F,$21,$21,$F1,$AA,$00
byte[]          = $00,$AA,$FF,$FF,$FF,$FF,$AA,$00
byte[]          = $00,$00,$AA,$FF,$FF,$AA,$00,$00
byte[]          = $55,$00,$AA,$AA,$AA,$AA,$00,$55
byte[]          = $55,$00,$00,$AA,$AA,$00,$00,$55
byte[]          = $55,$55,$00,$00,$00,$00,$55,$55
byte[]          = $55,$55,$00,$00,$00,$00,$55,$55

//
// Apple II graphics soft switches
//
const store80dis   = $C000
const store80ena   = $C001
const show40col    = $C00C
const show80col    = $C00D
const showgraphics = $C050
const showtext     = $C051
const showfull     = $C052
const showmix      = $C053
const page1m       = $C054
const page1x       = $C055
const showhires    = $C057
const dhresena     = $C05E
const dhresdis     = $C05F
const IOUdis       = $C07E
const IOUena       = $C07F
//
// HiRes scanline addresses
//
byte hgrscanl[]= $00,$00,$00,$00,$00,$00,$00,$00
byte           = $80,$80,$80,$80,$80,$80,$80,$80
byte           = $00,$00,$00,$00,$00,$00,$00,$00
byte           = $80,$80,$80,$80,$80,$80,$80,$80
byte           = $00,$00,$00,$00,$00,$00,$00,$00
byte           = $80,$80,$80,$80,$80,$80,$80,$80
byte           = $00,$00,$00,$00,$00,$00,$00,$00
byte           = $80,$80,$80,$80,$80,$80,$80,$80
byte           = $28,$28,$28,$28,$28,$28,$28,$28
byte           = $A8,$A8,$A8,$A8,$A8,$A8,$A8,$A8
byte           = $28,$28,$28,$28,$28,$28,$28,$28
byte           = $A8,$A8,$A8,$A8,$A8,$A8,$A8,$A8
byte           = $28,$28,$28,$28,$28,$28,$28,$28
byte           = $A8,$A8,$A8,$A8,$A8,$A8,$A8,$A8
byte           = $28,$28,$28,$28,$28,$28,$28,$28
byte           = $A8,$A8,$A8,$A8,$A8,$A8,$A8,$A8
byte           = $50,$50,$50,$50,$50,$50,$50,$50
byte           = $D0,$D0,$D0,$D0,$D0,$D0,$D0,$D0
byte           = $50,$50,$50,$50,$50,$50,$50,$50
byte           = $D0,$D0,$D0,$D0,$D0,$D0,$D0,$D0
byte           = $50,$50,$50,$50,$50,$50,$50,$50
byte           = $D0,$D0,$D0,$D0,$D0,$D0,$D0,$D0
byte           = $50,$50,$50,$50,$50,$50,$50,$50
byte           = $D0,$D0,$D0,$D0,$D0,$D0,$D0,$D0
byte hgrscanh[]= $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
//
// Pixel masks for 7 contiguous pixels
//
byte auxclrmsk[] = $0F
byte             = $70
byte             = $00
byte             = $03|$80
byte             = $3C|$80
byte             = $40|$80
byte             = $00
byte memclrmsk[] = $00
byte             = $01
byte             = $1E
byte             = $60
byte             = $00
byte             = $07|$80
byte             = $78|$80
//
// Solid colors
//
byte auxclrsl[] = $00 // black
byte            = $08 // magenta
byte            = $44 // brown
byte            = $4C // orange
byte            = $22 // dark green
byte            = $2A // gray 1
byte            = $66 // green
byte            = $6E // yellow
byte            = $11 // dark blue
byte            = $19 // purple
byte            = $55 // gray 2
byte            = $5D // pink
byte            = $33 // medium blue
byte            = $3B // light blue
byte            = $77 // aqua
byte            = $7F // white
byte auxclrsh[] = $00 // black
byte            = $22 // magenta
byte            = $11 // brown
byte            = $33 // orange
byte            = $08 // dark green
byte            = $2A // gray 1
byte            = $19 // green
byte            = $3B // yellow
byte            = $44 // dark blue
byte            = $66 // purple
byte            = $55 // gray 2
byte            = $77 // pink
byte            = $4C // medium blue
byte            = $6E // light blue
byte            = $5D // aqua
byte            = $7F // white
byte memclrsl[] = $00 // black
byte            = $11 // magenta
byte            = $08 // brown
byte            = $19 // orange
byte            = $44 // dark green
byte            = $55 // gray 1
byte            = $4C // green
byte            = $5D // yellow
byte            = $22 // dark blue
byte            = $33 // purple
byte            = $2A // gray 2
byte            = $3B // pink
byte            = $66 // medium blue
byte            = $77 // light blue
byte            = $6E // aqua
byte            = $7F // white
byte memclrsh[] = $00 // black
byte            = $44 // magenta
byte            = $22 // brown
byte            = $66 // orange
byte            = $11 // dark green
byte            = $55 // gray 1
byte            = $33 // green
byte            = $77 // yellow
byte            = $08 // dark blue
byte            = $4C // purple
byte            = $2A // gray 2
byte            = $6E // pink
byte            = $19 // medium blue
byte            = $5D // light blue
byte            = $3B // aqua
byte            = $7F // white
byte auxclrl, auxclrh, memclrl, memclrh
//
// Divide 7 combined with Modulo 7
//
byte divmod7[]  =   0+0,   0+1,   0+2,   0+3,   0+4,   0+5,   0+6
byte            =   8+0,   8+1,   8+2,   8+3,   8+4,   8+5,   8+6
byte            =  16+0,  16+1,  16+2,  16+3,  16+4,  16+5,  16+6
byte            =  24+0,  24+1,  24+2,  24+3,  24+4,  24+5,  24+6
byte            =  32+0,  32+1,  32+2,  32+3,  32+4,  32+5,  32+6
byte            =  40+0,  40+1,  40+2,  40+3,  40+4,  40+5,  40+6
byte            =  48+0,  48+1,  48+2,  48+3,  48+4,  48+5,  48+6
byte            =  56+0,  56+1,  56+2,  56+3,  56+4,  56+5,  56+6
byte            =  64+0,  64+1,  64+2,  64+3,  64+4,  64+5,  64+6
byte            =  72+0,  72+1,  72+2,  72+3,  72+4,  72+5,  72+6
byte            =  80+0,  80+1,  80+2,  80+3,  80+4,  80+5,  80+6
byte            =  88+0,  88+1,  88+2,  88+3,  88+4,  88+5,  88+6
byte            =  96+0,  96+1,  96+2,  96+3,  96+4,  96+5,  96+6
byte            = 104+0, 104+1, 104+2, 104+3, 104+4, 104+5, 104+6
byte            = 112+0, 112+1, 112+2, 112+3, 112+4, 112+5, 112+6
byte            = 120+0, 120+1, 120+2, 120+3, 120+4, 120+5, 120+6
byte            = 128+0, 128+1, 128+2, 128+3, 128+4, 128+5, 128+6
byte            = 136+0, 136+1, 136+2, 136+3, 136+4, 136+5, 136+6
byte            = 144+0, 144+1, 144+2, 144+3, 144+4, 144+5, 144+6
byte            = 152+0, 152+1, 152+2, 152+3, 152+4, 152+5, 152+6

export asm dcgrColor(c)#0
!SOURCE    "vmsrc/plvmzp.inc"
        LDA     ESTKL,X
        INX
        AND     #$0F
        TAY
end
asm _dcgrColorA
        LDA     $1000,Y     ; AUXCLRSL
        STA     $5000       ; AUXCLRL
        LDA     $2000,Y     ; AUXCLRSH
        STA     $5001       ; AUXCLRH
        LDA     $3000,Y     ; MEMCLRSL
        STA     $5002       ; MEMCLRL
        LDA     $4000,Y     ; MEMCLRSH
        STA     $5003       ; MEMCLRH
        RTS
end
export asm dcgrPlot(x, y)#0
        INX
        INX
        STX     ESP
        LDY     ESTKL-2,X   ; Y COORD
        CPY     #192
        BCS     +
end
asm     _dcgrPlotA
        LDA     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDY     ESTKL-1,X   ; X COORD
        CPY     #140
        BCS     +
end
asm     _dcgrPlotB
        LDA     $3000,Y     ; DIVMOD7
        TAX
        AND     #$F8
        LSR
        LSR
        TAY                 ; DIV7
        TXA
        AND     #$07
        TAX                 ; PIX7
end
asm _jmpPlotOp
        JMP     $A000
end
//
// Plot OP_SRC
//
asm     _dcgrPlotC
        LDA     $4000,X     ; AUXCLRMSK
        BEQ     ++
        STA     $C055       ; PAGE1X
        BMI     +++
end
asm     _dcgrPlotD
        LDA     $5000       ; AUXCLRL
        EOR     (DST),Y
        AND     $4000,X     ; AUXCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
        BNE     ++
        BEQ     ++
+++     INY
end
asm     _dcgrPlotE
        LDA     $5001       ; AUXCLRH
        EOR     (DST),Y
        AND     $4000,X     ; AUXCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
        DEY
end
asm     _dcgrPlotF
++      LDA     $4001,X     ; MEMCLRMSK
        BEQ     +
        STA     $C054       ; PAGE1M
        BMI     +++
end
asm     _dcgrPlotG
        LDA     $5002       ; MEMCLRL
        EOR     (DST),Y
        AND     $4000,X     ; MEMCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
        LDX     ESP
        RTS
+++     INY
end
asm     _dcgrPlotH
        LDA     $5003       ; MEMCLRH
        EOR     (DST),Y
        AND     $4000,X     ; MEMCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
+       LDX     ESP
        RTS
end
//
// Plot OP_XOR,OP_AND,OP_OR
//
asm     _dcgrPlotOpC
        LDA     $4000,X     ; AUXCLRMSK
        BEQ     ++
        STA     $C055       ; PAGE1X
        BMI     +++
end
asm     _dcgrPlotOpD
        AND     $5000       ; AUXCLRL
        EOR     (DST),Y
        STA     (DST),Y
        BNE     ++
        BEQ     ++
+++     INY
end
asm     _dcgrPlotOpE
        AND     $5001       ; AUXCLRH
        EOR     (DST),Y
        STA     (DST),Y
        DEY
end
asm     _dcgrPlotOpF
++      LDA     $4001,X     ; MEMCLRMSK
        BEQ     +
        STA     $C054       ; PAGE1M
        BMI     +++
end
asm     _dcgrPlotOpG
        AND     $5002       ; MEMCLRL
        EOR     (DST),Y
        STA     (DST),Y
+       LDX     ESP
        RTS
+++     INY
end
asm     _dcgrPlotOpH
        AND     $5003       ; MEMCLRH
        EOR     (DST),Y
        STA     (DST),Y
        LDX     ESP
        RTS
end
export asm dcgrHlin(x1, x2, y)#0
        INX
        INX
        INX
        STX     ESP
        LDY     ESTKL-3,X   ; Y COORD
        CPY     #192
        BCS     +
        INC     ESTKL-2,X   ; ADJUST BCS BELOW
end
asm     _dcgrHLinA
        LDA     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     $2000,Y     ; HGRSCANH
        STA     DSTH
-       LDA     ESTKL-1,X   ; X1 COORD
        CMP     #140
        BCS     +
        CMP     ESTKL-2,X   ; X2 COORD
        BCS     +
        TAY
end
asm     _dcgrHLinB
        JSR     $1000       ; PLOT PIX W/ XCOORD IN Y REG
        INC     ESTKL-1,X
        BNE     -
+       RTS
end
export asm dcgrVlin(y1, y2, x)#0
        INX
        INX
        INX
        STX     ESP
        INC     ESTKL-2,X   ; ADJUST BCS BELOW
-       LDA     ESTKL-1,X   ; Y1 COORD
        CMP     #192
        BCS     +
        CMP     ESTKL-2,X   ; Y2 COORD
        BCS     +
        TAY
end
asm     _dcgrVLinA
        LDA     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDY     ESTKL-3,X   ; X COORD
        CPY     #140
        BCS     +
end
asm     _dcgrVLinB
        JSR     $1000       ; PLOT PIX W/ XCOORD IN Y REG
        INC     ESTKL-1,X
        BNE     -
+       RTS
end
export asm dcgrPixBLT(x, y, w, h, pixptr)#0
        INX
        INX
        INX
        INX
        INX
        STX     ESP
        LDA     ESTKL-5,X   ; PIXPTR
        STA     SRCL
        LDA     ESTKH-5,X
        STA     SRCH
        LDA     ESTKL-1,X   ; X COORD
        CLC
        ADC     ESTKL-3,X   ; WIDTH
        STA     ESTKL-3,X   ; -> RIGHT EDGE
        LDA     ESTKL-2,X   ; Y COORD
        CLC
        ADC     ESTKL-4,X   ; HEIGHT
        STA     ESTKL-4,X   ; -> BOTTOM EDGE
-       LDA     ESTKL-2,X   ; Y COORD
        CMP     ESTKL-4,X   ; AT BOTTOM?
        BCS     +++
        INC     ESTKL-2,X   ; Y COORD++
        CMP     #192        ; OFF SCREEN?
        BCS     -
        TAY
end
asm     _dcgrPixBLTA
        LDA     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDA     ESTKL-1,X   ; X COORD
        STA     TMPL
PIXL    CMP     #140        ; OFF SCREEN?
        BCS     PIXH
        LDY     #$00        ; LO NIBBLE SRC PIXEL
        LDA     (SRC),Y
        AND     #$0F
        CMP     #$05        ; TRANSPARENT?
        BEQ     PIXH
        TAY
end
asm     _dcgrPixBLTB
        JSR     $2000       ; SET COLOR
        LDY     TMPL
end
asm     _dcgrPixBLTC
        JSR     $1000       ; PLOT PIXEL
PIXH    INC     TMPL
        LDA     TMPL
        CMP     ESTKL-3,X   ; AT RIGHT EDGE?
        BCS     -           ; NEXT ROW
        CMP     #140        ; OFF SCREEN?
        BCS     +
        LDY     #$00        ; HI NIBBLE SRC PIXEL
        LDA     (SRC),Y
        LSR
        LSR
        LSR
        LSR
        CMP     #$05        ; TRANSPARENT?
        BEQ     +
        TAY
end
asm     _dcgrPixBLTD
        JSR     $2000       ; SET COLOR
        LDY     TMPL
end
asm     _dcgrPixBLTE
        JSR     $1000       ; PLOT PIXEL
+       INC     SRCL
        BNE     ++
        INC     SRCH
++      INC     TMPL
        LDA     TMPL
        CMP     ESTKL-3,X   ; AT RIGHT EDGE?
        BCC     PIXL
        BCS     -           ; NEXT ROW
+++     RTS
end
export asm dcgrBLTMem(x7, y, w7, h, dstptr)#0
        INX
        INX
        INX
        INX
        INX
        LDA     ESTKL-5,X   ; DSTPTR
        STA     DSTL
        LDA     ESTKH-5,X
        STA     DSTH
        LDA     ESTKL-2,X   ; Y COORD
        CLC
        ADC     ESTKL-4,X   ; HEIGHT
        STA     ESTKL-4,X   ; -> BOTTOM EDGE
-       LDA     ESTKL-2,X   ; Y COORD
        CMP     ESTKL-4,X   ; AT BOTTOM?
        BCS     ++
        INC     ESTKL-2,X   ; Y COORD++
        CMP     #192        ; OFF SCREEN?
        BCS     -
        TAY
        LDA     ESTKL-3,X   ; WIDTH7
        STA     TMPL
        LDA     ESTKL-1,X   ; X7 COORD
        CMP     #20
        BCS     ++
end
asm     _dcgrBLTMemA
        ADC     $1000,Y     ; HGRSCANL
        STA     SRCL
        LDA     #$00
        ADC     $2000,Y     ; HGRSCANH
        STA     SRCH
        LDY     #$00
--      STA     $C055       ; PAGE1X
        LDA     (SRC),Y
        STA     (DST),Y
+       INC     DSTL
        BNE     +
        INC     DSTH
+       STA     $C054       ; PAGE1M
        LDA     (SRC),Y
        INC     SRCL
        BNE     +
        INC     SRCH
+       STA     (DST),Y
        INC     DSTL
        BNE     +
        INC     DSTH
+       STA     $C055       ; PAGE1X
        LDA     (SRC),Y
        STA     (DST),Y
+       INC     DSTL
        BNE     +
        INC     DSTH
+       STA     $C054       ; PAGE1M
        LDA     (SRC),Y
        INC     SRCL
        BNE     +
        INC     SRCH
+       STA     (DST),Y
        INC     DSTL
        BNE     +
        INC     DSTH
+       DEC     TMPL
        BNE     --
        BEQ     -
++      RTS
end
export asm dcgrMemBLT(x7, y, w7, h, srcptr)#0
        INX
        INX
        INX
        INX
        INX
        LDA     ESTKL-5,X   ; SRCPTR
        STA     SRCL
        LDA     ESTKH-5,X
        STA     SRCH
        LDA     ESTKL-2,X   ; Y COORD
        CLC
        ADC     ESTKL-4,X   ; HEIGHT
        STA     ESTKL-4,X   ; -> BOTTOM EDGE
end
asm     _jmpMemOpBLT
        JMP     $A000
end
asm     _dcgrMemBLTA
-       LDA     ESTKL-2,X   ; Y COORD
        CMP     ESTKL-4,X   ; AT BOTTOM?
        BCS     ++
        INC     ESTKL-2,X   ; Y COORD++
        CMP     #192        ; OFF SCREEN?
        BCS     -
        TAY
        LDA     ESTKL-3,X   ; WIDTH7
        STA     TMPL
        LDA     ESTKL-1,X   ; X7 COORD
        CMP     #20
        BCS     ++
end
asm     _dcgrMemBLTB
        ADC     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     #$00
        ADC     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDY     #$00
--      STA     $C055       ; PAGE1X
        LDA     (SRC),Y
        INC     SRCL
        BNE     +
        INC     SRCH
+       STA     (DST),Y
        STA     $C054       ; PAGE1M
        LDA     (SRC),Y
        INC     SRCL
        BNE     +
        INC     SRCH
+       STA     (DST),Y
        INC     DSTL
        BNE     +
        INC     DSTH
+       STA     $C055       ; PAGE1X
        LDA     (SRC),Y
        INC     SRCL
        BNE     +
        INC     SRCH
+       STA     (DST),Y
        STA     $C054       ; PAGE1M
        LDA     (SRC),Y
        INC     SRCL
        BNE     +
        INC     SRCH
+       STA     (DST),Y
        INC     DSTL
        BNE     +
        INC     DSTH
+       DEC     TMPL
        BNE     --
        BEQ     -
++      RTS
end
asm     _dcgrMemOpBLTA
-       LDA     ESTKL-2,X   ; Y COORD
        CMP     ESTKL-4,X   ; AT BOTTOM?
        BCS     ++
        INC     ESTKL-2,X   ; Y COORD++
        CMP     #192        ; OFF SCREEN?
        BCS     -
        TAY
        LDA     ESTKL-3,X   ; WIDTH7
        STA     TMPL
        LDA     ESTKL-1,X   ; X7 COORD
        CMP     #20
        BCS     ++
end
asm     _dcgrMemOpBLTB
        ADC     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     #$00
        ADC     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDY     #$00
--      STA     $C055       ; PAGE1X
        LDA     (SRC),Y
        INC     SRCL
        BNE     +
        INC     SRCH
end
asm     _dcgrMemOpBLTC
+       EOR     (DST),Y
        STA     (DST),Y
        STA     $C054       ; PAGE1M
        LDA     (SRC),Y
        INC     SRCL
        BNE     +
        INC     SRCH
end
asm     _dcgrMemOpBLTD
+       EOR     (DST),Y
        STA     (DST),Y
        INC     DSTL
        BNE     +
        INC     DSTH
+       STA     $C055       ; PAGE1X
        LDA     (SRC),Y
        INC     SRCL
        BNE     +
        INC     SRCH
end
asm     _dcgrMemOpBLTE
+       EOR     (DST),Y
        STA     (DST),Y
        STA     $C054       ; PAGE1M
        LDA     (SRC),Y
        INC     SRCL
        BNE     +
        INC     SRCH
end
asm     _dcgrMemOpBLTF
+       EOR     (DST),Y
        STA     (DST),Y
        INC     DSTL
        BNE     +
        INC     DSTH
+       DEC     TMPL
        BNE     --
        BEQ     -
++      RTS
end
//
// Wait for VLB
//
export asm dcgrVLB#0
        PHP
        SEI
        STA     $C079   ; Enable IOU access and reset VBL int on //c
        STA     $C05B   ; Enable VBL int
-       LDA     $C019
        STA     $C079   ; Reset VBL int on //c
        BMI     -
-       LDA     $C019
        BPL     -
        STA     $C05A   ; Disable VBL int on //c
        STA     $C078   ; Disable IOU access on //c
        PLP
        RTS
end

export def dcgrOp(op)#0
    byte opcode

    //
    // Self modifying code!
    //
    opcode = $11 // ORA (ZP),Y
    when op
        is OP_XOR
            opcode = opcode + $20 // $51 = EOR (ZP),Y
        is OP_AND
            opcode = opcode + $20 // $31 = AND (ZP),Y
        is OP_OR
            _jmpPlotOp:1     = @_dcgrPlotOpC
            _jmpMemOpBLT:1   = @_dcgrMemOpBLTA
            _dcgrPlotOpD.3   = opcode
            _dcgrPlotOpE.3   = opcode
            _dcgrPlotOpG.3   = opcode
            _dcgrPlotOpH.3   = opcode
            _dcgrMemOpBLTC.0 = opcode
            _dcgrMemOpBLTD.0 = opcode
            _dcgrMemOpBLTE.0 = opcode
            _dcgrMemOpBLTF.0 = opcode
            break
        otherwise // OP_SRC
            _jmpPlotOp:1   = @_dcgrPlotC
            _jmpMemOpBLT:1 = @_dcgrMemBLTA
    wend
end
export def dcgrMode(mode)
    if mode >= 0
        ^page1m
        ^showfull
        ^showhires
        ^showgraphics
        ^IOUdis     = 0
        ^show80col  = 0
        ^dhresena
        ^store80ena = 0
        ^page1m
        memset($2000, 0, $2000)
        ^page1x
        memset($2000, 0, $2000)
        dcgrOp(OP_SRC)
    else
        ^store80dis = 0
        ^dhresdis
        ^show40col  = 0
        ^showtext
        ^page1m
    fin
    return mode
end

def dcgrTest#0
    byte i, j
    word pixblk, inci, incj

    setlineplot(@dcgrPlot)
    setlinespans(@dcgrHLin, @dcgrVLin)
    for i = 0 to 191 step 4
        dcgrColor(i)
        linespans(0, 0, 139, i)
    next
    for i = 139 downto 0 step 4
        dcgrColor(i)
        linespans(0, 0, i, 191)
    next
    if 1
    pixblk = heapalloc(16/2*20)
    dcgrBLTMem(0, 0, 2, 20, pixblk)
    for i = 1 to 170
        dcgrMemBLT(i/7, i, 2, 20, pixblk)
    next
    fin
    getc
    i = 86; j = 90
    inci = 1; incj = 1
    while ^$C000 < 128
        dcgrPixBLT(i, j, 16, 16, @sprite)
        if i > 114 or i < 2; inci = -inci; fin
        i = i + inci
        if j > 178 or j < 2; incj = -incj; fin
        j = j + incj
    loop
    ^$C010
    getc
end
//
// Make sure we are a 128K //e or //c
//
if MACHID & $F0 <> $B0
    puts("\n128K required for double-lores.\n")
    ^$C010
    while ^$C000 < 128; loop
    return -1
fin
//
// Assembly symbol fixups
//
_dcgrColorA:1 = @auxclrsl
_dcgrColorA:4 = @auxclrl
_dcgrColorA:7 = @auxclrsh
_dcgrColorA:10 = @auxclrh
_dcgrColorA:13 = @memclrsl
_dcgrColorA:16 = @memclrl
_dcgrColorA:19 = @memclrsh
_dcgrColorA:22 = @memclrh
_dcgrPlotA:1 = @hgrscanl
_dcgrPlotA:6 = @hgrscanh
_dcgrPlotB:1 = @divmod7
_dcgrPlotC:1 = @auxclrmsk
_dcgrPlotD:1 = @auxclrl
_dcgrPlotD:6 = @auxclrmsk
_dcgrPlotE:1 = @auxclrh
_dcgrPlotE:6 = @auxclrmsk
_dcgrPlotF:1 = @memclrmsk
_dcgrPlotG:1 = @memclrl
_dcgrPlotG:6 = @memclrmsk
_dcgrPlotH:1 = @memclrh
_dcgrPlotH:6 = @memclrmsk
_dcgrPlotOpC:1 = @auxclrmsk
_dcgrPlotOpD:1 = @auxclrl
_dcgrPlotOpE:1 = @auxclrh
_dcgrPlotOpF:1 = @memclrmsk
_dcgrPlotOpG:1 = @memclrl
_dcgrPlotOpH:1 = @memclrh
_dcgrHLinA:1 = @hgrscanl
_dcgrHLinA:6 = @hgrscanh
_dcgrHlinB:1 = @_dcgrPlotB
_dcgrVLinA:1 = @hgrscanl
_dcgrVLinA:6 = @hgrscanh
_dcgrVlinB:1 = @_dcgrPlotB
_dcgrPixBLTA:1 = @hgrscanl
_dcgrPixBLTA:6 = @hgrscanh
_dcgrPixBLTB:1 = @_dcgrColorA
_dcgrPixBLTC:1 = @_dcgrPlotB
_dcgrPixBLTD:1 = @_dcgrColorA
_dcgrPixBLTE:1 = @_dcgrPlotB
_dcgrBLTMemA:1 = @hgrscanl
_dcgrBLTMemA:8 = @hgrscanh
_dcgrMemBLTB:1 = @hgrscanl
_dcgrMemBLTB:8 = @hgrscanh
_dcgrMemOpBLTB:1 = @hgrscanl
_dcgrMemOpBLTB:8 = @hgrscanh

dcgrMode(0)
dcgrTest
dcgrMode(-1)
done
