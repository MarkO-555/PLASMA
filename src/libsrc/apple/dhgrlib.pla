include "inc/cmdsys.plh"
include "inc/lines.plh"

sysflags resxtxt1|reshgr1|resxhgr1

//
// Apple II graphics soft switches
//
const store80dis   = $C000
const store80ena   = $C001
const show40col    = $C00C
const show80col    = $C00D
const showgraphics = $C050
const showtext     = $C051
const showfull     = $C052
const showmix      = $C053
const page1m       = $C054
const page1x       = $C055
const showhires    = $C057
const dhresena     = $C05E
const dhresdis     = $C05F
const IOUdis       = $C07E
const IOUena       = $C07F
//
// HiRes scanline addresses
//
word hgrscan[] = $2000,$2400,$2800,$2C00,$3000,$3400,$3800,$3C00
word           = $2080,$2480,$2880,$2C80,$3080,$3480,$3880,$3C80
word           = $2100,$2500,$2900,$2D00,$3100,$3500,$3900,$3D00
word           = $2180,$2580,$2980,$2D80,$3180,$3580,$3980,$3D80
word           = $2200,$2600,$2A00,$2E00,$3200,$3600,$3A00,$3E00
word           = $2280,$2680,$2A80,$2E80,$3280,$3680,$3A80,$3E80
word           = $2300,$2700,$2B00,$2F00,$3300,$3700,$3B00,$3F00
word           = $2380,$2780,$2B80,$2F80,$3380,$3780,$3B80,$3F80
word           = $2028,$2428,$2828,$2C28,$3028,$3428,$3828,$3C28
word           = $20A8,$24A8,$28A8,$2CA8,$30A8,$34A8,$38A8,$3CA8
word           = $2128,$2528,$2928,$2D28,$3128,$3528,$3928,$3D28
word           = $21A8,$25A8,$29A8,$2DA8,$31A8,$35A8,$39A8,$3DA8
word           = $2228,$2628,$2A28,$2E28,$3228,$3628,$3A28,$3E28
word           = $22A8,$26A8,$2AA8,$2EA8,$32A8,$36A8,$3AA8,$3EA8
word           = $2328,$2728,$2B28,$2F28,$3328,$3728,$3B28,$3F28
word           = $23A8,$27A8,$2BA8,$2FA8,$33A8,$37A8,$3BA8,$3FA8
word           = $2050,$2450,$2850,$2C50,$3050,$3450,$3850,$3C50
word           = $20D0,$24D0,$28D0,$2CD0,$30D0,$34D0,$38D0,$3CD0
word           = $2150,$2550,$2950,$2D50,$3150,$3550,$3950,$3D50
word           = $21D0,$25D0,$29D0,$2DD0,$31D0,$35D0,$39D0,$3DD0
word           = $2250,$2650,$2A50,$2E50,$3250,$3650,$3A50,$3E50
word           = $22D0,$26D0,$2AD0,$2ED0,$32D0,$36D0,$3AD0,$3ED0
word           = $2350,$2750,$2B50,$2F50,$3350,$3750,$3B50,$3F50
word           = $23D0,$27D0,$2BD0,$2FD0,$33D0,$37D0,$3BD0,$3FD0
byte hgrscanl[]= $00,$00,$00,$00,$00,$00,$00,$00
byte           = $80,$80,$80,$80,$80,$80,$80,$80
byte           = $00,$00,$00,$00,$00,$00,$00,$00
byte           = $80,$80,$80,$80,$80,$80,$80,$80
byte           = $00,$00,$00,$00,$00,$00,$00,$00
byte           = $80,$80,$80,$80,$80,$80,$80,$80
byte           = $00,$00,$00,$00,$00,$00,$00,$00
byte           = $80,$80,$80,$80,$80,$80,$80,$80
byte           = $28,$28,$28,$28,$28,$28,$28,$28
byte           = $A8,$A8,$A8,$A8,$A8,$A8,$A8,$A8
byte           = $28,$28,$28,$28,$28,$28,$28,$28
byte           = $A8,$A8,$A8,$A8,$A8,$A8,$A8,$A8
byte           = $28,$28,$28,$28,$28,$28,$28,$28
byte           = $A8,$A8,$A8,$A8,$A8,$A8,$A8,$A8
byte           = $28,$28,$28,$28,$28,$28,$28,$28
byte           = $A8,$A8,$A8,$A8,$A8,$A8,$A8,$A8
byte           = $50,$50,$50,$50,$50,$50,$50,$50
byte           = $D0,$D0,$D0,$D0,$D0,$D0,$D0,$D0
byte           = $50,$50,$50,$50,$50,$50,$50,$50
byte           = $D0,$D0,$D0,$D0,$D0,$D0,$D0,$D0
byte           = $50,$50,$50,$50,$50,$50,$50,$50
byte           = $D0,$D0,$D0,$D0,$D0,$D0,$D0,$D0
byte           = $50,$50,$50,$50,$50,$50,$50,$50
byte           = $D0,$D0,$D0,$D0,$D0,$D0,$D0,$D0
byte hgrscanh[]= $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $20,$24,$28,$2C,$30,$34,$38,$3C
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $21,$25,$29,$2D,$31,$35,$39,$3D
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $22,$26,$2A,$2E,$32,$36,$3A,$3E
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
byte           = $23,$27,$2B,$2F,$33,$37,$3B,$3F
//
// Pixel masks for 7 contiguous pixels
//
//word auxmask[] = $000F
//word           = $0070
//word           = $0000
//word           = $0300
//word           = $3C00
//word           = $4000
//word           = $0000
byte auxclrmsk[] = $0F
byte             = $70
byte             = $00
byte             = $03|$80
byte             = $3C|$80
byte             = $40|$80
byte             = $00
//word memmedmsk[] = $0000
//word           = $0001
//word           = $001E
//word           = $0060
//word           = $0000
//word           = $0700
//word           = $7800
byte memclrmsk[] = $00
byte             = $01
byte             = $1E
byte             = $60
byte             = $00
byte             = $07|$80
byte             = $78|$80
//
// Solid colors
//
//word auxclrs[] = $0000 // black
//word           = $2208 // magenta
//word           = $1144 // brown
//word           = $334C // orange
//word           = $0822 // dark green
//word           = $2A2A // gray 1
//word           = $1966 // green
//word           = $3B6E // yellow
//word           = $4411 // dark blue
//word           = $6619 // purple
//word           = $5555 // gray 2
//word           = $775D // pink
//word           = $4C33 // medium blue
//word           = $6E3B // light blue
//word           = $5D77 // aqua
//word           = $7F7F // white
byte auxclrsl[] = $00 // black
byte            = $08 // magenta
byte            = $44 // brown
byte            = $4C // orange
byte            = $22 // dark green
byte            = $2A // gray 1
byte            = $66 // green
byte            = $6E // yellow
byte            = $11 // dark blue
byte            = $19 // purple
byte            = $55 // gray 2
byte            = $5D // pink
byte            = $33 // medium blue
byte            = $3B // light blue
byte            = $77 // aqua
byte            = $7F // white
byte auxclrsh[] = $00 // black
byte            = $22 // magenta
byte            = $11 // brown
byte            = $33 // orange
byte            = $08 // dark green
byte            = $2A // gray 1
byte            = $19 // green
byte            = $3B // yellow
byte            = $44 // dark blue
byte            = $66 // purple
byte            = $55 // gray 2
byte            = $77 // pink
byte            = $4C // medium blue
byte            = $6E // light blue
byte            = $5D // aqua
byte            = $7F // white
//word memclrs[] = $0000 // black
//word           = $4411 // magenta
//word           = $2208 // brown
//word           = $6619 // orange
//word           = $1144 // dark green
//word           = $5555 // gray 1
//word           = $334C // green
//word           = $775D // yellow
//word           = $0822 // dark blue
//word           = $4C33 // purple
//word           = $2A2A // gray 2
//word           = $6E3B // pink
//word           = $1966 // medium blue
//word           = $5D77 // light blue
//word           = $3B6E // aqua
//word           = $7F7F // white
byte memclrsl[] = $00 // black
byte            = $11 // magenta
byte            = $08 // brown
byte            = $19 // orange
byte            = $44 // dark green
byte            = $55 // gray 1
byte            = $4C // green
byte            = $5D // yellow
byte            = $22 // dark blue
byte            = $33 // purple
byte            = $2A // gray 2
byte            = $3B // pink
byte            = $66 // medium blue
byte            = $77 // light blue
byte            = $6E // aqua
byte            = $7F // white
byte memclrsh[] = $00 // black
byte            = $44 // magenta
byte            = $22 // brown
byte            = $66 // orange
byte            = $11 // dark green
byte            = $55 // gray 1
byte            = $33 // green
byte            = $77 // yellow
byte            = $08 // dark blue
byte            = $4C // purple
byte            = $2A // gray 2
byte            = $6E // pink
byte            = $19 // medium blue
byte            = $5D // light blue
byte            = $3B // aqua
byte            = $7F // white
//word auxclr, memclr
byte auxclrl, auxclrh, memclrl, memclrh
//
// Modulo 7
//
//byte mod7[] = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//byte        = 0, 1, 2, 3, 4, 5, 6
//
// Divide 7
//
//byte div7x2[] = 0, 0, 0, 0, 0, 0, 0
//byte          = 2, 2, 2, 2, 2, 2, 2
//byte          = 4, 4, 4, 4, 4, 4, 4
//byte          = 6, 6, 6, 6, 6, 6, 6
//byte          = 8, 8, 8, 8, 8, 8, 8
//byte          =10,10,10,10,10,10,10
//byte          =12,12,12,12,12,12,12
//byte          =14,14,14,14,14,14,14
//byte          =16,16,16,16,16,16,16
//byte          =18,18,18,18,18,18,18
//byte          =20,20,20,20,20,20,20
//byte          =22,22,22,22,22,22,22
//byte          =24,24,24,24,24,24,24
//byte          =26,26,26,26,26,26,26
//byte          =28,28,28,28,28,28,28
//byte          =30,30,30,30,30,30,30
//byte          =32,32,32,32,32,32,32
//byte          =34,34,34,34,34,34,34
//byte          =36,36,36,36,36,36,36
//byte          =38,38,38,38,38,38,38
byte divmod7[]  =   0+0,   0+1,   0+2,   0+3,   0+4,   0+5,   0+6
byte            =   8+0,   8+1,   8+2,   8+3,   8+4,   8+5,   8+6
byte            =  16+0,  16+1,  16+2,  16+3,  16+4,  16+5,  16+6
byte            =  24+0,  24+1,  24+2,  24+3,  24+4,  24+5,  24+6
byte            =  32+0,  32+1,  32+2,  32+3,  32+4,  32+5,  32+6
byte            =  40+0,  40+1,  40+2,  40+3,  40+4,  40+5,  40+6
byte            =  48+0,  48+1,  48+2,  48+3,  48+4,  48+5,  48+6
byte            =  56+0,  56+1,  56+2,  56+3,  56+4,  56+5,  56+6
byte            =  64+0,  64+1,  64+2,  64+3,  64+4,  64+5,  64+6
byte            =  72+0,  72+1,  72+2,  72+3,  72+4,  72+5,  72+6
byte            =  80+0,  80+1,  80+2,  80+3,  80+4,  80+5,  80+6
byte            =  88+0,  88+1,  88+2,  88+3,  88+4,  88+5,  88+6
byte            =  96+0,  96+1,  96+2,  96+3,  96+4,  96+5,  96+6
byte            = 104+0, 104+1, 104+2, 104+3, 104+4, 104+5, 104+6
byte            = 112+0, 112+1, 112+2, 112+3, 112+4, 112+5, 112+6
byte            = 120+0, 120+1, 120+2, 120+3, 120+4, 120+5, 120+6
byte            = 128+0, 128+1, 128+2, 128+3, 128+4, 128+5, 128+6
byte            = 136+0, 136+1, 136+2, 136+3, 136+4, 136+5, 136+6
byte            = 144+0, 144+1, 144+2, 144+3, 144+4, 144+5, 144+6
byte            = 152+0, 152+1, 152+2, 152+3, 152+4, 152+5, 152+6
//byte            = 160+0, 160+1, 160+2, 160+3, 160+4, 160+5, 160+6

//def dcgrPlot(x, y)#0
//    byte pix7, mask
//    word pix7addr
//
//    pix7addr = hgrscanl[y] + (hgrscanh[y] << 8) + ((divmod7[x] & $F8) >> 2)
//    pix7     = divmod7[x] & 7
//    mask = auxclrmsk[pix7]
//    if mask
//        ^page1x
//        if mask & $80 // Flag for hi byte
//            ^(pix7addr+1) = (^(pix7addr+1) & ~mask) | (mask & auxclrh)
//        else
//            ^pix7addr = (^pix7addr & ~mask) | (mask & auxclrl)
//        fin
//    fin
//    mask = memclrmsk[pix7]
//    if mask
//        ^page1m
//        if mask & $80 // Flag for hi byte
//            ^(pix7addr+1) = (^(pix7addr+1) & ~mask) | (mask & memclrh)
//        else
//            ^pix7addr = (^pix7addr & ~mask) | (mask & memclrl)
//        fin
//    fin
//end
export asm dcgrPlot(x, y)#0
!SOURCE    "vmsrc/plvmzp.inc"
        INX
        INX
        STX     ESP
        LDY     ESTKL-2,X   ; Y COORD
        CPY     #192
        BCS     +
end
asm     _dcgrPlotA
        LDA     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDY     ESTKL-1,X   ; X COORD
        CPY     #140
        BCS     +
end
asm     _dcgrPlotB
        LDA     $3000,Y     ; DIVMOD7
        TAX
        AND     #$F8
        LSR
        LSR
        TAY                 ; DIV7
        TXA
        AND     #$07
        TAX                 ; PIX7
end
asm     _dcgrPlotC
        LDA     $4000,X     ; AUXCLRMSK
        BEQ     ++
        STA     $C055       ; PAGE1X
        BMI     +++
end
asm     _dcgrPlotD
        LDA     $5000       ; AUXCLRL
        EOR     (DST),Y
        AND     $4000,X     ; AUXCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
        BNE     ++
        BEQ     ++
+++     INY
end
asm     _dcgrPlotE
        LDA     $5001       ; AUXCLRH
        EOR     (DST),Y
        AND     $4000,X     ; AUXCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
        DEY
end
asm     _dcgrPlotF
++      LDA     $4001,X     ; MEMCLRMSK
        BEQ     +
        STA     $C054       ; PAGE1M
        BMI     +++
end
asm     _dcgrPlotG
        LDA     $5002       ; MEMCLRL
        EOR     (DST),Y
        AND     $4000,X     ; MEMCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
+       LDX     ESP
        RTS
+++     INY
end
asm     _dcgrPlotH
        LDA     $5003       ; MEMCLRH
        EOR     (DST),Y
        AND     $4000,X     ; MEMCLRMSK
        EOR     (DST),Y
        STA     (DST),Y
        LDX     ESP
        RTS
end
export asm dcgrXorPlot(x, y)#0
        INX
        INX
        STX     ESP
        LDY     ESTKL-2,X   ; Y COORD
        CPY     #192
        BCS     +
end
asm     _dcgrXorPlotA
        LDA     $1000,Y     ; HGRSCANL
        STA     DSTL
        LDA     $2000,Y     ; HGRSCANH
        STA     DSTH
        LDY     ESTKL-1,X   ; X COORD
        CPY     #140
        BCS     +
end
asm     _dcgrXorPlotB
        LDA     $3000,Y     ; DIVMOD7
        TAX
        AND     #$F8
        LSR
        LSR
        TAY                 ; DIV7
        TXA
        AND     #$07
        TAX                 ; PIX7
end
asm     _dcgrXorPlotC
        LDA     $4000,X     ; AUXCLRMSK
        BEQ     ++
        STA     $C055       ; PAGE1X
        BMI     +++
end
asm     _dcgrXorPlotD
        AND     $5000       ; AUXCLRL
        EOR     (DST),Y
        STA     (DST),Y
        BNE     ++
        BEQ     ++
+++     INY
end
asm     _dcgrXorPlotE
        AND     $5001       ; AUXCLRH
        EOR     (DST),Y
        STA     (DST),Y
        DEY
end
asm     _dcgrXorPlotF
++      LDA     $4001,X     ; MEMCLRMSK
        BEQ     +
        STA     $C054       ; PAGE1M
        BMI     +++
end
asm     _dcgrXorPlotG
        AND     $5002       ; MEMCLRL
        EOR     (DST),Y
        STA     (DST),Y
+       LDX     ESP
        RTS
+++     INY
end
asm     _dcgrXorPlotH
        AND     $5003       ; MEMCLRH
        EOR     (DST),Y
        STA     (DST),Y
        LDX     ESP
        RTS
end

def dcgrHLin(x1, x2, y)#0
    byte pix7, mask
    word pix7addr

    pix7addr = hgrscanl[y] + (hgrscanh[y] << 8) + ((divmod7[x1] & $F8) >> 2)
    pix7     = divmod7[x1] & 7
    while x1 <= x2
        mask = auxclrmsk[pix7]
        if mask
            ^page1x
            if mask & $80
                ^(pix7addr+1) = (^(pix7addr+1) & ~mask) | (mask & auxclrh)
            else
                ^pix7addr = (^pix7addr & ~mask) | (mask & auxclrl)
            fin
        fin
        mask = memclrmsk[pix7]
        if mask
            ^page1m
            if mask & $80
                ^(pix7addr+1) = (^(pix7addr+1) & ~mask) | (mask & memclrh)
            else
                ^pix7addr = (^pix7addr & ~mask) | (mask & memclrl)
            fin
        fin
        pix7++
        if pix7 == 7
            pix7 = 0;
            pix7addr = pix7addr + 2
        fin
        x1++
    loop
end
def dcgrVLin(y1, y2, x)#0
    byte pix7, div7, mask
    word pix7addr

    pix7 = divmod7[x] & 7
    div7 = (divmod7[x] & $F8) >> 2
    while y1 <= y2
        pix7addr = hgrscanl[y1] + (hgrscanh[y1] << 8) + div7
        mask = auxclrmsk[pix7]
        if mask
            ^page1x
            if mask & $80
                ^(pix7addr+1) = (^(pix7addr+1) & ~mask) | (mask & auxclrh)
            else
                ^pix7addr = (^pix7addr & ~mask) | (mask & auxclrl)
            fin
        fin
        mask = memclrmsk[pix7]
        if mask
            ^page1m
            if mask & $80
                ^(pix7addr+1) = (^(pix7addr+1) & ~mask) | (mask & memclrh)
            else
                ^pix7addr = (^pix7addr & ~mask) | (mask & memclrl)
            fin
        fin
        y1++
    loop
end
def dcgrScan(x, y, w, scanptr)#0
    byte pix7, c, mask
    word pix7addr

    pix7addr = hgrscanl[y] + (hgrscanh[y] << 8) + ((divmod7[x] & $F8) >> 2)
    pix7     = divmod7[x] & 7
    for x = 1 to w
        if x & 1
            c = ^scanptr & $0F
        else
            c = ^scanptr >> 4
            scanptr++
        fin
        if (c <> 10) // gray 2 is transparent
            mask = auxclrmsk[pix7]
            if mask
                ^page1x
                if mask & $80
                    ^(pix7addr+1) = (^(pix7addr+1) & ~mask) | (mask & auxclrsh[c])
                else
                    ^pix7addr = (^pix7addr & ~mask) | (mask & auxclrsl[c])
                fin
            fin
            mask = memclrmsk[pix7]
            if mask
                ^page1m
                if mask & $80
                    ^(pix7addr+1) = (^(pix7addr+1) & ~mask) | (mask & memclrsh[c])
                else
                    ^pix7addr = (^pix7addr & ~mask) | (mask & memclrsl[c])
                fin
            fin
        fin
        pix7++
        if pix7 == 7
            pix7 = 0;
            pix7addr = pix7addr + 2
        fin
    next
end
def dcgrBLT(x, y, w, h, srcptr)#0
    word i, j
    byte c

    for j = y to y + h - 1
        dcgrScan(x, y, w, srcptr)
        srcptr = srcptr + (w + 1) / 2
    next
end
def dhgrTile(x7, y8, tileptr)#0
    word tileaddr
    byte scan

    tileaddr = hgrscan[y8 * 8] + x7 * 2
    for scan = 0 to 7
        ^page1x
        *tileaddr = *tileptr
        tileptr   = tileptr + 2
        ^page1m
        *tileaddr = *tileptr
        tileptr   = tileptr + 2
        tileaddr  = tileaddr + $0400
    next
end
def dhgrDst(x7, y, w7, h, dstptr)#0
    word pix7addr
    byte scan, b

    for scan = y to y+h-1
        pix7addr = hgrscan[scan] + x7 * 2
        for b = 1 to w7
            ^page1x
            *dstptr  = *pix7addr
            dstptr   = dstptr + 2
            ^page1m
            *dstptr  = *pix7addr
            dstptr   = dstptr + 2
            pix7addr = pix7addr + 2
        next
    next
end
def dhgrSrc(x7, y, w7, h, srcptr)#0
    word pix7addr
    byte scan, b

    for scan = y to y+h-1
        pix7addr = hgrscan[scan] + x7 * 2
        for b = 1 to w7
            ^page1x
            *pix7addr = *srcptr
            srcptr    = srcptr + 2
            ^page1m
            *pix7addr = *srcptr
            srcptr    = srcptr + 2
            pix7addr = pix7addr + 2
        next
    next
end
def dhgrColor(c)#0
    c = c & $0F
    auxclrl = auxclrsl[c]
    auxclrh = auxclrsh[c]
    memclrl = memclrsl[c]
    memclrh = memclrsh[c]
end
def dhgrMode(mode)
    if mode >= 0
        ^page1m
        ^showfull
        ^showhires
        ^showgraphics
        ^IOUdis     = 0
        ^show80col  = 0
        ^dhresena
        ^store80ena = 0
        if mode == 1 // Turn off color burst
        fin
        ^page1m
        memset($2000, 0, $2000)
        ^page1x
        memset($2000, 0, $2000)
    else
        ^store80dis = 0
        ^dhresdis
        ^show40col  = 0
        ^showtext
        ^page1m
    fin
    return mode
end

def dcgrTest#0
  byte i, j
  word pixblk

  setlineplot(@dcgrPlot)
  setlinespans(@dcgrHLin, @dcgrVLin)
  for i = 0 to 191 step 4
    dhgrColor(i)
    line(0, 0, 139, i)
  next
  for i = 139 downto 0 step 4
    dhgrColor(i)
    line(0, 0, i, 191)
  next
  pixblk = heapalloc(16/2*20)
  dhgrDst(0, 0, 2, 20, pixblk)
  for i = 1 to 170
    dhgrSrc(0, i, 2, 20, pixblk)
  next
  dhgrDst(0, 0, 1, 8, pixblk) // Create tile
  for j = 0 to 19
    for i = 0 to 19
      dhgrTile(i, j, pixblk)
    next
  next
  while ^$C000 < 128
  loop
  ^$C010
end

_dcgrPlotA:1 = @hgrscanl
_dcgrPlotA:6 = @hgrscanh
_dcgrPlotB:1 = @divmod7
_dcgrPlotC:1 = @auxclrmsk
_dcgrPlotD:1 = @auxclrl
_dcgrPlotD:6 = @auxclrmsk
_dcgrPlotE:1 = @auxclrh
_dcgrPlotE:6 = @auxclrmsk
_dcgrPlotF:1 = @memclrmsk
_dcgrPlotG:1 = @memclrl
_dcgrPlotG:6 = @memclrmsk
_dcgrPlotH:1 = @memclrh
_dcgrPlotH:6 = @memclrmsk
_dcgrXorPlotA:1 = @hgrscanl
_dcgrXorPlotA:6 = @hgrscanh
_dcgrXorPlotB:1 = @divmod7
_dcgrXorPlotC:1 = @auxclrmsk
_dcgrXorPlotD:1 = @auxclrl
_dcgrXorPlotE:1 = @auxclrh
_dcgrXorPlotF:1 = @memclrmsk
_dcgrXorPlotG:1 = @memclrl
_dcgrXorPlotH:1 = @memclrh

dhgrMode(0)
dcgrTest
dhgrMode(-1)
done
