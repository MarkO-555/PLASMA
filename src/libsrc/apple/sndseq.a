; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; libsrc/apple/sndseq.pla: 0001: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0200 // Version built against
					; _SYSVER_ = 512
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $03
					; MACHID_MEM = 3
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     //
; inc/cmdsys.plh: 0038:     // Module don't free memory
; inc/cmdsys.plh: 0039:     //
; inc/cmdsys.plh: 0040:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0041:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0042:     //
; inc/cmdsys.plh: 0043:     // CMD exported interface table
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     struc t_cmdsys
; inc/cmdsys.plh: 0046:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0047:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0048:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0049:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0050:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0051:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0052:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0053:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0054:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0055:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0056:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0057:         byte refcons    // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0058:         byte devcons    // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0059:     end
					; t_cmdsys = 21
; inc/cmdsys.plh: 0060:     //
; inc/cmdsys.plh: 0061:     // CMD exported functions
; inc/cmdsys.plh: 0062:     //
; inc/cmdsys.plh: 0063:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0064:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0065:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0066:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0067:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0068:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0069: end
; libsrc/apple/sndseq.pla: 0001: 
; libsrc/apple/sndseq.pla: 0002: include "inc/fileio.plh"
; inc/fileio.plh: 0001: import fileio
	; DCI STRING: FILEIO
	!BYTE	$C6,$C9,$CC,$C5,$C9,$4F
					; FILEIO -> X028
; inc/fileio.plh: 0002:     //
; inc/fileio.plh: 0003:     // Useful ProDOS values
; inc/fileio.plh: 0004:     //
; inc/fileio.plh: 0005:     // MACHID is defined in cmdsys.plh
; inc/fileio.plh: 0006:     // Which slot has a ROM
; inc/fileio.plh: 0007:     const SLTBYT = $BF99
					; SLTBYT = 49049
; inc/fileio.plh: 0008:     // Prefix active
; inc/fileio.plh: 0009:     const PFIXPTR = $BF9A
					; PFIXPTR = 49050
; inc/fileio.plh: 0010:     // Memory alocate bitmap
; inc/fileio.plh: 0011:     const MEMTABL = $BF58
					; MEMTABL = 48984
; inc/fileio.plh: 0012:     //
; inc/fileio.plh: 0013:     // SOS/ProDOS error codes
; inc/fileio.plh: 0014:     //
; inc/fileio.plh: 0015:     const FILE_ERR_OK            = $00
					; FILE_ERR_OK = 0
; inc/fileio.plh: 0016:     const FILE_ERR_BAD_CALL_NUM  = $01
					; FILE_ERR_BAD_CALL_NUM = 1
; inc/fileio.plh: 0017:     const FILE_ERR_BAD_PARAM_CNT = $04
					; FILE_ERR_BAD_PARAM_CNT = 4
; inc/fileio.plh: 0018:     const FILE_ERR_INT_TBL_FULL  = $25
					; FILE_ERR_INT_TBL_FULL = 37
; inc/fileio.plh: 0019:     const FILE_ERR_IO            = $27
					; FILE_ERR_IO = 39
; inc/fileio.plh: 0020:     //
; inc/fileio.plh: 0021:     // File entry struc
; inc/fileio.plh: 0022:     //
; inc/fileio.plh: 0023:     struc t_fileentry
; inc/fileio.plh: 0024:         byte store_namelen
					; store_namelen = 0
; inc/fileio.plh: 0025:         byte entry_name[15]
					; entry_name = 1
; inc/fileio.plh: 0026:         byte entry_type
					; entry_type = 16
; inc/fileio.plh: 0027:         word entry_keyptr
					; entry_keyptr = 17
; inc/fileio.plh: 0028:         word entry_blocks
					; entry_blocks = 19
; inc/fileio.plh: 0029:         word entry_EOFL
					; entry_EOFL = 21
; inc/fileio.plh: 0030:         byte entry_EOFH
					; entry_EOFH = 23
; inc/fileio.plh: 0031:         word entry_create[2]
					; entry_create = 24
; inc/fileio.plh: 0032:         byte entry_version
					; entry_version = 28
; inc/fileio.plh: 0033:         byte entry_minver
					; entry_minver = 29
; inc/fileio.plh: 0034:         byte entry_access
					; entry_access = 30
; inc/fileio.plh: 0035:         word entry_aux
					; entry_aux = 31
; inc/fileio.plh: 0036:         word entry_mod[2]
					; entry_mod = 33
; inc/fileio.plh: 0037:         word entry_headptr
					; entry_headptr = 37
; inc/fileio.plh: 0038:     end
					; t_fileentry = 39
; inc/fileio.plh: 0039:     //
; inc/fileio.plh: 0040:     // File info struc
; inc/fileio.plh: 0041:     //
; inc/fileio.plh: 0042:     struc t_fileinfo
; inc/fileio.plh: 0043:         byte file_access
					; file_access = 0
; inc/fileio.plh: 0044:         byte file_type
					; file_type = 1
; inc/fileio.plh: 0045:         word aux_type
					; aux_type = 2
; inc/fileio.plh: 0046:         byte storage_type
					; storage_type = 4
; inc/fileio.plh: 0047:         word blocks_used
					; blocks_used = 5
; inc/fileio.plh: 0048:         word mod_date
					; mod_date = 7
; inc/fileio.plh: 0049:         word mod_time
					; mod_time = 9
; inc/fileio.plh: 0050:         word create_date
					; create_date = 11
; inc/fileio.plh: 0051:         word create_time
					; create_time = 13
; inc/fileio.plh: 0052:     end
					; t_fileinfo = 15
; inc/fileio.plh: 0053:     //
; inc/fileio.plh: 0054:     // File functions
; inc/fileio.plh: 0055:     //
; inc/fileio.plh: 0056:     struc t_fileio
; inc/fileio.plh: 0057:         word getpfx
					; getpfx = 0
; inc/fileio.plh: 0058:         word setpfx
					; setpfx = 2
; inc/fileio.plh: 0059:         word getfileinfo
					; getfileinfo = 4
; inc/fileio.plh: 0060:         word setfileinfo
					; setfileinfo = 6
; inc/fileio.plh: 0061:         word geteof
					; geteof = 8
; inc/fileio.plh: 0062:         word seteof
					; seteof = 10
; inc/fileio.plh: 0063:         word iobufalloc
					; iobufalloc = 12
; inc/fileio.plh: 0064:         word open
					; open = 14
; inc/fileio.plh: 0065:         word close
					; close = 16
; inc/fileio.plh: 0066:         word read
					; read = 18
; inc/fileio.plh: 0067:         word write
					; write = 20
; inc/fileio.plh: 0068:         word create
					; create = 22
; inc/fileio.plh: 0069:         word destroy
					; destroy = 24
; inc/fileio.plh: 0070:         word rename
					; rename = 26
; inc/fileio.plh: 0071:         word newline
					; newline = 28
; inc/fileio.plh: 0072:         word online
					; online = 30
; inc/fileio.plh: 0073:         word readblock
					; readblock = 32
; inc/fileio.plh: 0074:         word writeblock
					; writeblock = 34
; inc/fileio.plh: 0075:     end
					; t_fileio = 36
; inc/fileio.plh: 0076:     //
; inc/fileio.plh: 0077:     // Globally accessible error code
; inc/fileio.plh: 0078:     //
; inc/fileio.plh: 0079:     byte perr
					; PERR -> X029
; inc/fileio.plh: 0080: end
; libsrc/apple/sndseq.pla: 0002: 
; libsrc/apple/sndseq.pla: 0003: include "inc/args.plh"
; inc/args.plh: 0001: import args
	; DCI STRING: ARGS
	!BYTE	$C1,$D2,$C7,$53
					; ARGS -> X030
; inc/args.plh: 0002:     predef  argFirst, argNext(str)
					; ARGFIRST -> X031
					; ARGNEXT -> X032
; inc/args.plh: 0003: end
; libsrc/apple/sndseq.pla: 0003: 
; libsrc/apple/sndseq.pla: 0004: //
; libsrc/apple/sndseq.pla: 0005: // Usage is documented following the source in this file...
; libsrc/apple/sndseq.pla: 0006: //
; libsrc/apple/sndseq.pla: 0007: const rndseed        = $004E
	!BYTE	$00			; END OF MODULE DEPENDENCIES
					; rndseed = 78
; libsrc/apple/sndseq.pla: 0008: const LSB            = 0
					; LSB = 0
; libsrc/apple/sndseq.pla: 0009: const MSB            = 1
					; MSB = 1
; libsrc/apple/sndseq.pla: 0010: const MB_ARPEGGIO    = 4 // In 16ths of a second
					; MB_ARPEGGIO = 4
; libsrc/apple/sndseq.pla: 0011: const MAX_MBCH_NOTES = 9
					; MAX_MBCH_NOTES = 9
; libsrc/apple/sndseq.pla: 0012: const SPKR_ARPEGGIO  = 2 // In 16ths of a second
					; SPKR_ARPEGGIO = 2
; libsrc/apple/sndseq.pla: 0013: const DUR16TH        = 8
					; DUR16TH = 8
; libsrc/apple/sndseq.pla: 0014: const MAX_SPKR_NOTES = 4
					; MAX_SPKR_NOTES = 4
; libsrc/apple/sndseq.pla: 0015: const NOTEDIV        = 4
					; NOTEDIV = 4
; libsrc/apple/sndseq.pla: 0016: //
; libsrc/apple/sndseq.pla: 0017: // 6522 VIA registers
; libsrc/apple/sndseq.pla: 0018: //
; libsrc/apple/sndseq.pla: 0019: struc t_VIA
; libsrc/apple/sndseq.pla: 0020:     byte IORB       // I/O Register B
					; IORB = 0
; libsrc/apple/sndseq.pla: 0021:     byte IORA       // I/O Register A
					; IORA = 1
; libsrc/apple/sndseq.pla: 0022:     byte DDRB       // Data Direction Register B
					; DDRB = 2
; libsrc/apple/sndseq.pla: 0023:     byte DDRA       // Data Direction Register A
					; DDRA = 3
; libsrc/apple/sndseq.pla: 0024:     word T1C        // Timer 1 Count
					; T1C = 4
; libsrc/apple/sndseq.pla: 0025:     word T1L        // Timer 1 Latch
					; T1L = 6
; libsrc/apple/sndseq.pla: 0026:     word T2C        // Timer 2 Count
					; T2C = 8
; libsrc/apple/sndseq.pla: 0027:     byte SR         // Shift Register
					; SR = 10
; libsrc/apple/sndseq.pla: 0028:     byte ACR        // Aux Control Register
					; ACR = 11
; libsrc/apple/sndseq.pla: 0029:     byte PCR        // Peripheral Control Register
					; PCR = 12
; libsrc/apple/sndseq.pla: 0030:     byte IFR        // Interrupt Flag Register
					; IFR = 13
; libsrc/apple/sndseq.pla: 0031:     byte IER        // Interrupt Enable Register
					; IER = 14
; libsrc/apple/sndseq.pla: 0032:     byte IOA_noHS   // I/O Register A - no HandShake
					; IOA_noHS = 15
; libsrc/apple/sndseq.pla: 0033: end
					; t_VIA = 16
; libsrc/apple/sndseq.pla: 0034: const T1CH = T1C+1
					; T1CH = 5
; libsrc/apple/sndseq.pla: 0035: //
; libsrc/apple/sndseq.pla: 0036: // AY-3-8910 PSG registers
; libsrc/apple/sndseq.pla: 0037: //
; libsrc/apple/sndseq.pla: 0038: struc t_PSG
; libsrc/apple/sndseq.pla: 0039:     word AFREQ      // A Frequency Period
					; AFREQ = 0
; libsrc/apple/sndseq.pla: 0040:     word BFREQ      // B Frequency Period
					; BFREQ = 2
; libsrc/apple/sndseq.pla: 0041:     word CFREQ      // C Frequency Period
					; CFREQ = 4
; libsrc/apple/sndseq.pla: 0042:     byte NGFREQ     // Noise Generator Frequency Period
					; NGFREQ = 6
; libsrc/apple/sndseq.pla: 0043:     byte MIXER      // Enable=0/Disable=1 NG C(5) B(4) A(3) Tone C(2) B(1) A(0)
					; MIXER = 7
; libsrc/apple/sndseq.pla: 0044:     byte AENVAMP    // A Envelope/Amplitude
					; AENVAMP = 8
; libsrc/apple/sndseq.pla: 0045:     byte BENVAMP    // B Envelope/Amplitude
					; BENVAMP = 9
; libsrc/apple/sndseq.pla: 0046:     byte CENVAMP    // C Envelope/Amplitude
					; CENVAMP = 10
; libsrc/apple/sndseq.pla: 0047:     word ENVPERIOD  // Envelope Period
					; ENVPERIOD = 11
; libsrc/apple/sndseq.pla: 0048:     byte ENVSHAPE   // Envelope Shape
					; ENVSHAPE = 13
; libsrc/apple/sndseq.pla: 0049: end
					; t_PSG = 14
; libsrc/apple/sndseq.pla: 0050: //
; libsrc/apple/sndseq.pla: 0051: // Apple III hardware constants.
; libsrc/apple/sndseq.pla: 0052: //
; libsrc/apple/sndseq.pla: 0053: const ENV_REG      = $FFDF
					; ENV_REG = 65503
; libsrc/apple/sndseq.pla: 0054: //
; libsrc/apple/sndseq.pla: 0055: // Sequence event
; libsrc/apple/sndseq.pla: 0056: //
; libsrc/apple/sndseq.pla: 0057: struc t_event
; libsrc/apple/sndseq.pla: 0058:     byte deltatime  // Event delta time in 4.4 seconds
					; deltatime = 0
; libsrc/apple/sndseq.pla: 0059:     byte percnote   // Percussion:7==0 ? Pitch:4-0 : Octave:6-4,Note:3-0
					; percnote = 1
; libsrc/apple/sndseq.pla: 0060:     byte perchanvol // Percussion      ? EnvDur:7-0           : Channel:7,Volume:3-0
					; perchanvol = 2
; libsrc/apple/sndseq.pla: 0061: end
					; t_event = 3
; libsrc/apple/sndseq.pla: 0062: //
; libsrc/apple/sndseq.pla: 0063: // Predef routines
; libsrc/apple/sndseq.pla: 0064: //
; libsrc/apple/sndseq.pla: 0065: predef musicPlay(track, rept)#0
; libsrc/apple/sndseq.pla: 0066: predef musicStop#0
; libsrc/apple/sndseq.pla: 0067: predef spkrSequence(yield, func)#0
; libsrc/apple/sndseq.pla: 0068: predef a2spkrTone(pitch, duration)#0
; libsrc/apple/sndseq.pla: 0069: predef a2spkrPWM(sample, speed, len)#0
; libsrc/apple/sndseq.pla: 0070: predef a2keypressed
; libsrc/apple/sndseq.pla: 0071: //
; libsrc/apple/sndseq.pla: 0072: // Static sequencer values
; libsrc/apple/sndseq.pla: 0073: //
; libsrc/apple/sndseq.pla: 0074: export word musicSequence = @spkrSequence
_D039 					; musicSequence = @spkrSequence
_F000 	!WORD	_P002
; libsrc/apple/sndseq.pla: 0075: export word spkrTone      = @a2spkrTone
_D040 					; spkrTone      = @a2spkrTone
_F001 	!WORD	_P003
; libsrc/apple/sndseq.pla: 0076: export word spkrPWM       = @a2spkrPWM
_D041 					; spkrPWM       = @a2spkrPWM
_F002 	!WORD	_P004
; libsrc/apple/sndseq.pla: 0077: word        keypressed    = @a2keypressed
_D042 					; keypressed    = @a2keypressed
_F003 	!WORD	_P005
; libsrc/apple/sndseq.pla: 0078: 
; libsrc/apple/sndseq.pla: 0079: word instr[] // Overlay with other variables
_D043 					; instr[] // Overlay with other variables
; libsrc/apple/sndseq.pla: 0080: word seqTrack, seqEvent, seqTime, eventTime, updateTime
_D044 	!FILL	2			; seqTrack, seqEvent, seqTime, eventTime, updateTime
_D045 	!FILL	2			; seqEvent, seqTime, eventTime, updateTime
_D046 	!FILL	2			; seqTime, eventTime, updateTime
_D047 	!FILL	2			; eventTime, updateTime
_D048 	!FILL	2			; updateTime
; libsrc/apple/sndseq.pla: 0081: byte numNotes, seqRepeat
_D049 	!FILL	1			; numNotes, seqRepeat
_D050 	!FILL	1			; seqRepeat
; libsrc/apple/sndseq.pla: 0082: byte indexA[2], indexB[2], indexC[2]
_D051 	!FILL	2			; indexA[2], indexB[2], indexC[2]
_D052 	!FILL	2			; indexB[2], indexC[2]
_D053 	!FILL	2			; indexC[2]
; libsrc/apple/sndseq.pla: 0083: byte noteA[2], noteB[2], noteC[2]
_D054 	!FILL	2			; noteA[2], noteB[2], noteC[2]
_D055 	!FILL	2			; noteB[2], noteC[2]
_D056 	!FILL	2			; noteC[2]
; libsrc/apple/sndseq.pla: 0084: word notes1[MAX_MBCH_NOTES], notes2[MAX_MBCH_NOTES]
_D057 	!FILL	18			; notes1[MAX_MBCH_NOTES], notes2[MAX_MBCH_NOTES]
_D058 	!FILL	18			; notes2[MAX_MBCH_NOTES]
; libsrc/apple/sndseq.pla: 0085: word notes[2] = @notes1, @notes2
_D059 					; notes[2] = @notes1, @notes2
_F004 	!WORD	_D057
_F005 	!WORD	_D058
; libsrc/apple/sndseq.pla: 0086: word periods1[MAX_MBCH_NOTES], periods2[MAX_MBCH_NOTES]
_D060 	!FILL	18			; periods1[MAX_MBCH_NOTES], periods2[MAX_MBCH_NOTES]
_D061 	!FILL	18			; periods2[MAX_MBCH_NOTES]
; libsrc/apple/sndseq.pla: 0087: word periods[2] = @periods1, @periods2
_D062 					; periods[2] = @periods1, @periods2
_F006 	!WORD	_D060
_F007 	!WORD	_D061
; libsrc/apple/sndseq.pla: 0088: //
; libsrc/apple/sndseq.pla: 0089: // MockingBoard data.
; libsrc/apple/sndseq.pla: 0090: //
; libsrc/apple/sndseq.pla: 0091: word[] mbVIAs      // Treat this as an array of VIA ptrs
_D063 					; mbVIAs      // Treat this as an array of VIA ptrs
; libsrc/apple/sndseq.pla: 0092: word   mbVIA1, mbVIA2
_D064 	!FILL	2			; mbVIA1, mbVIA2
_D065 	!FILL	2			; mbVIA2
; libsrc/apple/sndseq.pla: 0093: word   mbSlot = -1
_D066 					; mbSlot = -1
	!WORD	$FFFF
; libsrc/apple/sndseq.pla: 0094: //
; libsrc/apple/sndseq.pla: 0095: // Octave basis frequency periods (starting at MIDI note #12)
; libsrc/apple/sndseq.pla: 0096: // Notes will be encoded as basis note (LSNibble) and octave (MSNibble))
; libsrc/apple/sndseq.pla: 0097: //
; libsrc/apple/sndseq.pla: 0098: word[] spkrOctave0 // Overlay and scale mbOctave0 for speaker version
_D067 					; spkrOctave0 // Overlay and scale mbOctave0 for speaker version
; libsrc/apple/sndseq.pla: 0099: word[12] mbOctave0 = 3900, 3681, 3474, 3279, 3095, 2922, 2758, 2603, 2457, 2319, 2189, 2066
_D068 					; mbOctave0 = 3900, 3681, 3474, 3279, 3095, 2922, 2758, 2603, 2457, 2319, 2189, 2066
	!WORD	$0F3C
	!WORD	$0E61
	!WORD	$0D92
	!WORD	$0CCF
	!WORD	$0C17
	!WORD	$0B6A
	!WORD	$0AC6
	!WORD	$0A2B
	!WORD	$0999
	!WORD	$090F
	!WORD	$088D
	!WORD	$0812
; libsrc/apple/sndseq.pla: 0100: word[5] arpeggioDuration = DUR16TH, DUR16TH, DUR16TH/2, DUR16TH/3, DUR16TH/4
_D069 					; arpeggioDuration = DUR16TH, DUR16TH, DUR16TH/2, DUR16TH/3, DUR16TH/4
	!WORD	$0008
	!WORD	$0008
	!WORD	$0004
	!WORD	$0002
	!WORD	$0002
; libsrc/apple/sndseq.pla: 0101: //
; libsrc/apple/sndseq.pla: 0102: // Emulators are broken - they only activate the MockingBoard's 6522 Timer1
; libsrc/apple/sndseq.pla: 0103: // functionality when interrupts are enabled. This music sequencer is run
; libsrc/apple/sndseq.pla: 0104: // in polling mode without the use of MockingBoard interrupts. To work around
; libsrc/apple/sndseq.pla: 0105: // the emulators, MockingBoard interrupts are enabled, but the 6502 IRQs are
; libsrc/apple/sndseq.pla: 0106: // disabled. NO INTERRUPTS ARE HANDLED WHEN PLAYING MUSIC! The previous state
; libsrc/apple/sndseq.pla: 0107: // is restored between playing sequences.
; libsrc/apple/sndseq.pla: 0108: //
; libsrc/apple/sndseq.pla: 0109: asm vmincs
_A000 					; vmincs()
; libsrc/apple/sndseq.pla: 0110:         !SOURCE "vmsrc/plvmzp.inc"
        !SOURCE "vmsrc/plvmzp.inc"
; libsrc/apple/sndseq.pla: 0111: end
; libsrc/apple/sndseq.pla: 0112: asm getStatusReg#1
_A001 					; getStatusReg()
; libsrc/apple/sndseq.pla: 0113:         PHP
        PHP
; libsrc/apple/sndseq.pla: 0114:         PLA
        PLA
; libsrc/apple/sndseq.pla: 0115:         DEX
        DEX
; libsrc/apple/sndseq.pla: 0116:         STA     ESTKL,X
        STA     ESTKL,X
; libsrc/apple/sndseq.pla: 0117:         LDA     #$00
        LDA     #$00
; libsrc/apple/sndseq.pla: 0118:         STA     ESTKH,X
        STA     ESTKH,X
; libsrc/apple/sndseq.pla: 0119:         RTS
        RTS
; libsrc/apple/sndseq.pla: 0120: end
; libsrc/apple/sndseq.pla: 0121: asm setStatusReg(stat)#0
_A002 					; setStatusReg()
; libsrc/apple/sndseq.pla: 0122:         LDA     ESTKL,X
        LDA     ESTKL,X
; libsrc/apple/sndseq.pla: 0123:         INX
        INX
; libsrc/apple/sndseq.pla: 0124:         PHA
        PHA
; libsrc/apple/sndseq.pla: 0125:         PLP
        PLP
; libsrc/apple/sndseq.pla: 0126:         RTS
        RTS
; libsrc/apple/sndseq.pla: 0127: end
; libsrc/apple/sndseq.pla: 0128: asm disableInts#0
_A003 					; disableInts()
; libsrc/apple/sndseq.pla: 0129:         SEI
        SEI
; libsrc/apple/sndseq.pla: 0130:         RTS
        RTS
; libsrc/apple/sndseq.pla: 0131: end
; libsrc/apple/sndseq.pla: 0132: asm enableInts#0
_A004 					; enableInts()
; libsrc/apple/sndseq.pla: 0133:         CLI
        CLI
; libsrc/apple/sndseq.pla: 0134:         RTS
        RTS
; libsrc/apple/sndseq.pla: 0135: end
; libsrc/apple/sndseq.pla: 0136: //
; libsrc/apple/sndseq.pla: 0137: // Write Programmable Sound Generator Registers
; libsrc/apple/sndseq.pla: 0138: //
; libsrc/apple/sndseq.pla: 0139: asm psgWriteTone(pVIA, reg, freq, vol)#0
_A005 					; psgWriteTone()
; libsrc/apple/sndseq.pla: 0140:         LDA     ESTKL+3,X
        LDA     ESTKL+3,X
; libsrc/apple/sndseq.pla: 0141:         STA     TMPL
        STA     TMPL
; libsrc/apple/sndseq.pla: 0142:         LDA     ESTKH+3,X
        LDA     ESTKH+3,X
; libsrc/apple/sndseq.pla: 0143:         STA     TMPH
        STA     TMPH
; libsrc/apple/sndseq.pla: 0144:         LDY     #$01
        LDY     #$01
; libsrc/apple/sndseq.pla: 0145:         LDA     ESTKL+2,X
        LDA     ESTKL+2,X
; libsrc/apple/sndseq.pla: 0146:         LSR
        LSR
; libsrc/apple/sndseq.pla: 0147:         ADC     #$08
        ADC     #$08
; libsrc/apple/sndseq.pla: 0148:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0149:         DEY
        DEY
; libsrc/apple/sndseq.pla: 0150:         LDA     #$07
        LDA     #$07
; libsrc/apple/sndseq.pla: 0151:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0152:         LDA     #$04
        LDA     #$04
; libsrc/apple/sndseq.pla: 0153:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0154:         LDA     ESTKL,X
        LDA     ESTKL,X
; libsrc/apple/sndseq.pla: 0155:         INY
        INY
; libsrc/apple/sndseq.pla: 0156:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0157:         DEY
        DEY
; libsrc/apple/sndseq.pla: 0158:         LDA     #$06
        LDA     #$06
; libsrc/apple/sndseq.pla: 0159:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0160:         LDA     #$04
        LDA     #$04
; libsrc/apple/sndseq.pla: 0161:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0162:         INX
        INX
; libsrc/apple/sndseq.pla: 0163:         BNE     +
        BNE     +
; libsrc/apple/sndseq.pla: 0164: end
; libsrc/apple/sndseq.pla: 0165: asm psgWriteWord(pVIA, reg, val)#0
_A006 					; psgWriteWord()
; libsrc/apple/sndseq.pla: 0166:         LDA     ESTKL+2,X
        LDA     ESTKL+2,X
; libsrc/apple/sndseq.pla: 0167:         STA     TMPL
        STA     TMPL
; libsrc/apple/sndseq.pla: 0168:         LDA     ESTKH+2,X
        LDA     ESTKH+2,X
; libsrc/apple/sndseq.pla: 0169:         STA     TMPH
        STA     TMPH
; libsrc/apple/sndseq.pla: 0170: +       LDY     #$01
+       LDY     #$01
; libsrc/apple/sndseq.pla: 0171:         TYA
        TYA
; libsrc/apple/sndseq.pla: 0172:         CLC
        CLC
; libsrc/apple/sndseq.pla: 0173:         ADC     ESTKL+1,X
        ADC     ESTKL+1,X
; libsrc/apple/sndseq.pla: 0174:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0175:         DEY
        DEY
; libsrc/apple/sndseq.pla: 0176:         LDA     #$07
        LDA     #$07
; libsrc/apple/sndseq.pla: 0177:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0178:         LDA     #$04
        LDA     #$04
; libsrc/apple/sndseq.pla: 0179:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0180:         LDA     ESTKH,X
        LDA     ESTKH,X
; libsrc/apple/sndseq.pla: 0181:         INY
        INY
; libsrc/apple/sndseq.pla: 0182:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0183:         DEY
        DEY
; libsrc/apple/sndseq.pla: 0184:         LDA     #$06
        LDA     #$06
; libsrc/apple/sndseq.pla: 0185:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0186:         LDA     #$04
        LDA     #$04
; libsrc/apple/sndseq.pla: 0187:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0188:         BNE     +
        BNE     +
; libsrc/apple/sndseq.pla: 0189: end
; libsrc/apple/sndseq.pla: 0190: asm psgWrite(pVIA, reg, val)#0
_A007 					; psgWrite()
; libsrc/apple/sndseq.pla: 0191:         LDA     ESTKL+2,X
        LDA     ESTKL+2,X
; libsrc/apple/sndseq.pla: 0192:         STA     TMPL
        STA     TMPL
; libsrc/apple/sndseq.pla: 0193:         LDA     ESTKH+2,X
        LDA     ESTKH+2,X
; libsrc/apple/sndseq.pla: 0194:         STA     TMPH
        STA     TMPH
; libsrc/apple/sndseq.pla: 0195: +       LDY     #$01
+       LDY     #$01
; libsrc/apple/sndseq.pla: 0196:         LDA     ESTKL+1,X
        LDA     ESTKL+1,X
; libsrc/apple/sndseq.pla: 0197:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0198:         DEY
        DEY
; libsrc/apple/sndseq.pla: 0199:         LDA     #$07
        LDA     #$07
; libsrc/apple/sndseq.pla: 0200:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0201:         LDA     #$04
        LDA     #$04
; libsrc/apple/sndseq.pla: 0202:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0203:         LDA     ESTKL,X
        LDA     ESTKL,X
; libsrc/apple/sndseq.pla: 0204:         INY
        INY
; libsrc/apple/sndseq.pla: 0205:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0206:         DEY
        DEY
; libsrc/apple/sndseq.pla: 0207:         LDA     #$06
        LDA     #$06
; libsrc/apple/sndseq.pla: 0208:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0209:         LDA     #$04
        LDA     #$04
; libsrc/apple/sndseq.pla: 0210:         STA     (TMP),Y
        STA     (TMP),Y
; libsrc/apple/sndseq.pla: 0211:         INX
        INX
; libsrc/apple/sndseq.pla: 0212:         INX
        INX
; libsrc/apple/sndseq.pla: 0213:         INX
        INX
; libsrc/apple/sndseq.pla: 0214:         RTS
        RTS
; libsrc/apple/sndseq.pla: 0215: end
; libsrc/apple/sndseq.pla: 0216: asm viaCheck(pVIA)#1
_A008 					; viaCheck()
; libsrc/apple/sndseq.pla: 0217:         PHP
        PHP
; libsrc/apple/sndseq.pla: 0218:         SEI
        SEI
; libsrc/apple/sndseq.pla: 0219:         LDA     ESTKL,X
        LDA     ESTKL,X
; libsrc/apple/sndseq.pla: 0220:         STA     TMPL
        STA     TMPL
; libsrc/apple/sndseq.pla: 0221:         LDA     ESTKH,X
        LDA     ESTKH,X
; libsrc/apple/sndseq.pla: 0222:         STA     TMPH
        STA     TMPH
; libsrc/apple/sndseq.pla: 0223:         STX     ESP
        STX     ESP
; libsrc/apple/sndseq.pla: 0224:         LDX     #$80
        LDX     #$80
; libsrc/apple/sndseq.pla: 0225:         LDY     #$04
        LDY     #$04
; libsrc/apple/sndseq.pla: 0226:         SEC
        SEC
; libsrc/apple/sndseq.pla: 0227: -       LDA     (TMP),Y
-       LDA     (TMP),Y
; libsrc/apple/sndseq.pla: 0228:         BMI     +
        BMI     +
; libsrc/apple/sndseq.pla: 0229:         DEX
        DEX
; libsrc/apple/sndseq.pla: 0230:         BNE     -
        BNE     -
; libsrc/apple/sndseq.pla: 0231:         TXA                 ; TIMEOUT
        TXA                 ; TIMEOUT
; libsrc/apple/sndseq.pla: 0232:         BEQ     ++
        BEQ     ++
; libsrc/apple/sndseq.pla: 0233: +       SBC     (TMP),Y
+       SBC     (TMP),Y
; libsrc/apple/sndseq.pla: 0234: ++      LDX     ESP
++      LDX     ESP
; libsrc/apple/sndseq.pla: 0235:         STA     ESTKL,X
        STA     ESTKL,X
; libsrc/apple/sndseq.pla: 0236:         LDA     #$00
        LDA     #$00
; libsrc/apple/sndseq.pla: 0237:         STA     ESTKH,X
        STA     ESTKH,X
; libsrc/apple/sndseq.pla: 0238:         PLP
        PLP
; libsrc/apple/sndseq.pla: 0239:         RTS
        RTS
; libsrc/apple/sndseq.pla: 0240: end
; libsrc/apple/sndseq.pla: 0241: //
; libsrc/apple/sndseq.pla: 0242: // Apple II speaker tone generator routines
; libsrc/apple/sndseq.pla: 0243: //
; libsrc/apple/sndseq.pla: 0244: asm a2spkrTone(pitch, duration)#0
_P003 					; a2spkrTone(pitch, duration)#0()
_A009 					; a2spkrTone()
; libsrc/apple/sndseq.pla: 0245:         STX     ESP
        STX     ESP
; libsrc/apple/sndseq.pla: 0246:         LDY     ESTKH,X
        LDY     ESTKH,X
; libsrc/apple/sndseq.pla: 0247:         LDA     ESTKL,X
        LDA     ESTKL,X
; libsrc/apple/sndseq.pla: 0248:         BEQ     +
        BEQ     +
; libsrc/apple/sndseq.pla: 0249:         INY
        INY
; libsrc/apple/sndseq.pla: 0250: +       STA     DSTL
+       STA     DSTL
; libsrc/apple/sndseq.pla: 0251:         STY     DSTH
        STY     DSTH
; libsrc/apple/sndseq.pla: 0252:         LDY     ESTKH+1,X
        LDY     ESTKH+1,X
; libsrc/apple/sndseq.pla: 0253:         LDA     ESTKL+1,X
        LDA     ESTKL+1,X
; libsrc/apple/sndseq.pla: 0254:         BEQ     +
        BEQ     +
; libsrc/apple/sndseq.pla: 0255:         INY
        INY
; libsrc/apple/sndseq.pla: 0256: +       STA     TMPL
+       STA     TMPL
; libsrc/apple/sndseq.pla: 0257:         STY     TMPH
        STY     TMPH
; libsrc/apple/sndseq.pla: 0258:         TAX
        TAX
; libsrc/apple/sndseq.pla: 0259:         LDA     #$FF
        LDA     #$FF
; libsrc/apple/sndseq.pla: 0260:         PHP
        PHP
; libsrc/apple/sndseq.pla: 0261:         SEI
        SEI
; libsrc/apple/sndseq.pla: 0262: ;
; libsrc/apple/sndseq.pla: 0263: ; Total loop count is 32 cycles, regardless of path taken
; Total loop count is 32 cycles, regardless of path taken
; libsrc/apple/sndseq.pla: 0264: ;
; libsrc/apple/sndseq.pla: 0265: -       NOP                 ; 2
-       NOP                 ; 2
; libsrc/apple/sndseq.pla: 0266:         NOP                 ; 2
        NOP                 ; 2
; libsrc/apple/sndseq.pla: 0267:         BCS     +           ; 3
        BCS     +           ; 3
; libsrc/apple/sndseq.pla: 0268:                             ;---
                            ;---
; libsrc/apple/sndseq.pla: 0269:                             ;+7 = 12 (from BCS below)
                            ;+7 = 12 (from BCS below)
; libsrc/apple/sndseq.pla: 0270: +
+
; libsrc/apple/sndseq.pla: 0271: --      SEC                 ; 2
--      SEC                 ; 2
; libsrc/apple/sndseq.pla: 0272:         DEX                 ; 2
        DEX                 ; 2
; libsrc/apple/sndseq.pla: 0273:         BNE     ++          ; 2/3
        BNE     ++          ; 2/3
; libsrc/apple/sndseq.pla: 0274:                             ;----
                            ;----
; libsrc/apple/sndseq.pla: 0275:                             ; 6/7
                            ; 6/7
; libsrc/apple/sndseq.pla: 0276: 
; libsrc/apple/sndseq.pla: 0277:         DEY                 ; 2
        DEY                 ; 2
; libsrc/apple/sndseq.pla: 0278:         BNE     +++         ; 2/3
        BNE     +++         ; 2/3
; libsrc/apple/sndseq.pla: 0279:                             ;----
                            ;----
; libsrc/apple/sndseq.pla: 0280:                             ;+4/5 = 10/11
                            ;+4/5 = 10/11
; libsrc/apple/sndseq.pla: 0281: 
; libsrc/apple/sndseq.pla: 0282:         BIT     $C030       ; 4
        BIT     $C030       ; 4
; libsrc/apple/sndseq.pla: 0283:         LDX     TMPL        ; 3
        LDX     TMPL        ; 3
; libsrc/apple/sndseq.pla: 0284:         LDY     TMPH        ; 3
        LDY     TMPH        ; 3
; libsrc/apple/sndseq.pla: 0285:                             ;---
                            ;---
; libsrc/apple/sndseq.pla: 0286:                             ;+10 = 20
                            ;+10 = 20
; libsrc/apple/sndseq.pla: 0287: 
; libsrc/apple/sndseq.pla: 0288: TONELP  SBC     #$01        ; 2
TONELP  SBC     #$01        ; 2
; libsrc/apple/sndseq.pla: 0289:         BCS     -           ; 2/3
        BCS     -           ; 2/3
; libsrc/apple/sndseq.pla: 0290:                             ;----
                            ;----
; libsrc/apple/sndseq.pla: 0291:                             ; 4/5
                            ; 4/5
; libsrc/apple/sndseq.pla: 0292: 
; libsrc/apple/sndseq.pla: 0293:         DEC     DSTL        ; 5
        DEC     DSTL        ; 5
; libsrc/apple/sndseq.pla: 0294:         BNE     --          ; 3
        BNE     --          ; 3
; libsrc/apple/sndseq.pla: 0295:                             ;----
                            ;----
; libsrc/apple/sndseq.pla: 0296:                             ;+8 = 12
                            ;+8 = 12
; libsrc/apple/sndseq.pla: 0297: 
; libsrc/apple/sndseq.pla: 0298:         DEC     DSTH        ; This sequence isn't accounted for
        DEC     DSTH        ; This sequence isn't accounted for
; libsrc/apple/sndseq.pla: 0299:         BNE     --          ; since it is taken only in extreme cases
        BNE     --          ; since it is taken only in extreme cases
; libsrc/apple/sndseq.pla: 0300:         BEQ     TONEXIT
        BEQ     TONEXIT
; libsrc/apple/sndseq.pla: 0301: 
; libsrc/apple/sndseq.pla: 0302: ++      NOP                 ; 2
++      NOP                 ; 2
; libsrc/apple/sndseq.pla: 0303:         NOP                 ; 2
        NOP                 ; 2
; libsrc/apple/sndseq.pla: 0304:                             ;---
                            ;---
; libsrc/apple/sndseq.pla: 0305:                             ;+4 = 11 (from BNE above)
                            ;+4 = 11 (from BNE above)
; libsrc/apple/sndseq.pla: 0306: 
; libsrc/apple/sndseq.pla: 0307: +++     BIT     $C000       ; 4
+++     BIT     $C000       ; 4
; libsrc/apple/sndseq.pla: 0308:         NOP                 ; 2
        NOP                 ; 2
; libsrc/apple/sndseq.pla: 0309:         BPL     TONELP      ; 3
        BPL     TONELP      ; 3
; libsrc/apple/sndseq.pla: 0310:                             ;---
                            ;---
; libsrc/apple/sndseq.pla: 0311:                             ;+9 = 20
                            ;+9 = 20
; libsrc/apple/sndseq.pla: 0312: TONEXIT PLP
TONEXIT PLP
; libsrc/apple/sndseq.pla: 0313:         LDX     ESP
        LDX     ESP
; libsrc/apple/sndseq.pla: 0314:         INX
        INX
; libsrc/apple/sndseq.pla: 0315:         INX
        INX
; libsrc/apple/sndseq.pla: 0316:         RTS
        RTS
; libsrc/apple/sndseq.pla: 0317: end
; libsrc/apple/sndseq.pla: 0318: asm a2spkrPWM(sample, speed, len)#0
_P004 					; a2spkrPWM(sample, speed, len)#0()
_A010 					; a2spkrPWM()
; libsrc/apple/sndseq.pla: 0319:         STX     ESP
        STX     ESP
; libsrc/apple/sndseq.pla: 0320:         LDY     ESTKH,X
        LDY     ESTKH,X
; libsrc/apple/sndseq.pla: 0321:         LDA     ESTKL,X
        LDA     ESTKL,X
; libsrc/apple/sndseq.pla: 0322:         BEQ     +
        BEQ     +
; libsrc/apple/sndseq.pla: 0323:         INY
        INY
; libsrc/apple/sndseq.pla: 0324: +       STY     DSTH
+       STY     DSTH
; libsrc/apple/sndseq.pla: 0325:         STA     DSTL
        STA     DSTL
; libsrc/apple/sndseq.pla: 0326:         LDA     ESTKL+2,X
        LDA     ESTKL+2,X
; libsrc/apple/sndseq.pla: 0327:         STA     SRCL
        STA     SRCL
; libsrc/apple/sndseq.pla: 0328:         LDA     ESTKH+2,X
        LDA     ESTKH+2,X
; libsrc/apple/sndseq.pla: 0329:         STA     SRCH
        STA     SRCH
; libsrc/apple/sndseq.pla: 0330:         LDY     ESTKL+1,X
        LDY     ESTKL+1,X
; libsrc/apple/sndseq.pla: 0331:         INY
        INY
; libsrc/apple/sndseq.pla: 0332:         STY     TMPL
        STY     TMPL
; libsrc/apple/sndseq.pla: 0333:         LDY     #$00
        LDY     #$00
; libsrc/apple/sndseq.pla: 0334:         PHP
        PHP
; libsrc/apple/sndseq.pla: 0335:         SEI
        SEI
; libsrc/apple/sndseq.pla: 0336: -       LDA     (SRC),Y
-       LDA     (SRC),Y
; libsrc/apple/sndseq.pla: 0337:         SEC
        SEC
; libsrc/apple/sndseq.pla: 0338: --      LDX     TMPL
--      LDX     TMPL
; libsrc/apple/sndseq.pla: 0339: ---     DEX
---     DEX
; libsrc/apple/sndseq.pla: 0340:         BNE     ---
        BNE     ---
; libsrc/apple/sndseq.pla: 0341:         SBC     #$01
        SBC     #$01
; libsrc/apple/sndseq.pla: 0342:         BCS     --
        BCS     --
; libsrc/apple/sndseq.pla: 0343:         BIT     $C030
        BIT     $C030
; libsrc/apple/sndseq.pla: 0344:         INY
        INY
; libsrc/apple/sndseq.pla: 0345:         BNE     +
        BNE     +
; libsrc/apple/sndseq.pla: 0346:         INC     SRCH
        INC     SRCH
; libsrc/apple/sndseq.pla: 0347: +       DEC     DSTL
+       DEC     DSTL
; libsrc/apple/sndseq.pla: 0348:         BNE     -
        BNE     -
; libsrc/apple/sndseq.pla: 0349:         DEC     DSTH
        DEC     DSTH
; libsrc/apple/sndseq.pla: 0350:         BNE     -
        BNE     -
; libsrc/apple/sndseq.pla: 0351:         PLP
        PLP
; libsrc/apple/sndseq.pla: 0352:         LDX     ESP
        LDX     ESP
; libsrc/apple/sndseq.pla: 0353:         INX
        INX
; libsrc/apple/sndseq.pla: 0354:         INX
        INX
; libsrc/apple/sndseq.pla: 0355:         INX
        INX
; libsrc/apple/sndseq.pla: 0356:         RTS
        RTS
; libsrc/apple/sndseq.pla: 0357: end
; libsrc/apple/sndseq.pla: 0358: asm a2keypressed
_P005 					; a2keypressed()
_A011 					; a2keypressed()
; libsrc/apple/sndseq.pla: 0359:         INC     $004E       ; rndseed
        INC     $004E       ; rndseed
; libsrc/apple/sndseq.pla: 0360:         BNE     +
        BNE     +
; libsrc/apple/sndseq.pla: 0361:         INC     $004F
        INC     $004F
; libsrc/apple/sndseq.pla: 0362: +       DEX
+       DEX
; libsrc/apple/sndseq.pla: 0363:         LDY     #$00
        LDY     #$00
; libsrc/apple/sndseq.pla: 0364:         BIT     $C000
        BIT     $C000
; libsrc/apple/sndseq.pla: 0365:         BPL     +
        BPL     +
; libsrc/apple/sndseq.pla: 0366:         DEY
        DEY
; libsrc/apple/sndseq.pla: 0367: +       STY     ESTKL,X
+       STY     ESTKL,X
; libsrc/apple/sndseq.pla: 0368:         STY     ESTKH,X
        STY     ESTKH,X
; libsrc/apple/sndseq.pla: 0369:         RTS
        RTS
; libsrc/apple/sndseq.pla: 0370: end
; libsrc/apple/sndseq.pla: 0371: def a3keypressed
	!BYTE	$00			; PAD BYTE
_SUBSEG 				; BYTECODE STARTS
_C000 					; a3keypressed()
; libsrc/apple/sndseq.pla: 0372:     byte count
					; count -> [0]
; libsrc/apple/sndseq.pla: 0373:     byte params[5]
					; params -> [1]
; libsrc/apple/sndseq.pla: 0374: 
; libsrc/apple/sndseq.pla: 0375:     params.0 = 3
	!BYTE	$58,$06,$00		; ENTER	6,0
; libsrc/apple/sndseq.pla: 0376:     params.1 = cmdsys.devcons
; libsrc/apple/sndseq.pla: 0377:     params.2 = 5
; libsrc/apple/sndseq.pla: 0378:     params:3 = @count
; libsrc/apple/sndseq.pla: 0379:     syscall($82, @params)
; libsrc/apple/sndseq.pla: 0380:     return count
	!BYTE	$06			; CN	3
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$68			; LAB	_X000+20
_F008 	!WORD	0+20		
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$0A			; CN	5
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$2A,$82			; CB	130
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$54			; CALL	_X011
_F009 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/apple/sndseq.pla: 0381: end
; libsrc/apple/sndseq.pla: 0382: def a3spkrTone(pitch, duration)#0
					; pitch -> [0]
					; duration -> [2]
_C001 					; a3spkrTone()
; libsrc/apple/sndseq.pla: 0383:     byte env
					; env -> [4]
; libsrc/apple/sndseq.pla: 0384: 
; libsrc/apple/sndseq.pla: 0385:     env = ^ENV_REG
	!BYTE	$58,$05,$02		; ENTER	5,2
; libsrc/apple/sndseq.pla: 0386:     ^ENV_REG = env | $C0
; libsrc/apple/sndseq.pla: 0387:     a2spkrTone(pitch, duration)
; libsrc/apple/sndseq.pla: 0388:     ^ENV_REG = env
; libsrc/apple/sndseq.pla: 0389: end
	!BYTE	$68,$DF,$FF		; LAB	65503
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$3E,$C0			; ORI	192
	!BYTE	$78,$DF,$FF		; SAB	65503
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_A009
_F010 	!WORD	_A009		
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$78,$DF,$FF		; SAB	65503
	!BYTE	$5A,$05			; LEAVE	5
; libsrc/apple/sndseq.pla: 0390: def a3spkrPWM(sample, speed, len)#0
					; sample -> [0]
					; speed -> [2]
					; len -> [4]
_C002 					; a3spkrPWM()
; libsrc/apple/sndseq.pla: 0391:     byte env
					; env -> [6]
; libsrc/apple/sndseq.pla: 0392: 
; libsrc/apple/sndseq.pla: 0393:     env = ^ENV_REG
	!BYTE	$58,$07,$03		; ENTER	7,3
; libsrc/apple/sndseq.pla: 0394:     ^ENV_REG = env | $C0
; libsrc/apple/sndseq.pla: 0395:     a2spkrPWM(sample, speed, len)
; libsrc/apple/sndseq.pla: 0396:     ^ENV_REG = env
; libsrc/apple/sndseq.pla: 0397: end
	!BYTE	$68,$DF,$FF		; LAB	65503
	!BYTE	$6C,$06			; DLB	[6]
	!BYTE	$3E,$C0			; ORI	192
	!BYTE	$78,$DF,$FF		; SAB	65503
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_A010
_F011 	!WORD	_A010		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$78,$DF,$FF		; SAB	65503
	!BYTE	$5A,$07			; LEAVE	7
; libsrc/apple/sndseq.pla: 0398: //
; libsrc/apple/sndseq.pla: 0399: // Search slots for MockingBoard
; libsrc/apple/sndseq.pla: 0400: //
; libsrc/apple/sndseq.pla: 0401: def mbTicklePSG(pVIA)
					; pVIA -> [0]
_C003 					; mbTicklePSG()
; libsrc/apple/sndseq.pla: 0402:     //puts("VIA address: $"); puth(pVIA); puts(" Timer Diff = "); puti(viaCheck(pVIA)); putln
; libsrc/apple/sndseq.pla: 0403:     if viaCheck(pVIA) == 8 and viaCheck(pVIA) == 8 // Check twice
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/apple/sndseq.pla: 0404:         pVIA->IER  = $7F  // Mask all interrupts
; libsrc/apple/sndseq.pla: 0405:         //pVIA->ACR  = $00  // Stop T1 countdown
; libsrc/apple/sndseq.pla: 0406:         pVIA->DDRB = $FF  // Output enable port A and B
; libsrc/apple/sndseq.pla: 0407:         pVIA->DDRA = $FF
; libsrc/apple/sndseq.pla: 0408:         pVIA->IORA = $00 // Reset MockingBoard
; libsrc/apple/sndseq.pla: 0409:         //if pVIA->IORA == $00
; libsrc/apple/sndseq.pla: 0410:         pVIA->IORA = $04 // Inactive MockingBoard control lines
; libsrc/apple/sndseq.pla: 0411:         //if pVIA->IORA == $04
; libsrc/apple/sndseq.pla: 0412:             //
; libsrc/apple/sndseq.pla: 0413:             // At least we know we have some sort of R/W in the ROM
; libsrc/apple/sndseq.pla: 0414:             // address space. Most likely a MockingBoard or John Bell
; libsrc/apple/sndseq.pla: 0415:             // 6522 board. We will assume its a MockingBoard because
; libsrc/apple/sndseq.pla: 0416:             // emulators fail the following PSG read test.
; libsrc/apple/sndseq.pla: 0417:             //
; libsrc/apple/sndseq.pla: 0418:             //psgWriteWord(pVIA, 2, $DA7E)
; libsrc/apple/sndseq.pla: 0419:             //if mbReadP(pVIA, 2) == $7E and mbReadP(pVIA, 3) == $0A
; libsrc/apple/sndseq.pla: 0420:                 return pVIA
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_A008
_F012 	!WORD	_A008		
	!BYTE	$10			; CN	8
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B001
	!WORD	_B001-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_A008
_F013 	!WORD	_A008		
	!BYTE	$10			; CN	8
	!BYTE	$40			; ISEQ
_B001 
	!BYTE	$4C			; BRFLS	_B002
	!WORD	_B002-*
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$70			; SB
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$08			; CN	4
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/sndseq.pla: 0421:             //fin
; libsrc/apple/sndseq.pla: 0422:         //fin
; libsrc/apple/sndseq.pla: 0423:     fin
_B002 
_B003 
; libsrc/apple/sndseq.pla: 0424:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/sndseq.pla: 0425: end
; libsrc/apple/sndseq.pla: 0426: def mbSearch(slot)
					; slot -> [0]
_C004 					; mbSearch()
; libsrc/apple/sndseq.pla: 0427:     if slot >= 0 and slot <= 7
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/apple/sndseq.pla: 0428:         if slot
; libsrc/apple/sndseq.pla: 0429:             mbVIA1 = mbTicklePSG($C000 + (slot << 8))
; libsrc/apple/sndseq.pla: 0430:             if mbVIA1
; libsrc/apple/sndseq.pla: 0431:                 mbVIA2 = mbTicklePSG(mbVIA1 + $80)
; libsrc/apple/sndseq.pla: 0432:                 return slot
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B004
	!WORD	_B004-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$0E			; CN	7
	!BYTE	$4A			; ISLE
_B004 
	!BYTE	$4C			; BRFLS	_B005
	!WORD	_B005-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4C			; BRFLS	_B007
	!WORD	_B007-*
	!BYTE	$2C,$00,$C0		; CW	49152
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$10			; CN	8
	!BYTE	$9A			; SHL
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_C003
_F014 	!WORD	_C003		
	!BYTE	$7E			; DAW	_D064+0
_F015 	!WORD	_D064+0		
	!BYTE	$4C			; BRFLS	_B009
	!WORD	_B009-*
	!BYTE	$6A			; LAW	_D064+0
_F016 	!WORD	_D064+0		
	!BYTE	$38,$80			; ADDI	128
	!BYTE	$54			; CALL	_C003
_F017 	!WORD	_C003		
	!BYTE	$7A			; SAW	_D065+0
_F018 	!WORD	_D065+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/sndseq.pla: 0433:             fin
_B009 
_B010 
; libsrc/apple/sndseq.pla: 0434:         else
	!BYTE	$50			; BRNCH	_B008
	!WORD	_B008-*
_B007 
; libsrc/apple/sndseq.pla: 0435:             for slot = 1 to 7
	!BYTE	$0E			; CN	7
	!BYTE	$02			; CN	1
_B012 
	!BYTE	$6E,$00			; DLW	[0]
; libsrc/apple/sndseq.pla: 0436:                 if slot == 3 or slot == 6
; libsrc/apple/sndseq.pla: 0437:                     continue
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$06			; CN	3
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B014
	!WORD	_B014-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$0C			; CN	6
	!BYTE	$40			; ISEQ
_B014 
	!BYTE	$4C			; BRFLS	_B015
	!WORD	_B015-*
	!BYTE	$50			; BRNCH	_B013
	!WORD	_B013-*
; libsrc/apple/sndseq.pla: 0438:                 fin
_B015 
_B016 
; libsrc/apple/sndseq.pla: 0439:                 mbVIA1 = mbTicklePSG($C000 + (slot << 8))
; libsrc/apple/sndseq.pla: 0440:                 if mbVIA1
; libsrc/apple/sndseq.pla: 0441:                     mbVIA2 = mbTicklePSG(mbVIA1 + $80)
; libsrc/apple/sndseq.pla: 0442:                     return slot
	!BYTE	$2C,$00,$C0		; CW	49152
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$10			; CN	8
	!BYTE	$9A			; SHL
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_C003
_F019 	!WORD	_C003		
	!BYTE	$7E			; DAW	_D064+0
_F020 	!WORD	_D064+0		
	!BYTE	$4C			; BRFLS	_B017
	!WORD	_B017-*
	!BYTE	$6A			; LAW	_D064+0
_F021 	!WORD	_D064+0		
	!BYTE	$38,$80			; ADDI	128
	!BYTE	$54			; CALL	_C003
_F022 	!WORD	_C003		
	!BYTE	$7A			; SAW	_D065+0
_F023 	!WORD	_D065+0		
	!BYTE	$32			; DROP2
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/sndseq.pla: 0443:                 fin
_B017 
_B018 
; libsrc/apple/sndseq.pla: 0444:             next
_B013 
	!BYTE	$A4			; INCBRLE	_B012
	!WORD	_B012-*
_B011 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; libsrc/apple/sndseq.pla: 0445:         fin
_B008 
; libsrc/apple/sndseq.pla: 0446:     fin
_B005 
_B006 
; libsrc/apple/sndseq.pla: 0447:     return -1
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/sndseq.pla: 0448: end
; libsrc/apple/sndseq.pla: 0449: def psgSetup(pVIA)#0
					; pVIA -> [0]
_C005 					; psgSetup()
; libsrc/apple/sndseq.pla: 0450:     psgWrite(pVIA,     MIXER,     $3F)   // Turn everything off
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/apple/sndseq.pla: 0451:     psgWrite(pVIA,     AENVAMP,   $00)
; libsrc/apple/sndseq.pla: 0452:     psgWrite(pVIA,     BENVAMP,   $00)
; libsrc/apple/sndseq.pla: 0453:     psgWrite(pVIA,     CENVAMP,   $10)
; libsrc/apple/sndseq.pla: 0454:     psgWrite(pVIA,     NGFREQ,    $01)
; libsrc/apple/sndseq.pla: 0455:     psgWriteWord(pVIA, ENVPERIOD, $0001)
; libsrc/apple/sndseq.pla: 0456:     psgWrite(pVIA,     ENVSHAPE,  $00)   // Single decay
; libsrc/apple/sndseq.pla: 0457:     psgWriteWord(pVIA, AFREQ,     $0000) // Fast response to update
; libsrc/apple/sndseq.pla: 0458:     psgWriteWord(pVIA, BFREQ,     $0000)
; libsrc/apple/sndseq.pla: 0459:     psgWriteWord(pVIA, CFREQ,     $0000)
; libsrc/apple/sndseq.pla: 0460:     psgWrite(pVIA,     MIXER,     $38)   // Tone on C, B, A
; libsrc/apple/sndseq.pla: 0461: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$0E			; CN	7
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$54			; CALL	_A007
_F024 	!WORD	_A007		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$10			; CN	8
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A007
_F025 	!WORD	_A007		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$12			; CN	9
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A007
_F026 	!WORD	_A007		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$14			; CN	10
	!BYTE	$2A,$10			; CB	16
	!BYTE	$54			; CALL	_A007
_F027 	!WORD	_A007		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$0C			; CN	6
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_A007
_F028 	!WORD	_A007		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$16			; CN	11
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_A006
_F029 	!WORD	_A006		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$1A			; CN	13
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A007
_F030 	!WORD	_A007		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A006
_F031 	!WORD	_A006		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$04			; CN	2
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A006
_F032 	!WORD	_A006		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$08			; CN	4
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A006
_F033 	!WORD	_A006		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$0E			; CN	7
	!BYTE	$2A,$38			; CB	56
	!BYTE	$54			; CALL	_A007
_F034 	!WORD	_A007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/sndseq.pla: 0462: //
; libsrc/apple/sndseq.pla: 0463: // Sequence notes through MockingBoard
; libsrc/apple/sndseq.pla: 0464: //
; libsrc/apple/sndseq.pla: 0465: def mbSequence(yield, func)#0
					; yield -> [0]
					; func -> [2]
_C006 					; mbSequence()
; libsrc/apple/sndseq.pla: 0466:     word period, n, yieldTime
					; period -> [4]
					; n -> [6]
					; yieldTime -> [8]
; libsrc/apple/sndseq.pla: 0467:     byte note, volume, channel, i, overflow, status, quit
					; note -> [10]
					; volume -> [11]
					; channel -> [12]
					; i -> [13]
					; overflow -> [14]
					; status -> [15]
					; quit -> [16]
; libsrc/apple/sndseq.pla: 0468: 
; libsrc/apple/sndseq.pla: 0469:     //
; libsrc/apple/sndseq.pla: 0470:     // Reset oscillator table
; libsrc/apple/sndseq.pla: 0471:     //
; libsrc/apple/sndseq.pla: 0472:     indexA[0] = 0; indexA[1] = 0
	!BYTE	$58,$11,$02		; ENTER	17,2
; libsrc/apple/sndseq.pla: 0473:     indexB[0] = 1; indexB[1] = 1
; libsrc/apple/sndseq.pla: 0474:     indexC[0] = 2; indexC[1] = 2
; libsrc/apple/sndseq.pla: 0475:     noteA[0]  = 0; noteA[1]  = 0
; libsrc/apple/sndseq.pla: 0476:     noteB[0]  = 0; noteB[1]  = 0
; libsrc/apple/sndseq.pla: 0477:     noteC[0]  = 0; noteC[1]  = 0
; libsrc/apple/sndseq.pla: 0478:     //
; libsrc/apple/sndseq.pla: 0479:     // Get the PSGs ready
; libsrc/apple/sndseq.pla: 0480:     //
; libsrc/apple/sndseq.pla: 0481:     status = getStatusReg
; libsrc/apple/sndseq.pla: 0482:     disableInts
; libsrc/apple/sndseq.pla: 0483:     mbVIA1->ACR = $40       // Continuous T1 interrupts
; libsrc/apple/sndseq.pla: 0484:     mbVIA1=>T1L = $F9C2     // 16 Ints/sec
; libsrc/apple/sndseq.pla: 0485:     mbVIA1=>T1C = $F9C2     // 16 Ints/sec
; libsrc/apple/sndseq.pla: 0486:     mbVIA1->IFR = $40       // Clear interrupt
; libsrc/apple/sndseq.pla: 0487:     mbVIA1->IER = $C0       // Enable Timer1 interrupt
; libsrc/apple/sndseq.pla: 0488:     psgSetup(mbVIA1)
; libsrc/apple/sndseq.pla: 0489:     if mbVIA2; psgSetup(mbVIA2); fin
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D051+0
_F035 	!WORD	_D051+0		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D051+1
_F036 	!WORD	_D051+1		
	!BYTE	$02			; CN	1
	!BYTE	$78			; SAB	_D052+0
_F037 	!WORD	_D052+0		
	!BYTE	$02			; CN	1
	!BYTE	$78			; SAB	_D052+1
_F038 	!WORD	_D052+1		
	!BYTE	$04			; CN	2
	!BYTE	$78			; SAB	_D053+0
_F039 	!WORD	_D053+0		
	!BYTE	$04			; CN	2
	!BYTE	$78			; SAB	_D053+1
_F040 	!WORD	_D053+1		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D054+0
_F041 	!WORD	_D054+0		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D054+1
_F042 	!WORD	_D054+1		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D055+0
_F043 	!WORD	_D055+0		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D055+1
_F044 	!WORD	_D055+1		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D056+0
_F045 	!WORD	_D056+0		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D056+1
_F046 	!WORD	_D056+1		
	!BYTE	$54			; CALL	_A001
_F047 	!WORD	_A001		
	!BYTE	$74,$0F			; SLB	[15]
	!BYTE	$54			; CALL	_A003
_F048 	!WORD	_A003		
	!BYTE	$2A,$40			; CB	64
	!BYTE	$6A			; LAW	_D064+0
_F049 	!WORD	_D064+0		
	!BYTE	$38,$0B			; ADDI	11
	!BYTE	$70			; SB
	!BYTE	$2C,$C2,$F9		; CW	63938
	!BYTE	$6A			; LAW	_D064+0
_F050 	!WORD	_D064+0		
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$2C,$C2,$F9		; CW	63938
	!BYTE	$6A			; LAW	_D064+0
_F051 	!WORD	_D064+0		
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$2A,$40			; CB	64
	!BYTE	$6A			; LAW	_D064+0
_F052 	!WORD	_D064+0		
	!BYTE	$38,$0D			; ADDI	13
	!BYTE	$70			; SB
	!BYTE	$2A,$C0			; CB	192
	!BYTE	$6A			; LAW	_D064+0
_F053 	!WORD	_D064+0		
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D064+0
_F054 	!WORD	_D064+0		
	!BYTE	$54			; CALL	_C005
_F055 	!WORD	_C005		
	!BYTE	$6A			; LAW	_D065+0
_F056 	!WORD	_D065+0		
	!BYTE	$4C			; BRFLS	_B019
	!WORD	_B019-*
	!BYTE	$6A			; LAW	_D065+0
_F057 	!WORD	_D065+0		
	!BYTE	$54			; CALL	_C005
_F058 	!WORD	_C005		
_B019 
_B020 
; libsrc/apple/sndseq.pla: 0490:     overflow    = 0
; libsrc/apple/sndseq.pla: 0491:     if yield and func
; libsrc/apple/sndseq.pla: 0492:         yieldTime = seqTime + yield
; libsrc/apple/sndseq.pla: 0493:     else
	!BYTE	$00			; CN	0
	!BYTE	$74,$0E			; SLB	[14]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$AC			; BRAND	_B021
	!WORD	_B021-*
	!BYTE	$66,$02			; LLW	[2]
_B021 
	!BYTE	$4C			; BRFLS	_B022
	!WORD	_B022-*
	!BYTE	$6A			; LAW	_D046+0
_F059 	!WORD	_D046+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B023
	!WORD	_B023-*
_B022 
; libsrc/apple/sndseq.pla: 0494:         yieldTime = $7FFF
; libsrc/apple/sndseq.pla: 0495:     fin
	!BYTE	$2C,$FF,$7F		; CW	32767
	!BYTE	$76,$08			; SLW	[8]
_B023 
; libsrc/apple/sndseq.pla: 0496:     updateTime = seqTime
; libsrc/apple/sndseq.pla: 0497:     quit = FALSE
; libsrc/apple/sndseq.pla: 0498:     repeat
	!BYTE	$6A			; LAW	_D046+0
_F060 	!WORD	_D046+0		
	!BYTE	$7A			; SAW	_D048+0
_F061 	!WORD	_D048+0		
	!BYTE	$00			; CN	0
	!BYTE	$74,$10			; SLB	[16]
_B025 
; libsrc/apple/sndseq.pla: 0499:         while eventTime == seqTime
	!BYTE	$50			; BRNCH	_B029
	!WORD	_B029-*
_B027 
; libsrc/apple/sndseq.pla: 0500:             note = seqEvent->percnote
; libsrc/apple/sndseq.pla: 0501:             if note & $80
; libsrc/apple/sndseq.pla: 0502:                 //
; libsrc/apple/sndseq.pla: 0503:                 // Note event
; libsrc/apple/sndseq.pla: 0504:                 //
; libsrc/apple/sndseq.pla: 0505:                 volume  = seqEvent->perchanvol
; libsrc/apple/sndseq.pla: 0506:                 channel = (volume & mbVIA2.LSB) >> 7 // Clever - mbVIA2.0 will be $80 if it exists
; libsrc/apple/sndseq.pla: 0507:                 if volume & $0F
; libsrc/apple/sndseq.pla: 0508:                     //
; libsrc/apple/sndseq.pla: 0509:                     // Note on
; libsrc/apple/sndseq.pla: 0510:                     //
; libsrc/apple/sndseq.pla: 0511:                     for i = 0 to MAX_MBCH_NOTES-1
	!BYTE	$6A			; LAW	_D045+0
_F062 	!WORD	_D045+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$6C,$0A			; DLB	[10]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B030
	!WORD	_B030-*
	!BYTE	$6A			; LAW	_D045+0
_F063 	!WORD	_D045+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$6C,$0B			; DLB	[11]
	!BYTE	$68			; LAB	_D065+0
_F064 	!WORD	_D065+0		
	!BYTE	$94			; AND 
	!BYTE	$0E			; CN	7
	!BYTE	$9C			; SHR
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$64,$0B			; LLB	[11]
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$4C			; BRFLS	_B032
	!WORD	_B032-*
	!BYTE	$10			; CN	8
	!BYTE	$00			; CN	0
_B035 
	!BYTE	$6C,$0D			; DLB	[13]
; libsrc/apple/sndseq.pla: 0512:                         //
; libsrc/apple/sndseq.pla: 0513:                         // Look for available slot in active note table
; libsrc/apple/sndseq.pla: 0514:                         //
; libsrc/apple/sndseq.pla: 0515:                         if !notes[channel, i].LSB //or notes[channel, i] == note
; libsrc/apple/sndseq.pla: 0516:                             break
	!BYTE	$26			; LA	_D059+0
_F065 	!WORD	_D059+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$B8,$0D			; IDXLB	[13]
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B037
	!WORD	_B037-*
	!BYTE	$50			; BRNCH	_B034
	!WORD	_B034-*
; libsrc/apple/sndseq.pla: 0517:                         fin
_B037 
_B038 
; libsrc/apple/sndseq.pla: 0518:                     next
_B036 
	!BYTE	$A4			; INCBRLE	_B035
	!WORD	_B035-*
_B034 
	!BYTE	$74,$0D			; SLB	[13]
	!BYTE	$30			; DROP 
; libsrc/apple/sndseq.pla: 0519:                     //
; libsrc/apple/sndseq.pla: 0520:                     // Full note table, kick one out
; libsrc/apple/sndseq.pla: 0521:                     //
; libsrc/apple/sndseq.pla: 0522:                     if i == MAX_MBCH_NOTES
; libsrc/apple/sndseq.pla: 0523:                         i = overflow
; libsrc/apple/sndseq.pla: 0524:                         overflow = (overflow + 1) % MAX_MBCH_NOTES
; libsrc/apple/sndseq.pla: 0525:                     else
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$12			; CN	9
	!BYTE	$24			; BRNE	_B039
	!WORD	_B039-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$74,$0D			; SLB	[13]
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$8C			; INCR
	!BYTE	$12			; CN	9
	!BYTE	$8A			; MOD
	!BYTE	$74,$0E			; SLB	[14]
	!BYTE	$50			; BRNCH	_B040
	!WORD	_B040-*
_B039 
; libsrc/apple/sndseq.pla: 0526:                         numNotes++
	!BYTE	$68			; LAB	_D049+0
_F066 	!WORD	_D049+0		
	!BYTE	$8C			; INCR
; libsrc/apple/sndseq.pla: 0527:                     fin
	!BYTE	$78			; SAB	_D049+0
_F067 	!WORD	_D049+0		
_B040 
; libsrc/apple/sndseq.pla: 0528:                     notes[channel, i] = note | (volume << 8)
; libsrc/apple/sndseq.pla: 0529:                     periods[channel, i] = mbOctave0[note & $0F] >> ((note >> 4) & $07)
; libsrc/apple/sndseq.pla: 0530:                 else
	!BYTE	$64,$0A			; LLB	[10]
	!BYTE	$64,$0B			; LLB	[11]
	!BYTE	$10			; CN	8
	!BYTE	$9A			; SHL
	!BYTE	$96			; OR 
	!BYTE	$26			; LA	_D059+0
_F068 	!WORD	_D059+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$B8,$0D			; IDXLB	[13]
	!BYTE	$72			; SW
	!BYTE	$26			; LA	_D068+0
_F069 	!WORD	_D068+0		
	!BYTE	$64,$0A			; LLB	[10]
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$64,$0A			; LLB	[10]
	!BYTE	$08			; CN	4
	!BYTE	$9C			; SHR
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$9C			; SHR
	!BYTE	$26			; LA	_D062+0
_F070 	!WORD	_D062+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$B8,$0D			; IDXLB	[13]
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B033
	!WORD	_B033-*
_B032 
; libsrc/apple/sndseq.pla: 0531:                     //
; libsrc/apple/sndseq.pla: 0532:                     // Note off
; libsrc/apple/sndseq.pla: 0533:                     //
; libsrc/apple/sndseq.pla: 0534:                     for i = 0 to MAX_MBCH_NOTES-1
	!BYTE	$10			; CN	8
	!BYTE	$00			; CN	0
_B042 
	!BYTE	$6C,$0D			; DLB	[13]
; libsrc/apple/sndseq.pla: 0535:                         //
; libsrc/apple/sndseq.pla: 0536:                         // Remove from active note table
; libsrc/apple/sndseq.pla: 0537:                         //
; libsrc/apple/sndseq.pla: 0538:                         if notes[channel, i].LSB == note
; libsrc/apple/sndseq.pla: 0539:                             notes[channel, i] = 0
; libsrc/apple/sndseq.pla: 0540:                             numNotes--
	!BYTE	$26			; LA	_D059+0
_F071 	!WORD	_D059+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$B8,$0D			; IDXLB	[13]
	!BYTE	$60			; LB
	!BYTE	$64,$0A			; LLB	[10]
	!BYTE	$24			; BRNE	_B044
	!WORD	_B044-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D059+0
_F072 	!WORD	_D059+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$B8,$0D			; IDXLB	[13]
	!BYTE	$72			; SW
	!BYTE	$68			; LAB	_D049+0
_F073 	!WORD	_D049+0		
	!BYTE	$8E			; DECR
; libsrc/apple/sndseq.pla: 0541:                             break
	!BYTE	$78			; SAB	_D049+0
_F074 	!WORD	_D049+0		
	!BYTE	$50			; BRNCH	_B041
	!WORD	_B041-*
; libsrc/apple/sndseq.pla: 0542:                         fin
_B044 
_B045 
; libsrc/apple/sndseq.pla: 0543:                     next
_B043 
	!BYTE	$A4			; INCBRLE	_B042
	!WORD	_B042-*
_B041 
	!BYTE	$74,$0D			; SLB	[13]
	!BYTE	$30			; DROP 
; libsrc/apple/sndseq.pla: 0544:                 fin
_B033 
; libsrc/apple/sndseq.pla: 0545:                 updateTime = seqTime
; libsrc/apple/sndseq.pla: 0546:             else
	!BYTE	$6A			; LAW	_D046+0
_F075 	!WORD	_D046+0		
	!BYTE	$7A			; SAW	_D048+0
_F076 	!WORD	_D048+0		
	!BYTE	$50			; BRNCH	_B031
	!WORD	_B031-*
_B030 
; libsrc/apple/sndseq.pla: 0547:                 //
; libsrc/apple/sndseq.pla: 0548:                 // Percussion event
; libsrc/apple/sndseq.pla: 0549:                 //
; libsrc/apple/sndseq.pla: 0550:                 period = seqEvent->perchanvol
; libsrc/apple/sndseq.pla: 0551:                 if period
; libsrc/apple/sndseq.pla: 0552:                     if (period & $80)
; libsrc/apple/sndseq.pla: 0553:                         psgWrite(mbVIA1, MIXER,       $1C)   // NG on C, Tone on B, A
; libsrc/apple/sndseq.pla: 0554:                         psgWrite(mbVIA1, CENVAMP,     $10)
; libsrc/apple/sndseq.pla: 0555:                         psgWrite(mbVIA1, ENVSHAPE,   (note >> 4) & $04)
; libsrc/apple/sndseq.pla: 0556:                         psgWrite(mbVIA1, NGFREQ,     (note >> 1) & $1F)
; libsrc/apple/sndseq.pla: 0557:                         psgWrite(mbVIA1, ENVPERIOD+1, period & $7F)
; libsrc/apple/sndseq.pla: 0558:                     elsif mbVIA2
	!BYTE	$6A			; LAW	_D045+0
_F077 	!WORD	_D045+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4C			; BRFLS	_B046
	!WORD	_B046-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B048
	!WORD	_B048-*
	!BYTE	$6A			; LAW	_D064+0
_F078 	!WORD	_D064+0		
	!BYTE	$0E			; CN	7
	!BYTE	$2A,$1C			; CB	28
	!BYTE	$54			; CALL	_A007
_F079 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D064+0
_F080 	!WORD	_D064+0		
	!BYTE	$14			; CN	10
	!BYTE	$2A,$10			; CB	16
	!BYTE	$54			; CALL	_A007
_F081 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D064+0
_F082 	!WORD	_D064+0		
	!BYTE	$1A			; CN	13
	!BYTE	$64,$0A			; LLB	[10]
	!BYTE	$08			; CN	4
	!BYTE	$9C			; SHR
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$54			; CALL	_A007
_F083 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D064+0
_F084 	!WORD	_D064+0		
	!BYTE	$0C			; CN	6
	!BYTE	$64,$0A			; LLB	[10]
	!BYTE	$02			; CN	1
	!BYTE	$9C			; SHR
	!BYTE	$3C,$1F			; ANDI	31
	!BYTE	$54			; CALL	_A007
_F085 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D064+0
_F086 	!WORD	_D064+0		
	!BYTE	$18			; CN	12
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$54			; CALL	_A007
_F087 	!WORD	_A007		
	!BYTE	$50			; BRNCH	_B049
	!WORD	_B049-*
_B048 
; libsrc/apple/sndseq.pla: 0559:                         psgWrite(mbVIA2, MIXER,       $1C)   // NG on C, Tone on B, A
; libsrc/apple/sndseq.pla: 0560:                         psgWrite(mbVIA2, CENVAMP,     $10)
; libsrc/apple/sndseq.pla: 0561:                         psgWrite(mbVIA2, ENVSHAPE,   (note >> 4) & $04)
; libsrc/apple/sndseq.pla: 0562:                         psgWrite(mbVIA2, NGFREQ,     (note >> 1) & $1F)
; libsrc/apple/sndseq.pla: 0563:                         psgWrite(mbVIA2, ENVPERIOD+1, period)
; libsrc/apple/sndseq.pla: 0564:                     fin
	!BYTE	$6A			; LAW	_D065+0
_F088 	!WORD	_D065+0		
	!BYTE	$4C			; BRFLS	_B050
	!WORD	_B050-*
	!BYTE	$6A			; LAW	_D065+0
_F089 	!WORD	_D065+0		
	!BYTE	$0E			; CN	7
	!BYTE	$2A,$1C			; CB	28
	!BYTE	$54			; CALL	_A007
_F090 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D065+0
_F091 	!WORD	_D065+0		
	!BYTE	$14			; CN	10
	!BYTE	$2A,$10			; CB	16
	!BYTE	$54			; CALL	_A007
_F092 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D065+0
_F093 	!WORD	_D065+0		
	!BYTE	$1A			; CN	13
	!BYTE	$64,$0A			; LLB	[10]
	!BYTE	$08			; CN	4
	!BYTE	$9C			; SHR
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$54			; CALL	_A007
_F094 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D065+0
_F095 	!WORD	_D065+0		
	!BYTE	$0C			; CN	6
	!BYTE	$64,$0A			; LLB	[10]
	!BYTE	$02			; CN	1
	!BYTE	$9C			; SHR
	!BYTE	$3C,$1F			; ANDI	31
	!BYTE	$54			; CALL	_A007
_F096 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D065+0
_F097 	!WORD	_D065+0		
	!BYTE	$18			; CN	12
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_A007
_F098 	!WORD	_A007		
_B050 
_B049 
; libsrc/apple/sndseq.pla: 0565:                 else
	!BYTE	$50			; BRNCH	_B047
	!WORD	_B047-*
_B046 
; libsrc/apple/sndseq.pla: 0566:                     if seqRepeat
; libsrc/apple/sndseq.pla: 0567:                         //
; libsrc/apple/sndseq.pla: 0568:                         // Reset sequence
; libsrc/apple/sndseq.pla: 0569:                         //
; libsrc/apple/sndseq.pla: 0570:                         musicPlay(seqTrack, TRUE)
; libsrc/apple/sndseq.pla: 0571:                         seqTime = -1 // Offset seqTime++ later
; libsrc/apple/sndseq.pla: 0572:                     else
	!BYTE	$68			; LAB	_D050+0
_F099 	!WORD	_D050+0		
	!BYTE	$4C			; BRFLS	_B051
	!WORD	_B051-*
	!BYTE	$6A			; LAW	_D044+0
_F100 	!WORD	_D044+0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$54			; CALL	_P000
_F101 	!WORD	_P000		
	!BYTE	$20			; MINUS ONE
	!BYTE	$7A			; SAW	_D046+0
_F102 	!WORD	_D046+0		
	!BYTE	$50			; BRNCH	_B052
	!WORD	_B052-*
_B051 
; libsrc/apple/sndseq.pla: 0573:                         musicStop
; libsrc/apple/sndseq.pla: 0574:                     fin
	!BYTE	$54			; CALL	_P001
_F103 	!WORD	_P001		
_B052 
; libsrc/apple/sndseq.pla: 0575:                     quit = TRUE // Exit out
; libsrc/apple/sndseq.pla: 0576:                     break
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$50			; BRNCH	_B028
	!WORD	_B028-*
; libsrc/apple/sndseq.pla: 0577:                 fin
_B047 
; libsrc/apple/sndseq.pla: 0578:             fin
_B031 
; libsrc/apple/sndseq.pla: 0579:             //
; libsrc/apple/sndseq.pla: 0580:             // Next event
; libsrc/apple/sndseq.pla: 0581:             //
; libsrc/apple/sndseq.pla: 0582:             seqEvent  = seqEvent + t_event
; libsrc/apple/sndseq.pla: 0583:             eventTime = seqEvent->deltatime + eventTime
; libsrc/apple/sndseq.pla: 0584:         loop
	!BYTE	$6A			; LAW	_D045+0
_F104 	!WORD	_D045+0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$7E			; DAW	_D045+0
_F105 	!WORD	_D045+0		
	!BYTE	$60			; LB
	!BYTE	$B6			; ADDAW	_D047+0
_F106 	!WORD	_D047+0		
	!BYTE	$7A			; SAW	_D047+0
_F107 	!WORD	_D047+0		
_B029 
	!BYTE	$6A			; LAW	_D047+0
_F108 	!WORD	_D047+0		
	!BYTE	$6A			; LAW	_D046+0
_F109 	!WORD	_D046+0		
	!BYTE	$22			; BREQ	_B027
	!WORD	_B027-*
_B028 
; libsrc/apple/sndseq.pla: 0585:         if updateTime <= seqTime
; libsrc/apple/sndseq.pla: 0586:             //
; libsrc/apple/sndseq.pla: 0587:             // Time slice active note tables (arpeggio)
; libsrc/apple/sndseq.pla: 0588:             //
; libsrc/apple/sndseq.pla: 0589:             for channel = 0 to 1
	!BYTE	$6A			; LAW	_D048+0
_F110 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D046+0
_F111 	!WORD	_D046+0		
	!BYTE	$4A			; ISLE
	!BYTE	$4C			; BRFLS	_B053
	!WORD	_B053-*
	!BYTE	$02			; CN	1
	!BYTE	$00			; CN	0
_B056 
	!BYTE	$6C,$0C			; DLB	[12]
; libsrc/apple/sndseq.pla: 0590:                 //
; libsrc/apple/sndseq.pla: 0591:                 // Multiplex oscillator A
; libsrc/apple/sndseq.pla: 0592:                 //
; libsrc/apple/sndseq.pla: 0593:                 i = indexA[channel]
; libsrc/apple/sndseq.pla: 0594:                 repeat
	!BYTE	$26			; LA	_D051+0
_F112 	!WORD	_D051+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$74,$0D			; SLB	[13]
_B059 
; libsrc/apple/sndseq.pla: 0595:                     i = (i + 3) % MAX_MBCH_NOTES
; libsrc/apple/sndseq.pla: 0596:                     n = notes[channel, i]
; libsrc/apple/sndseq.pla: 0597:                     if n // Non-zero volume
; libsrc/apple/sndseq.pla: 0598:                         break
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$12			; CN	9
	!BYTE	$8A			; MOD
	!BYTE	$74,$0D			; SLB	[13]
	!BYTE	$26			; LA	_D059+0
_F113 	!WORD	_D059+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$B8,$0D			; IDXLB	[13]
	!BYTE	$62			; LW
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$4C			; BRFLS	_B061
	!WORD	_B061-*
	!BYTE	$50			; BRNCH	_B058
	!WORD	_B058-*
; libsrc/apple/sndseq.pla: 0599:                     fin
_B061 
_B062 
; libsrc/apple/sndseq.pla: 0600:                 until i == indexA[channel]
_B060 
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$26			; LA	_D051+0
_F114 	!WORD	_D051+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B059
	!WORD	_B059-*
_B058 
; libsrc/apple/sndseq.pla: 0601:                 if n.LSB <> noteA[channel]
; libsrc/apple/sndseq.pla: 0602:                     psgWriteTone(mbVIAs[channel], AFREQ, periods[channel, i], n.MSB)
; libsrc/apple/sndseq.pla: 0603:                     noteA[channel]  = n.LSB
; libsrc/apple/sndseq.pla: 0604:                     indexA[channel] = i
; libsrc/apple/sndseq.pla: 0605:                 fin
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$26			; LA	_D054+0
_F115 	!WORD	_D054+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$22			; BREQ	_B063
	!WORD	_B063-*
	!BYTE	$26			; LA	_D063+0
_F116 	!WORD	_D063+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D062+0
_F117 	!WORD	_D062+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$B8,$0D			; IDXLB	[13]
	!BYTE	$62			; LW
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$54			; CALL	_A005
_F118 	!WORD	_A005		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$26			; LA	_D054+0
_F119 	!WORD	_D054+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$26			; LA	_D051+0
_F120 	!WORD	_D051+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B063 
_B064 
; libsrc/apple/sndseq.pla: 0606:                 //
; libsrc/apple/sndseq.pla: 0607:                 // Multiplex oscillator B
; libsrc/apple/sndseq.pla: 0608:                 //
; libsrc/apple/sndseq.pla: 0609:                 i = indexB[channel]
; libsrc/apple/sndseq.pla: 0610:                 repeat
	!BYTE	$26			; LA	_D052+0
_F121 	!WORD	_D052+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$74,$0D			; SLB	[13]
_B066 
; libsrc/apple/sndseq.pla: 0611:                     i = (i + 3) % MAX_MBCH_NOTES
; libsrc/apple/sndseq.pla: 0612:                     n = notes[channel, i]
; libsrc/apple/sndseq.pla: 0613:                     if n // Non-zero volume
; libsrc/apple/sndseq.pla: 0614:                         break
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$12			; CN	9
	!BYTE	$8A			; MOD
	!BYTE	$74,$0D			; SLB	[13]
	!BYTE	$26			; LA	_D059+0
_F122 	!WORD	_D059+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$B8,$0D			; IDXLB	[13]
	!BYTE	$62			; LW
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$4C			; BRFLS	_B068
	!WORD	_B068-*
	!BYTE	$50			; BRNCH	_B065
	!WORD	_B065-*
; libsrc/apple/sndseq.pla: 0615:                     fin
_B068 
_B069 
; libsrc/apple/sndseq.pla: 0616:                 until i == indexB[channel]
_B067 
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$26			; LA	_D052+0
_F123 	!WORD	_D052+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B066
	!WORD	_B066-*
_B065 
; libsrc/apple/sndseq.pla: 0617:                 if n.LSB <> noteB[channel]
; libsrc/apple/sndseq.pla: 0618:                     psgWriteTone(mbVIAs[channel], BFREQ, periods[channel, i], n.MSB)
; libsrc/apple/sndseq.pla: 0619:                     noteB[channel]  = n.LSB
; libsrc/apple/sndseq.pla: 0620:                     indexB[channel] = i
; libsrc/apple/sndseq.pla: 0621:                 fin
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$26			; LA	_D055+0
_F124 	!WORD	_D055+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$22			; BREQ	_B070
	!WORD	_B070-*
	!BYTE	$26			; LA	_D063+0
_F125 	!WORD	_D063+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$04			; CN	2
	!BYTE	$26			; LA	_D062+0
_F126 	!WORD	_D062+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$B8,$0D			; IDXLB	[13]
	!BYTE	$62			; LW
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$54			; CALL	_A005
_F127 	!WORD	_A005		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$26			; LA	_D055+0
_F128 	!WORD	_D055+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$26			; LA	_D052+0
_F129 	!WORD	_D052+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B070 
_B071 
; libsrc/apple/sndseq.pla: 0622:                 //
; libsrc/apple/sndseq.pla: 0623:                 // Multiplex oscillator C
; libsrc/apple/sndseq.pla: 0624:                 //
; libsrc/apple/sndseq.pla: 0625:                 i = indexC[channel]
; libsrc/apple/sndseq.pla: 0626:                 repeat
	!BYTE	$26			; LA	_D053+0
_F130 	!WORD	_D053+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$74,$0D			; SLB	[13]
_B073 
; libsrc/apple/sndseq.pla: 0627:                     i = (i + 3) % MAX_MBCH_NOTES
; libsrc/apple/sndseq.pla: 0628:                     n = notes[channel, i]
; libsrc/apple/sndseq.pla: 0629:                     if n // Non-zero volume
; libsrc/apple/sndseq.pla: 0630:                         break
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$12			; CN	9
	!BYTE	$8A			; MOD
	!BYTE	$74,$0D			; SLB	[13]
	!BYTE	$26			; LA	_D059+0
_F131 	!WORD	_D059+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$B8,$0D			; IDXLB	[13]
	!BYTE	$62			; LW
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$4C			; BRFLS	_B075
	!WORD	_B075-*
	!BYTE	$50			; BRNCH	_B072
	!WORD	_B072-*
; libsrc/apple/sndseq.pla: 0631:                     fin
_B075 
_B076 
; libsrc/apple/sndseq.pla: 0632:                 until i == indexC[channel]
_B074 
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$26			; LA	_D053+0
_F132 	!WORD	_D053+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B073
	!WORD	_B073-*
_B072 
; libsrc/apple/sndseq.pla: 0633:                 if n.LSB <> noteC[channel]
; libsrc/apple/sndseq.pla: 0634:                     psgWrite(mbVIAs[channel],     MIXER,   $38)   // Tone on C, B, A
; libsrc/apple/sndseq.pla: 0635:                     psgWriteTone(mbVIAs[channel], CFREQ,   periods[channel, i], n.MSB)
; libsrc/apple/sndseq.pla: 0636:                     noteC[channel]  = n.LSB
; libsrc/apple/sndseq.pla: 0637:                     indexC[channel] = i
; libsrc/apple/sndseq.pla: 0638:                 fin
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$26			; LA	_D056+0
_F133 	!WORD	_D056+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$22			; BREQ	_B077
	!WORD	_B077-*
	!BYTE	$26			; LA	_D063+0
_F134 	!WORD	_D063+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$0E			; CN	7
	!BYTE	$2A,$38			; CB	56
	!BYTE	$54			; CALL	_A007
_F135 	!WORD	_A007		
	!BYTE	$26			; LA	_D063+0
_F136 	!WORD	_D063+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$08			; CN	4
	!BYTE	$26			; LA	_D062+0
_F137 	!WORD	_D062+0		
	!BYTE	$B8,$0C			; IDXLB	[12]
	!BYTE	$62			; LW
	!BYTE	$B8,$0D			; IDXLB	[13]
	!BYTE	$62			; LW
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$54			; CALL	_A005
_F138 	!WORD	_A005		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$26			; LA	_D056+0
_F139 	!WORD	_D056+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$26			; LA	_D053+0
_F140 	!WORD	_D053+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B077 
_B078 
; libsrc/apple/sndseq.pla: 0639:             next
_B057 
	!BYTE	$A4			; INCBRLE	_B056
	!WORD	_B056-*
_B055 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; libsrc/apple/sndseq.pla: 0640:             updateTime = seqTime + MB_ARPEGGIO - (numNotes >> 2)
; libsrc/apple/sndseq.pla: 0641:         fin
	!BYTE	$6A			; LAW	_D046+0
_F141 	!WORD	_D046+0		
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$68			; LAB	_D049+0
_F142 	!WORD	_D049+0		
	!BYTE	$04			; CN	2
	!BYTE	$9C			; SHR
	!BYTE	$84			; SUB 
	!BYTE	$7A			; SAW	_D048+0
_F143 	!WORD	_D048+0		
_B053 
_B054 
; libsrc/apple/sndseq.pla: 0642:         //
; libsrc/apple/sndseq.pla: 0643:         // Increment time tick
; libsrc/apple/sndseq.pla: 0644:         //
; libsrc/apple/sndseq.pla: 0645:         seqTime++
	!BYTE	$6A			; LAW	_D046+0
_F144 	!WORD	_D046+0		
	!BYTE	$8C			; INCR
; libsrc/apple/sndseq.pla: 0646:         while !(mbVIA1->IFR & $40) // Wait for T1 interrupt
	!BYTE	$7A			; SAW	_D046+0
_F145 	!WORD	_D046+0		
	!BYTE	$50			; BRNCH	_B081
	!WORD	_B081-*
_B079 
; libsrc/apple/sndseq.pla: 0647:             if a2keypressed(); quit = TRUE; break; fin
	!BYTE	$54			; CALL	_A011
_F146 	!WORD	_A011		
	!BYTE	$4C			; BRFLS	_B082
	!WORD	_B082-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$50			; BRNCH	_B080
	!WORD	_B080-*
_B082 
_B083 
; libsrc/apple/sndseq.pla: 0648:         loop
_B081 
	!BYTE	$6A			; LAW	_D064+0
_F147 	!WORD	_D064+0		
	!BYTE	$38,$0D			; ADDI	13
	!BYTE	$60			; LB
	!BYTE	$3C,$40			; ANDI	64
	!BYTE	$4C			; BRFLS	_B079
	!WORD	_B079-*
_B080 
; libsrc/apple/sndseq.pla: 0649:         mbVIA1->IFR = $40 // Clear interrupt
; libsrc/apple/sndseq.pla: 0650:         if yieldTime <= seqTime; func()#0; yieldTime = seqTime + yield; fin
	!BYTE	$2A,$40			; CB	64
	!BYTE	$6A			; LAW	_D064+0
_F148 	!WORD	_D064+0		
	!BYTE	$38,$0D			; ADDI	13
	!BYTE	$70			; SB
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$6A			; LAW	_D046+0
_F149 	!WORD	_D046+0		
	!BYTE	$4A			; ISLE
	!BYTE	$4C			; BRFLS	_B084
	!WORD	_B084-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_D046+0
_F150 	!WORD	_D046+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$76,$08			; SLW	[8]
_B084 
_B085 
; libsrc/apple/sndseq.pla: 0651:     until quit
_B026 
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$4C			; BRFLS	_B025
	!WORD	_B025-*
_B024 
; libsrc/apple/sndseq.pla: 0652:     psgWrite(mbVIA1, MIXER,   $FF) // Turn everything off
; libsrc/apple/sndseq.pla: 0653:     psgWrite(mbVIA1, AENVAMP, $00)
; libsrc/apple/sndseq.pla: 0654:     psgWrite(mbVIA1, BENVAMP, $00)
; libsrc/apple/sndseq.pla: 0655:     psgWrite(mbVIA1, CENVAMP, $00)
; libsrc/apple/sndseq.pla: 0656:     if mbVIA2
; libsrc/apple/sndseq.pla: 0657:         psgWrite(mbVIA2, MIXER,   $FF)
; libsrc/apple/sndseq.pla: 0658:         psgWrite(mbVIA2, AENVAMP, $00)
; libsrc/apple/sndseq.pla: 0659:         psgWrite(mbVIA2, BENVAMP, $00)
; libsrc/apple/sndseq.pla: 0660:         psgWrite(mbVIA2, CENVAMP, $00)
; libsrc/apple/sndseq.pla: 0661:     fin
	!BYTE	$6A			; LAW	_D064+0
_F151 	!WORD	_D064+0		
	!BYTE	$0E			; CN	7
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$54			; CALL	_A007
_F152 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D064+0
_F153 	!WORD	_D064+0		
	!BYTE	$10			; CN	8
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A007
_F154 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D064+0
_F155 	!WORD	_D064+0		
	!BYTE	$12			; CN	9
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A007
_F156 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D064+0
_F157 	!WORD	_D064+0		
	!BYTE	$14			; CN	10
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A007
_F158 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D065+0
_F159 	!WORD	_D065+0		
	!BYTE	$4C			; BRFLS	_B086
	!WORD	_B086-*
	!BYTE	$6A			; LAW	_D065+0
_F160 	!WORD	_D065+0		
	!BYTE	$0E			; CN	7
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$54			; CALL	_A007
_F161 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D065+0
_F162 	!WORD	_D065+0		
	!BYTE	$10			; CN	8
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A007
_F163 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D065+0
_F164 	!WORD	_D065+0		
	!BYTE	$12			; CN	9
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A007
_F165 	!WORD	_A007		
	!BYTE	$6A			; LAW	_D065+0
_F166 	!WORD	_D065+0		
	!BYTE	$14			; CN	10
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_A007
_F167 	!WORD	_A007		
_B086 
_B087 
; libsrc/apple/sndseq.pla: 0662:     //mbVIA1->ACR = $00 // Stop T1 countdown
; libsrc/apple/sndseq.pla: 0663:     mbVIA1->IER = $7F // Mask all interrupts
; libsrc/apple/sndseq.pla: 0664:     mbVIA1->IFR = $40 // Clear interrupt
; libsrc/apple/sndseq.pla: 0665:     setStatusReg(status)
; libsrc/apple/sndseq.pla: 0666: end
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$6A			; LAW	_D064+0
_F168 	!WORD	_D064+0		
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$70			; SB
	!BYTE	$2A,$40			; CB	64
	!BYTE	$6A			; LAW	_D064+0
_F169 	!WORD	_D064+0		
	!BYTE	$38,$0D			; ADDI	13
	!BYTE	$70			; SB
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$54			; CALL	_A002
_F170 	!WORD	_A002		
	!BYTE	$5A,$11			; LEAVE	17
; libsrc/apple/sndseq.pla: 0667: //
; libsrc/apple/sndseq.pla: 0668: // Sequence notes through Apple II speaker
; libsrc/apple/sndseq.pla: 0669: //
; libsrc/apple/sndseq.pla: 0670: def spkrSequence(yield, func)#0
					; yield -> [0]
					; func -> [2]
_P002 					; spkrSequence(yield, func)#0()
_C007 					; spkrSequence()
; libsrc/apple/sndseq.pla: 0671:     word period, duration, yieldTime
					; period -> [4]
					; duration -> [6]
					; yieldTime -> [8]
; libsrc/apple/sndseq.pla: 0672:     byte note, i, n, overflow
					; note -> [10]
					; i -> [11]
					; n -> [12]
					; overflow -> [13]
; libsrc/apple/sndseq.pla: 0673: 
; libsrc/apple/sndseq.pla: 0674:     //
; libsrc/apple/sndseq.pla: 0675:     // Start sequencing
; libsrc/apple/sndseq.pla: 0676:     //
; libsrc/apple/sndseq.pla: 0677:     overflow = 0
	!BYTE	$58,$0E,$02		; ENTER	14,2
; libsrc/apple/sndseq.pla: 0678:     if yield and func
; libsrc/apple/sndseq.pla: 0679:         yieldTime = seqTime + yield
; libsrc/apple/sndseq.pla: 0680:     else
	!BYTE	$00			; CN	0
	!BYTE	$74,$0D			; SLB	[13]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$AC			; BRAND	_B088
	!WORD	_B088-*
	!BYTE	$66,$02			; LLW	[2]
_B088 
	!BYTE	$4C			; BRFLS	_B089
	!WORD	_B089-*
	!BYTE	$6A			; LAW	_D046+0
_F171 	!WORD	_D046+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B090
	!WORD	_B090-*
_B089 
; libsrc/apple/sndseq.pla: 0681:         yieldTime = $7FFF
; libsrc/apple/sndseq.pla: 0682:     fin
	!BYTE	$2C,$FF,$7F		; CW	32767
	!BYTE	$76,$08			; SLW	[8]
_B090 
; libsrc/apple/sndseq.pla: 0683:     updateTime = seqTime
; libsrc/apple/sndseq.pla: 0684:     repeat
	!BYTE	$6A			; LAW	_D046+0
_F172 	!WORD	_D046+0		
	!BYTE	$7A			; SAW	_D048+0
_F173 	!WORD	_D048+0		
_B092 
; libsrc/apple/sndseq.pla: 0685:         while eventTime == seqTime
	!BYTE	$50			; BRNCH	_B096
	!WORD	_B096-*
_B094 
; libsrc/apple/sndseq.pla: 0686:             note = seqEvent->percnote
; libsrc/apple/sndseq.pla: 0687:             if note & $80
; libsrc/apple/sndseq.pla: 0688:                 //
; libsrc/apple/sndseq.pla: 0689:                 // Note event
; libsrc/apple/sndseq.pla: 0690:                 //
; libsrc/apple/sndseq.pla: 0691:                 if seqEvent->perchanvol & $0F
; libsrc/apple/sndseq.pla: 0692:                     //
; libsrc/apple/sndseq.pla: 0693:                     // Note on
; libsrc/apple/sndseq.pla: 0694:                     //
; libsrc/apple/sndseq.pla: 0695:                     for i = 0 to MAX_SPKR_NOTES-1
	!BYTE	$6A			; LAW	_D045+0
_F174 	!WORD	_D045+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$6C,$0A			; DLB	[10]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B097
	!WORD	_B097-*
	!BYTE	$6A			; LAW	_D045+0
_F175 	!WORD	_D045+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$4C			; BRFLS	_B099
	!WORD	_B099-*
	!BYTE	$06			; CN	3
	!BYTE	$00			; CN	0
_B102 
	!BYTE	$6C,$0B			; DLB	[11]
; libsrc/apple/sndseq.pla: 0696:                         //
; libsrc/apple/sndseq.pla: 0697:                         // Look for available slot in active note table
; libsrc/apple/sndseq.pla: 0698:                         //
; libsrc/apple/sndseq.pla: 0699:                         if !notes1[i] or note == notes1[i]
; libsrc/apple/sndseq.pla: 0700:                             break
	!BYTE	$26			; LA	_D057+0
_F176 	!WORD	_D057+0		
	!BYTE	$B8,$0B			; IDXLB	[11]
	!BYTE	$62			; LW
	!BYTE	$80			; NOT
	!BYTE	$AE			; BROR	_B104
	!WORD	_B104-*
	!BYTE	$64,$0A			; LLB	[10]
	!BYTE	$26			; LA	_D057+0
_F177 	!WORD	_D057+0		
	!BYTE	$B8,$0B			; IDXLB	[11]
	!BYTE	$62			; LW
	!BYTE	$40			; ISEQ
_B104 
	!BYTE	$4C			; BRFLS	_B105
	!WORD	_B105-*
	!BYTE	$50			; BRNCH	_B101
	!WORD	_B101-*
; libsrc/apple/sndseq.pla: 0701:                         fin
_B105 
_B106 
; libsrc/apple/sndseq.pla: 0702:                     next
_B103 
	!BYTE	$A4			; INCBRLE	_B102
	!WORD	_B102-*
_B101 
	!BYTE	$74,$0B			; SLB	[11]
	!BYTE	$30			; DROP 
; libsrc/apple/sndseq.pla: 0703:                     if i == MAX_SPKR_NOTES
; libsrc/apple/sndseq.pla: 0704:                         //
; libsrc/apple/sndseq.pla: 0705:                         // Full note table, kick one out
; libsrc/apple/sndseq.pla: 0706:                         //
; libsrc/apple/sndseq.pla: 0707:                         overflow = (overflow + 1) & (MAX_SPKR_NOTES-1)
; libsrc/apple/sndseq.pla: 0708:                         i = overflow
; libsrc/apple/sndseq.pla: 0709:                     elsif !notes1[i]
	!BYTE	$64,$0B			; LLB	[11]
	!BYTE	$08			; CN	4
	!BYTE	$24			; BRNE	_B107
	!WORD	_B107-*
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$8C			; INCR
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$6C,$0D			; DLB	[13]
	!BYTE	$74,$0B			; SLB	[11]
	!BYTE	$50			; BRNCH	_B108
	!WORD	_B108-*
_B107 
; libsrc/apple/sndseq.pla: 0710:                         //
; libsrc/apple/sndseq.pla: 0711:                         // Add new note
; libsrc/apple/sndseq.pla: 0712:                         //
; libsrc/apple/sndseq.pla: 0713:                         numNotes++
	!BYTE	$26			; LA	_D057+0
_F178 	!WORD	_D057+0		
	!BYTE	$B8,$0B			; IDXLB	[11]
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B109
	!WORD	_B109-*
	!BYTE	$68			; LAB	_D049+0
_F179 	!WORD	_D049+0		
	!BYTE	$8C			; INCR
; libsrc/apple/sndseq.pla: 0714:                     fin
	!BYTE	$78			; SAB	_D049+0
_F180 	!WORD	_D049+0		
_B109 
_B108 
; libsrc/apple/sndseq.pla: 0715:                     notes1[i]   = note
; libsrc/apple/sndseq.pla: 0716:                     periods1[i] = spkrOctave0[note & $0F] >> ((note >> 4) & $07)
; libsrc/apple/sndseq.pla: 0717:                 else
	!BYTE	$64,$0A			; LLB	[10]
	!BYTE	$26			; LA	_D057+0
_F181 	!WORD	_D057+0		
	!BYTE	$B8,$0B			; IDXLB	[11]
	!BYTE	$72			; SW
	!BYTE	$26			; LA	_D067+0
_F182 	!WORD	_D067+0		
	!BYTE	$64,$0A			; LLB	[10]
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$64,$0A			; LLB	[10]
	!BYTE	$08			; CN	4
	!BYTE	$9C			; SHR
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$9C			; SHR
	!BYTE	$26			; LA	_D060+0
_F183 	!WORD	_D060+0		
	!BYTE	$B8,$0B			; IDXLB	[11]
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B100
	!WORD	_B100-*
_B099 
; libsrc/apple/sndseq.pla: 0718:                     //
; libsrc/apple/sndseq.pla: 0719:                     // Note off
; libsrc/apple/sndseq.pla: 0720:                     //
; libsrc/apple/sndseq.pla: 0721:                     for i = 0 to MAX_SPKR_NOTES-1
	!BYTE	$06			; CN	3
	!BYTE	$00			; CN	0
_B111 
	!BYTE	$6C,$0B			; DLB	[11]
; libsrc/apple/sndseq.pla: 0722:                         //
; libsrc/apple/sndseq.pla: 0723:                         // Remove from active note table
; libsrc/apple/sndseq.pla: 0724:                         //
; libsrc/apple/sndseq.pla: 0725:                         if notes1[i] == note
; libsrc/apple/sndseq.pla: 0726:                             notes1[i] = 0
; libsrc/apple/sndseq.pla: 0727:                             numNotes--
	!BYTE	$26			; LA	_D057+0
_F184 	!WORD	_D057+0		
	!BYTE	$B8,$0B			; IDXLB	[11]
	!BYTE	$62			; LW
	!BYTE	$64,$0A			; LLB	[10]
	!BYTE	$24			; BRNE	_B113
	!WORD	_B113-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D057+0
_F185 	!WORD	_D057+0		
	!BYTE	$B8,$0B			; IDXLB	[11]
	!BYTE	$72			; SW
	!BYTE	$68			; LAB	_D049+0
_F186 	!WORD	_D049+0		
	!BYTE	$8E			; DECR
; libsrc/apple/sndseq.pla: 0728:                             break
	!BYTE	$78			; SAB	_D049+0
_F187 	!WORD	_D049+0		
	!BYTE	$50			; BRNCH	_B110
	!WORD	_B110-*
; libsrc/apple/sndseq.pla: 0729:                         fin
_B113 
_B114 
; libsrc/apple/sndseq.pla: 0730:                     next
_B112 
	!BYTE	$A4			; INCBRLE	_B111
	!WORD	_B111-*
_B110 
	!BYTE	$74,$0B			; SLB	[11]
	!BYTE	$30			; DROP 
; libsrc/apple/sndseq.pla: 0731:                 fin
_B100 
; libsrc/apple/sndseq.pla: 0732:             else
	!BYTE	$50			; BRNCH	_B098
	!WORD	_B098-*
_B097 
; libsrc/apple/sndseq.pla: 0733:                 //
; libsrc/apple/sndseq.pla: 0734:                 // Percussion event
; libsrc/apple/sndseq.pla: 0735:                 //
; libsrc/apple/sndseq.pla: 0736:                 if seqEvent->perchanvol
; libsrc/apple/sndseq.pla: 0737:                     //spkrPWM($D000, 0, 64) // Play some random sample as percussion
; libsrc/apple/sndseq.pla: 0738:                 else
	!BYTE	$6A			; LAW	_D045+0
_F188 	!WORD	_D045+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B115
	!WORD	_B115-*
	!BYTE	$50			; BRNCH	_B116
	!WORD	_B116-*
_B115 
; libsrc/apple/sndseq.pla: 0739:                     if seqRepeat
; libsrc/apple/sndseq.pla: 0740:                         musicPlay(seqTrack, TRUE)
; libsrc/apple/sndseq.pla: 0741:                     else
	!BYTE	$68			; LAB	_D050+0
_F189 	!WORD	_D050+0		
	!BYTE	$4C			; BRFLS	_B117
	!WORD	_B117-*
	!BYTE	$6A			; LAW	_D044+0
_F190 	!WORD	_D044+0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$54			; CALL	_P000
_F191 	!WORD	_P000		
	!BYTE	$50			; BRNCH	_B118
	!WORD	_B118-*
_B117 
; libsrc/apple/sndseq.pla: 0742:                         musicStop
; libsrc/apple/sndseq.pla: 0743:                     fin
	!BYTE	$54			; CALL	_P001
_F192 	!WORD	_P001		
_B118 
; libsrc/apple/sndseq.pla: 0744:                     return
	!BYTE	$5A,$0E			; LEAVE	14
; libsrc/apple/sndseq.pla: 0745:                 fin
_B116 
; libsrc/apple/sndseq.pla: 0746:             fin
_B098 
; libsrc/apple/sndseq.pla: 0747:             //
; libsrc/apple/sndseq.pla: 0748:             // Next event
; libsrc/apple/sndseq.pla: 0749:             //
; libsrc/apple/sndseq.pla: 0750:             seqEvent  = seqEvent  + t_event
; libsrc/apple/sndseq.pla: 0751:             eventTime = eventTime + seqEvent->deltatime
; libsrc/apple/sndseq.pla: 0752:         loop
	!BYTE	$6A			; LAW	_D045+0
_F193 	!WORD	_D045+0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$7A			; SAW	_D045+0
_F194 	!WORD	_D045+0		
	!BYTE	$6A			; LAW	_D047+0
_F195 	!WORD	_D047+0		
	!BYTE	$6A			; LAW	_D045+0
_F196 	!WORD	_D045+0		
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$7A			; SAW	_D047+0
_F197 	!WORD	_D047+0		
_B096 
	!BYTE	$6A			; LAW	_D047+0
_F198 	!WORD	_D047+0		
	!BYTE	$6A			; LAW	_D046+0
_F199 	!WORD	_D046+0		
	!BYTE	$22			; BREQ	_B094
	!WORD	_B094-*
_B095 
; libsrc/apple/sndseq.pla: 0753:         if numNotes > 1
; libsrc/apple/sndseq.pla: 0754:             for i = 0 to MAX_SPKR_NOTES-1
	!BYTE	$68			; LAB	_D049+0
_F200 	!WORD	_D049+0		
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B119
	!WORD	_B119-*
	!BYTE	$06			; CN	3
	!BYTE	$00			; CN	0
_B122 
	!BYTE	$6C,$0B			; DLB	[11]
; libsrc/apple/sndseq.pla: 0755:                 if notes1[i]
; libsrc/apple/sndseq.pla: 0756:                     spkrTone(periods1[i], arpeggioDuration[numNotes])#0
; libsrc/apple/sndseq.pla: 0757:                 fin
	!BYTE	$26			; LA	_D057+0
_F201 	!WORD	_D057+0		
	!BYTE	$B8,$0B			; IDXLB	[11]
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B124
	!WORD	_B124-*
	!BYTE	$26			; LA	_D060+0
_F202 	!WORD	_D060+0		
	!BYTE	$B8,$0B			; IDXLB	[11]
	!BYTE	$62			; LW
	!BYTE	$26			; LA	_D069+0
_F203 	!WORD	_D069+0		
	!BYTE	$BC			; IDXAB	_D049+0
_F204 	!WORD	_D049+0		
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D040+0
_F205 	!WORD	_D040+0		
	!BYTE	$56			; ICAL
_B124 
_B125 
; libsrc/apple/sndseq.pla: 0758:             next
_B123 
	!BYTE	$A4			; INCBRLE	_B122
	!WORD	_B122-*
_B121 
	!BYTE	$74,$0B			; SLB	[11]
	!BYTE	$30			; DROP 
; libsrc/apple/sndseq.pla: 0759:             seqTime++
	!BYTE	$6A			; LAW	_D046+0
_F206 	!WORD	_D046+0		
	!BYTE	$8C			; INCR
; libsrc/apple/sndseq.pla: 0760:         else
	!BYTE	$7A			; SAW	_D046+0
_F207 	!WORD	_D046+0		
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
_B119 
; libsrc/apple/sndseq.pla: 0761:             period = 0
; libsrc/apple/sndseq.pla: 0762:             for i = 0 to MAX_SPKR_NOTES-1
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$06			; CN	3
	!BYTE	$00			; CN	0
_B127 
	!BYTE	$6C,$0B			; DLB	[11]
; libsrc/apple/sndseq.pla: 0763:                 if notes1[i]
; libsrc/apple/sndseq.pla: 0764:                     period = periods1[i]
; libsrc/apple/sndseq.pla: 0765:                     break;
	!BYTE	$26			; LA	_D057+0
_F208 	!WORD	_D057+0		
	!BYTE	$B8,$0B			; IDXLB	[11]
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B129
	!WORD	_B129-*
	!BYTE	$26			; LA	_D060+0
_F209 	!WORD	_D060+0		
	!BYTE	$B8,$0B			; IDXLB	[11]
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B126
	!WORD	_B126-*
; libsrc/apple/sndseq.pla: 0766:                 fin
_B129 
_B130 
; libsrc/apple/sndseq.pla: 0767:             next
_B128 
	!BYTE	$A4			; INCBRLE	_B127
	!WORD	_B127-*
_B126 
	!BYTE	$74,$0B			; SLB	[11]
	!BYTE	$30			; DROP 
; libsrc/apple/sndseq.pla: 0768:             duration = eventTime - seqTime
; libsrc/apple/sndseq.pla: 0769:             seqTime  = duration + seqTime
; libsrc/apple/sndseq.pla: 0770:             spkrTone(period, DUR16TH * duration)#0
; libsrc/apple/sndseq.pla: 0771:         fin
	!BYTE	$6A			; LAW	_D047+0
_F210 	!WORD	_D047+0		
	!BYTE	$6A			; LAW	_D046+0
_F211 	!WORD	_D046+0		
	!BYTE	$84			; SUB 
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$B6			; ADDAW	_D046+0
_F212 	!WORD	_D046+0		
	!BYTE	$7A			; SAW	_D046+0
_F213 	!WORD	_D046+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$10			; CN	8
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$86			; MUL
	!BYTE	$6A			; LAW	_D040+0
_F214 	!WORD	_D040+0		
	!BYTE	$56			; ICAL
_B120 
; libsrc/apple/sndseq.pla: 0772:         if keypressed(); return; fin
	!BYTE	$6A			; LAW	_D042+0
_F215 	!WORD	_D042+0		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B131
	!WORD	_B131-*
	!BYTE	$5A,$0E			; LEAVE	14
_B131 
_B132 
; libsrc/apple/sndseq.pla: 0773:         if yieldTime <= seqTime; func()#0; yieldTime = seqTime + yield; fin
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$6A			; LAW	_D046+0
_F216 	!WORD	_D046+0		
	!BYTE	$4A			; ISLE
	!BYTE	$4C			; BRFLS	_B133
	!WORD	_B133-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_D046+0
_F217 	!WORD	_D046+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$76,$08			; SLW	[8]
_B133 
_B134 
; libsrc/apple/sndseq.pla: 0774:     until FALSE
_B093 
	!BYTE	$50			; BRNCH	_B092
	!WORD	_B092-*
_B091 
; libsrc/apple/sndseq.pla: 0775: end
	!BYTE	$5A,$0E			; LEAVE	14
; libsrc/apple/sndseq.pla: 0776: //
; libsrc/apple/sndseq.pla: 0777: // No sequence, just waste time and yield
; libsrc/apple/sndseq.pla: 0778: //
; libsrc/apple/sndseq.pla: 0779: def noSequence(yield, func)#0
					; yield -> [0]
					; func -> [2]
_C008 					; noSequence()
; libsrc/apple/sndseq.pla: 0780:     //
; libsrc/apple/sndseq.pla: 0781:     // Start wasting time
; libsrc/apple/sndseq.pla: 0782:     //
; libsrc/apple/sndseq.pla: 0783:     if !yield or !func
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/apple/sndseq.pla: 0784:         yield = 0
; libsrc/apple/sndseq.pla: 0785:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$80			; NOT
	!BYTE	$AE			; BROR	_B135
	!WORD	_B135-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$80			; NOT
_B135 
	!BYTE	$4C			; BRFLS	_B136
	!WORD	_B136-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$00			; SLW	[0]
_B136 
_B137 
; libsrc/apple/sndseq.pla: 0786:     seqTime = 0
; libsrc/apple/sndseq.pla: 0787:     repeat
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D046+0
_F218 	!WORD	_D046+0		
_B139 
; libsrc/apple/sndseq.pla: 0788:         seqTime++
	!BYTE	$6A			; LAW	_D046+0
_F219 	!WORD	_D046+0		
	!BYTE	$8C			; INCR
; libsrc/apple/sndseq.pla: 0789:         if seqTime < 0; seqTime = 1; fin // Capture wrap-around
	!BYTE	$7E			; DAW	_D046+0
_F220 	!WORD	_D046+0		
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B141
	!WORD	_B141-*
	!BYTE	$02			; CN	1
	!BYTE	$7A			; SAW	_D046+0
_F221 	!WORD	_D046+0		
_B141 
_B142 
; libsrc/apple/sndseq.pla: 0790:         spkrTone(0, DUR16TH) // Waste 16th of a second playing silence
; libsrc/apple/sndseq.pla: 0791:         if keypressed(); return; fin
	!BYTE	$00			; CN	0
	!BYTE	$10			; CN	8
	!BYTE	$6A			; LAW	_D040+0
_F222 	!WORD	_D040+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D042+0
_F223 	!WORD	_D042+0		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B143
	!WORD	_B143-*
	!BYTE	$5A,$04			; LEAVE	4
_B143 
_B144 
; libsrc/apple/sndseq.pla: 0792:         if yield == seqTime; func()#0; seqTime = 0; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D046+0
_F224 	!WORD	_D046+0		
	!BYTE	$24			; BRNE	_B145
	!WORD	_B145-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$56			; ICAL
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D046+0
_F225 	!WORD	_D046+0		
_B145 
_B146 
; libsrc/apple/sndseq.pla: 0793:     until FALSE
_B140 
	!BYTE	$50			; BRNCH	_B139
	!WORD	_B139-*
_B138 
; libsrc/apple/sndseq.pla: 0794: end
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/apple/sndseq.pla: 0795: //
; libsrc/apple/sndseq.pla: 0796: // Start sequencing music track
; libsrc/apple/sndseq.pla: 0797: //
; libsrc/apple/sndseq.pla: 0798: export def musicPlay(track, rept)#0
					; track -> [0]
					; rept -> [2]
_P000 					; musicPlay(track, rept)#0()
_C009 					; musicPlay()
; libsrc/apple/sndseq.pla: 0799:     byte i
					; i -> [4]
; libsrc/apple/sndseq.pla: 0800: 
; libsrc/apple/sndseq.pla: 0801:     //
; libsrc/apple/sndseq.pla: 0802:     // Select proper sequencer based on hardware
; libsrc/apple/sndseq.pla: 0803:     //
; libsrc/apple/sndseq.pla: 0804:     if mbSlot > 0
	!BYTE	$58,$05,$02		; ENTER	5,2
; libsrc/apple/sndseq.pla: 0805:         musicSequence = @mbSequence
; libsrc/apple/sndseq.pla: 0806:     else
	!BYTE	$6A			; LAW	_D066+0
_F226 	!WORD	_D066+0		
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B147
	!WORD	_B147-*
	!BYTE	$26			; LA	_C006+0
_F227 	!WORD	_C006+0		
	!BYTE	$7A			; SAW	_D039+0
_F228 	!WORD	_D039+0		
	!BYTE	$50			; BRNCH	_B148
	!WORD	_B148-*
_B147 
; libsrc/apple/sndseq.pla: 0807:         musicSequence = @spkrSequence
; libsrc/apple/sndseq.pla: 0808:     fin
	!BYTE	$26			; LA	_C007+0
_F229 	!WORD	_C007+0		
	!BYTE	$7A			; SAW	_D039+0
_F230 	!WORD	_D039+0		
_B148 
; libsrc/apple/sndseq.pla: 0809:     //
; libsrc/apple/sndseq.pla: 0810:     // Zero out active notes
; libsrc/apple/sndseq.pla: 0811:     //
; libsrc/apple/sndseq.pla: 0812:     for i = 0 to MAX_MBCH_NOTES-1; notes1[i] = 0;   notes2[i] = 0;   next
	!BYTE	$10			; CN	8
	!BYTE	$00			; CN	0
_B150 
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D057+0
_F231 	!WORD	_D057+0		
	!BYTE	$B8,$04			; IDXLB	[4]
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D058+0
_F232 	!WORD	_D058+0		
	!BYTE	$B8,$04			; IDXLB	[4]
	!BYTE	$72			; SW
_B151 
	!BYTE	$A4			; INCBRLE	_B150
	!WORD	_B150-*
_B149 
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$30			; DROP 
; libsrc/apple/sndseq.pla: 0813:     for i = 0 to MAX_MBCH_NOTES-1; periods1[i] = 0; periods2[i] = 0; next
	!BYTE	$10			; CN	8
	!BYTE	$00			; CN	0
_B153 
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D060+0
_F233 	!WORD	_D060+0		
	!BYTE	$B8,$04			; IDXLB	[4]
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D061+0
_F234 	!WORD	_D061+0		
	!BYTE	$B8,$04			; IDXLB	[4]
	!BYTE	$72			; SW
_B154 
	!BYTE	$A4			; INCBRLE	_B153
	!WORD	_B153-*
_B152 
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$30			; DROP 
; libsrc/apple/sndseq.pla: 0814:     //
; libsrc/apple/sndseq.pla: 0815:     // Start sequencing
; libsrc/apple/sndseq.pla: 0816:     //
; libsrc/apple/sndseq.pla: 0817:     seqRepeat  = rept
; libsrc/apple/sndseq.pla: 0818:     seqTrack   = track
; libsrc/apple/sndseq.pla: 0819:     seqEvent   = seqTrack
; libsrc/apple/sndseq.pla: 0820:     seqTime    = 0
; libsrc/apple/sndseq.pla: 0821:     eventTime  = seqEvent->deltatime
; libsrc/apple/sndseq.pla: 0822:     numNotes   = 0
; libsrc/apple/sndseq.pla: 0823: end
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$78			; SAB	_D050+0
_F235 	!WORD	_D050+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7E			; DAW	_D044+0
_F236 	!WORD	_D044+0		
	!BYTE	$7A			; SAW	_D045+0
_F237 	!WORD	_D045+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D046+0
_F238 	!WORD	_D046+0		
	!BYTE	$6A			; LAW	_D045+0
_F239 	!WORD	_D045+0		
	!BYTE	$60			; LB
	!BYTE	$7A			; SAW	_D047+0
_F240 	!WORD	_D047+0		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D049+0
_F241 	!WORD	_D049+0		
	!BYTE	$5A,$05			; LEAVE	5
; libsrc/apple/sndseq.pla: 0824: //
; libsrc/apple/sndseq.pla: 0825: // Stop sequencing music track
; libsrc/apple/sndseq.pla: 0826: //
; libsrc/apple/sndseq.pla: 0827: export def musicStop#0
_P001 					; musicStop#0()
_C010 					; musicStop()
; libsrc/apple/sndseq.pla: 0828:     musicSequence = @noSequence
; libsrc/apple/sndseq.pla: 0829: end
	!BYTE	$26			; LA	_C008+0
_F242 	!WORD	_C008+0		
	!BYTE	$7A			; SAW	_D039+0
_F243 	!WORD	_D039+0		
	!BYTE	$5C			; RET
; libsrc/apple/sndseq.pla: 0830: //
; libsrc/apple/sndseq.pla: 0831: // Play until keystroke
; libsrc/apple/sndseq.pla: 0832: //
; libsrc/apple/sndseq.pla: 0833: export def musicGetKey(yield, backgroundProc)#1
					; yield -> [0]
					; backgroundProc -> [2]
_C011 					; musicGetKey()
; libsrc/apple/sndseq.pla: 0834:     while not keypressed()
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$50			; BRNCH	_B157
	!WORD	_B157-*
_B155 
; libsrc/apple/sndseq.pla: 0835:         musicSequence(yield, backgroundProc)#0 // Call background proc every half second
; libsrc/apple/sndseq.pla: 0836:     loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D039+0
_F244 	!WORD	_D039+0		
	!BYTE	$56			; ICAL
_B157 
	!BYTE	$6A			; LAW	_D042+0
_F245 	!WORD	_D042+0		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B155
	!WORD	_B155-*
_B156 
; libsrc/apple/sndseq.pla: 0837:     return getc
	!BYTE	$54			; CALL	_X006
_F246 	!WORD	0		
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/apple/sndseq.pla: 0838: end
; libsrc/apple/sndseq.pla: 0839: 
; libsrc/apple/sndseq.pla: 0840: when MACHID & MACHID_MODEL
_INIT 
	!BYTE	$68			; LAB	_X001+0
_F247 	!WORD	0+0		
	!BYTE	$3C,$C8			; ANDI	200
	!BYTE	$52			; SEL
	!WORD	_B159-*
; libsrc/apple/sndseq.pla: 0841:     is MACHID_III
_B160 
; libsrc/apple/sndseq.pla: 0842:         spkrTone   = @a3spkrTone
; libsrc/apple/sndseq.pla: 0843:         spkrPWM    = @a3spkrPWM
; libsrc/apple/sndseq.pla: 0844:         keypressed = @a3keypressed
; libsrc/apple/sndseq.pla: 0845:         break
	!BYTE	$26			; LA	_C001+0
_F248 	!WORD	_C001+0		
	!BYTE	$7A			; SAW	_D040+0
_F249 	!WORD	_D040+0		
	!BYTE	$26			; LA	_C002+0
_F250 	!WORD	_C002+0		
	!BYTE	$7A			; SAW	_D041+0
_F251 	!WORD	_D041+0		
	!BYTE	$26			; LA	_C000+0
_F252 	!WORD	_C000+0		
	!BYTE	$7A			; SAW	_D042+0
_F253 	!WORD	_D042+0		
	!BYTE	$50			; BRNCH	_B158
	!WORD	_B158-*
; libsrc/apple/sndseq.pla: 0846:     is MACHID_I
_B161 
; libsrc/apple/sndseq.pla: 0847:         puts("Sound unsupported.\n")
	!BYTE	$2E			; CS
	!BYTE	$13
	!BYTE	$53,$6F,$75,$6E,$64,$20,$75,$6E
	!BYTE	$73,$75,$70,$70,$6F,$72,$74,$65
	!BYTE	$64,$2E,$0D
	!BYTE	$54			; CALL	_X004
_F254 	!WORD	0		
; libsrc/apple/sndseq.pla: 0848:         return -1
	!BYTE	$20			; MINUS ONE
	!BYTE	$5C			; RET
; libsrc/apple/sndseq.pla: 0849:         break
	!BYTE	$50			; BRNCH	_B158
	!WORD	_B158-*
; libsrc/apple/sndseq.pla: 0850:     otherwise
_B159 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0008
	!WORD	_B161-*
	!WORD	$00C0
	!WORD	_B160-*
; libsrc/apple/sndseq.pla: 0851:         //puts("MockingBoard Slot:\n")
; libsrc/apple/sndseq.pla: 0852:         //puts("ENTER = None\n")
; libsrc/apple/sndseq.pla: 0853:         //puts("0     = Scan\n")
; libsrc/apple/sndseq.pla: 0854:         //puts("1-7   = Slot #\n")
; libsrc/apple/sndseq.pla: 0855:         //instr = gets('>'|$80)
; libsrc/apple/sndseq.pla: 0856:         //if ^instr
; libsrc/apple/sndseq.pla: 0857:         //    mbSlot = mbSearch(^(instr + 1) - '0')
; libsrc/apple/sndseq.pla: 0858:         //fin
; libsrc/apple/sndseq.pla: 0859:         mbSlot = mbSearch(0)
; libsrc/apple/sndseq.pla: 0860:         break
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C004
_F255 	!WORD	_C004		
	!BYTE	$7A			; SAW	_D066+0
_F256 	!WORD	_D066+0		
	!BYTE	$50			; BRNCH	_B158
	!WORD	_B158-*
; libsrc/apple/sndseq.pla: 0861: wend
_B158 
; libsrc/apple/sndseq.pla: 0862: if mbSlot < 0
; libsrc/apple/sndseq.pla: 0863:     //
; libsrc/apple/sndseq.pla: 0864:     // No MockingBoard - scale octave0 for speaker
; libsrc/apple/sndseq.pla: 0865:     //
; libsrc/apple/sndseq.pla: 0866:     for instr = 0 to 11
	!BYTE	$6A			; LAW	_D066+0
_F257 	!WORD	_D066+0		
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B162
	!WORD	_B162-*
	!BYTE	$16			; CN	11
	!BYTE	$00			; CN	0
_B165 
	!BYTE	$7E			; DAW	_D043+0
_F258 	!WORD	_D043+0		
; libsrc/apple/sndseq.pla: 0867:         spkrOctave0[instr] = mbOctave0[instr]/NOTEDIV
; libsrc/apple/sndseq.pla: 0868:     next
	!BYTE	$26			; LA	_D068+0
_F259 	!WORD	_D068+0		
	!BYTE	$BE			; IDXAW	_D043+0
_F260 	!WORD	_D043+0		
	!BYTE	$62			; LW
	!BYTE	$04			; CN	2
	!BYTE	$9C			; SHR
	!BYTE	$26			; LA	_D067+0
_F261 	!WORD	_D067+0		
	!BYTE	$BE			; IDXAW	_D043+0
_F262 	!WORD	_D043+0		
	!BYTE	$72			; SW
_B166 
	!BYTE	$A4			; INCBRLE	_B165
	!WORD	_B165-*
_B164 
	!BYTE	$7A			; SAW	_D043+0
_F263 	!WORD	_D043+0		
	!BYTE	$30			; DROP 
; libsrc/apple/sndseq.pla: 0869: fin
_B162 
_B163 
; libsrc/apple/sndseq.pla: 0870: 
; libsrc/apple/sndseq.pla: 0871: done
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
_SYSFLAGS	=	0
_DEFCNT	=	13
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C010		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C011		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	0			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	11			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F133-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F134-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F135-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F136-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F137-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F138-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F139-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F140-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F141-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F142-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F143-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F144-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F145-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F146-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F147-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F148-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F149-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F150-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F151-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F152-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F153-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F154-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F155-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F156-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F157-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F158-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F159-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F160-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F161-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F162-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F163-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F164-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F165-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F166-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F167-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F168-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F169-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F170-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F171-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F172-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F173-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F174-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F175-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F176-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F177-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F178-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F179-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F180-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F181-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F182-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F183-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F184-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F185-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F186-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F187-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F188-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F189-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F190-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F191-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F192-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F193-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F194-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F195-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F196-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F197-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F198-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F199-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F200-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F201-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F202-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F203-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F204-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F205-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F206-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F207-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F208-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F209-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F210-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F211-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F212-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F213-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F214-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F215-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F216-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F217-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F218-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F219-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F220-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F221-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F222-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F223-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F224-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F225-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F226-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F227-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F228-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F229-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F230-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F231-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F232-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F233-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F234-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F235-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F236-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F237-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F238-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F239-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F240-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F241-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F242-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F243-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F244-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F245-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F246-_SEGBEGIN		
	!BYTE	6			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F247-_SEGBEGIN		
	!BYTE	1			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F248-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F249-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F250-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F251-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F252-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F253-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F254-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F255-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F256-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F257-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F258-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F259-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F260-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F261-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F262-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F263-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	0			; ESD INDEX
	; DCI STRING: MACHID
	!BYTE	$CD,$C1,$C3,$C8,$C9,$44
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	1			; ESD INDEX
	; DCI STRING: PUTS
	!BYTE	$D0,$D5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	4			; ESD INDEX
	; DCI STRING: GETC
	!BYTE	$C7,$C5,$D4,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	6			; ESD INDEX
	; DCI STRING: SYSCALL
	!BYTE	$D3,$D9,$D3,$C3,$C1,$CC,$4C
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	11			; ESD INDEX
	; DCI STRING: MUSICPLAY
	!BYTE	$CD,$D5,$D3,$C9,$C3,$D0,$CC,$C1,$59
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C009		
	; DCI STRING: MUSICSTOP
	!BYTE	$CD,$D5,$D3,$C9,$C3,$D3,$D4,$CF,$50
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C010		
	; DCI STRING: MUSICSEQUENCE
	!BYTE	$CD,$D5,$D3,$C9,$C3,$D3,$C5,$D1,$D5,$C5,$CE,$C3,$45
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D039		
	; DCI STRING: SPKRTONE
	!BYTE	$D3,$D0,$CB,$D2,$D4,$CF,$CE,$45
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D040		
	; DCI STRING: SPKRPWM
	!BYTE	$D3,$D0,$CB,$D2,$D0,$D7,$4D
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D041		
	; DCI STRING: MUSICGETKEY
	!BYTE	$CD,$D5,$D3,$C9,$C3,$C7,$C5,$D4,$CB,$C5,$59
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C011		
	!BYTE	$00			; END OF ESD
