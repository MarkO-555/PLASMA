; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; libsrc/apple/uthernet2.pla: 0001: //
; libsrc/apple/uthernet2.pla: 0002: // Uthernet II Wiznet 5100 based ethernet card
; libsrc/apple/uthernet2.pla: 0003: //
; libsrc/apple/uthernet2.pla: 0004: // TCP/IP is built into hardware, so no dependencies on the software
; libsrc/apple/uthernet2.pla: 0005: // layers, like the Uthernet
; libsrc/apple/uthernet2.pla: 0006: //
; libsrc/apple/uthernet2.pla: 0007: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0200 // Version built against
					; _SYSVER_ = 512
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $03
					; MACHID_MEM = 3
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     //
; inc/cmdsys.plh: 0038:     // Module don't free memory
; inc/cmdsys.plh: 0039:     //
; inc/cmdsys.plh: 0040:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0041:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0042:     //
; inc/cmdsys.plh: 0043:     // CMD exported interface table
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     struc t_cmdsys
; inc/cmdsys.plh: 0046:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0047:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0048:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0049:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0050:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0051:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0052:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0053:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0054:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0055:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0056:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0057:         byte refcons    // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0058:         byte devcons    // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0059:     end
					; t_cmdsys = 21
; inc/cmdsys.plh: 0060:     //
; inc/cmdsys.plh: 0061:     // CMD exported functions
; inc/cmdsys.plh: 0062:     //
; inc/cmdsys.plh: 0063:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0064:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0065:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0066:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0067:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0068:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0069: end
; libsrc/apple/uthernet2.pla: 0007: 
; libsrc/apple/uthernet2.pla: 0008: include "inc/inet.plh"
; inc/inet.plh: 0001: //
; inc/inet.plh: 0002: // iNet API
; inc/inet.plh: 0003: //
; inc/inet.plh: 0004: import iNet
	; DCI STRING: INET
	!BYTE	$C9,$CE,$C5,$54
					; INET -> X028
; inc/inet.plh: 0005: struc t_inet
; inc/inet.plh: 0006:     word initIP
					; initIP = 0
; inc/inet.plh: 0007:     word serviceIP
					; serviceIP = 2
; inc/inet.plh: 0008:     word openUDP
					; openUDP = 4
; inc/inet.plh: 0009:     word sendUDP
					; sendUDP = 6
; inc/inet.plh: 0010:     word closeUDP
					; closeUDP = 8
; inc/inet.plh: 0011:     word listenTCP
					; listenTCP = 10
; inc/inet.plh: 0012:     word connectTCP
					; connectTCP = 12
; inc/inet.plh: 0013:     word sendTCP
					; sendTCP = 14
; inc/inet.plh: 0014:     word closeTCP
					; closeTCP = 16
; inc/inet.plh: 0015:     word setInterfaceIP
					; setInterfaceIP = 18
; inc/inet.plh: 0016:     word getInterfaceHA
					; getInterfaceHA = 20
; inc/inet.plh: 0017:     word setDNS
					; setDNS = 22
; inc/inet.plh: 0018:     word resolveIP
					; resolveIP = 24
; inc/inet.plh: 0019:     word setCallback
					; setCallback = 26
; inc/inet.plh: 0020:     word setParam
					; setParam = 28
; inc/inet.plh: 0021: end
					; t_inet = 30
; inc/inet.plh: 0022: end
; libsrc/apple/uthernet2.pla: 0008: 
; libsrc/apple/uthernet2.pla: 0009: //
; libsrc/apple/uthernet2.pla: 0010: // Wiznet registers
; libsrc/apple/uthernet2.pla: 0011: //
; libsrc/apple/uthernet2.pla: 0012: const WIZ_MR     = $00
	!BYTE	$00			; END OF MODULE DEPENDENCIES
					; WIZ_MR = 0
; libsrc/apple/uthernet2.pla: 0013: const WIZ_GWR    = $01
					; WIZ_GWR = 1
; libsrc/apple/uthernet2.pla: 0014: const WIZ_SUBR   = $05
					; WIZ_SUBR = 5
; libsrc/apple/uthernet2.pla: 0015: const WIZ_SHAR   = $09
					; WIZ_SHAR = 9
; libsrc/apple/uthernet2.pla: 0016: const WIZ_SIPR   = $0F
					; WIZ_SIPR = 15
; libsrc/apple/uthernet2.pla: 0017: const WIZ_IR     = $15
					; WIZ_IR = 21
; libsrc/apple/uthernet2.pla: 0018: const WIZ_IMR    = $16
					; WIZ_IMR = 22
; libsrc/apple/uthernet2.pla: 0019: const WIZ_RTR    = $17
					; WIZ_RTR = 23
; libsrc/apple/uthernet2.pla: 0020: const WIZ_RCR    = $19
					; WIZ_RCR = 25
; libsrc/apple/uthernet2.pla: 0021: const WIZ_RMSR   = $1A
					; WIZ_RMSR = 26
; libsrc/apple/uthernet2.pla: 0022: const WIZ_TMSR   = $1B
					; WIZ_TMSR = 27
; libsrc/apple/uthernet2.pla: 0023: const WIZ_PATR   = $1C
					; WIZ_PATR = 28
; libsrc/apple/uthernet2.pla: 0024: const WIZ_PTMR   = $28
					; WIZ_PTMR = 40
; libsrc/apple/uthernet2.pla: 0025: const WIZ_PMGC   = $29
					; WIZ_PMGC = 41
; libsrc/apple/uthernet2.pla: 0026: const WIZ_UIPR   = $2A
					; WIZ_UIPR = 42
; libsrc/apple/uthernet2.pla: 0027: const WIZ_UPRT   = $2E
					; WIZ_UPRT = 46
; libsrc/apple/uthernet2.pla: 0028: //
; libsrc/apple/uthernet2.pla: 0029: // Wiznet socket registers
; libsrc/apple/uthernet2.pla: 0030: //
; libsrc/apple/uthernet2.pla: 0031: const WIZ_SREGS   = $0400
					; WIZ_SREGS = 1024
; libsrc/apple/uthernet2.pla: 0032: const WIZ_SSIZE   = $0100
					; WIZ_SSIZE = 256
; libsrc/apple/uthernet2.pla: 0033: const WIZ_SOCK0   = $0400
					; WIZ_SOCK0 = 1024
; libsrc/apple/uthernet2.pla: 0034: const WIZ_SOCK1   = $0500
					; WIZ_SOCK1 = 1280
; libsrc/apple/uthernet2.pla: 0035: const WIZ_SOCK2   = $0600
					; WIZ_SOCK2 = 1536
; libsrc/apple/uthernet2.pla: 0036: const WIZ_SOCK3   = $0700
					; WIZ_SOCK3 = 1792
; libsrc/apple/uthernet2.pla: 0037: const WIZ_SnMR    = $00
					; WIZ_SnMR = 0
; libsrc/apple/uthernet2.pla: 0038: const WIZ_SnCR    = $01
					; WIZ_SnCR = 1
; libsrc/apple/uthernet2.pla: 0039: const WIZ_SnIR    = $02
					; WIZ_SnIR = 2
; libsrc/apple/uthernet2.pla: 0040: const WIZ_SnSR    = $03
					; WIZ_SnSR = 3
; libsrc/apple/uthernet2.pla: 0041: const WIZ_SnPORT  = $04
					; WIZ_SnPORT = 4
; libsrc/apple/uthernet2.pla: 0042: const WIZ_SnDHAR  = $06
					; WIZ_SnDHAR = 6
; libsrc/apple/uthernet2.pla: 0043: const WIZ_SnDIPR  = $0C
					; WIZ_SnDIPR = 12
; libsrc/apple/uthernet2.pla: 0044: const WIZ_SnDPORT = $10
					; WIZ_SnDPORT = 16
; libsrc/apple/uthernet2.pla: 0045: const WIZ_SnMSSR  = $12
					; WIZ_SnMSSR = 18
; libsrc/apple/uthernet2.pla: 0046: const WIZ_SnPROTO = $14
					; WIZ_SnPROTO = 20
; libsrc/apple/uthernet2.pla: 0047: const WIZ_SnTOS   = $15
					; WIZ_SnTOS = 21
; libsrc/apple/uthernet2.pla: 0048: const WIZ_SnTTL   = $16
					; WIZ_SnTTL = 22
; libsrc/apple/uthernet2.pla: 0049: const WIZ_SnFSR   = $20
					; WIZ_SnFSR = 32
; libsrc/apple/uthernet2.pla: 0050: const WIZ_SnTXRD  = $22
					; WIZ_SnTXRD = 34
; libsrc/apple/uthernet2.pla: 0051: const WIZ_SnTXWR  = $24
					; WIZ_SnTXWR = 36
; libsrc/apple/uthernet2.pla: 0052: const WIZ_SnRSR   = $26
					; WIZ_SnRSR = 38
; libsrc/apple/uthernet2.pla: 0053: const WIZ_SnRXRD  = $28
					; WIZ_SnRXRD = 40
; libsrc/apple/uthernet2.pla: 0054: //
; libsrc/apple/uthernet2.pla: 0055: // Wiznet socket data
; libsrc/apple/uthernet2.pla: 0056: //
; libsrc/apple/uthernet2.pla: 0057: const WIZ_TXMEM  = $4000
					; WIZ_TXMEM = 16384
; libsrc/apple/uthernet2.pla: 0058: const WIZ_TXSIZE = $0800
					; WIZ_TXSIZE = 2048
; libsrc/apple/uthernet2.pla: 0059: const WIZ_TXMASK = WIZ_TXSIZE-1
					; WIZ_TXMASK = 2047
; libsrc/apple/uthernet2.pla: 0060: const WIZ_TXMEM0 = $4000
					; WIZ_TXMEM0 = 16384
; libsrc/apple/uthernet2.pla: 0061: const WIZ_TXMEM1 = $4800
					; WIZ_TXMEM1 = 18432
; libsrc/apple/uthernet2.pla: 0062: const WIZ_TXMEM2 = $5000
					; WIZ_TXMEM2 = 20480
; libsrc/apple/uthernet2.pla: 0063: const WIZ_TXMEM3 = $5800
					; WIZ_TXMEM3 = 22528
; libsrc/apple/uthernet2.pla: 0064: const WIZ_RXMEM  = $6000
					; WIZ_RXMEM = 24576
; libsrc/apple/uthernet2.pla: 0065: const WIZ_RXSIZE = $0800
					; WIZ_RXSIZE = 2048
; libsrc/apple/uthernet2.pla: 0066: const WIZ_RXMASK = WIZ_RXSIZE-1
					; WIZ_RXMASK = 2047
; libsrc/apple/uthernet2.pla: 0067: const WIZ_RXMEM0 = $6000
					; WIZ_RXMEM0 = 24576
; libsrc/apple/uthernet2.pla: 0068: const WIZ_RXMEM1 = $6800
					; WIZ_RXMEM1 = 26624
; libsrc/apple/uthernet2.pla: 0069: const WIZ_RXMEM2 = $7000
					; WIZ_RXMEM2 = 28672
; libsrc/apple/uthernet2.pla: 0070: const WIZ_RXMEM3 = $7800
					; WIZ_RXMEM3 = 30720
; libsrc/apple/uthernet2.pla: 0071: //
; libsrc/apple/uthernet2.pla: 0072: // Wiznet indirect registers
; libsrc/apple/uthernet2.pla: 0073: //
; libsrc/apple/uthernet2.pla: 0074: word[] rom
_D029 					; rom
; libsrc/apple/uthernet2.pla: 0075: word   saveidx
_D030 	!FILL	2			; saveidx
; libsrc/apple/uthernet2.pla: 0076: byte   regidx
_D031 	!FILL	1			; regidx
; libsrc/apple/uthernet2.pla: 0077: byte   regdata
_D032 	!FILL	1			; regdata
; libsrc/apple/uthernet2.pla: 0078: byte   slot
_D033 	!FILL	1			; slot
; libsrc/apple/uthernet2.pla: 0079: //
; libsrc/apple/uthernet2.pla: 0080: // Wiznet MAC address
; libsrc/apple/uthernet2.pla: 0081: //
; libsrc/apple/uthernet2.pla: 0082: byte[6] wizMAC = $00,$0A,$99,$1E,$02,$B0
_D034 					; wizMAC = $00,$0A,$99,$1E,$02,$B0
	!BYTE	$00
	!BYTE	$0A
	!BYTE	$99
	!BYTE	$1E
	!BYTE	$02
	!BYTE	$B0
; libsrc/apple/uthernet2.pla: 0083: //
; libsrc/apple/uthernet2.pla: 0084: // Wiznet IP addresses
; libsrc/apple/uthernet2.pla: 0085: //
; libsrc/apple/uthernet2.pla: 0086: byte[4] localip
_D035 	!FILL	4			; localip
; libsrc/apple/uthernet2.pla: 0087: byte[4] subnet
_D036 	!FILL	4			; subnet
; libsrc/apple/uthernet2.pla: 0088: byte[4] gateway
_D037 	!FILL	4			; gateway
; libsrc/apple/uthernet2.pla: 0089: //
; libsrc/apple/uthernet2.pla: 0090: // Predefine service routine
; libsrc/apple/uthernet2.pla: 0091: //
; libsrc/apple/uthernet2.pla: 0092: predef wizServiceIP
; libsrc/apple/uthernet2.pla: 0093: //
; libsrc/apple/uthernet2.pla: 0094: // Segment list element
; libsrc/apple/uthernet2.pla: 0095: //
; libsrc/apple/uthernet2.pla: 0096: struc t_segment
; libsrc/apple/uthernet2.pla: 0097:     word seg_buf
					; seg_buf = 0
; libsrc/apple/uthernet2.pla: 0098:     word seg_len
					; seg_len = 2
; libsrc/apple/uthernet2.pla: 0099: end
					; t_segment = 4
; libsrc/apple/uthernet2.pla: 0100: //
; libsrc/apple/uthernet2.pla: 0101: // Max Ethernet frame size
; libsrc/apple/uthernet2.pla: 0102: //
; libsrc/apple/uthernet2.pla: 0103: const MAX_FRAME_SIZE = 1518
					; MAX_FRAME_SIZE = 1518
; libsrc/apple/uthernet2.pla: 0104: const MAC_BROADCAST  = $FFFF
					; MAC_BROADCAST = 65535
; libsrc/apple/uthernet2.pla: 0105: const MAC_SIZE       = 6
					; MAC_SIZE = 6
; libsrc/apple/uthernet2.pla: 0106: //
; libsrc/apple/uthernet2.pla: 0107: // Ethernet header
; libsrc/apple/uthernet2.pla: 0108: //
; libsrc/apple/uthernet2.pla: 0109: struc t_ethrhdr
; libsrc/apple/uthernet2.pla: 0110:     byte[MAC_SIZE] ethr_dst
					; ethr_dst = 0
; libsrc/apple/uthernet2.pla: 0111:     byte[MAC_SIZE] ethr_src
					; ethr_src = 6
; libsrc/apple/uthernet2.pla: 0112:     word           ethr_payload
					; ethr_payload = 12
; libsrc/apple/uthernet2.pla: 0113: end
					; t_ethrhdr = 14
; libsrc/apple/uthernet2.pla: 0114: const PAYLOAD_IP  = $0008 // BE format
					; PAYLOAD_IP = 8
; libsrc/apple/uthernet2.pla: 0115: const PAYLOAD_ARP = $0608 // BE format
					; PAYLOAD_ARP = 1544
; libsrc/apple/uthernet2.pla: 0116: //
; libsrc/apple/uthernet2.pla: 0117: // IP datagram header
; libsrc/apple/uthernet2.pla: 0118: //
; libsrc/apple/uthernet2.pla: 0119: const IP4ADR_SIZE = 4
					; IP4ADR_SIZE = 4
; libsrc/apple/uthernet2.pla: 0120: struc t_iphdr
; libsrc/apple/uthernet2.pla: 0121:     byte ip_vers_hlen
					; ip_vers_hlen = 0
; libsrc/apple/uthernet2.pla: 0122:     byte ip_service
					; ip_service = 1
; libsrc/apple/uthernet2.pla: 0123:     word ip_length
					; ip_length = 2
; libsrc/apple/uthernet2.pla: 0124:     word ip_id
					; ip_id = 4
; libsrc/apple/uthernet2.pla: 0125:     word ip_flags_fragofst
					; ip_flags_fragofst = 6
; libsrc/apple/uthernet2.pla: 0126:     byte ip_ttl
					; ip_ttl = 8
; libsrc/apple/uthernet2.pla: 0127:     byte ip_proto
					; ip_proto = 9
; libsrc/apple/uthernet2.pla: 0128:     word ip_chksm
					; ip_chksm = 10
; libsrc/apple/uthernet2.pla: 0129:     byte[IP4ADR_SIZE] ip_src
					; ip_src = 12
; libsrc/apple/uthernet2.pla: 0130:     byte[IP4ADR_SIZE] ip_dst
					; ip_dst = 16
; libsrc/apple/uthernet2.pla: 0131:     byte[] ip_options
					; ip_options = 20
; libsrc/apple/uthernet2.pla: 0132: end
					; t_iphdr = 20
; libsrc/apple/uthernet2.pla: 0133: const IP_BROADCAST  = $FFFF
					; IP_BROADCAST = 65535
; libsrc/apple/uthernet2.pla: 0134: const IP_PROTO_ICMP = $01
					; IP_PROTO_ICMP = 1
; libsrc/apple/uthernet2.pla: 0135: const IP_PROTO_UDP  = $11
					; IP_PROTO_UDP = 17
; libsrc/apple/uthernet2.pla: 0136: const IP_PROTO_TCP  = $06
					; IP_PROTO_TCP = 6
; libsrc/apple/uthernet2.pla: 0137: word bcast = IP_BROADCAST, IP_BROADCAST
_D039 					; bcast = IP_BROADCAST, IP_BROADCAST
	!WORD	$FFFF
	!WORD	$FFFF
; libsrc/apple/uthernet2.pla: 0138: //
; libsrc/apple/uthernet2.pla: 0139: // ICMP type/codes
; libsrc/apple/uthernet2.pla: 0140: //
; libsrc/apple/uthernet2.pla: 0141: const ICMP_ECHO_REQST = 8
					; ICMP_ECHO_REQST = 8
; libsrc/apple/uthernet2.pla: 0142: const ICMP_ECHO_REPLY = 0
					; ICMP_ECHO_REPLY = 0
; libsrc/apple/uthernet2.pla: 0143: //
; libsrc/apple/uthernet2.pla: 0144: // ICMP message format
; libsrc/apple/uthernet2.pla: 0145: //
; libsrc/apple/uthernet2.pla: 0146: struc t_icmp
; libsrc/apple/uthernet2.pla: 0147:     byte    icmp_type
					; icmp_type = 0
; libsrc/apple/uthernet2.pla: 0148:     byte    icmp_code
					; icmp_code = 1
; libsrc/apple/uthernet2.pla: 0149:     word    icmp_chksm
					; icmp_chksm = 2
; libsrc/apple/uthernet2.pla: 0150:     word[2] icmp_header
					; icmp_header = 4
; libsrc/apple/uthernet2.pla: 0151: end
					; t_icmp = 8
; libsrc/apple/uthernet2.pla: 0152: //
; libsrc/apple/uthernet2.pla: 0153: // UDP IPv4 psuedo header
; libsrc/apple/uthernet2.pla: 0154: //
; libsrc/apple/uthernet2.pla: 0155: struc t_piphdr
; libsrc/apple/uthernet2.pla: 0156:     byte[IP4ADR_SIZE] pip_src
					; pip_src = 0
; libsrc/apple/uthernet2.pla: 0157:     byte[IP4ADR_SIZE] pip_dst
					; pip_dst = 4
; libsrc/apple/uthernet2.pla: 0158:     byte              pip_zero
					; pip_zero = 8
; libsrc/apple/uthernet2.pla: 0159:     byte              pip_proto
					; pip_proto = 9
; libsrc/apple/uthernet2.pla: 0160:     word              pip_len
					; pip_len = 10
; libsrc/apple/uthernet2.pla: 0161: end
					; t_piphdr = 12
; libsrc/apple/uthernet2.pla: 0162: //
; libsrc/apple/uthernet2.pla: 0163: // UDP header
; libsrc/apple/uthernet2.pla: 0164: //
; libsrc/apple/uthernet2.pla: 0165: struc t_udphdr
; libsrc/apple/uthernet2.pla: 0166:     word udp_src
					; udp_src = 0
; libsrc/apple/uthernet2.pla: 0167:     word udp_dst
					; udp_dst = 2
; libsrc/apple/uthernet2.pla: 0168:     word udp_len
					; udp_len = 4
; libsrc/apple/uthernet2.pla: 0169:     word udp_chksm
					; udp_chksm = 6
; libsrc/apple/uthernet2.pla: 0170: end
					; t_udphdr = 8
; libsrc/apple/uthernet2.pla: 0171: //
; libsrc/apple/uthernet2.pla: 0172: // TCP header
; libsrc/apple/uthernet2.pla: 0173: //
; libsrc/apple/uthernet2.pla: 0174: struc t_tcphdr
; libsrc/apple/uthernet2.pla: 0175:     word tcp_src
					; tcp_src = 0
; libsrc/apple/uthernet2.pla: 0176:     word tcp_dst
					; tcp_dst = 2
; libsrc/apple/uthernet2.pla: 0177:     word tcp_len
					; tcp_len = 4
; libsrc/apple/uthernet2.pla: 0178:     word tcp_chksm
					; tcp_chksm = 6
; libsrc/apple/uthernet2.pla: 0179: end
					; t_tcphdr = 8
; libsrc/apple/uthernet2.pla: 0180: //
; libsrc/apple/uthernet2.pla: 0181: // Local network parameters
; libsrc/apple/uthernet2.pla: 0182: //
; libsrc/apple/uthernet2.pla: 0183: const MAX_WIZ_CHANNELS  = 4
					; MAX_WIZ_CHANNELS = 4
; libsrc/apple/uthernet2.pla: 0184: //
; libsrc/apple/uthernet2.pla: 0185: // Channel protocols
; libsrc/apple/uthernet2.pla: 0186: //
; libsrc/apple/uthernet2.pla: 0187: const WIZ_PROTO_CLOSED  = 0
					; WIZ_PROTO_CLOSED = 0
; libsrc/apple/uthernet2.pla: 0188: const WIZ_PROTO_TCP     = 1
					; WIZ_PROTO_TCP = 1
; libsrc/apple/uthernet2.pla: 0189: const WIZ_PROTO_UDP     = 2
					; WIZ_PROTO_UDP = 2
; libsrc/apple/uthernet2.pla: 0190: const WIZ_PROTO_IP      = 3
					; WIZ_PROTO_IP = 3
; libsrc/apple/uthernet2.pla: 0191: const WIZ_PROTO_RAW     = 4
					; WIZ_PROTO_RAW = 4
; libsrc/apple/uthernet2.pla: 0192: //
; libsrc/apple/uthernet2.pla: 0193: // State transistions
; libsrc/apple/uthernet2.pla: 0194: //
; libsrc/apple/uthernet2.pla: 0195: const TCP_STATE_CLOSED  = 0
					; TCP_STATE_CLOSED = 0
; libsrc/apple/uthernet2.pla: 0196: const TCP_STATE_CLOSING = 1
					; TCP_STATE_CLOSING = 1
; libsrc/apple/uthernet2.pla: 0197: const TCP_STATE_LISTEN  = 2
					; TCP_STATE_LISTEN = 2
; libsrc/apple/uthernet2.pla: 0198: const TCP_STATE_CONNECT = 3
					; TCP_STATE_CONNECT = 3
; libsrc/apple/uthernet2.pla: 0199: const TCP_STATE_OPEN    = 4
					; TCP_STATE_OPEN = 4
; libsrc/apple/uthernet2.pla: 0200: //
; libsrc/apple/uthernet2.pla: 0201: // HW channels
; libsrc/apple/uthernet2.pla: 0202: //
; libsrc/apple/uthernet2.pla: 0203: struc t_channel
; libsrc/apple/uthernet2.pla: 0204:     byte    channel_proto
					; channel_proto = 0
; libsrc/apple/uthernet2.pla: 0205:     byte    channel_state
					; channel_state = 1
; libsrc/apple/uthernet2.pla: 0206:     word    channel_regs
					; channel_regs = 2
; libsrc/apple/uthernet2.pla: 0207:     word    channel_txmem
					; channel_txmem = 4
; libsrc/apple/uthernet2.pla: 0208:     word    channel_rxmem
					; channel_rxmem = 6
; libsrc/apple/uthernet2.pla: 0209:     word    channel_lclport
					; channel_lclport = 8
; libsrc/apple/uthernet2.pla: 0210:     word    channel_remport
					; channel_remport = 10
; libsrc/apple/uthernet2.pla: 0211:     byte[4] channel_remip
					; channel_remip = 12
; libsrc/apple/uthernet2.pla: 0212:     word    channel_recv_func
					; channel_recv_func = 16
; libsrc/apple/uthernet2.pla: 0213:     word    channel_recv_parm
					; channel_recv_parm = 18
; libsrc/apple/uthernet2.pla: 0214: end
					; t_channel = 20
; libsrc/apple/uthernet2.pla: 0215: byte[t_channel] wizChannel[MAX_WIZ_CHANNELS]
_D040 	!FILL	80			; wizChannel[MAX_WIZ_CHANNELS]
; libsrc/apple/uthernet2.pla: 0216: //
; libsrc/apple/uthernet2.pla: 0217: // Service ICMP hook
; libsrc/apple/uthernet2.pla: 0218: //
; libsrc/apple/uthernet2.pla: 0219: export word hookICMP
_D041 	!FILL	2			; hookICMP
; libsrc/apple/uthernet2.pla: 0220: //
; libsrc/apple/uthernet2.pla: 0221: // Defines for ASM routines
; libsrc/apple/uthernet2.pla: 0222: //
; libsrc/apple/uthernet2.pla: 0223: asm equates
_A000 					; equates()
; libsrc/apple/uthernet2.pla: 0224:         !SOURCE "vmsrc/plvmzp.inc"
        !SOURCE "vmsrc/plvmzp.inc"
; libsrc/apple/uthernet2.pla: 0225: end
; libsrc/apple/uthernet2.pla: 0226: //
; libsrc/apple/uthernet2.pla: 0227: // Swap bytes in word
; libsrc/apple/uthernet2.pla: 0228: //
; libsrc/apple/uthernet2.pla: 0229: asm swab(val)
_A001 					; swab()
; libsrc/apple/uthernet2.pla: 0230:         LDA     ESTKL,X
        LDA     ESTKL,X
; libsrc/apple/uthernet2.pla: 0231:         LDY     ESTKH,X
        LDY     ESTKH,X
; libsrc/apple/uthernet2.pla: 0232:         STA     ESTKH,X
        STA     ESTKH,X
; libsrc/apple/uthernet2.pla: 0233:         STY     ESTKL,X
        STY     ESTKL,X
; libsrc/apple/uthernet2.pla: 0234:         RTS
        RTS
; libsrc/apple/uthernet2.pla: 0235: end
; libsrc/apple/uthernet2.pla: 0236: //
; libsrc/apple/uthernet2.pla: 0237: // Wiznet I/O functions
; libsrc/apple/uthernet2.pla: 0238: //
; libsrc/apple/uthernet2.pla: 0239: // POKE WORD TO I/O SPACE
; libsrc/apple/uthernet2.pla: 0240: // Note: Big Endian format
; libsrc/apple/uthernet2.pla: 0241: //
; libsrc/apple/uthernet2.pla: 0242: asm _pokeiow(val)#0
_A002 					; _pokeiow()
; libsrc/apple/uthernet2.pla: 0243:         LDA     ESTKH,X
        LDA     ESTKH,X
; libsrc/apple/uthernet2.pla: 0244: end
; libsrc/apple/uthernet2.pla: 0245: asm _pokeiowl
_A003 					; _pokeiowl()
; libsrc/apple/uthernet2.pla: 0246:         STA     $C000
        STA     $C000
; libsrc/apple/uthernet2.pla: 0247:         LDA     ESTKL,X
        LDA     ESTKL,X
; libsrc/apple/uthernet2.pla: 0248: end
; libsrc/apple/uthernet2.pla: 0249: asm _pokeiowh
_A004 					; _pokeiowh()
; libsrc/apple/uthernet2.pla: 0250:         STA     $C000
        STA     $C000
; libsrc/apple/uthernet2.pla: 0251:         INX
        INX
; libsrc/apple/uthernet2.pla: 0252:         RTS
        RTS
; libsrc/apple/uthernet2.pla: 0253: end
; libsrc/apple/uthernet2.pla: 0254: //
; libsrc/apple/uthernet2.pla: 0255: // POKE BYTE TO I/O SPACE
; libsrc/apple/uthernet2.pla: 0256: //
; libsrc/apple/uthernet2.pla: 0257: asm _pokeio(val)#0
_A005 					; _pokeio()
; libsrc/apple/uthernet2.pla: 0258:         LDA     ESTKL,X
        LDA     ESTKL,X
; libsrc/apple/uthernet2.pla: 0259: end
; libsrc/apple/uthernet2.pla: 0260: asm _pokeiol
_A006 					; _pokeiol()
; libsrc/apple/uthernet2.pla: 0261:         STA     $C000
        STA     $C000
; libsrc/apple/uthernet2.pla: 0262:         INX
        INX
; libsrc/apple/uthernet2.pla: 0263:         RTS
        RTS
; libsrc/apple/uthernet2.pla: 0264: end
; libsrc/apple/uthernet2.pla: 0265: //
; libsrc/apple/uthernet2.pla: 0266: // PEEK BYTE FROM I/O SPACE
; libsrc/apple/uthernet2.pla: 0267: //
; libsrc/apple/uthernet2.pla: 0268: asm _peekio
_A007 					; _peekio()
; libsrc/apple/uthernet2.pla: 0269:         DEX
        DEX
; libsrc/apple/uthernet2.pla: 0270: end
; libsrc/apple/uthernet2.pla: 0271: asm _peekiol
_A008 					; _peekiol()
; libsrc/apple/uthernet2.pla: 0272:         LDA     $C000
        LDA     $C000
; libsrc/apple/uthernet2.pla: 0273:         STA     ESTKL,X
        STA     ESTKL,X
; libsrc/apple/uthernet2.pla: 0274:         LDA     #$00
        LDA     #$00
; libsrc/apple/uthernet2.pla: 0275:         STA     ESTKH,X
        STA     ESTKH,X
; libsrc/apple/uthernet2.pla: 0276:         RTS
        RTS
; libsrc/apple/uthernet2.pla: 0277: end
; libsrc/apple/uthernet2.pla: 0278: //
; libsrc/apple/uthernet2.pla: 0279: // PEEK WORD FROM I/O SPACE
; libsrc/apple/uthernet2.pla: 0280: // Note: Big Endian format
; libsrc/apple/uthernet2.pla: 0281: //
; libsrc/apple/uthernet2.pla: 0282: asm _peekiow
_A009 					; _peekiow()
; libsrc/apple/uthernet2.pla: 0283:         DEX
        DEX
; libsrc/apple/uthernet2.pla: 0284: end
; libsrc/apple/uthernet2.pla: 0285: asm _peekiowl
_A010 					; _peekiowl()
; libsrc/apple/uthernet2.pla: 0286:         LDA     $C000
        LDA     $C000
; libsrc/apple/uthernet2.pla: 0287:         STA     ESTKH,X
        STA     ESTKH,X
; libsrc/apple/uthernet2.pla: 0288: end
; libsrc/apple/uthernet2.pla: 0289: asm _peekiowh
_A011 					; _peekiowh()
; libsrc/apple/uthernet2.pla: 0290:         LDA     $C000
        LDA     $C000
; libsrc/apple/uthernet2.pla: 0291:         STA     ESTKL,X
        STA     ESTKL,X
; libsrc/apple/uthernet2.pla: 0292:         RTS
        RTS
; libsrc/apple/uthernet2.pla: 0293: end
; libsrc/apple/uthernet2.pla: 0294: //
; libsrc/apple/uthernet2.pla: 0295: // WRITE DATA INTO I/O SPACE
; libsrc/apple/uthernet2.pla: 0296: // pokedata(BUF, LEN)
; libsrc/apple/uthernet2.pla: 0297: //
; libsrc/apple/uthernet2.pla: 0298: asm pokedata(buf, len)#0
_A012 					; pokedata()
; libsrc/apple/uthernet2.pla: 0299:         LDA     ESTKL+1,X
        LDA     ESTKL+1,X
; libsrc/apple/uthernet2.pla: 0300:         STA     SRCL
        STA     SRCL
; libsrc/apple/uthernet2.pla: 0301:         LDA     ESTKH+1,X
        LDA     ESTKH+1,X
; libsrc/apple/uthernet2.pla: 0302:         STA     SRCH
        STA     SRCH
; libsrc/apple/uthernet2.pla: 0303:         LDY     ESTKL,X
        LDY     ESTKL,X
; libsrc/apple/uthernet2.pla: 0304:         BEQ     POKELP
        BEQ     POKELP
; libsrc/apple/uthernet2.pla: 0305:         LDY     #$00
        LDY     #$00
; libsrc/apple/uthernet2.pla: 0306:         INC     ESTKH,X
        INC     ESTKH,X
; libsrc/apple/uthernet2.pla: 0307: POKELP  LDA     (SRC),Y
POKELP  LDA     (SRC),Y
; libsrc/apple/uthernet2.pla: 0308: end
; libsrc/apple/uthernet2.pla: 0309: asm _pokedata
_A013 					; _pokedata()
; libsrc/apple/uthernet2.pla: 0310:         STA     $C000
        STA     $C000
; libsrc/apple/uthernet2.pla: 0311:         INY
        INY
; libsrc/apple/uthernet2.pla: 0312:         BNE     +
        BNE     +
; libsrc/apple/uthernet2.pla: 0313:         INC     SRCH
        INC     SRCH
; libsrc/apple/uthernet2.pla: 0314: +       DEC     ESTKL,X
+       DEC     ESTKL,X
; libsrc/apple/uthernet2.pla: 0315:         BNE     POKELP
        BNE     POKELP
; libsrc/apple/uthernet2.pla: 0316:         DEC     ESTKH,X
        DEC     ESTKH,X
; libsrc/apple/uthernet2.pla: 0317:         BNE     POKELP
        BNE     POKELP
; libsrc/apple/uthernet2.pla: 0318:         INX
        INX
; libsrc/apple/uthernet2.pla: 0319:         INX
        INX
; libsrc/apple/uthernet2.pla: 0320:         RTS
        RTS
; libsrc/apple/uthernet2.pla: 0321: end
; libsrc/apple/uthernet2.pla: 0322: //
; libsrc/apple/uthernet2.pla: 0323: // READ DATA FROM I/O SPACE
; libsrc/apple/uthernet2.pla: 0324: // peekdata(BUF, LEN)
; libsrc/apple/uthernet2.pla: 0325: //
; libsrc/apple/uthernet2.pla: 0326: asm peekdata(buf, len)#0
_A014 					; peekdata()
; libsrc/apple/uthernet2.pla: 0327:         LDA     ESTKL+1,X
        LDA     ESTKL+1,X
; libsrc/apple/uthernet2.pla: 0328:         STA     DSTL
        STA     DSTL
; libsrc/apple/uthernet2.pla: 0329:         LDA     ESTKH+1,X
        LDA     ESTKH+1,X
; libsrc/apple/uthernet2.pla: 0330:         STA     DSTH
        STA     DSTH
; libsrc/apple/uthernet2.pla: 0331:         LDY     ESTKL,X
        LDY     ESTKL,X
; libsrc/apple/uthernet2.pla: 0332:         BEQ     PEEKLP
        BEQ     PEEKLP
; libsrc/apple/uthernet2.pla: 0333:         LDY     #$00
        LDY     #$00
; libsrc/apple/uthernet2.pla: 0334:         INC     ESTKH,X
        INC     ESTKH,X
; libsrc/apple/uthernet2.pla: 0335: end
; libsrc/apple/uthernet2.pla: 0336: asm _peekdata
_A015 					; _peekdata()
; libsrc/apple/uthernet2.pla: 0337: PEEKLP  LDA     $C000
PEEKLP  LDA     $C000
; libsrc/apple/uthernet2.pla: 0338:         STA     (DST),Y
        STA     (DST),Y
; libsrc/apple/uthernet2.pla: 0339:         INY
        INY
; libsrc/apple/uthernet2.pla: 0340:         BNE     +
        BNE     +
; libsrc/apple/uthernet2.pla: 0341:         INC     DSTH
        INC     DSTH
; libsrc/apple/uthernet2.pla: 0342: +       DEC     ESTKL,X
+       DEC     ESTKL,X
; libsrc/apple/uthernet2.pla: 0343:         BNE     PEEKLP
        BNE     PEEKLP
; libsrc/apple/uthernet2.pla: 0344:         DEC     ESTKH,X
        DEC     ESTKH,X
; libsrc/apple/uthernet2.pla: 0345:         BNE     PEEKLP
        BNE     PEEKLP
; libsrc/apple/uthernet2.pla: 0346:         INX
        INX
; libsrc/apple/uthernet2.pla: 0347:         INX
        INX
; libsrc/apple/uthernet2.pla: 0348:         RTS
        RTS
; libsrc/apple/uthernet2.pla: 0349: end
; libsrc/apple/uthernet2.pla: 0350: def pokeiow(io, data)#0
_SUBSEG 				; BYTECODE STARTS
					; io -> [0]
					; data -> [2]
_C000 					; pokeiow()
; libsrc/apple/uthernet2.pla: 0351:     _pokeiowl.1 = io
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/apple/uthernet2.pla: 0352:     _pokeiowh.1 = io+1
; libsrc/apple/uthernet2.pla: 0353:     _pokeiow(data)
; libsrc/apple/uthernet2.pla: 0354: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$78			; SAB	_A003+1
_F000 	!WORD	_A003+1		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$78			; SAB	_A004+1
_F001 	!WORD	_A004+1		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_A002
_F002 	!WORD	_A002		
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/apple/uthernet2.pla: 0355: def pokeio(io, data)#0
					; io -> [0]
					; data -> [2]
_C001 					; pokeio()
; libsrc/apple/uthernet2.pla: 0356:     _pokeiol.1 = io
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/apple/uthernet2.pla: 0357:     _pokeio(data)
; libsrc/apple/uthernet2.pla: 0358: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$78			; SAB	_A006+1
_F003 	!WORD	_A006+1		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_A005
_F004 	!WORD	_A005		
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/apple/uthernet2.pla: 0359: def peekio(io)
					; io -> [0]
_C002 					; peekio()
; libsrc/apple/uthernet2.pla: 0360:     _peekiol.1 = io
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/apple/uthernet2.pla: 0361:     return _peekio()
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$78			; SAB	_A008+1
_F005 	!WORD	_A008+1		
	!BYTE	$54			; CALL	_A007
_F006 	!WORD	_A007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/uthernet2.pla: 0362: end
; libsrc/apple/uthernet2.pla: 0363: def peekiow(io)
					; io -> [0]
_C003 					; peekiow()
; libsrc/apple/uthernet2.pla: 0364:     _peekiowl.1 = io
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/apple/uthernet2.pla: 0365:     _peekiowh.1 = io+1
; libsrc/apple/uthernet2.pla: 0366:     return _peekiow()
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$78			; SAB	_A010+1
_F007 	!WORD	_A010+1		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$78			; SAB	_A011+1
_F008 	!WORD	_A011+1		
	!BYTE	$54			; CALL	_A009
_F009 	!WORD	_A009		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/uthernet2.pla: 0367: end
; libsrc/apple/uthernet2.pla: 0368: def pokereg(reg, data)#0
					; reg -> [0]
					; data -> [2]
_C004 					; pokereg()
; libsrc/apple/uthernet2.pla: 0369:     _pokeiow(reg)
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/apple/uthernet2.pla: 0370:     _pokeio(data)
; libsrc/apple/uthernet2.pla: 0371: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_A002
_F010 	!WORD	_A002		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_A005
_F011 	!WORD	_A005		
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/apple/uthernet2.pla: 0372: def peekreg(reg)
					; reg -> [0]
_C005 					; peekreg()
; libsrc/apple/uthernet2.pla: 0373:     _pokeiow(reg)
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/apple/uthernet2.pla: 0374:     return _peekio()
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_A002
_F012 	!WORD	_A002		
	!BYTE	$54			; CALL	_A007
_F013 	!WORD	_A007		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/uthernet2.pla: 0375: end
; libsrc/apple/uthernet2.pla: 0376: def pokeregs(reg, buf, len)#0
					; reg -> [0]
					; buf -> [2]
					; len -> [4]
_C006 					; pokeregs()
; libsrc/apple/uthernet2.pla: 0377:     _pokeiow(reg)
	!BYTE	$58,$06,$03		; ENTER	6,3
; libsrc/apple/uthernet2.pla: 0378:     pokedata(buf, len)
; libsrc/apple/uthernet2.pla: 0379: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_A002
_F014 	!WORD	_A002		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_A012
_F015 	!WORD	_A012		
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/apple/uthernet2.pla: 0380: def peekregs(reg, buf, len)#0
					; reg -> [0]
					; buf -> [2]
					; len -> [4]
_C007 					; peekregs()
; libsrc/apple/uthernet2.pla: 0381:     _pokeiow(reg)
	!BYTE	$58,$06,$03		; ENTER	6,3
; libsrc/apple/uthernet2.pla: 0382:     peekdata(buf, len)
; libsrc/apple/uthernet2.pla: 0383: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_A002
_F016 	!WORD	_A002		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_A014
_F017 	!WORD	_A014		
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/apple/uthernet2.pla: 0384: def pokeregw(reg, dataw)#0
					; reg -> [0]
					; dataw -> [2]
_C008 					; pokeregw()
; libsrc/apple/uthernet2.pla: 0385:     _pokeiow(reg)
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/apple/uthernet2.pla: 0386:     _pokeio(dataw.1)
; libsrc/apple/uthernet2.pla: 0387:     _pokeio(dataw.0)
; libsrc/apple/uthernet2.pla: 0388: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_A002
_F018 	!WORD	_A002		
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$54			; CALL	_A005
_F019 	!WORD	_A005		
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$54			; CALL	_A005
_F020 	!WORD	_A005		
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/apple/uthernet2.pla: 0389: def peekregw(reg)
					; reg -> [0]
_C009 					; peekregw()
; libsrc/apple/uthernet2.pla: 0390:     word dataw
					; dataw -> [2]
; libsrc/apple/uthernet2.pla: 0391: 
; libsrc/apple/uthernet2.pla: 0392:     _pokeiow(reg)
	!BYTE	$58,$04,$01		; ENTER	4,1
; libsrc/apple/uthernet2.pla: 0393:     dataw.1 = _peekio()
; libsrc/apple/uthernet2.pla: 0394:     _pokeiow(reg + 1)
; libsrc/apple/uthernet2.pla: 0395:     dataw.0 = _peekio()
; libsrc/apple/uthernet2.pla: 0396:     return dataw
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_A002
_F021 	!WORD	_A002		
	!BYTE	$54			; CALL	_A007
_F022 	!WORD	_A007		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_A002
_F023 	!WORD	_A002		
	!BYTE	$54			; CALL	_A007
_F024 	!WORD	_A007		
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/apple/uthernet2.pla: 0397: end
; libsrc/apple/uthernet2.pla: 0398: //
; libsrc/apple/uthernet2.pla: 0399: // Send UDP datagram
; libsrc/apple/uthernet2.pla: 0400: //
; libsrc/apple/uthernet2.pla: 0401: def wizSendUDP(wiz, ipdst, portdst, data, len)
					; wiz -> [0]
					; ipdst -> [2]
					; portdst -> [4]
					; data -> [6]
					; len -> [8]
_C010 					; wizSendUDP()
; libsrc/apple/uthernet2.pla: 0402:     word wizregs, wizdata, txrr, txwr, splitlen
					; wizregs -> [10]
					; wizdata -> [12]
					; txrr -> [14]
					; txwr -> [16]
					; splitlen -> [18]
; libsrc/apple/uthernet2.pla: 0403: 
; libsrc/apple/uthernet2.pla: 0404:     wizregs = wiz=>channel_regs
	!BYTE	$58,$14,$05		; ENTER	20,5
; libsrc/apple/uthernet2.pla: 0405:     wizdata = wiz=>channel_txmem
; libsrc/apple/uthernet2.pla: 0406:     if !ipdst
; libsrc/apple/uthernet2.pla: 0407:         ipdst = @bcast
; libsrc/apple/uthernet2.pla: 0408:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B001
	!WORD	_B001-*
	!BYTE	$26			; LA	_D039+0
_F025 	!WORD	_D039+0		
	!BYTE	$76,$02			; SLW	[2]
_B001 
_B002 
; libsrc/apple/uthernet2.pla: 0409:     //
; libsrc/apple/uthernet2.pla: 0410:     // Wait for Tx room
; libsrc/apple/uthernet2.pla: 0411:     //
; libsrc/apple/uthernet2.pla: 0412:     repeat; until peekregw(wizregs + WIZ_SnFSR) >= len
_B004 
_B005 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$20			; ADDI	32
	!BYTE	$54			; CALL	_C009
_F026 	!WORD	_C009		
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B004
	!WORD	_B004-*
_B003 
; libsrc/apple/uthernet2.pla: 0413:     //
; libsrc/apple/uthernet2.pla: 0414:     // Calc new write ptr, check for split
; libsrc/apple/uthernet2.pla: 0415:     //
; libsrc/apple/uthernet2.pla: 0416:     txwr = peekregw(wizregs + WIZ_SnTXWR)
; libsrc/apple/uthernet2.pla: 0417:     txrr = txwr & WIZ_TXMASK
; libsrc/apple/uthernet2.pla: 0418:     if txrr + len > WIZ_TXSIZE
; libsrc/apple/uthernet2.pla: 0419:         splitlen = WIZ_TXSIZE - txrr
; libsrc/apple/uthernet2.pla: 0420:         pokeregs(wizdata + txrr, data,            splitlen)
; libsrc/apple/uthernet2.pla: 0421:         pokeregs(wizdata,        data + splitlen, len - splitlen)
; libsrc/apple/uthernet2.pla: 0422:     else
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$24			; ADDI	36
	!BYTE	$54			; CALL	_C009
_F027 	!WORD	_C009		
	!BYTE	$6E,$10			; DLW	[16]
	!BYTE	$2C,$FF,$07		; CW	2047
	!BYTE	$94			; AND 
	!BYTE	$6E,$0E			; DLW	[14]
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B006
	!WORD	_B006-*
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$84			; SUB 
	!BYTE	$76,$12			; SLW	[18]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$B2,$0E			; ADDLW	[14]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$54			; CALL	_C006
_F028 	!WORD	_C006		
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$B2,$12			; ADDLW	[18]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_C006
_F029 	!WORD	_C006		
	!BYTE	$50			; BRNCH	_B007
	!WORD	_B007-*
_B006 
; libsrc/apple/uthernet2.pla: 0423:         pokeregs(wizdata + txrr, data, len)
; libsrc/apple/uthernet2.pla: 0424:     fin
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$B2,$0E			; ADDLW	[14]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$54			; CALL	_C006
_F030 	!WORD	_C006		
_B007 
; libsrc/apple/uthernet2.pla: 0425:     //
; libsrc/apple/uthernet2.pla: 0426:     // Set destination address/port
; libsrc/apple/uthernet2.pla: 0427:     //
; libsrc/apple/uthernet2.pla: 0428:     pokeregs(wizregs + WIZ_SnDIPR, ipdst, IP4ADR_SIZE)
; libsrc/apple/uthernet2.pla: 0429:     pokeregw(wizregs + WIZ_SnDPORT, portdst)
; libsrc/apple/uthernet2.pla: 0430:     //
; libsrc/apple/uthernet2.pla: 0431:     // Update write pointer and send
; libsrc/apple/uthernet2.pla: 0432:     //
; libsrc/apple/uthernet2.pla: 0433:     pokeregw(wizregs + WIZ_SnTXWR, txwr + len)
; libsrc/apple/uthernet2.pla: 0434:     pokereg(wizregs + WIZ_SnCR, $20) // SEND
; libsrc/apple/uthernet2.pla: 0435:     return 0
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_C006
_F031 	!WORD	_C006		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C008
_F032 	!WORD	_C008		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$24			; ADDI	36
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$54			; CALL	_C008
_F033 	!WORD	_C008		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C004
_F034 	!WORD	_C004		
	!BYTE	$00			; CN	0
	!BYTE	$5A,$14			; LEAVE	20
; libsrc/apple/uthernet2.pla: 0436: end
; libsrc/apple/uthernet2.pla: 0437: //
; libsrc/apple/uthernet2.pla: 0438: // Open UDP channel and set datagram received callback
; libsrc/apple/uthernet2.pla: 0439: //
; libsrc/apple/uthernet2.pla: 0440: def wizOpenUDP(localport, callback, param)
					; localport -> [0]
					; callback -> [2]
					; param -> [4]
_C011 					; wizOpenUDP()
; libsrc/apple/uthernet2.pla: 0441:     word wiz
					; wiz -> [6]
; libsrc/apple/uthernet2.pla: 0442:     byte i
					; i -> [8]
; libsrc/apple/uthernet2.pla: 0443: 
; libsrc/apple/uthernet2.pla: 0444:     if !localport; return -1; fin // invalid port
	!BYTE	$58,$09,$03		; ENTER	9,3
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B008
	!WORD	_B008-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$09			; LEAVE	9
_B008 
_B009 
; libsrc/apple/uthernet2.pla: 0445:     //
; libsrc/apple/uthernet2.pla: 0446:     // Look for an existing notification on localport
; libsrc/apple/uthernet2.pla: 0447:     //
; libsrc/apple/uthernet2.pla: 0448:     wiz = @wizChannel
; libsrc/apple/uthernet2.pla: 0449:     for i = 1 to MAX_WIZ_CHANNELS
	!BYTE	$26			; LA	_D040+0
_F035 	!WORD	_D040+0		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$08			; CN	4
	!BYTE	$02			; CN	1
_B011 
	!BYTE	$6C,$08			; DLB	[8]
; libsrc/apple/uthernet2.pla: 0450:         if wiz->channel_proto == IP_PROTO_UDP and wiz=>channel_lclport == localport
; libsrc/apple/uthernet2.pla: 0451:             break
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$60			; LB
	!BYTE	$2A,$11			; CB	17
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B013
	!WORD	_B013-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$40			; ISEQ
_B013 
	!BYTE	$4C			; BRFLS	_B014
	!WORD	_B014-*
	!BYTE	$50			; BRNCH	_B010
	!WORD	_B010-*
; libsrc/apple/uthernet2.pla: 0452:         fin
_B014 
_B015 
; libsrc/apple/uthernet2.pla: 0453:         wiz = wiz + t_channel
; libsrc/apple/uthernet2.pla: 0454:     next
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$14			; ADDI	20
	!BYTE	$76,$06			; SLW	[6]
_B012 
	!BYTE	$A4			; INCBRLE	_B011
	!WORD	_B011-*
_B010 
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$30			; DROP 
; libsrc/apple/uthernet2.pla: 0455:     if i > MAX_WIZ_CHANNELS
; libsrc/apple/uthernet2.pla: 0456:         //
; libsrc/apple/uthernet2.pla: 0457:         // Add notification on localport if room
; libsrc/apple/uthernet2.pla: 0458:         //
; libsrc/apple/uthernet2.pla: 0459:         wiz = @wizChannel
; libsrc/apple/uthernet2.pla: 0460:         for i = 1 to MAX_WIZ_CHANNELS
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$08			; CN	4
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B016
	!WORD	_B016-*
	!BYTE	$26			; LA	_D040+0
_F036 	!WORD	_D040+0		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$08			; CN	4
	!BYTE	$02			; CN	1
_B019 
	!BYTE	$6C,$08			; DLB	[8]
; libsrc/apple/uthernet2.pla: 0461:             if !wiz->channel_proto
; libsrc/apple/uthernet2.pla: 0462:                 break
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B021
	!WORD	_B021-*
	!BYTE	$50			; BRNCH	_B018
	!WORD	_B018-*
; libsrc/apple/uthernet2.pla: 0463:             fin
_B021 
_B022 
; libsrc/apple/uthernet2.pla: 0464:             wiz = wiz + t_channel
; libsrc/apple/uthernet2.pla: 0465:         next
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$14			; ADDI	20
	!BYTE	$76,$06			; SLW	[6]
_B020 
	!BYTE	$A4			; INCBRLE	_B019
	!WORD	_B019-*
_B018 
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$30			; DROP 
; libsrc/apple/uthernet2.pla: 0466:         if i > MAX_WIZ_CHANNELS
; libsrc/apple/uthernet2.pla: 0467:             return 0
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$08			; CN	4
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B023
	!WORD	_B023-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$09			; LEAVE	9
; libsrc/apple/uthernet2.pla: 0468:         fin
_B023 
_B024 
; libsrc/apple/uthernet2.pla: 0469:     fin
_B016 
_B017 
; libsrc/apple/uthernet2.pla: 0470:     //
; libsrc/apple/uthernet2.pla: 0471:     // Fill in this channel and open it
; libsrc/apple/uthernet2.pla: 0472:     //
; libsrc/apple/uthernet2.pla: 0473:     wiz->channel_proto     = WIZ_PROTO_UDP
; libsrc/apple/uthernet2.pla: 0474:     wiz=>channel_lclport   = localport
; libsrc/apple/uthernet2.pla: 0475:     wiz=>channel_recv_func = callback
; libsrc/apple/uthernet2.pla: 0476:     wiz=>channel_recv_parm = param
; libsrc/apple/uthernet2.pla: 0477:     pokereg(wiz=>channel_regs  + WIZ_SnMR,   $02) // UDP protocol
; libsrc/apple/uthernet2.pla: 0478:     pokeregw(wiz=>channel_regs + WIZ_SnPORT, localport)
; libsrc/apple/uthernet2.pla: 0479:     pokereg(wiz=>channel_regs  + WIZ_SnCR,   $01) // OPEN
; libsrc/apple/uthernet2.pla: 0480:     return wiz
	!BYTE	$04			; CN	2
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$12			; ADDI	18
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F037 	!WORD	_C004		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C008
_F038 	!WORD	_C008		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C004
_F039 	!WORD	_C004		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$5A,$09			; LEAVE	9
; libsrc/apple/uthernet2.pla: 0481: end
; libsrc/apple/uthernet2.pla: 0482: //
; libsrc/apple/uthernet2.pla: 0483: // Close UDP port
; libsrc/apple/uthernet2.pla: 0484: //
; libsrc/apple/uthernet2.pla: 0485: def wizCloseUDP(wiz)
					; wiz -> [0]
_C012 					; wizCloseUDP()
; libsrc/apple/uthernet2.pla: 0486:     if isuge(wiz, @wizChannel) and isult(wiz, @wizChannel + MAX_WIZ_CHANNELS * t_channel)
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/apple/uthernet2.pla: 0487:         //
; libsrc/apple/uthernet2.pla: 0488:         // Clear notiications on this port
; libsrc/apple/uthernet2.pla: 0489:         //
; libsrc/apple/uthernet2.pla: 0490:         if wiz->channel_proto == WIZ_PROTO_UDP
; libsrc/apple/uthernet2.pla: 0491:             wiz->channel_proto = WIZ_PROTO_CLOSED
; libsrc/apple/uthernet2.pla: 0492:             pokereg(wiz=>channel_regs + WIZ_SnCR, $10) // CLOSE
; libsrc/apple/uthernet2.pla: 0493:             return 0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D040+0
_F040 	!WORD	_D040+0		
	!BYTE	$54			; CALL	_X025
_F041 	!WORD	0		
	!BYTE	$AC			; BRAND	_B025
	!WORD	_B025-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D040+80
_F042 	!WORD	_D040+80		
	!BYTE	$54			; CALL	_X026
_F043 	!WORD	0		
_B025 
	!BYTE	$4C			; BRFLS	_B026
	!WORD	_B026-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$04			; CN	2
	!BYTE	$24			; BRNE	_B028
	!WORD	_B028-*
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$2A,$10			; CB	16
	!BYTE	$54			; CALL	_C004
_F044 	!WORD	_C004		
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/uthernet2.pla: 0494:         fin
_B028 
_B029 
; libsrc/apple/uthernet2.pla: 0495:     fin
_B026 
_B027 
; libsrc/apple/uthernet2.pla: 0496:     //
; libsrc/apple/uthernet2.pla: 0497:     // Invalid port
; libsrc/apple/uthernet2.pla: 0498:     //
; libsrc/apple/uthernet2.pla: 0499:     return -1
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/uthernet2.pla: 0500: end
; libsrc/apple/uthernet2.pla: 0501: //
; libsrc/apple/uthernet2.pla: 0502: // Open TCP socket in SERVER mode
; libsrc/apple/uthernet2.pla: 0503: //
; libsrc/apple/uthernet2.pla: 0504: def wizListenTCP(lclport, callback, param)
					; lclport -> [0]
					; callback -> [2]
					; param -> [4]
_C013 					; wizListenTCP()
; libsrc/apple/uthernet2.pla: 0505:     word wiz
					; wiz -> [6]
; libsrc/apple/uthernet2.pla: 0506:     byte i
					; i -> [8]
; libsrc/apple/uthernet2.pla: 0507: 
; libsrc/apple/uthernet2.pla: 0508:     //
; libsrc/apple/uthernet2.pla: 0509:     // Look for an existing notification on localport
; libsrc/apple/uthernet2.pla: 0510:     //
; libsrc/apple/uthernet2.pla: 0511:     wiz = @wizChannel
	!BYTE	$58,$09,$03		; ENTER	9,3
; libsrc/apple/uthernet2.pla: 0512:     for i = 1 to MAX_WIZ_CHANNELS
	!BYTE	$26			; LA	_D040+0
_F045 	!WORD	_D040+0		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$08			; CN	4
	!BYTE	$02			; CN	1
_B031 
	!BYTE	$6C,$08			; DLB	[8]
; libsrc/apple/uthernet2.pla: 0513:         if wiz->channel_proto == WIZ_PROTO_TCP and wiz->channel_state == TCP_STATE_LISTEN and wiz=>channel_lclport == lclport
; libsrc/apple/uthernet2.pla: 0514:             break
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B033
	!WORD	_B033-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$04			; CN	2
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B034
	!WORD	_B034-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$40			; ISEQ
_B034 
_B033 
	!BYTE	$4C			; BRFLS	_B035
	!WORD	_B035-*
	!BYTE	$50			; BRNCH	_B030
	!WORD	_B030-*
; libsrc/apple/uthernet2.pla: 0515:         fin
_B035 
_B036 
; libsrc/apple/uthernet2.pla: 0516:         wiz = wiz + t_channel
; libsrc/apple/uthernet2.pla: 0517:     next
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$14			; ADDI	20
	!BYTE	$76,$06			; SLW	[6]
_B032 
	!BYTE	$A4			; INCBRLE	_B031
	!WORD	_B031-*
_B030 
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$30			; DROP 
; libsrc/apple/uthernet2.pla: 0518:     if i > MAX_WIZ_CHANNELS
; libsrc/apple/uthernet2.pla: 0519:         //
; libsrc/apple/uthernet2.pla: 0520:         // Add notification on localport if room
; libsrc/apple/uthernet2.pla: 0521:         //
; libsrc/apple/uthernet2.pla: 0522:         wiz = @wizChannel
; libsrc/apple/uthernet2.pla: 0523:         for i = 1 to MAX_WIZ_CHANNELS
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$08			; CN	4
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B037
	!WORD	_B037-*
	!BYTE	$26			; LA	_D040+0
_F046 	!WORD	_D040+0		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$08			; CN	4
	!BYTE	$02			; CN	1
_B040 
	!BYTE	$6C,$08			; DLB	[8]
; libsrc/apple/uthernet2.pla: 0524:             if !wiz->channel_proto
; libsrc/apple/uthernet2.pla: 0525:                 break
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B042
	!WORD	_B042-*
	!BYTE	$50			; BRNCH	_B039
	!WORD	_B039-*
; libsrc/apple/uthernet2.pla: 0526:             fin
_B042 
_B043 
; libsrc/apple/uthernet2.pla: 0527:             wiz = wiz + t_channel
; libsrc/apple/uthernet2.pla: 0528:         next
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$14			; ADDI	20
	!BYTE	$76,$06			; SLW	[6]
_B041 
	!BYTE	$A4			; INCBRLE	_B040
	!WORD	_B040-*
_B039 
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$30			; DROP 
; libsrc/apple/uthernet2.pla: 0529:         if i > MAX_WIZ_CHANNELS
; libsrc/apple/uthernet2.pla: 0530:             return 0
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$08			; CN	4
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B044
	!WORD	_B044-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$09			; LEAVE	9
; libsrc/apple/uthernet2.pla: 0531:         fin
_B044 
_B045 
; libsrc/apple/uthernet2.pla: 0532:     fin
_B037 
_B038 
; libsrc/apple/uthernet2.pla: 0533:     //
; libsrc/apple/uthernet2.pla: 0534:     // Fill in this channel and open it
; libsrc/apple/uthernet2.pla: 0535:     //
; libsrc/apple/uthernet2.pla: 0536:     wiz->channel_proto     = WIZ_PROTO_TCP
; libsrc/apple/uthernet2.pla: 0537:     wiz->channel_state     = TCP_STATE_LISTEN
; libsrc/apple/uthernet2.pla: 0538:     wiz=>channel_remip:0   = 0
; libsrc/apple/uthernet2.pla: 0539:     wiz=>channel_remip:2   = 0
; libsrc/apple/uthernet2.pla: 0540:     wiz=>channel_remport   = 0
; libsrc/apple/uthernet2.pla: 0541:     wiz=>channel_lclport   = lclport
; libsrc/apple/uthernet2.pla: 0542:     wiz=>channel_recv_func = callback
; libsrc/apple/uthernet2.pla: 0543:     wiz=>channel_recv_parm = param
; libsrc/apple/uthernet2.pla: 0544:     pokereg(wiz=>channel_regs  + WIZ_SnMR,   $01) // TCP protocol
; libsrc/apple/uthernet2.pla: 0545:     pokeregw(wiz=>channel_regs + WIZ_SnPORT, lclport)
; libsrc/apple/uthernet2.pla: 0546:     pokereg(wiz=>channel_regs  + WIZ_SnCR,   $01) // OPEN
; libsrc/apple/uthernet2.pla: 0547:     while peekreg(wiz=>channel_regs + WIZ_SnSR) <> $13; loop // Wait for init
	!BYTE	$02			; CN	1
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$70			; SB
	!BYTE	$04			; CN	2
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$0A			; ADDI	10
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$12			; ADDI	18
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C004
_F047 	!WORD	_C004		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C008
_F048 	!WORD	_C008		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C004
_F049 	!WORD	_C004		
	!BYTE	$50			; BRNCH	_B048
	!WORD	_B048-*
_B046 
_B048 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_C005
_F050 	!WORD	_C005		
	!BYTE	$2A,$13			; CB	19
	!BYTE	$24			; BRNE	_B046
	!WORD	_B046-*
_B047 
; libsrc/apple/uthernet2.pla: 0548:     pokereg(wiz=>channel_regs + WIZ_SnCR, $02) // LISTEN
; libsrc/apple/uthernet2.pla: 0549:     return wiz
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F051 	!WORD	_C004		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$5A,$09			; LEAVE	9
; libsrc/apple/uthernet2.pla: 0550: end
; libsrc/apple/uthernet2.pla: 0551: //
; libsrc/apple/uthernet2.pla: 0552: // Open TCP socket in CLIENT mode
; libsrc/apple/uthernet2.pla: 0553: //
; libsrc/apple/uthernet2.pla: 0554: def wizConnectTCP(remip, remport, lclport, callback, param)
					; remip -> [0]
					; remport -> [2]
					; lclport -> [4]
					; callback -> [6]
					; param -> [8]
_C014 					; wizConnectTCP()
; libsrc/apple/uthernet2.pla: 0555:     word wiz
					; wiz -> [10]
; libsrc/apple/uthernet2.pla: 0556:     byte i
					; i -> [12]
; libsrc/apple/uthernet2.pla: 0557: 
; libsrc/apple/uthernet2.pla: 0558:     //
; libsrc/apple/uthernet2.pla: 0559:     // Look for an existing notification on localport
; libsrc/apple/uthernet2.pla: 0560:     //
; libsrc/apple/uthernet2.pla: 0561:     wiz = @wizChannel
	!BYTE	$58,$0D,$05		; ENTER	13,5
; libsrc/apple/uthernet2.pla: 0562:     for i = 1 to MAX_WIZ_CHANNELS
	!BYTE	$26			; LA	_D040+0
_F052 	!WORD	_D040+0		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$08			; CN	4
	!BYTE	$02			; CN	1
_B050 
	!BYTE	$6C,$0C			; DLB	[12]
; libsrc/apple/uthernet2.pla: 0563:         if wiz->channel_proto == WIZ_PROTO_TCP and wiz->channel_state == TCP_STATE_CONNECT and wiz=>channel_lclport == lclport
; libsrc/apple/uthernet2.pla: 0564:             break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B052
	!WORD	_B052-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$06			; CN	3
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B053
	!WORD	_B053-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$40			; ISEQ
_B053 
_B052 
	!BYTE	$4C			; BRFLS	_B054
	!WORD	_B054-*
	!BYTE	$50			; BRNCH	_B049
	!WORD	_B049-*
; libsrc/apple/uthernet2.pla: 0565:         fin
_B054 
_B055 
; libsrc/apple/uthernet2.pla: 0566:         wiz = wiz + t_channel
; libsrc/apple/uthernet2.pla: 0567:     next
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$14			; ADDI	20
	!BYTE	$76,$0A			; SLW	[10]
_B051 
	!BYTE	$A4			; INCBRLE	_B050
	!WORD	_B050-*
_B049 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; libsrc/apple/uthernet2.pla: 0568:     if i > MAX_WIZ_CHANNELS
; libsrc/apple/uthernet2.pla: 0569:         //
; libsrc/apple/uthernet2.pla: 0570:         // Add notification on localport if room
; libsrc/apple/uthernet2.pla: 0571:         //
; libsrc/apple/uthernet2.pla: 0572:         wiz = @wizChannel
; libsrc/apple/uthernet2.pla: 0573:         for i = 1 to MAX_WIZ_CHANNELS
	!BYTE	$64,$0C			; LLB	[12]
	!BYTE	$08			; CN	4
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B056
	!WORD	_B056-*
	!BYTE	$26			; LA	_D040+0
_F053 	!WORD	_D040+0		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$08			; CN	4
	!BYTE	$02			; CN	1
_B059 
	!BYTE	$6C,$0C			; DLB	[12]
; libsrc/apple/uthernet2.pla: 0574:             if !wiz->channel_proto
; libsrc/apple/uthernet2.pla: 0575:                 break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B061
	!WORD	_B061-*
	!BYTE	$50			; BRNCH	_B058
	!WORD	_B058-*
; libsrc/apple/uthernet2.pla: 0576:             fin
_B061 
_B062 
; libsrc/apple/uthernet2.pla: 0577:             wiz = wiz + t_channel
; libsrc/apple/uthernet2.pla: 0578:         next
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$14			; ADDI	20
	!BYTE	$76,$0A			; SLW	[10]
_B060 
	!BYTE	$A4			; INCBRLE	_B059
	!WORD	_B059-*
_B058 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; libsrc/apple/uthernet2.pla: 0579:         if i > MAX_WIZ_CHANNELS
; libsrc/apple/uthernet2.pla: 0580:             return 0
	!BYTE	$64,$0C			; LLB	[12]
	!BYTE	$08			; CN	4
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B063
	!WORD	_B063-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$0D			; LEAVE	13
; libsrc/apple/uthernet2.pla: 0581:         fin
_B063 
_B064 
; libsrc/apple/uthernet2.pla: 0582:     fin
_B056 
_B057 
; libsrc/apple/uthernet2.pla: 0583:     //
; libsrc/apple/uthernet2.pla: 0584:     // Fill in this channel and open it
; libsrc/apple/uthernet2.pla: 0585:     //
; libsrc/apple/uthernet2.pla: 0586:     wiz->channel_proto     = WIZ_PROTO_TCP
; libsrc/apple/uthernet2.pla: 0587:     wiz->channel_state     = TCP_STATE_CONNECT
; libsrc/apple/uthernet2.pla: 0588:     wiz=>channel_remip:0   = remip=>0
; libsrc/apple/uthernet2.pla: 0589:     wiz=>channel_remip:2   = remip=>2
; libsrc/apple/uthernet2.pla: 0590:     wiz=>channel_remport   = remport
; libsrc/apple/uthernet2.pla: 0591:     wiz=>channel_lclport   = lclport
; libsrc/apple/uthernet2.pla: 0592:     wiz=>channel_recv_func = callback
; libsrc/apple/uthernet2.pla: 0593:     wiz=>channel_recv_parm = param
; libsrc/apple/uthernet2.pla: 0594:     pokereg(wiz=>channel_regs + WIZ_SnMR, $01) // TCP protocol
; libsrc/apple/uthernet2.pla: 0595:     pokeregs(wiz=>channel_regs + WIZ_SnDIPR, remip, IP4ADR_SIZE)
; libsrc/apple/uthernet2.pla: 0596:     pokeregw(wiz=>channel_regs + WIZ_SnDPORT, remport)
; libsrc/apple/uthernet2.pla: 0597:     pokeregw(wiz=>channel_regs + WIZ_SnPORT, lclport)
; libsrc/apple/uthernet2.pla: 0598:     pokereg(wiz=>channel_regs + WIZ_SnCR, $01) // OPEN
; libsrc/apple/uthernet2.pla: 0599:     while peekreg(wiz=>channel_regs + WIZ_SnSR) <> $13; loop // Wait for init
	!BYTE	$02			; CN	1
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$06			; CN	3
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$0A			; ADDI	10
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$72			; SW
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$12			; ADDI	18
	!BYTE	$72			; SW
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C004
_F054 	!WORD	_C004		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_C006
_F055 	!WORD	_C006		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C008
_F056 	!WORD	_C008		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C008
_F057 	!WORD	_C008		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C004
_F058 	!WORD	_C004		
	!BYTE	$50			; BRNCH	_B067
	!WORD	_B067-*
_B065 
_B067 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_C005
_F059 	!WORD	_C005		
	!BYTE	$2A,$13			; CB	19
	!BYTE	$24			; BRNE	_B065
	!WORD	_B065-*
_B066 
; libsrc/apple/uthernet2.pla: 0600:     pokereg(wiz=>channel_regs + WIZ_SnCR, $04) // CONNECT
; libsrc/apple/uthernet2.pla: 0601:     return wiz
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_C004
_F060 	!WORD	_C004		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$5A,$0D			; LEAVE	13
; libsrc/apple/uthernet2.pla: 0602: end
; libsrc/apple/uthernet2.pla: 0603: //
; libsrc/apple/uthernet2.pla: 0604: // Write to TCP socket
; libsrc/apple/uthernet2.pla: 0605: //
; libsrc/apple/uthernet2.pla: 0606: def wizSendTCP(wiz, data, len)
					; wiz -> [0]
					; data -> [2]
					; len -> [4]
_C015 					; wizSendTCP()
; libsrc/apple/uthernet2.pla: 0607:     word wizregs, wizdata, txrr, txwr, splitlen
					; wizregs -> [6]
					; wizdata -> [8]
					; txrr -> [10]
					; txwr -> [12]
					; splitlen -> [14]
; libsrc/apple/uthernet2.pla: 0608: 
; libsrc/apple/uthernet2.pla: 0609:     if wiz->channel_state <> TCP_STATE_OPEN; return -1; fin
	!BYTE	$58,$10,$03		; ENTER	16,3
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$08			; CN	4
	!BYTE	$22			; BREQ	_B068
	!WORD	_B068-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$10			; LEAVE	16
_B068 
_B069 
; libsrc/apple/uthernet2.pla: 0610:     wizregs = wiz=>channel_regs
; libsrc/apple/uthernet2.pla: 0611:     wizdata = wiz=>channel_txmem
; libsrc/apple/uthernet2.pla: 0612:     //
; libsrc/apple/uthernet2.pla: 0613:     // Wait for Tx room
; libsrc/apple/uthernet2.pla: 0614:     //
; libsrc/apple/uthernet2.pla: 0615:     repeat; until peekregw(wizregs + WIZ_SnFSR) >= len
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
_B071 
_B072 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$20			; ADDI	32
	!BYTE	$54			; CALL	_C009
_F061 	!WORD	_C009		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B071
	!WORD	_B071-*
_B070 
; libsrc/apple/uthernet2.pla: 0616:     //
; libsrc/apple/uthernet2.pla: 0617:     // Calc new write ptr, check for split
; libsrc/apple/uthernet2.pla: 0618:     //
; libsrc/apple/uthernet2.pla: 0619:     txwr = peekregw(wizregs + WIZ_SnTXWR)
; libsrc/apple/uthernet2.pla: 0620:     txrr = txwr & WIZ_TXMASK
; libsrc/apple/uthernet2.pla: 0621:     if txrr + len > WIZ_TXSIZE
; libsrc/apple/uthernet2.pla: 0622:         splitlen = WIZ_TXSIZE - txrr
; libsrc/apple/uthernet2.pla: 0623:         pokeregs(wizdata + txrr, data,            splitlen)
; libsrc/apple/uthernet2.pla: 0624:         pokeregs(wizdata,        data + splitlen, len - splitlen)
; libsrc/apple/uthernet2.pla: 0625:         //putc('(');puti(splitlen);putc(',');puti(len-splitlen);putc(')')
; libsrc/apple/uthernet2.pla: 0626:     else
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$24			; ADDI	36
	!BYTE	$54			; CALL	_C009
_F062 	!WORD	_C009		
	!BYTE	$6E,$0C			; DLW	[12]
	!BYTE	$2C,$FF,$07		; CW	2047
	!BYTE	$94			; AND 
	!BYTE	$6E,$0A			; DLW	[10]
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B073
	!WORD	_B073-*
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$84			; SUB 
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$54			; CALL	_C006
_F063 	!WORD	_C006		
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B2,$0E			; ADDLW	[14]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_C006
_F064 	!WORD	_C006		
	!BYTE	$50			; BRNCH	_B074
	!WORD	_B074-*
_B073 
; libsrc/apple/uthernet2.pla: 0627:         pokeregs(wizdata + txrr, data, len)
; libsrc/apple/uthernet2.pla: 0628:     fin
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C006
_F065 	!WORD	_C006		
_B074 
; libsrc/apple/uthernet2.pla: 0629:     //
; libsrc/apple/uthernet2.pla: 0630:     // Update write pointer and send
; libsrc/apple/uthernet2.pla: 0631:     //
; libsrc/apple/uthernet2.pla: 0632:     pokeregw(wizregs + WIZ_SnTXWR, txwr + len)
; libsrc/apple/uthernet2.pla: 0633:     pokereg(wizregs + WIZ_SnCR, $20) // SEND
; libsrc/apple/uthernet2.pla: 0634:     return wiz
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$24			; ADDI	36
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$54			; CALL	_C008
_F066 	!WORD	_C008		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8C			; INCR
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C004
_F067 	!WORD	_C004		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$10			; LEAVE	16
; libsrc/apple/uthernet2.pla: 0635: end
; libsrc/apple/uthernet2.pla: 0636: //
; libsrc/apple/uthernet2.pla: 0637: // Close TCP socket
; libsrc/apple/uthernet2.pla: 0638: //
; libsrc/apple/uthernet2.pla: 0639: def wizCloseTCP(wiz)
					; wiz -> [0]
_C016 					; wizCloseTCP()
; libsrc/apple/uthernet2.pla: 0640:     if isuge(wiz, @wizChannel) and isult(wiz, @wizChannel + MAX_WIZ_CHANNELS * t_channel)
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/apple/uthernet2.pla: 0641:         //
; libsrc/apple/uthernet2.pla: 0642:         // Clear notiications on this port
; libsrc/apple/uthernet2.pla: 0643:         //
; libsrc/apple/uthernet2.pla: 0644:         if wiz->channel_proto == WIZ_PROTO_TCP
; libsrc/apple/uthernet2.pla: 0645:             pokereg(wiz=>channel_regs + WIZ_SnCR, $10) // CLOSE
; libsrc/apple/uthernet2.pla: 0646:             wiz->channel_proto = WIZ_PROTO_CLOSED
; libsrc/apple/uthernet2.pla: 0647:             return 0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D040+0
_F068 	!WORD	_D040+0		
	!BYTE	$54			; CALL	_X025
_F069 	!WORD	0		
	!BYTE	$AC			; BRAND	_B075
	!WORD	_B075-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D040+80
_F070 	!WORD	_D040+80		
	!BYTE	$54			; CALL	_X026
_F071 	!WORD	0		
_B075 
	!BYTE	$4C			; BRFLS	_B076
	!WORD	_B076-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$24			; BRNE	_B078
	!WORD	_B078-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$2A,$10			; CB	16
	!BYTE	$54			; CALL	_C004
_F072 	!WORD	_C004		
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/uthernet2.pla: 0648:         fin
_B078 
_B079 
; libsrc/apple/uthernet2.pla: 0649:     fin
_B076 
_B077 
; libsrc/apple/uthernet2.pla: 0650:     //
; libsrc/apple/uthernet2.pla: 0651:     // Invalid port
; libsrc/apple/uthernet2.pla: 0652:     //
; libsrc/apple/uthernet2.pla: 0653:     return -1
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/uthernet2.pla: 0654: end
; libsrc/apple/uthernet2.pla: 0655: //
; libsrc/apple/uthernet2.pla: 0656: // Update notify callback
; libsrc/apple/uthernet2.pla: 0657: //
; libsrc/apple/uthernet2.pla: 0658: def wizSetCallback(wiz, callback)
					; wiz -> [0]
					; callback -> [2]
_C017 					; wizSetCallback()
; libsrc/apple/uthernet2.pla: 0659:     if wiz->channel_proto == WIZ_PROTO_UDP or wiz->channel_proto == WIZ_PROTO_TCP
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/apple/uthernet2.pla: 0660:         //
; libsrc/apple/uthernet2.pla: 0661:         // Update callback on this port
; libsrc/apple/uthernet2.pla: 0662:         //
; libsrc/apple/uthernet2.pla: 0663:         wiz=>channel_recv_func = callback
; libsrc/apple/uthernet2.pla: 0664:         return 0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$04			; CN	2
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B080
	!WORD	_B080-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$40			; ISEQ
_B080 
	!BYTE	$4C			; BRFLS	_B081
	!WORD	_B081-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/apple/uthernet2.pla: 0665:     fin
_B081 
_B082 
; libsrc/apple/uthernet2.pla: 0666:     //
; libsrc/apple/uthernet2.pla: 0667:     // Invalid port
; libsrc/apple/uthernet2.pla: 0668:     //
; libsrc/apple/uthernet2.pla: 0669:     return -1
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/apple/uthernet2.pla: 0670: end
; libsrc/apple/uthernet2.pla: 0671: //
; libsrc/apple/uthernet2.pla: 0672: // Update notify param
; libsrc/apple/uthernet2.pla: 0673: //
; libsrc/apple/uthernet2.pla: 0674: def wizSetParam(wiz, param)
					; wiz -> [0]
					; param -> [2]
_C018 					; wizSetParam()
; libsrc/apple/uthernet2.pla: 0675:     if wiz->channel_proto == WIZ_PROTO_UDP or wiz->channel_proto == WIZ_PROTO_TCP
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/apple/uthernet2.pla: 0676:         //
; libsrc/apple/uthernet2.pla: 0677:         // Update param on this port
; libsrc/apple/uthernet2.pla: 0678:         //
; libsrc/apple/uthernet2.pla: 0679:         wiz=>channel_recv_parm = param
; libsrc/apple/uthernet2.pla: 0680:         return 0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$04			; CN	2
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B083
	!WORD	_B083-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$40			; ISEQ
_B083 
	!BYTE	$4C			; BRFLS	_B084
	!WORD	_B084-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$12			; ADDI	18
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/apple/uthernet2.pla: 0681:     fin
_B084 
_B085 
; libsrc/apple/uthernet2.pla: 0682:     //
; libsrc/apple/uthernet2.pla: 0683:     // Invalid port
; libsrc/apple/uthernet2.pla: 0684:     //
; libsrc/apple/uthernet2.pla: 0685:     return -1
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/apple/uthernet2.pla: 0686: end
; libsrc/apple/uthernet2.pla: 0687: //
; libsrc/apple/uthernet2.pla: 0688: // Service incoming packets
; libsrc/apple/uthernet2.pla: 0689: //
; libsrc/apple/uthernet2.pla: 0690: def wizServiceIP
_P000 					; wizServiceIP()
_C019 					; wizServiceIP()
; libsrc/apple/uthernet2.pla: 0691:     word wiz, wizregs, wizdata, rxlen, rxrr, rxwr, rxpkt, splitlen
					; wiz -> [0]
					; wizregs -> [2]
					; wizdata -> [4]
					; rxlen -> [6]
					; rxrr -> [8]
					; rxwr -> [10]
					; rxpkt -> [12]
					; splitlen -> [14]
; libsrc/apple/uthernet2.pla: 0692:     byte ir, i, sir
					; ir -> [16]
					; i -> [17]
					; sir -> [18]
; libsrc/apple/uthernet2.pla: 0693: 
; libsrc/apple/uthernet2.pla: 0694:     ir = peekreg(WIZ_IR)
	!BYTE	$58,$13,$00		; ENTER	19,0
; libsrc/apple/uthernet2.pla: 0695:     if ir
; libsrc/apple/uthernet2.pla: 0696:         wiz = @wizChannel
; libsrc/apple/uthernet2.pla: 0697:         for i = 0 to 3
	!BYTE	$2A,$15			; CB	21
	!BYTE	$54			; CALL	_C005
_F073 	!WORD	_C005		
	!BYTE	$6C,$10			; DLB	[16]
	!BYTE	$4C			; BRFLS	_B086
	!WORD	_B086-*
	!BYTE	$26			; LA	_D040+0
_F074 	!WORD	_D040+0		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$06			; CN	3
	!BYTE	$00			; CN	0
_B089 
	!BYTE	$6C,$11			; DLB	[17]
; libsrc/apple/uthernet2.pla: 0698:             //
; libsrc/apple/uthernet2.pla: 0699:             // Socket activity
; libsrc/apple/uthernet2.pla: 0700:             //
; libsrc/apple/uthernet2.pla: 0701:             if ir & (1 << i)
; libsrc/apple/uthernet2.pla: 0702:                 wizregs = wiz=>channel_regs
; libsrc/apple/uthernet2.pla: 0703:                 wizdata = wiz=>channel_rxmem
; libsrc/apple/uthernet2.pla: 0704:                 sir = peekreg(wizregs + WIZ_SnIR)
; libsrc/apple/uthernet2.pla: 0705:                 pokereg(wizregs + WIZ_SnIR, sir) // Clear SnIR
; libsrc/apple/uthernet2.pla: 0706:                 when wiz->channel_proto
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$02			; CN	1
	!BYTE	$64,$11			; LLB	[17]
	!BYTE	$9A			; SHL
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B091
	!WORD	_B091-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$54			; CALL	_C005
_F075 	!WORD	_C005		
	!BYTE	$74,$12			; SLB	[18]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$64,$12			; LLB	[18]
	!BYTE	$54			; CALL	_C004
_F076 	!WORD	_C004		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B094-*
; libsrc/apple/uthernet2.pla: 0707:                     is WIZ_PROTO_UDP
_B095 
; libsrc/apple/uthernet2.pla: 0708:                         if sir & $04
; libsrc/apple/uthernet2.pla: 0709:                             //
; libsrc/apple/uthernet2.pla: 0710:                             // Receive UDP packet
; libsrc/apple/uthernet2.pla: 0711:                             //
; libsrc/apple/uthernet2.pla: 0712:                             rxlen = peekregw(wizregs + WIZ_SnRSR)
; libsrc/apple/uthernet2.pla: 0713:                             rxrr  = peekregw(wizregs + WIZ_SnRXRD)
; libsrc/apple/uthernet2.pla: 0714:                             rxwr  = rxrr & WIZ_RXMASK
; libsrc/apple/uthernet2.pla: 0715:                             rxpkt = heapalloc(rxlen)
; libsrc/apple/uthernet2.pla: 0716:                             if rxwr + rxlen >= WIZ_RXSIZE
; libsrc/apple/uthernet2.pla: 0717:                                 splitlen = WIZ_RXSIZE - rxwr
; libsrc/apple/uthernet2.pla: 0718:                                 peekregs(wizdata + rxwr, rxpkt,            splitlen)
; libsrc/apple/uthernet2.pla: 0719:                                 peekregs(wizdata,        rxpkt + splitlen, rxlen - splitlen)
; libsrc/apple/uthernet2.pla: 0720:                             else
	!BYTE	$64,$12			; LLB	[18]
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B096
	!WORD	_B096-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$26			; ADDI	38
	!BYTE	$54			; CALL	_C009
_F077 	!WORD	_C009		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$28			; ADDI	40
	!BYTE	$54			; CALL	_C009
_F078 	!WORD	_C009		
	!BYTE	$6E,$08			; DLW	[8]
	!BYTE	$2C,$FF,$07		; CW	2047
	!BYTE	$94			; AND 
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_X014
_F079 	!WORD	0		
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B098
	!WORD	_B098-*
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$84			; SUB 
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$54			; CALL	_C007
_F080 	!WORD	_C007		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$B2,$0E			; ADDLW	[14]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_C007
_F081 	!WORD	_C007		
	!BYTE	$50			; BRNCH	_B099
	!WORD	_B099-*
_B098 
; libsrc/apple/uthernet2.pla: 0721:                                 peekregs(wizdata + rxwr, rxpkt, rxlen)
; libsrc/apple/uthernet2.pla: 0722:                             fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C007
_F082 	!WORD	_C007		
_B099 
; libsrc/apple/uthernet2.pla: 0723:                             pokeregw(wizregs + WIZ_SnRXRD, rxrr + rxlen)
; libsrc/apple/uthernet2.pla: 0724:                             pokereg(wizregs + WIZ_SnCR, $40) // RECV
; libsrc/apple/uthernet2.pla: 0725:                             wiz=>channel_recv_func(rxpkt,swab(rxpkt=>4),rxpkt+8,rxlen-8,wiz=>channel_recv_parm)
; libsrc/apple/uthernet2.pla: 0726:                             heaprelease(rxpkt)
; libsrc/apple/uthernet2.pla: 0727:                         fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$28			; ADDI	40
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$54			; CALL	_C008
_F083 	!WORD	_C008		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$2A,$40			; CB	64
	!BYTE	$54			; CALL	_C004
_F084 	!WORD	_C004		
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$34			; DUP
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_A001
_F085 	!WORD	_A001		
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$3A,$08			; SUBI	8
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$12			; ADDI	18
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$62			; LW
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$54			; CALL	_X015
_F086 	!WORD	0		
	!BYTE	$30			; DROP 
_B096 
_B097 
; libsrc/apple/uthernet2.pla: 0728:                         break
	!BYTE	$50			; BRNCH	_B093
	!WORD	_B093-*
; libsrc/apple/uthernet2.pla: 0729:                     is WIZ_PROTO_TCP
_B100 
; libsrc/apple/uthernet2.pla: 0730:                         if sir & $01
; libsrc/apple/uthernet2.pla: 0731:                             //
; libsrc/apple/uthernet2.pla: 0732:                             // Connect TCP socket
; libsrc/apple/uthernet2.pla: 0733:                             //
; libsrc/apple/uthernet2.pla: 0734:                             when wiz->channel_state
	!BYTE	$64,$12			; LLB	[18]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B101
	!WORD	_B101-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B104-*
; libsrc/apple/uthernet2.pla: 0735:                                 is TCP_STATE_LISTEN
_B105 
; libsrc/apple/uthernet2.pla: 0736:                                     peekregs(wiz=>channel_regs + WIZ_SnDIPR, @wiz=>channel_remip, IP4ADR_SIZE)
; libsrc/apple/uthernet2.pla: 0737:                                     wiz=>channel_remport = peekregw(wiz=>channel_regs + WIZ_SnDPORT)
; libsrc/apple/uthernet2.pla: 0738:                                 is TCP_STATE_CONNECT
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_C007
_F087 	!WORD	_C007		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$54			; CALL	_C009
_F088 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$0A			; ADDI	10
	!BYTE	$72			; SW
_B106 
; libsrc/apple/uthernet2.pla: 0739:                                     wiz->channel_state = TCP_STATE_OPEN
; libsrc/apple/uthernet2.pla: 0740:                             wend
	!BYTE	$08			; CN	4
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B103
	!WORD	_B103-*
_B104 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0002
	!WORD	_B105-*
	!WORD	$0003
	!WORD	_B106-*
_B103 
; libsrc/apple/uthernet2.pla: 0741:                         fin
_B101 
_B102 
; libsrc/apple/uthernet2.pla: 0742:                         if sir & $04
; libsrc/apple/uthernet2.pla: 0743:                             //
; libsrc/apple/uthernet2.pla: 0744:                             // Receive TCP packet
; libsrc/apple/uthernet2.pla: 0745:                             //
; libsrc/apple/uthernet2.pla: 0746:                             if wiz->channel_state == TCP_STATE_OPEN
; libsrc/apple/uthernet2.pla: 0747:                                 rxlen = peekregw(wizregs + WIZ_SnRSR)
; libsrc/apple/uthernet2.pla: 0748:                                 rxrr  = peekregw(wizregs + WIZ_SnRXRD)
; libsrc/apple/uthernet2.pla: 0749:                                 rxwr  = rxrr & WIZ_RXMASK
; libsrc/apple/uthernet2.pla: 0750:                                 rxpkt = heapalloc(rxlen)
; libsrc/apple/uthernet2.pla: 0751:                                 if rxwr + rxlen > WIZ_RXSIZE
; libsrc/apple/uthernet2.pla: 0752:                                     splitlen = WIZ_RXSIZE - rxwr
; libsrc/apple/uthernet2.pla: 0753:                                     peekregs(wizdata + rxwr, rxpkt,            splitlen)
; libsrc/apple/uthernet2.pla: 0754:                                     peekregs(wizdata,        rxpkt + splitlen, rxlen - splitlen)
; libsrc/apple/uthernet2.pla: 0755:                                 else
	!BYTE	$64,$12			; LLB	[18]
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B107
	!WORD	_B107-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$08			; CN	4
	!BYTE	$24			; BRNE	_B109
	!WORD	_B109-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$26			; ADDI	38
	!BYTE	$54			; CALL	_C009
_F089 	!WORD	_C009		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$28			; ADDI	40
	!BYTE	$54			; CALL	_C009
_F090 	!WORD	_C009		
	!BYTE	$6E,$08			; DLW	[8]
	!BYTE	$2C,$FF,$07		; CW	2047
	!BYTE	$94			; AND 
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_X014
_F091 	!WORD	0		
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B111
	!WORD	_B111-*
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$84			; SUB 
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$54			; CALL	_C007
_F092 	!WORD	_C007		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$B2,$0E			; ADDLW	[14]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_C007
_F093 	!WORD	_C007		
	!BYTE	$50			; BRNCH	_B112
	!WORD	_B112-*
_B111 
; libsrc/apple/uthernet2.pla: 0756:                                     peekregs(wizdata + rxwr, rxpkt, rxlen)
; libsrc/apple/uthernet2.pla: 0757:                                 fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C007
_F094 	!WORD	_C007		
_B112 
; libsrc/apple/uthernet2.pla: 0758:                                 pokeregw(wizregs + WIZ_SnRXRD, rxrr + rxlen)
; libsrc/apple/uthernet2.pla: 0759:                                 pokereg(wizregs + WIZ_SnCR, $40) // RECV
; libsrc/apple/uthernet2.pla: 0760:                                 wiz=>channel_recv_func(@wiz=>channel_remip,wiz=>channel_remport,wiz=>channel_lclport,rxpkt,rxlen,wiz=>channel_recv_parm)
; libsrc/apple/uthernet2.pla: 0761:                                 heaprelease(rxpkt)
; libsrc/apple/uthernet2.pla: 0762:                             fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$28			; ADDI	40
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$54			; CALL	_C008
_F095 	!WORD	_C008		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$2A,$40			; CB	64
	!BYTE	$54			; CALL	_C004
_F096 	!WORD	_C004		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$0A			; ADDI	10
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$62			; LW
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$12			; ADDI	18
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$62			; LW
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$54			; CALL	_X015
_F097 	!WORD	0		
	!BYTE	$30			; DROP 
_B109 
_B110 
; libsrc/apple/uthernet2.pla: 0763:                         fin
_B107 
_B108 
; libsrc/apple/uthernet2.pla: 0764:                         if sir & $02
; libsrc/apple/uthernet2.pla: 0765:                             //
; libsrc/apple/uthernet2.pla: 0766:                             // Close TCP socket
; libsrc/apple/uthernet2.pla: 0767:                             //
; libsrc/apple/uthernet2.pla: 0768:                             if wiz->channel_state == TCP_STATE_OPEN // Notify callback w/ len = 0
; libsrc/apple/uthernet2.pla: 0769:                                 wiz=>channel_recv_func(@wiz=>channel_remip,wiz=>channel_remport,0,wiz=>channel_lclport,0,wiz=>channel_recv_parm)
; libsrc/apple/uthernet2.pla: 0770:                             fin
	!BYTE	$64,$12			; LLB	[18]
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B113
	!WORD	_B113-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$08			; CN	4
	!BYTE	$24			; BRNE	_B115
	!WORD	_B115-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$0A			; ADDI	10
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$12			; ADDI	18
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$62			; LW
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B115 
_B116 
; libsrc/apple/uthernet2.pla: 0771:                             wiz->channel_state = TCP_STATE_CLOSED
; libsrc/apple/uthernet2.pla: 0772:                             pokereg(wiz=>channel_regs + WIZ_SnCR, $10) // CLOSE
; libsrc/apple/uthernet2.pla: 0773:                         fin
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$2A,$10			; CB	16
	!BYTE	$54			; CALL	_C004
_F098 	!WORD	_C004		
_B113 
_B114 
; libsrc/apple/uthernet2.pla: 0774:                         if sir & $08
; libsrc/apple/uthernet2.pla: 0775:                             //
; libsrc/apple/uthernet2.pla: 0776:                             // Timeout on TCP socket
; libsrc/apple/uthernet2.pla: 0777:                             //
; libsrc/apple/uthernet2.pla: 0778:                             when wiz->channel_state
	!BYTE	$64,$12			; LLB	[18]
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B117
	!WORD	_B117-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B120-*
; libsrc/apple/uthernet2.pla: 0779:                                 is TCP_STATE_OPEN
_B121 
; libsrc/apple/uthernet2.pla: 0780:                                     wiz->channel_state = TCP_STATE_CLOSING
; libsrc/apple/uthernet2.pla: 0781:                                     wiz=>channel_recv_func(@wiz=>channel_remip,wiz=>channel_remport,wiz=>channel_lclport,0,0,wiz=>channel_recv_parm)
; libsrc/apple/uthernet2.pla: 0782:                                     break
	!BYTE	$02			; CN	1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$0A			; ADDI	10
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$12			; ADDI	18
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$62			; LW
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B119
	!WORD	_B119-*
; libsrc/apple/uthernet2.pla: 0783:                                 is TCP_STATE_CONNECT
_B122 
; libsrc/apple/uthernet2.pla: 0784:                                     wiz=>channel_recv_func(@wiz=>channel_remip,wiz=>channel_remport,wiz=>channel_lclport,0,0,wiz=>channel_recv_parm)
; libsrc/apple/uthernet2.pla: 0785:                                 is TCP_STATE_CLOSING
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$0A			; ADDI	10
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$12			; ADDI	18
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$62			; LW
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B123 
; libsrc/apple/uthernet2.pla: 0786:                                     wiz->channel_state = TCP_STATE_CLOSED
; libsrc/apple/uthernet2.pla: 0787:                                     pokereg(wiz=>channel_regs + WIZ_SnCR, $10) // CLOSE
; libsrc/apple/uthernet2.pla: 0788:                             wend
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$2A,$10			; CB	16
	!BYTE	$54			; CALL	_C004
_F099 	!WORD	_C004		
	!BYTE	$50			; BRNCH	_B119
	!WORD	_B119-*
_B120 
	!BYTE	$03			; CASEBLOCK
	!WORD	$0001
	!WORD	_B123-*
	!WORD	$0003
	!WORD	_B122-*
	!WORD	$0004
	!WORD	_B121-*
_B119 
; libsrc/apple/uthernet2.pla: 0789:                         fin
_B117 
_B118 
; libsrc/apple/uthernet2.pla: 0790:                 wend
	!BYTE	$50			; BRNCH	_B093
	!WORD	_B093-*
_B094 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0001
	!WORD	_B100-*
	!WORD	$0002
	!WORD	_B095-*
_B093 
; libsrc/apple/uthernet2.pla: 0791:             fin
_B091 
_B092 
; libsrc/apple/uthernet2.pla: 0792:             wiz = wiz + t_channel
; libsrc/apple/uthernet2.pla: 0793:         next
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$14			; ADDI	20
	!BYTE	$76,$00			; SLW	[0]
_B090 
	!BYTE	$A4			; INCBRLE	_B089
	!WORD	_B089-*
_B088 
	!BYTE	$74,$11			; SLB	[17]
	!BYTE	$30			; DROP 
; libsrc/apple/uthernet2.pla: 0794:         if ir & $80
; libsrc/apple/uthernet2.pla: 0795:             //
; libsrc/apple/uthernet2.pla: 0796:             // IP conflict
; libsrc/apple/uthernet2.pla: 0797:             //
; libsrc/apple/uthernet2.pla: 0798:             pokereg(WIZ_IR, $80)
; libsrc/apple/uthernet2.pla: 0799:         fin
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B124
	!WORD	_B124-*
	!BYTE	$2A,$15			; CB	21
	!BYTE	$2A,$80			; CB	128
	!BYTE	$54			; CALL	_C004
_F100 	!WORD	_C004		
_B124 
_B125 
; libsrc/apple/uthernet2.pla: 0800:         if ir & $40
; libsrc/apple/uthernet2.pla: 0801:             //
; libsrc/apple/uthernet2.pla: 0802:             // Destination unreachable
; libsrc/apple/uthernet2.pla: 0803:             //
; libsrc/apple/uthernet2.pla: 0804:             pokereg(WIZ_IR, $40)
; libsrc/apple/uthernet2.pla: 0805:         fin
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$3C,$40			; ANDI	64
	!BYTE	$4C			; BRFLS	_B126
	!WORD	_B126-*
	!BYTE	$2A,$15			; CB	21
	!BYTE	$2A,$40			; CB	64
	!BYTE	$54			; CALL	_C004
_F101 	!WORD	_C004		
_B126 
_B127 
; libsrc/apple/uthernet2.pla: 0806:         if ir & $20
; libsrc/apple/uthernet2.pla: 0807:             //
; libsrc/apple/uthernet2.pla: 0808:             // PPOE connection close
; libsrc/apple/uthernet2.pla: 0809:             //
; libsrc/apple/uthernet2.pla: 0810:             pokereg(WIZ_IR, $20)
; libsrc/apple/uthernet2.pla: 0811:         fin
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$4C			; BRFLS	_B128
	!WORD	_B128-*
	!BYTE	$2A,$15			; CB	21
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C004
_F102 	!WORD	_C004		
_B128 
_B129 
; libsrc/apple/uthernet2.pla: 0812:     fin
_B086 
_B087 
; libsrc/apple/uthernet2.pla: 0813:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$13			; LEAVE	19
; libsrc/apple/uthernet2.pla: 0814: end
; libsrc/apple/uthernet2.pla: 0815: //
; libsrc/apple/uthernet2.pla: 0816: // Set the local IP addresses
; libsrc/apple/uthernet2.pla: 0817: //
; libsrc/apple/uthernet2.pla: 0818: def setWizIP(newIP, newSubnet, newGateway)
					; newIP -> [0]
					; newSubnet -> [2]
					; newGateway -> [4]
_C020 					; setWizIP()
; libsrc/apple/uthernet2.pla: 0819:     if newIP
	!BYTE	$58,$06,$03		; ENTER	6,3
; libsrc/apple/uthernet2.pla: 0820:         localip:0 = newIP=>0; localip:2 = newIP=>2
; libsrc/apple/uthernet2.pla: 0821:         pokeregs(WIZ_SIPR, newIP, IP4ADR_SIZE)
; libsrc/apple/uthernet2.pla: 0822:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4C			; BRFLS	_B130
	!WORD	_B130-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D035+0
_F103 	!WORD	_D035+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D035+2
_F104 	!WORD	_D035+2		
	!BYTE	$1E			; CN	15
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_C006
_F105 	!WORD	_C006		
_B130 
_B131 
; libsrc/apple/uthernet2.pla: 0823:     if newSubnet
; libsrc/apple/uthernet2.pla: 0824:         subnet:0 = newSubnet=>0; subnet:2 = newSubnet=>2
; libsrc/apple/uthernet2.pla: 0825:         pokeregs(WIZ_SUBR, newSubnet, IP4ADR_SIZE)
; libsrc/apple/uthernet2.pla: 0826:     fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B132
	!WORD	_B132-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D036+0
_F106 	!WORD	_D036+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D036+2
_F107 	!WORD	_D036+2		
	!BYTE	$0A			; CN	5
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_C006
_F108 	!WORD	_C006		
_B132 
_B133 
; libsrc/apple/uthernet2.pla: 0827:     if newGateway
; libsrc/apple/uthernet2.pla: 0828:         gateway:0 = newGateway=>0; gateway:2 = newGateway=>2
; libsrc/apple/uthernet2.pla: 0829:         pokeregs(WIZ_GWR, newGateway, IP4ADR_SIZE)
; libsrc/apple/uthernet2.pla: 0830:     fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$4C			; BRFLS	_B134
	!WORD	_B134-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D037+0
_F109 	!WORD	_D037+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D037+2
_F110 	!WORD	_D037+2		
	!BYTE	$02			; CN	1
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_C006
_F111 	!WORD	_C006		
_B134 
_B135 
; libsrc/apple/uthernet2.pla: 0831:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/apple/uthernet2.pla: 0832: end
; libsrc/apple/uthernet2.pla: 0833: //
; libsrc/apple/uthernet2.pla: 0834: // Get the interface hardware address
; libsrc/apple/uthernet2.pla: 0835: //
; libsrc/apple/uthernet2.pla: 0836: def getWizHA(ha)
					; ha -> [0]
_C021 					; getWizHA()
; libsrc/apple/uthernet2.pla: 0837:     if ha
	!BYTE	$58,$02,$01		; ENTER	2,1
; libsrc/apple/uthernet2.pla: 0838:         ha=>0 = wizMAC:0; ha=>2 = wizMAC:2; ha=>4 = wizMAC:4
; libsrc/apple/uthernet2.pla: 0839:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4C			; BRFLS	_B136
	!WORD	_B136-*
	!BYTE	$6A			; LAW	_D034+0
_F112 	!WORD	_D034+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D034+2
_F113 	!WORD	_D034+2		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D034+4
_F114 	!WORD	_D034+4		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
_B136 
_B137 
; libsrc/apple/uthernet2.pla: 0840:     return MAC_SIZE
	!BYTE	$0C			; CN	6
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/apple/uthernet2.pla: 0841: end
; libsrc/apple/uthernet2.pla: 0842: //
; libsrc/apple/uthernet2.pla: 0843: // Identify Uthernet II card and initialize
; libsrc/apple/uthernet2.pla: 0844: //
; libsrc/apple/uthernet2.pla: 0845: for slot = $90 to $F0 step $10
_INIT 
	!BYTE	$2A,$F0			; CB	240
	!BYTE	$2A,$90			; CB	144
_B139 
	!BYTE	$7C			; DAB	_D033+0
_F115 	!WORD	_D033+0		
; libsrc/apple/uthernet2.pla: 0846:     rom = ((slot & $70) << 4) | $C000
; libsrc/apple/uthernet2.pla: 0847:     if rom=>$06 <> $3C86 or (slot == $0B or (rom->$05 <> $38 and rom->$07 <> $18)) // Skip slots with signature
; libsrc/apple/uthernet2.pla: 0848:         regdata = peekio(slot)
; libsrc/apple/uthernet2.pla: 0849:         if (regdata & $E4) == $00
; libsrc/apple/uthernet2.pla: 0850:             pokeio(slot, $03) // Try setting auto-increment indirect I/F
; libsrc/apple/uthernet2.pla: 0851:             if peekio(slot) == $03
; libsrc/apple/uthernet2.pla: 0852:                 saveidx = peekiow(slot + 1)
; libsrc/apple/uthernet2.pla: 0853:                 peekio(slot + 3) // Dummy read to data register should increment index
; libsrc/apple/uthernet2.pla: 0854:                 if peekiow(slot + 1) == saveidx + 1
; libsrc/apple/uthernet2.pla: 0855:                     //
; libsrc/apple/uthernet2.pla: 0856:                     // Good chance this is it
; libsrc/apple/uthernet2.pla: 0857:                     //
; libsrc/apple/uthernet2.pla: 0858:                     pokeio(slot, $80) // RESET
; libsrc/apple/uthernet2.pla: 0859:                     regidx      = slot + 1
; libsrc/apple/uthernet2.pla: 0860:                     regdata     = slot + 3
; libsrc/apple/uthernet2.pla: 0861:                     _pokedata.1 = regdata
; libsrc/apple/uthernet2.pla: 0862:                     _peekdata.1 = regdata
; libsrc/apple/uthernet2.pla: 0863:                     repeat
	!BYTE	$68			; LAB	_D033+0
_F116 	!WORD	_D033+0		
	!BYTE	$3C,$70			; ANDI	112
	!BYTE	$08			; CN	4
	!BYTE	$9A			; SHL
	!BYTE	$2C,$00,$C0		; CW	49152
	!BYTE	$96			; OR 
	!BYTE	$7E			; DAW	_D029+0
_F117 	!WORD	_D029+0		
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$2C,$86,$3C		; CW	15494
	!BYTE	$42			; ISNE
	!BYTE	$AE			; BROR	_B141
	!WORD	_B141-*
	!BYTE	$68			; LAB	_D033+0
_F118 	!WORD	_D033+0		
	!BYTE	$16			; CN	11
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B142
	!WORD	_B142-*
	!BYTE	$6A			; LAW	_D029+0
_F119 	!WORD	_D029+0		
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$60			; LB
	!BYTE	$2A,$38			; CB	56
	!BYTE	$42			; ISNE
	!BYTE	$AC			; BRAND	_B143
	!WORD	_B143-*
	!BYTE	$6A			; LAW	_D029+0
_F120 	!WORD	_D029+0		
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$60			; LB
	!BYTE	$2A,$18			; CB	24
	!BYTE	$42			; ISNE
_B143 
_B142 
_B141 
	!BYTE	$4C			; BRFLS	_B144
	!WORD	_B144-*
	!BYTE	$68			; LAB	_D033+0
_F121 	!WORD	_D033+0		
	!BYTE	$54			; CALL	_C002
_F122 	!WORD	_C002		
	!BYTE	$7C			; DAB	_D032+0
_F123 	!WORD	_D032+0		
	!BYTE	$3C,$E4			; ANDI	228
	!BYTE	$4E			; BRTRU	_B146
	!WORD	_B146-*
	!BYTE	$68			; LAB	_D033+0
_F124 	!WORD	_D033+0		
	!BYTE	$06			; CN	3
	!BYTE	$54			; CALL	_C001
_F125 	!WORD	_C001		
	!BYTE	$68			; LAB	_D033+0
_F126 	!WORD	_D033+0		
	!BYTE	$54			; CALL	_C002
_F127 	!WORD	_C002		
	!BYTE	$06			; CN	3
	!BYTE	$24			; BRNE	_B148
	!WORD	_B148-*
	!BYTE	$68			; LAB	_D033+0
_F128 	!WORD	_D033+0		
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_C003
_F129 	!WORD	_C003		
	!BYTE	$7A			; SAW	_D030+0
_F130 	!WORD	_D030+0		
	!BYTE	$68			; LAB	_D033+0
_F131 	!WORD	_D033+0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$54			; CALL	_C002
_F132 	!WORD	_C002		
	!BYTE	$30			; DROP 
	!BYTE	$68			; LAB	_D033+0
_F133 	!WORD	_D033+0		
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_C003
_F134 	!WORD	_C003		
	!BYTE	$6A			; LAW	_D030+0
_F135 	!WORD	_D030+0		
	!BYTE	$8C			; INCR
	!BYTE	$24			; BRNE	_B150
	!WORD	_B150-*
	!BYTE	$68			; LAB	_D033+0
_F136 	!WORD	_D033+0		
	!BYTE	$2A,$80			; CB	128
	!BYTE	$54			; CALL	_C001
_F137 	!WORD	_C001		
	!BYTE	$68			; LAB	_D033+0
_F138 	!WORD	_D033+0		
	!BYTE	$8C			; INCR
	!BYTE	$78			; SAB	_D031+0
_F139 	!WORD	_D031+0		
	!BYTE	$68			; LAB	_D033+0
_F140 	!WORD	_D033+0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$7C			; DAB	_D032+0
_F141 	!WORD	_D032+0		
	!BYTE	$78			; SAB	_A013+1
_F142 	!WORD	_A013+1		
	!BYTE	$68			; LAB	_D032+0
_F143 	!WORD	_D032+0		
	!BYTE	$78			; SAB	_A015+1
_F144 	!WORD	_A015+1		
_B153 
; libsrc/apple/uthernet2.pla: 0864:                         pokeio(slot, $03) // Auto-increment indirect I/F + enable ping
; libsrc/apple/uthernet2.pla: 0865:                     until peekio(slot) == $03
	!BYTE	$68			; LAB	_D033+0
_F145 	!WORD	_D033+0		
	!BYTE	$06			; CN	3
	!BYTE	$54			; CALL	_C001
_F146 	!WORD	_C001		
_B154 
	!BYTE	$68			; LAB	_D033+0
_F147 	!WORD	_D033+0		
	!BYTE	$54			; CALL	_C002
_F148 	!WORD	_C002		
	!BYTE	$06			; CN	3
	!BYTE	$24			; BRNE	_B153
	!WORD	_B153-*
_B152 
; libsrc/apple/uthernet2.pla: 0866:                     //
; libsrc/apple/uthernet2.pla: 0867:                     // The following looks redundant, but it sets up the peek/poke locations
; libsrc/apple/uthernet2.pla: 0868:                     // for peekreg(s)/pokereg(s)
; libsrc/apple/uthernet2.pla: 0869:                     //
; libsrc/apple/uthernet2.pla: 0870:                     pokeiow(regidx, WIZ_MR)
; libsrc/apple/uthernet2.pla: 0871:                     pokeio(regdata, $03) // Auto-increment indirect I/F + enable ping
; libsrc/apple/uthernet2.pla: 0872:                     peekio(regdata)
; libsrc/apple/uthernet2.pla: 0873:                     //
; libsrc/apple/uthernet2.pla: 0874:                     // Initialize common registers
; libsrc/apple/uthernet2.pla: 0875:                     //
; libsrc/apple/uthernet2.pla: 0876:                     wizMAC[5] = slot >> 4          // Slighty unique MAC address
; libsrc/apple/uthernet2.pla: 0877:                     pokeregs(WIZ_SHAR, @wizMAC, 6) // MAC addr
; libsrc/apple/uthernet2.pla: 0878:                     pokeregw(WIZ_RTR, 5000)        // Timeout period to 500ms
; libsrc/apple/uthernet2.pla: 0879:                     pokereg(WIZ_RMSR, $55)         // 2K Rx memory/channel
; libsrc/apple/uthernet2.pla: 0880:                     pokereg(WIZ_TMSR, $55)         // 2K Tx memory/channel
; libsrc/apple/uthernet2.pla: 0881:                     //
; libsrc/apple/uthernet2.pla: 0882:                     // Print settings
; libsrc/apple/uthernet2.pla: 0883:                     //
; libsrc/apple/uthernet2.pla: 0884:                     puts("Found Uthernet II in slot #")
	!BYTE	$68			; LAB	_D031+0
_F149 	!WORD	_D031+0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C000
_F150 	!WORD	_C000		
	!BYTE	$68			; LAB	_D032+0
_F151 	!WORD	_D032+0		
	!BYTE	$06			; CN	3
	!BYTE	$54			; CALL	_C001
_F152 	!WORD	_C001		
	!BYTE	$68			; LAB	_D032+0
_F153 	!WORD	_D032+0		
	!BYTE	$54			; CALL	_C002
_F154 	!WORD	_C002		
	!BYTE	$30			; DROP 
	!BYTE	$68			; LAB	_D033+0
_F155 	!WORD	_D033+0		
	!BYTE	$08			; CN	4
	!BYTE	$9C			; SHR
	!BYTE	$78			; SAB	_D034+5
_F156 	!WORD	_D034+5		
	!BYTE	$12			; CN	9
	!BYTE	$26			; LA	_D034+0
_F157 	!WORD	_D034+0		
	!BYTE	$0C			; CN	6
	!BYTE	$54			; CALL	_C006
_F158 	!WORD	_C006		
	!BYTE	$2A,$17			; CB	23
	!BYTE	$2C,$88,$13		; CW	5000
	!BYTE	$54			; CALL	_C008
_F159 	!WORD	_C008		
	!BYTE	$2A,$1A			; CB	26
	!BYTE	$2A,$55			; CB	85
	!BYTE	$54			; CALL	_C004
_F160 	!WORD	_C004		
	!BYTE	$2A,$1B			; CB	27
	!BYTE	$2A,$55			; CB	85
	!BYTE	$54			; CALL	_C004
_F161 	!WORD	_C004		
	!BYTE	$2E			; CS
	!BYTE	$1B
	!BYTE	$46,$6F,$75,$6E,$64,$20,$55,$74
	!BYTE	$68,$65,$72,$6E,$65,$74,$20,$49
	!BYTE	$49,$20,$69,$6E,$20,$73,$6C,$6F
	!BYTE	$74,$20,$23
	!BYTE	$54			; CALL	_X004
_F162 	!WORD	0		
; libsrc/apple/uthernet2.pla: 0885:                     putc('0' + ((slot - $80) >> 4))
; libsrc/apple/uthernet2.pla: 0886:                     putln
; libsrc/apple/uthernet2.pla: 0887:                     //
; libsrc/apple/uthernet2.pla: 0888:                     // Fill channel structure
; libsrc/apple/uthernet2.pla: 0889:                     //
; libsrc/apple/uthernet2.pla: 0890:                     saveidx = @wizChannel
; libsrc/apple/uthernet2.pla: 0891:                     for slot = 0 to 3
	!BYTE	$2A,$30			; CB	48
	!BYTE	$68			; LAB	_D033+0
_F163 	!WORD	_D033+0		
	!BYTE	$3A,$80			; SUBI	128
	!BYTE	$08			; CN	4
	!BYTE	$9C			; SHR
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X002
_F164 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F165 	!WORD	0		
	!BYTE	$26			; LA	_D040+0
_F166 	!WORD	_D040+0		
	!BYTE	$7A			; SAW	_D030+0
_F167 	!WORD	_D030+0		
	!BYTE	$06			; CN	3
	!BYTE	$00			; CN	0
_B156 
	!BYTE	$7C			; DAB	_D033+0
_F168 	!WORD	_D033+0		
; libsrc/apple/uthernet2.pla: 0892:                         saveidx=>channel_regs  = WIZ_SREGS + (WIZ_SSIZE  * slot)
; libsrc/apple/uthernet2.pla: 0893:                         saveidx=>channel_txmem = WIZ_TXMEM + (WIZ_TXSIZE * slot)
; libsrc/apple/uthernet2.pla: 0894:                         saveidx=>channel_rxmem = WIZ_RXMEM + (WIZ_RXSIZE * slot)
; libsrc/apple/uthernet2.pla: 0895:                         saveidx = saveidx + t_channel
; libsrc/apple/uthernet2.pla: 0896:                     next
	!BYTE	$2C,$00,$04		; CW	1024
	!BYTE	$2C,$00,$01		; CW	256
	!BYTE	$68			; LAB	_D033+0
_F169 	!WORD	_D033+0		
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$6A			; LAW	_D030+0
_F170 	!WORD	_D030+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$2C,$00,$40		; CW	16384
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$68			; LAB	_D033+0
_F171 	!WORD	_D033+0		
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$6A			; LAW	_D030+0
_F172 	!WORD	_D030+0		
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$2C,$00,$60		; CW	24576
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$68			; LAB	_D033+0
_F173 	!WORD	_D033+0		
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$6A			; LAW	_D030+0
_F174 	!WORD	_D030+0		
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D030+0
_F175 	!WORD	_D030+0		
	!BYTE	$38,$14			; ADDI	20
	!BYTE	$7A			; SAW	_D030+0
_F176 	!WORD	_D030+0		
_B157 
	!BYTE	$A4			; INCBRLE	_B156
	!WORD	_B156-*
_B155 
	!BYTE	$78			; SAB	_D033+0
_F177 	!WORD	_D033+0		
	!BYTE	$30			; DROP 
; libsrc/apple/uthernet2.pla: 0897:                     //
; libsrc/apple/uthernet2.pla: 0898:                     // Fill in Net class
; libsrc/apple/uthernet2.pla: 0899:                     //
; libsrc/apple/uthernet2.pla: 0900:                     iNet:serviceIP      = @wizServiceIP
; libsrc/apple/uthernet2.pla: 0901:                     iNet:openUDP        = @wizOpenUDP
; libsrc/apple/uthernet2.pla: 0902:                     iNet:sendUDP        = @wizSendUDP
; libsrc/apple/uthernet2.pla: 0903:                     iNet:closeUDP       = @wizCloseUDP
; libsrc/apple/uthernet2.pla: 0904:                     iNet:listenTCP      = @wizListenTCP
; libsrc/apple/uthernet2.pla: 0905:                     iNet:connectTCP     = @wizConnectTCP
; libsrc/apple/uthernet2.pla: 0906:                     iNet:sendTCP        = @wizSendTCP
; libsrc/apple/uthernet2.pla: 0907:                     iNet:closeTCP       = @wizCloseTCP
; libsrc/apple/uthernet2.pla: 0908:                     iNet:setInterfaceIP = @setWizIP
; libsrc/apple/uthernet2.pla: 0909:                     iNet:getInterfaceHA = @getWizHA
; libsrc/apple/uthernet2.pla: 0910:                     iNet:setCallback    = @wizSetCallback
; libsrc/apple/uthernet2.pla: 0911:                     iNet:setParam       = @wizSetParam
; libsrc/apple/uthernet2.pla: 0912:                     return modkeep
	!BYTE	$26			; LA	_C019+0
_F178 	!WORD	_C019+0		
	!BYTE	$7A			; SAW	_X028+2
_F179 	!WORD	0+2		
	!BYTE	$26			; LA	_C011+0
_F180 	!WORD	_C011+0		
	!BYTE	$7A			; SAW	_X028+4
_F181 	!WORD	0+4		
	!BYTE	$26			; LA	_C010+0
_F182 	!WORD	_C010+0		
	!BYTE	$7A			; SAW	_X028+6
_F183 	!WORD	0+6		
	!BYTE	$26			; LA	_C012+0
_F184 	!WORD	_C012+0		
	!BYTE	$7A			; SAW	_X028+8
_F185 	!WORD	0+8		
	!BYTE	$26			; LA	_C013+0
_F186 	!WORD	_C013+0		
	!BYTE	$7A			; SAW	_X028+10
_F187 	!WORD	0+10		
	!BYTE	$26			; LA	_C014+0
_F188 	!WORD	_C014+0		
	!BYTE	$7A			; SAW	_X028+12
_F189 	!WORD	0+12		
	!BYTE	$26			; LA	_C015+0
_F190 	!WORD	_C015+0		
	!BYTE	$7A			; SAW	_X028+14
_F191 	!WORD	0+14		
	!BYTE	$26			; LA	_C016+0
_F192 	!WORD	_C016+0		
	!BYTE	$7A			; SAW	_X028+16
_F193 	!WORD	0+16		
	!BYTE	$26			; LA	_C020+0
_F194 	!WORD	_C020+0		
	!BYTE	$7A			; SAW	_X028+18
_F195 	!WORD	0+18		
	!BYTE	$26			; LA	_C021+0
_F196 	!WORD	_C021+0		
	!BYTE	$7A			; SAW	_X028+20
_F197 	!WORD	0+20		
	!BYTE	$26			; LA	_C017+0
_F198 	!WORD	_C017+0		
	!BYTE	$7A			; SAW	_X028+26
_F199 	!WORD	0+26		
	!BYTE	$26			; LA	_C018+0
_F200 	!WORD	_C018+0		
	!BYTE	$7A			; SAW	_X028+28
_F201 	!WORD	0+28		
	!BYTE	$32			; DROP2
	!BYTE	$2C,$00,$20		; CW	8192
	!BYTE	$5C			; RET
; libsrc/apple/uthernet2.pla: 0913:                 fin
_B150 
_B151 
; libsrc/apple/uthernet2.pla: 0914:             fin
_B148 
_B149 
; libsrc/apple/uthernet2.pla: 0915:             pokeio(slot, regdata) // Restore register
; libsrc/apple/uthernet2.pla: 0916:         fin
	!BYTE	$68			; LAB	_D033+0
_F202 	!WORD	_D033+0		
	!BYTE	$68			; LAB	_D032+0
_F203 	!WORD	_D032+0		
	!BYTE	$54			; CALL	_C001
_F204 	!WORD	_C001		
_B146 
_B147 
; libsrc/apple/uthernet2.pla: 0917:     fin
_B144 
_B145 
; libsrc/apple/uthernet2.pla: 0918: next
_B140 
	!BYTE	$2A,$10			; CB	16
	!BYTE	$A6			; ADDBRLE	_B139
	!WORD	_B139-*
_B138 
	!BYTE	$78			; SAB	_D033+0
_F205 	!WORD	_D033+0		
	!BYTE	$30			; DROP 
; libsrc/apple/uthernet2.pla: 0919: //
; libsrc/apple/uthernet2.pla: 0920: // Not found
; libsrc/apple/uthernet2.pla: 0921: //
; libsrc/apple/uthernet2.pla: 0922: return -1
	!BYTE	$20			; MINUS ONE
	!BYTE	$5C			; RET
; libsrc/apple/uthernet2.pla: 0923: done
_SYSFLAGS	=	0
_DEFCNT	=	23
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C010		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C011		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C012		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C013		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C014		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C015		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C016		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C017		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C018		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C019		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C020		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C021		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	25			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	26			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	25			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	26			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F133-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F134-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F135-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F136-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F137-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F138-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F139-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F140-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F141-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F142-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F143-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F144-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F145-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F146-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F147-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F148-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F149-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F150-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F151-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F152-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F153-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F154-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F155-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F156-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F157-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F158-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F159-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F160-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F161-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F162-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F163-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F164-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F165-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F166-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F167-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F168-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F169-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F170-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F171-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F172-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F173-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F174-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F175-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F176-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F177-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F178-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F179-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F180-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F181-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F182-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F183-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F184-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F185-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F186-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F187-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F188-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F189-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F190-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F191-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F192-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F193-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F194-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F195-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F196-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F197-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F198-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F199-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F200-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F201-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F202-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F203-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F204-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F205-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: PUTC
	!BYTE	$D0,$D5,$D4,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	2			; ESD INDEX
	; DCI STRING: PUTLN
	!BYTE	$D0,$D5,$D4,$CC,$4E
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	3			; ESD INDEX
	; DCI STRING: PUTS
	!BYTE	$D0,$D5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	4			; ESD INDEX
	; DCI STRING: HEAPALLOC
	!BYTE	$C8,$C5,$C1,$D0,$C1,$CC,$CC,$CF,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	14			; ESD INDEX
	; DCI STRING: HEAPRELEASE
	!BYTE	$C8,$C5,$C1,$D0,$D2,$C5,$CC,$C5,$C1,$D3,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	15			; ESD INDEX
	; DCI STRING: ISUGE
	!BYTE	$C9,$D3,$D5,$C7,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	25			; ESD INDEX
	; DCI STRING: ISULT
	!BYTE	$C9,$D3,$D5,$CC,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	26			; ESD INDEX
	; DCI STRING: INET
	!BYTE	$C9,$CE,$C5,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	28			; ESD INDEX
	; DCI STRING: HOOKICMP
	!BYTE	$C8,$CF,$CF,$CB,$C9,$C3,$CD,$50
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D041		
	!BYTE	$00			; END OF ESD
