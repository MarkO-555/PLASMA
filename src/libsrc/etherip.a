; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; libsrc/etherip.pla: 0001: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0200 // Version built against
					; _SYSVER_ = 512
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $03
					; MACHID_MEM = 3
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     //
; inc/cmdsys.plh: 0038:     // Module don't free memory
; inc/cmdsys.plh: 0039:     //
; inc/cmdsys.plh: 0040:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0041:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0042:     //
; inc/cmdsys.plh: 0043:     // CMD exported interface table
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     struc t_cmdsys
; inc/cmdsys.plh: 0046:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0047:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0048:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0049:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0050:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0051:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0052:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0053:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0054:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0055:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0056:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0057:         byte refcons    // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0058:         byte devcons    // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0059:     end
					; t_cmdsys = 21
; inc/cmdsys.plh: 0060:     //
; inc/cmdsys.plh: 0061:     // CMD exported functions
; inc/cmdsys.plh: 0062:     //
; inc/cmdsys.plh: 0063:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0064:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0065:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0066:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0067:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0068:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0069: end
; libsrc/etherip.pla: 0001: 
; libsrc/etherip.pla: 0002: include "inc/inet.plh"
; inc/inet.plh: 0001: //
; inc/inet.plh: 0002: // iNet API
; inc/inet.plh: 0003: //
; inc/inet.plh: 0004: import iNet
	; DCI STRING: INET
	!BYTE	$C9,$CE,$C5,$54
					; INET -> X028
; inc/inet.plh: 0005: struc t_inet
; inc/inet.plh: 0006:     word initIP
					; initIP = 0
; inc/inet.plh: 0007:     word serviceIP
					; serviceIP = 2
; inc/inet.plh: 0008:     word openUDP
					; openUDP = 4
; inc/inet.plh: 0009:     word sendUDP
					; sendUDP = 6
; inc/inet.plh: 0010:     word closeUDP
					; closeUDP = 8
; inc/inet.plh: 0011:     word listenTCP
					; listenTCP = 10
; inc/inet.plh: 0012:     word connectTCP
					; connectTCP = 12
; inc/inet.plh: 0013:     word sendTCP
					; sendTCP = 14
; inc/inet.plh: 0014:     word closeTCP
					; closeTCP = 16
; inc/inet.plh: 0015:     word setInterfaceIP
					; setInterfaceIP = 18
; inc/inet.plh: 0016:     word getInterfaceHA
					; getInterfaceHA = 20
; inc/inet.plh: 0017:     word setDNS
					; setDNS = 22
; inc/inet.plh: 0018:     word resolveIP
					; resolveIP = 24
; inc/inet.plh: 0019:     word setCallback
					; setCallback = 26
; inc/inet.plh: 0020:     word setParam
					; setParam = 28
; inc/inet.plh: 0021: end
					; t_inet = 30
; inc/inet.plh: 0022: end
; libsrc/etherip.pla: 0002: 
; libsrc/etherip.pla: 0003: //
; libsrc/etherip.pla: 0004: // Predefine service routine
; libsrc/etherip.pla: 0005: //
; libsrc/etherip.pla: 0006: predef etherServiceIP
	!BYTE	$00			; END OF MODULE DEPENDENCIES
; libsrc/etherip.pla: 0007: //
; libsrc/etherip.pla: 0008: // Segment list element
; libsrc/etherip.pla: 0009: //
; libsrc/etherip.pla: 0010: struc t_segment
; libsrc/etherip.pla: 0011:     word seg_buf
					; seg_buf = 0
; libsrc/etherip.pla: 0012:     word seg_len
					; seg_len = 2
; libsrc/etherip.pla: 0013: end
					; t_segment = 4
; libsrc/etherip.pla: 0014: //
; libsrc/etherip.pla: 0015: // Max Ethernet frame size
; libsrc/etherip.pla: 0016: //
; libsrc/etherip.pla: 0017: const MAX_FRAME_SIZE = 1518
					; MAX_FRAME_SIZE = 1518
; libsrc/etherip.pla: 0018: const MAC_BROADCAST  = $FFFF
					; MAC_BROADCAST = 65535
; libsrc/etherip.pla: 0019: const MAC_SIZE       = 6
					; MAC_SIZE = 6
; libsrc/etherip.pla: 0020: //
; libsrc/etherip.pla: 0021: // Ethernet header
; libsrc/etherip.pla: 0022: //
; libsrc/etherip.pla: 0023: struc t_ethrhdr
; libsrc/etherip.pla: 0024:     byte[MAC_SIZE] ethr_dst
					; ethr_dst = 0
; libsrc/etherip.pla: 0025:     byte[MAC_SIZE] ethr_src
					; ethr_src = 6
; libsrc/etherip.pla: 0026:     word           ethr_payload
					; ethr_payload = 12
; libsrc/etherip.pla: 0027: end
					; t_ethrhdr = 14
; libsrc/etherip.pla: 0028: const PAYLOAD_IP  = $0008 // BE format
					; PAYLOAD_IP = 8
; libsrc/etherip.pla: 0029: const PAYLOAD_ARP = $0608 // BE format
					; PAYLOAD_ARP = 1544
; libsrc/etherip.pla: 0030: //
; libsrc/etherip.pla: 0031: // IP datagram header
; libsrc/etherip.pla: 0032: //
; libsrc/etherip.pla: 0033: const IP4ADR_SIZE = 4
					; IP4ADR_SIZE = 4
; libsrc/etherip.pla: 0034: struc t_iphdr
; libsrc/etherip.pla: 0035:     byte ip_vers_hlen
					; ip_vers_hlen = 0
; libsrc/etherip.pla: 0036:     byte ip_service
					; ip_service = 1
; libsrc/etherip.pla: 0037:     word ip_length
					; ip_length = 2
; libsrc/etherip.pla: 0038:     word ip_id
					; ip_id = 4
; libsrc/etherip.pla: 0039:     word ip_flags_fragofst
					; ip_flags_fragofst = 6
; libsrc/etherip.pla: 0040:     byte ip_ttl
					; ip_ttl = 8
; libsrc/etherip.pla: 0041:     byte ip_proto
					; ip_proto = 9
; libsrc/etherip.pla: 0042:     word ip_chksm
					; ip_chksm = 10
; libsrc/etherip.pla: 0043:     byte[IP4ADR_SIZE] ip_src
					; ip_src = 12
; libsrc/etherip.pla: 0044:     byte[IP4ADR_SIZE] ip_dst
					; ip_dst = 16
; libsrc/etherip.pla: 0045:     byte[] ip_options
					; ip_options = 20
; libsrc/etherip.pla: 0046: end
					; t_iphdr = 20
; libsrc/etherip.pla: 0047: const t_ethriphdr   = t_ethrhdr + t_iphdr
					; t_ethriphdr = 34
; libsrc/etherip.pla: 0048: const IP_BROADCAST  = $FFFF
					; IP_BROADCAST = 65535
; libsrc/etherip.pla: 0049: const IP_PROTO_ICMP = $01
					; IP_PROTO_ICMP = 1
; libsrc/etherip.pla: 0050: const IP_PROTO_UDP  = $11
					; IP_PROTO_UDP = 17
; libsrc/etherip.pla: 0051: const IP_PROTO_TCP  = $06
					; IP_PROTO_TCP = 6
; libsrc/etherip.pla: 0052: //
; libsrc/etherip.pla: 0053: // ICMP type/codes
; libsrc/etherip.pla: 0054: //
; libsrc/etherip.pla: 0055: const ICMP_ECHO_REQST = 8
					; ICMP_ECHO_REQST = 8
; libsrc/etherip.pla: 0056: const ICMP_ECHO_REPLY = 0
					; ICMP_ECHO_REPLY = 0
; libsrc/etherip.pla: 0057: //
; libsrc/etherip.pla: 0058: // ICMP message format
; libsrc/etherip.pla: 0059: //
; libsrc/etherip.pla: 0060: struc t_icmp
; libsrc/etherip.pla: 0061:     byte icmp_type
					; icmp_type = 0
; libsrc/etherip.pla: 0062:     byte icmp_code
					; icmp_code = 1
; libsrc/etherip.pla: 0063:     word icmp_chksm
					; icmp_chksm = 2
; libsrc/etherip.pla: 0064:     word[2] icmp_header
					; icmp_header = 4
; libsrc/etherip.pla: 0065: end
					; t_icmp = 8
; libsrc/etherip.pla: 0066: //
; libsrc/etherip.pla: 0067: // UDP IPv4 pseudo header
; libsrc/etherip.pla: 0068: //
; libsrc/etherip.pla: 0069: struc t_piphdr
; libsrc/etherip.pla: 0070:     byte[IP4ADR_SIZE] pip_src
					; pip_src = 0
; libsrc/etherip.pla: 0071:     byte[IP4ADR_SIZE] pip_dst
					; pip_dst = 4
; libsrc/etherip.pla: 0072:     byte              pip_zero
					; pip_zero = 8
; libsrc/etherip.pla: 0073:     byte              pip_proto
					; pip_proto = 9
; libsrc/etherip.pla: 0074:     word              pip_len
					; pip_len = 10
; libsrc/etherip.pla: 0075: end
					; t_piphdr = 12
; libsrc/etherip.pla: 0076: //
; libsrc/etherip.pla: 0077: // UDP header
; libsrc/etherip.pla: 0078: //
; libsrc/etherip.pla: 0079: struc t_udphdr
; libsrc/etherip.pla: 0080:     word udp_src
					; udp_src = 0
; libsrc/etherip.pla: 0081:     word udp_dst
					; udp_dst = 2
; libsrc/etherip.pla: 0082:     word udp_len
					; udp_len = 4
; libsrc/etherip.pla: 0083:     word udp_chksm
					; udp_chksm = 6
; libsrc/etherip.pla: 0084: end
					; t_udphdr = 8
; libsrc/etherip.pla: 0085: //
; libsrc/etherip.pla: 0086: // TCP header
; libsrc/etherip.pla: 0087: //
; libsrc/etherip.pla: 0088: struc t_tcphdr
; libsrc/etherip.pla: 0089:     word tcp_src
					; tcp_src = 0
; libsrc/etherip.pla: 0090:     word tcp_dst
					; tcp_dst = 2
; libsrc/etherip.pla: 0091:     word tcp_len
					; tcp_len = 4
; libsrc/etherip.pla: 0092:     word tcp_chksm
					; tcp_chksm = 6
; libsrc/etherip.pla: 0093: end
					; t_tcphdr = 8
; libsrc/etherip.pla: 0094: //
; libsrc/etherip.pla: 0095: // ARP packet
; libsrc/etherip.pla: 0096: //
; libsrc/etherip.pla: 0097: const HW_ETHER  = $0100 // BE format
					; HW_ETHER = 256
; libsrc/etherip.pla: 0098: const ARP_PROTO = $0008 // BE format
					; ARP_PROTO = 8
; libsrc/etherip.pla: 0099: const ARP_REQST = $0100 // BE format
					; ARP_REQST = 256
; libsrc/etherip.pla: 0100: const ARP_REPLY = $0200 // BE format
					; ARP_REPLY = 512
; libsrc/etherip.pla: 0101: struc t_arp
; libsrc/etherip.pla: 0102:     word arp_hw
					; arp_hw = 0
; libsrc/etherip.pla: 0103:     word arp_prot
					; arp_prot = 2
; libsrc/etherip.pla: 0104:     byte arp_hlen
					; arp_hlen = 4
; libsrc/etherip.pla: 0105:     byte arp_plen
					; arp_plen = 5
; libsrc/etherip.pla: 0106:     word arp_op
					; arp_op = 6
; libsrc/etherip.pla: 0107:     byte[MAC_SIZE]    arp_senderha
					; arp_senderha = 8
; libsrc/etherip.pla: 0108:     byte[IP4ADR_SIZE] arp_senderip
					; arp_senderip = 14
; libsrc/etherip.pla: 0109:     byte[MAC_SIZE]    arp_targha
					; arp_targha = 18
; libsrc/etherip.pla: 0110:     byte[IP4ADR_SIZE] arp_targip
					; arp_targip = 24
; libsrc/etherip.pla: 0111: end
					; t_arp = 28
; libsrc/etherip.pla: 0112: const t_earp = t_ethrhdr+t_arp
					; t_earp = 42
; libsrc/etherip.pla: 0113: //
; libsrc/etherip.pla: 0114: // Pre-configured Ethernet header
; libsrc/etherip.pla: 0115: //
; libsrc/etherip.pla: 0116: byte[] eFrame
_D030 					; eFrame
; libsrc/etherip.pla: 0117: //
; libsrc/etherip.pla: 0118: // Destination MAC address
; libsrc/etherip.pla: 0119: //
; libsrc/etherip.pla: 0120: byte[MAC_SIZE] dstMAC
_D031 	!FILL	6			; dstMAC
; libsrc/etherip.pla: 0121: //
; libsrc/etherip.pla: 0122: // My MAC address
; libsrc/etherip.pla: 0123: //
; libsrc/etherip.pla: 0124: byte[MAC_SIZE] myMAC
_D032 	!FILL	6			; myMAC
; libsrc/etherip.pla: 0125: //
; libsrc/etherip.pla: 0126: // Ethernet payload
; libsrc/etherip.pla: 0127: //
; libsrc/etherip.pla: 0128: word ePayload = PAYLOAD_ARP
_D033 					; ePayload = PAYLOAD_ARP
	!WORD	$0608
; libsrc/etherip.pla: 0129: //
; libsrc/etherip.pla: 0130: // Pre-configured ARP packet - MUST follow ethernet header!
; libsrc/etherip.pla: 0131: //
; libsrc/etherip.pla: 0132: word ARP   = HW_ETHER    // HW TYPE
_D034 					; ARP   = HW_ETHER    // HW TYPE
	!WORD	$0100
; libsrc/etherip.pla: 0133: word       = ARP_PROTO   // PROTO TYPE
	!WORD	$0008
; libsrc/etherip.pla: 0134: byte       = MAC_SIZE    // HLEN
	!BYTE	$06
; libsrc/etherip.pla: 0135: byte       = IP4ADR_SIZE // PLEN
	!BYTE	$04
; libsrc/etherip.pla: 0136: word opARP               // OP
_D035 	!FILL	2			; opARP               // OP
; libsrc/etherip.pla: 0137: export byte[MAC_SIZE]    localha
_D036 	!FILL	6			; localha
; libsrc/etherip.pla: 0138: export byte[IP4ADR_SIZE] localip
_D037 	!FILL	4			; localip
; libsrc/etherip.pla: 0139: byte[MAC_SIZE]           remoteha
_D038 	!FILL	6			; remoteha
; libsrc/etherip.pla: 0140: byte[IP4ADR_SIZE]        remoteip
_D039 	!FILL	4			; remoteip
; libsrc/etherip.pla: 0141: //
; libsrc/etherip.pla: 0142: // Local network parameters
; libsrc/etherip.pla: 0143: //
; libsrc/etherip.pla: 0144: byte[IP4ADR_SIZE] netmask
_D040 	!FILL	4			; netmask
; libsrc/etherip.pla: 0145: byte[IP4ADR_SIZE] subnet
_D041 	!FILL	4			; subnet
; libsrc/etherip.pla: 0146: byte[IP4ADR_SIZE] gateway
_D042 	!FILL	4			; gateway
; libsrc/etherip.pla: 0147: const MAX_UDP_NOTIFIES    = 4
					; MAX_UDP_NOTIFIES = 4
; libsrc/etherip.pla: 0148: const MAX_TCP_NOTIFIES    = 4
					; MAX_TCP_NOTIFIES = 4
; libsrc/etherip.pla: 0149: //
; libsrc/etherip.pla: 0150: // Notify callbacks
; libsrc/etherip.pla: 0151: //
; libsrc/etherip.pla: 0152: struc t_notify
; libsrc/etherip.pla: 0153:     word notify_port
					; notify_port = 0
; libsrc/etherip.pla: 0154:     word notify_func
					; notify_func = 2
; libsrc/etherip.pla: 0155:     word notify_parm
					; notify_parm = 4
; libsrc/etherip.pla: 0156: end
					; t_notify = 6
; libsrc/etherip.pla: 0157: byte[t_notify] portsUDP[MAX_UDP_NOTIFIES]
_D043 	!FILL	24			; portsUDP[MAX_UDP_NOTIFIES]
; libsrc/etherip.pla: 0158: byte[t_notify] portsTCP[MAX_TCP_NOTIFIES]
_D044 	!FILL	24			; portsTCP[MAX_TCP_NOTIFIES]
; libsrc/etherip.pla: 0159: //
; libsrc/etherip.pla: 0160: // Service ICMP hook
; libsrc/etherip.pla: 0161: //
; libsrc/etherip.pla: 0162: export word hookICMP
_D045 	!FILL	2			; hookICMP
; libsrc/etherip.pla: 0163: //
; libsrc/etherip.pla: 0164: // Ethernet driver entrypoints
; libsrc/etherip.pla: 0165: //
; libsrc/etherip.pla: 0166: word setFrameLen, writeFrame, getFrameLen, readFrame
_D046 	!FILL	2			; setFrameLen, writeFrame, getFrameLen, readFrame
_D047 	!FILL	2			; writeFrame, getFrameLen, readFrame
_D048 	!FILL	2			; getFrameLen, readFrame
_D049 	!FILL	2			; readFrame
; libsrc/etherip.pla: 0167: //
; libsrc/etherip.pla: 0168: // Defines for ASM routines
; libsrc/etherip.pla: 0169: //
; libsrc/etherip.pla: 0170: asm equates
_A000 					; equates()
; libsrc/etherip.pla: 0171:     !SOURCE    "vmsrc/plvmzp.inc"
    !SOURCE    "vmsrc/plvmzp.inc"
; libsrc/etherip.pla: 0172: end
; libsrc/etherip.pla: 0173: //
; libsrc/etherip.pla: 0174: // Swap bytes in word
; libsrc/etherip.pla: 0175: //
; libsrc/etherip.pla: 0176: asm swab(val)
_A001 					; swab()
; libsrc/etherip.pla: 0177:     LDA    ESTKL,X
    LDA    ESTKL,X
; libsrc/etherip.pla: 0178:     LDY    ESTKH,X
    LDY    ESTKH,X
; libsrc/etherip.pla: 0179:     STA    ESTKH,X
    STA    ESTKH,X
; libsrc/etherip.pla: 0180:     STY    ESTKL,X
    STY    ESTKL,X
; libsrc/etherip.pla: 0181:     RTS
    RTS
; libsrc/etherip.pla: 0182: end
; libsrc/etherip.pla: 0183: //
; libsrc/etherip.pla: 0184: // 1'S COMPLIMENT SUM BE format
; libsrc/etherip.pla: 0185: // sum1(PREVSUM, BUF, LEN)
; libsrc/etherip.pla: 0186: //
; libsrc/etherip.pla: 0187: asm sum1(prevsum, buf, len)
_A002 					; sum1()
; libsrc/etherip.pla: 0188:     LDY    #$00
    LDY    #$00
; libsrc/etherip.pla: 0189:     LDA    ESTKL+1,X
    LDA    ESTKL+1,X
; libsrc/etherip.pla: 0190:     STA    SRCL
    STA    SRCL
; libsrc/etherip.pla: 0191:     LDA    ESTKH+1,X
    LDA    ESTKH+1,X
; libsrc/etherip.pla: 0192:     STA    SRCH
    STA    SRCH
; libsrc/etherip.pla: 0193:     LSR    ESTKH,X     ; CONVERT BYTE LEN TO WORD LEN
    LSR    ESTKH,X     ; CONVERT BYTE LEN TO WORD LEN
; libsrc/etherip.pla: 0194:     LDA    ESTKL,X
    LDA    ESTKL,X
; libsrc/etherip.pla: 0195:     ROR
    ROR
; libsrc/etherip.pla: 0196:     ADC    #$00
    ADC    #$00
; libsrc/etherip.pla: 0197:     STA    ESTKL,X
    STA    ESTKL,X
; libsrc/etherip.pla: 0198:     BEQ    +
    BEQ    +
; libsrc/etherip.pla: 0199:     !BYTE  $A9
    !BYTE  $A9
; libsrc/etherip.pla: 0200: -   CLC
-   CLC
; libsrc/etherip.pla: 0201:     INC    ESTKH,X
    INC    ESTKH,X
; libsrc/etherip.pla: 0202: +   BCS    -
+   BCS    -
; libsrc/etherip.pla: 0203: CHKLP     LDA  (SRC),Y
CHKLP     LDA  (SRC),Y
; libsrc/etherip.pla: 0204:     PHA
    PHA
; libsrc/etherip.pla: 0205:     INY
    INY
; libsrc/etherip.pla: 0206:     BNE    +
    BNE    +
; libsrc/etherip.pla: 0207:     INC    SRCH
    INC    SRCH
; libsrc/etherip.pla: 0208: +   LDA    (SRC),Y
+   LDA    (SRC),Y
; libsrc/etherip.pla: 0209:     ADC    ESTKH+2,X
    ADC    ESTKH+2,X
; libsrc/etherip.pla: 0210:     STA    ESTKH+2,X
    STA    ESTKH+2,X
; libsrc/etherip.pla: 0211:     PLA
    PLA
; libsrc/etherip.pla: 0212:     ADC    ESTKL+2,X
    ADC    ESTKL+2,X
; libsrc/etherip.pla: 0213:     STA    ESTKL+2,X
    STA    ESTKL+2,X
; libsrc/etherip.pla: 0214:     INY
    INY
; libsrc/etherip.pla: 0215:     BNE    +
    BNE    +
; libsrc/etherip.pla: 0216:     INC    SRCH
    INC    SRCH
; libsrc/etherip.pla: 0217: +   DEC    ESTKL,X
+   DEC    ESTKL,X
; libsrc/etherip.pla: 0218:     BNE    CHKLP
    BNE    CHKLP
; libsrc/etherip.pla: 0219:     DEC    ESTKH,X
    DEC    ESTKH,X
; libsrc/etherip.pla: 0220:     BNE    CHKLP
    BNE    CHKLP
; libsrc/etherip.pla: 0221:     BCC    +
    BCC    +
; libsrc/etherip.pla: 0222: -   INC    ESTKH+2,X
-   INC    ESTKH+2,X
; libsrc/etherip.pla: 0223:     BNE    +
    BNE    +
; libsrc/etherip.pla: 0224:     INC    ESTKL+2,X
    INC    ESTKL+2,X
; libsrc/etherip.pla: 0225:     BEQ    -
    BEQ    -
; libsrc/etherip.pla: 0226: +   INX
+   INX
; libsrc/etherip.pla: 0227:     INX
    INX
; libsrc/etherip.pla: 0228:     RTS
    RTS
; libsrc/etherip.pla: 0229: end
; libsrc/etherip.pla: 0230: //
; libsrc/etherip.pla: 0231: // Send IP datagram
; libsrc/etherip.pla: 0232: //
; libsrc/etherip.pla: 0233: def etherSendIP(ipdst, proto, seglist, size)
_SUBSEG 				; BYTECODE STARTS
					; ipdst -> [0]
					; proto -> [2]
					; seglist -> [4]
					; size -> [6]
_C000 					; etherSendIP()
; libsrc/etherip.pla: 0234:     byte[t_iphdr] hdr
					; hdr -> [8]
; libsrc/etherip.pla: 0235:     byte retry
					; retry -> [28]
; libsrc/etherip.pla: 0236:     word timeout
					; timeout -> [29]
; libsrc/etherip.pla: 0237: 
; libsrc/etherip.pla: 0238:     hdr.ip_vers_hlen      = $45
	!BYTE	$58,$1F,$04		; ENTER	31,4
; libsrc/etherip.pla: 0239:     hdr.ip_service        = 0
; libsrc/etherip.pla: 0240:     hdr:ip_length         = swab(t_iphdr + size)
; libsrc/etherip.pla: 0241:     hdr:ip_id             = 0
; libsrc/etherip.pla: 0242:     hdr:ip_flags_fragofst = 0 //$40 // Don't fragment
; libsrc/etherip.pla: 0243:     hdr.ip_ttl            = 10 // Is this reasonable?
; libsrc/etherip.pla: 0244:     hdr.ip_proto          = proto
; libsrc/etherip.pla: 0245:     hdr:ip_chksm          = 0
; libsrc/etherip.pla: 0246:     memcpy(@hdr.ip_src, @localip, IP4ADR_SIZE)
; libsrc/etherip.pla: 0247:     if !ipdst // IP_BROADCAST
; libsrc/etherip.pla: 0248:         memset(@hdr.ip_dst, IP_BROADCAST, IP4ADR_SIZE)
; libsrc/etherip.pla: 0249:         memset(@dstMAC, MAC_BROADCAST, MAC_SIZE)
; libsrc/etherip.pla: 0250:     else
	!BYTE	$2A,$45			; CB	69
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$00			; CN	0
	!BYTE	$74,$09			; SLB	[9]
	!BYTE	$2A,$14			; CB	20
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$54			; CALL	_A001
_F000 	!WORD	_A001		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$00			; CN	0
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$00			; CN	0
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$14			; CN	10
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$74,$11			; SLB	[17]
	!BYTE	$00			; CN	0
	!BYTE	$76,$12			; SLW	[18]
	!BYTE	$28,$14			; LLA	[20]
	!BYTE	$26			; LA	_D037+0
_F001 	!WORD	_D037+0		
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_X018
_F002 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B001
	!WORD	_B001-*
	!BYTE	$28,$18			; LLA	[24]
	!BYTE	$20			; MINUS ONE
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_X017
_F003 	!WORD	0		
	!BYTE	$26			; LA	_D031+0
_F004 	!WORD	_D031+0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$0C			; CN	6
	!BYTE	$54			; CALL	_X017
_F005 	!WORD	0		
	!BYTE	$50			; BRNCH	_B002
	!WORD	_B002-*
_B001 
; libsrc/etherip.pla: 0251:         if ipdst=>0 & netmask:0 <> subnet:0 or ipdst=>2 & netmask:2 <> subnet:2
; libsrc/etherip.pla: 0252:             ipdst = @gateway // External net destination
; libsrc/etherip.pla: 0253:         fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D040+0
_F006 	!WORD	_D040+0		
	!BYTE	$94			; AND 
	!BYTE	$6A			; LAW	_D041+0
_F007 	!WORD	_D041+0		
	!BYTE	$42			; ISNE
	!BYTE	$AE			; BROR	_B003
	!WORD	_B003-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D040+2
_F008 	!WORD	_D040+2		
	!BYTE	$94			; AND 
	!BYTE	$6A			; LAW	_D041+2
_F009 	!WORD	_D041+2		
	!BYTE	$42			; ISNE
_B003 
	!BYTE	$4C			; BRFLS	_B004
	!WORD	_B004-*
	!BYTE	$26			; LA	_D042+0
_F010 	!WORD	_D042+0		
	!BYTE	$76,$00			; SLW	[0]
_B004 
_B005 
; libsrc/etherip.pla: 0254:         memcpy(@hdr.ip_dst, ipdst, IP4ADR_SIZE)
; libsrc/etherip.pla: 0255:         retry = 0
; libsrc/etherip.pla: 0256:         while hdr:ip_dst:0 <> remoteip:0 and hdr:ip_dst:2 <> remoteip:2
	!BYTE	$28,$18			; LLA	[24]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_X018
_F011 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$74,$1C			; SLB	[28]
	!BYTE	$50			; BRNCH	_B008
	!WORD	_B008-*
_B006 
; libsrc/etherip.pla: 0257:             if retry >= 3
; libsrc/etherip.pla: 0258:                 return -1 // ARP failed
	!BYTE	$64,$1C			; LLB	[28]
	!BYTE	$06			; CN	3
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B010
	!WORD	_B010-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$1F			; LEAVE	31
; libsrc/etherip.pla: 0259:             fin
_B010 
_B011 
; libsrc/etherip.pla: 0260:             retry++
	!BYTE	$64,$1C			; LLB	[28]
	!BYTE	$8C			; INCR
; libsrc/etherip.pla: 0261:             memset(@dstMAC,   MAC_BROADCAST, MAC_SIZE)
; libsrc/etherip.pla: 0262:             memset(@remoteha, 0,             MAC_SIZE)
; libsrc/etherip.pla: 0263:             memcpy(@remoteip, @hdr.ip_dst,   IP4ADR_SIZE)
; libsrc/etherip.pla: 0264:             ePayload = PAYLOAD_ARP
; libsrc/etherip.pla: 0265:             opARP    = ARP_REQST
; libsrc/etherip.pla: 0266:             setFrameLen(t_earp)
; libsrc/etherip.pla: 0267:             writeFrame(@eFrame, t_earp)
; libsrc/etherip.pla: 0268:             for timeout = 1000 downto 0
	!BYTE	$74,$1C			; SLB	[28]
	!BYTE	$26			; LA	_D031+0
_F012 	!WORD	_D031+0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$0C			; CN	6
	!BYTE	$54			; CALL	_X017
_F013 	!WORD	0		
	!BYTE	$26			; LA	_D038+0
_F014 	!WORD	_D038+0		
	!BYTE	$00			; CN	0
	!BYTE	$0C			; CN	6
	!BYTE	$54			; CALL	_X017
_F015 	!WORD	0		
	!BYTE	$26			; LA	_D039+0
_F016 	!WORD	_D039+0		
	!BYTE	$28,$18			; LLA	[24]
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_X018
_F017 	!WORD	0		
	!BYTE	$2C,$08,$06		; CW	1544
	!BYTE	$7A			; SAW	_D033+0
_F018 	!WORD	_D033+0		
	!BYTE	$2C,$00,$01		; CW	256
	!BYTE	$7A			; SAW	_D035+0
_F019 	!WORD	_D035+0		
	!BYTE	$2A,$2A			; CB	42
	!BYTE	$6A			; LAW	_D046+0
_F020 	!WORD	_D046+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D030+0
_F021 	!WORD	_D030+0		
	!BYTE	$2A,$2A			; CB	42
	!BYTE	$6A			; LAW	_D047+0
_F022 	!WORD	_D047+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$2C,$E8,$03		; CW	1000
_B013 
	!BYTE	$6E,$1D			; DLW	[29]
; libsrc/etherip.pla: 0269:                 etherServiceIP
; libsrc/etherip.pla: 0270:                 if remoteha:0 | remoteha:2 | remoteha:4
; libsrc/etherip.pla: 0271:                     break
	!BYTE	$54			; CALL	_P000
_F023 	!WORD	_P000		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D038+0
_F024 	!WORD	_D038+0		
	!BYTE	$6A			; LAW	_D038+2
_F025 	!WORD	_D038+2		
	!BYTE	$96			; OR 
	!BYTE	$6A			; LAW	_D038+4
_F026 	!WORD	_D038+4		
	!BYTE	$96			; OR 
	!BYTE	$4C			; BRFLS	_B015
	!WORD	_B015-*
	!BYTE	$50			; BRNCH	_B012
	!WORD	_B012-*
; libsrc/etherip.pla: 0272:                 fin
_B015 
_B016 
; libsrc/etherip.pla: 0273:             next
_B014 
	!BYTE	$A8			; DECBRGE	_B013
	!WORD	_B013-*
_B012 
	!BYTE	$76,$1D			; SLW	[29]
	!BYTE	$30			; DROP 
; libsrc/etherip.pla: 0274:         loop
_B008 
	!BYTE	$66,$18			; LLW	[24]
	!BYTE	$6A			; LAW	_D039+0
_F027 	!WORD	_D039+0		
	!BYTE	$42			; ISNE
	!BYTE	$AC			; BRAND	_B009
	!WORD	_B009-*
	!BYTE	$28,$18			; LLA	[24]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D039+2
_F028 	!WORD	_D039+2		
	!BYTE	$42			; ISNE
_B009 
	!BYTE	$4E			; BRTRU	_B006
	!WORD	_B006-*
_B007 
; libsrc/etherip.pla: 0275:         memcpy(@dstMAC, @remoteha, MAC_SIZE)
; libsrc/etherip.pla: 0276:     fin
	!BYTE	$26			; LA	_D031+0
_F029 	!WORD	_D031+0		
	!BYTE	$26			; LA	_D038+0
_F030 	!WORD	_D038+0		
	!BYTE	$0C			; CN	6
	!BYTE	$54			; CALL	_X018
_F031 	!WORD	0		
_B002 
; libsrc/etherip.pla: 0277:     //
; libsrc/etherip.pla: 0278:     // Calculate checksum
; libsrc/etherip.pla: 0279:     //
; libsrc/etherip.pla: 0280:     hdr:ip_chksm = sum1(0, @hdr, t_iphdr) ^ $FFFF
; libsrc/etherip.pla: 0281:     //
; libsrc/etherip.pla: 0282:     // set the ethernet payload and frame length
; libsrc/etherip.pla: 0283:     //
; libsrc/etherip.pla: 0284:     ePayload = PAYLOAD_IP
; libsrc/etherip.pla: 0285:     setFrameLen(t_ethriphdr + size)
; libsrc/etherip.pla: 0286:     //
; libsrc/etherip.pla: 0287:     // Write the ethernet header
; libsrc/etherip.pla: 0288:     //
; libsrc/etherip.pla: 0289:     writeFrame(@eFrame, t_ethrhdr)
; libsrc/etherip.pla: 0290:     //
; libsrc/etherip.pla: 0291:     // Write the IP header
; libsrc/etherip.pla: 0292:     //
; libsrc/etherip.pla: 0293:     writeFrame(@hdr, t_iphdr)
; libsrc/etherip.pla: 0294:     //
; libsrc/etherip.pla: 0295:     // Write the remaining segments
; libsrc/etherip.pla: 0296:     //
; libsrc/etherip.pla: 0297:     while size > 0
	!BYTE	$00			; CN	0
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$2A,$14			; CB	20
	!BYTE	$54			; CALL	_A002
_F032 	!WORD	_A002		
	!BYTE	$20			; MINUS ONE
	!BYTE	$98			; XOR
	!BYTE	$76,$12			; SLW	[18]
	!BYTE	$10			; CN	8
	!BYTE	$7A			; SAW	_D033+0
_F033 	!WORD	_D033+0		
	!BYTE	$2A,$22			; CB	34
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$6A			; LAW	_D046+0
_F034 	!WORD	_D046+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D030+0
_F035 	!WORD	_D030+0		
	!BYTE	$1C			; CN	14
	!BYTE	$6A			; LAW	_D047+0
_F036 	!WORD	_D047+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$2A,$14			; CB	20
	!BYTE	$6A			; LAW	_D047+0
_F037 	!WORD	_D047+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B019
	!WORD	_B019-*
_B017 
; libsrc/etherip.pla: 0298:         writeFrame(seglist=>seg_buf, seglist=>seg_len)
; libsrc/etherip.pla: 0299:         size    = size - seglist=>seg_len
; libsrc/etherip.pla: 0300:         seglist = seglist + t_segment
; libsrc/etherip.pla: 0301:     loop
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D047+0
_F038 	!WORD	_D047+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$84			; SUB 
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$76,$04			; SLW	[4]
_B019 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B017
	!WORD	_B017-*
_B018 
; libsrc/etherip.pla: 0302:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$1F			; LEAVE	31
; libsrc/etherip.pla: 0303: end
; libsrc/etherip.pla: 0304: //
; libsrc/etherip.pla: 0305: // Send UDP datagram
; libsrc/etherip.pla: 0306: //
; libsrc/etherip.pla: 0307: def etherSendUDP(port, ipdst, portdst, data, len)
					; port -> [0]
					; ipdst -> [2]
					; portdst -> [4]
					; data -> [6]
					; len -> [8]
_C001 					; etherSendUDP()
; libsrc/etherip.pla: 0308:     word[8] seglist // list of data and header segments
					; seglist -> [10]
; libsrc/etherip.pla: 0309:     byte[t_udphdr] hdr
					; hdr -> [26]
; libsrc/etherip.pla: 0310: 
; libsrc/etherip.pla: 0311:     hdr:udp_src       = swab(port=>notify_port)
	!BYTE	$58,$22,$05		; ENTER	34,5
; libsrc/etherip.pla: 0312:     hdr:udp_dst       = swab(portdst)
; libsrc/etherip.pla: 0313:     hdr:udp_len       = swab(t_udphdr + len)
; libsrc/etherip.pla: 0314:     hdr:udp_chksm     = 0
; libsrc/etherip.pla: 0315:     seglist:0:seg_buf = @hdr
; libsrc/etherip.pla: 0316:     seglist:0:seg_len = t_udphdr
; libsrc/etherip.pla: 0317:     seglist:4:seg_buf = data
; libsrc/etherip.pla: 0318:     seglist:4:seg_len = len
; libsrc/etherip.pla: 0319:     return etherSendIP(ipdst, IP_PROTO_UDP, @seglist, t_udphdr + len)
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_A001
_F039 	!WORD	_A001		
	!BYTE	$76,$1A			; SLW	[26]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_A001
_F040 	!WORD	_A001		
	!BYTE	$76,$1C			; SLW	[28]
	!BYTE	$10			; CN	8
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$54			; CALL	_A001
_F041 	!WORD	_A001		
	!BYTE	$76,$1E			; SLW	[30]
	!BYTE	$00			; CN	0
	!BYTE	$76,$20			; SLW	[32]
	!BYTE	$28,$1A			; LLA	[26]
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$10			; CN	8
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$28,$0E			; LLA	[14]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$11			; CB	17
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$10			; CN	8
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$54			; CALL	_C000
_F042 	!WORD	_C000		
	!BYTE	$5A,$22			; LEAVE	34
; libsrc/etherip.pla: 0320: end
; libsrc/etherip.pla: 0321: //
; libsrc/etherip.pla: 0322: // Notify on UDP datagram received
; libsrc/etherip.pla: 0323: //
; libsrc/etherip.pla: 0324: def etherOpenUDP(localport, callback, param)
					; localport -> [0]
					; callback -> [2]
					; param -> [4]
_C002 					; etherOpenUDP()
; libsrc/etherip.pla: 0325:     word port
					; port -> [6]
; libsrc/etherip.pla: 0326:     byte i
					; i -> [8]
; libsrc/etherip.pla: 0327: 
; libsrc/etherip.pla: 0328:     if !localport; return -1; fin // invalid port
	!BYTE	$58,$09,$03		; ENTER	9,3
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B020
	!WORD	_B020-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$09			; LEAVE	9
_B020 
_B021 
; libsrc/etherip.pla: 0329:     //
; libsrc/etherip.pla: 0330:     // Look for an existing notification on localport
; libsrc/etherip.pla: 0331:     //
; libsrc/etherip.pla: 0332:     port = @portsUDP
; libsrc/etherip.pla: 0333:     for i = 1 to MAX_UDP_NOTIFIES
	!BYTE	$26			; LA	_D043+0
_F043 	!WORD	_D043+0		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$08			; CN	4
	!BYTE	$02			; CN	1
_B023 
	!BYTE	$6C,$08			; DLB	[8]
; libsrc/etherip.pla: 0334:         if port=>notify_port == localport
; libsrc/etherip.pla: 0335:             port=>notify_func = callback
; libsrc/etherip.pla: 0336:             port=>notify_parm = param
; libsrc/etherip.pla: 0337:             return port
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$24			; BRNE	_B025
	!WORD	_B025-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$32			; DROP2
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$5A,$09			; LEAVE	9
; libsrc/etherip.pla: 0338:         fin
_B025 
_B026 
; libsrc/etherip.pla: 0339:         port = port + t_notify
; libsrc/etherip.pla: 0340:     next
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$76,$06			; SLW	[6]
_B024 
	!BYTE	$A4			; INCBRLE	_B023
	!WORD	_B023-*
_B022 
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$30			; DROP 
; libsrc/etherip.pla: 0341:     //
; libsrc/etherip.pla: 0342:     // Add notification on localport if room
; libsrc/etherip.pla: 0343:     //
; libsrc/etherip.pla: 0344:     port = @portsUDP
; libsrc/etherip.pla: 0345:     for i = 1 to MAX_UDP_NOTIFIES
	!BYTE	$26			; LA	_D043+0
_F044 	!WORD	_D043+0		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$08			; CN	4
	!BYTE	$02			; CN	1
_B028 
	!BYTE	$6C,$08			; DLB	[8]
; libsrc/etherip.pla: 0346:         if !port=>notify_port
; libsrc/etherip.pla: 0347:             port=>notify_port = localport
; libsrc/etherip.pla: 0348:             port=>notify_func = callback
; libsrc/etherip.pla: 0349:             port=>notify_parm = param
; libsrc/etherip.pla: 0350:             return port
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B030
	!WORD	_B030-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$32			; DROP2
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$5A,$09			; LEAVE	9
; libsrc/etherip.pla: 0351:         fin
_B030 
_B031 
; libsrc/etherip.pla: 0352:         port = port + t_notify
; libsrc/etherip.pla: 0353:     next
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$76,$06			; SLW	[6]
_B029 
	!BYTE	$A4			; INCBRLE	_B028
	!WORD	_B028-*
_B027 
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$30			; DROP 
; libsrc/etherip.pla: 0354:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$09			; LEAVE	9
; libsrc/etherip.pla: 0355: end
; libsrc/etherip.pla: 0356: //
; libsrc/etherip.pla: 0357: // Clear notify on UDP port
; libsrc/etherip.pla: 0358: //
; libsrc/etherip.pla: 0359: def etherCloseUDP(port)
					; port -> [0]
_C003 					; etherCloseUDP()
; libsrc/etherip.pla: 0360:     word port
					; port -> [2]
; libsrc/etherip.pla: 0361:     byte i
					; i -> [4]
; libsrc/etherip.pla: 0362: 
; libsrc/etherip.pla: 0363:     if isuge(port, @portsUDP) and isult(port, @portsUDP + MAX_UDP_NOTIFIES * t_notify)
	!BYTE	$58,$05,$01		; ENTER	5,1
; libsrc/etherip.pla: 0364:         //
; libsrc/etherip.pla: 0365:         // Clear notiications on this port
; libsrc/etherip.pla: 0366:         //
; libsrc/etherip.pla: 0367:         if port=>notify_port
; libsrc/etherip.pla: 0368:             port=>notify_port = 0
; libsrc/etherip.pla: 0369:             return 0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D043+0
_F045 	!WORD	_D043+0		
	!BYTE	$54			; CALL	_X025
_F046 	!WORD	0		
	!BYTE	$AC			; BRAND	_B032
	!WORD	_B032-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D043+24
_F047 	!WORD	_D043+24		
	!BYTE	$54			; CALL	_X026
_F048 	!WORD	0		
_B032 
	!BYTE	$4C			; BRFLS	_B033
	!WORD	_B033-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B035
	!WORD	_B035-*
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$5A,$05			; LEAVE	5
; libsrc/etherip.pla: 0370:         fin
_B035 
_B036 
; libsrc/etherip.pla: 0371:     fin
_B033 
_B034 
; libsrc/etherip.pla: 0372:     //
; libsrc/etherip.pla: 0373:     // Invalid port
; libsrc/etherip.pla: 0374:     //
; libsrc/etherip.pla: 0375:     return -1
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$05			; LEAVE	5
; libsrc/etherip.pla: 0376: end
; libsrc/etherip.pla: 0377: //
; libsrc/etherip.pla: 0378: // Open TCP socket in SERVER mode
; libsrc/etherip.pla: 0379: //
; libsrc/etherip.pla: 0380: def etherListenTCP(lclport, callback, param)
					; lclport -> [0]
					; callback -> [2]
					; param -> [4]
_C004 					; etherListenTCP()
; libsrc/etherip.pla: 0381:     puts("TCP/IP not yet implented for this hardware.\n")
	!BYTE	$58,$06,$03		; ENTER	6,3
	!BYTE	$2E			; CS
	!BYTE	$2C
	!BYTE	$54,$43,$50,$2F,$49,$50,$20,$6E
	!BYTE	$6F,$74,$20,$79,$65,$74,$20,$69
	!BYTE	$6D,$70,$6C,$65,$6E,$74,$65,$64
	!BYTE	$20,$66,$6F,$72,$20,$74,$68,$69
	!BYTE	$73,$20,$68,$61,$72,$64,$77,$61
	!BYTE	$72,$65,$2E,$0D
	!BYTE	$54			; CALL	_X004
_F049 	!WORD	0		
; libsrc/etherip.pla: 0382:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/etherip.pla: 0383: end
; libsrc/etherip.pla: 0384: //
; libsrc/etherip.pla: 0385: // Open TCP socket in CLIENT mode
; libsrc/etherip.pla: 0386: //
; libsrc/etherip.pla: 0387: def etherConnectTCP(remip, remport, lclport, callback, param)
					; remip -> [0]
					; remport -> [2]
					; lclport -> [4]
					; callback -> [6]
					; param -> [8]
_C005 					; etherConnectTCP()
; libsrc/etherip.pla: 0388:     puts("TCP/IP not yet implented for this hardware.\n")
	!BYTE	$58,$0A,$05		; ENTER	10,5
	!BYTE	$2E			; CS
	!BYTE	$2C
	!BYTE	$54,$43,$50,$2F,$49,$50,$20,$6E
	!BYTE	$6F,$74,$20,$79,$65,$74,$20,$69
	!BYTE	$6D,$70,$6C,$65,$6E,$74,$65,$64
	!BYTE	$20,$66,$6F,$72,$20,$74,$68,$69
	!BYTE	$73,$20,$68,$61,$72,$64,$77,$61
	!BYTE	$72,$65,$2E,$0D
	!BYTE	$54			; CALL	_X004
_F050 	!WORD	0		
; libsrc/etherip.pla: 0389:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$0A			; LEAVE	10
; libsrc/etherip.pla: 0390: end
; libsrc/etherip.pla: 0391: //
; libsrc/etherip.pla: 0392: // Write to TCP socket
; libsrc/etherip.pla: 0393: //
; libsrc/etherip.pla: 0394: def etherSendTCP(wiz, data, len)
					; wiz -> [0]
					; data -> [2]
					; len -> [4]
_C006 					; etherSendTCP()
; libsrc/etherip.pla: 0395:     return 0
	!BYTE	$58,$06,$03		; ENTER	6,3
	!BYTE	$00			; CN	0
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/etherip.pla: 0396: end
; libsrc/etherip.pla: 0397: //
; libsrc/etherip.pla: 0398: // Close TCP socket
; libsrc/etherip.pla: 0399: //
; libsrc/etherip.pla: 0400: def etherCloseTCP(wiz)
					; wiz -> [0]
_C007 					; etherCloseTCP()
; libsrc/etherip.pla: 0401:     return 0
	!BYTE	$58,$02,$01		; ENTER	2,1
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/etherip.pla: 0402: end
; libsrc/etherip.pla: 0403: //
; libsrc/etherip.pla: 0404: // Update notify callback
; libsrc/etherip.pla: 0405: //
; libsrc/etherip.pla: 0406: def etherSetCallback(port, callback)
					; port -> [0]
					; callback -> [2]
_C008 					; etherSetCallback()
; libsrc/etherip.pla: 0407:     if isuge(port, @portsUDP) and isult(port, @portsUDP + MAX_UDP_NOTIFIES * t_notify)
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/etherip.pla: 0408:         //
; libsrc/etherip.pla: 0409:         // Update callback on this port
; libsrc/etherip.pla: 0410:         //
; libsrc/etherip.pla: 0411:         if port=>notify_port
; libsrc/etherip.pla: 0412:                 port=>notify_func = callback
; libsrc/etherip.pla: 0413:             return 0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D043+0
_F051 	!WORD	_D043+0		
	!BYTE	$54			; CALL	_X025
_F052 	!WORD	0		
	!BYTE	$AC			; BRAND	_B037
	!WORD	_B037-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D043+24
_F053 	!WORD	_D043+24		
	!BYTE	$54			; CALL	_X026
_F054 	!WORD	0		
_B037 
	!BYTE	$4C			; BRFLS	_B038
	!WORD	_B038-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B040
	!WORD	_B040-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/etherip.pla: 0414:         fin
_B040 
_B041 
; libsrc/etherip.pla: 0415:     fin
_B038 
_B039 
; libsrc/etherip.pla: 0416:     //
; libsrc/etherip.pla: 0417:     // Invalid port
; libsrc/etherip.pla: 0418:     //
; libsrc/etherip.pla: 0419:     return -1
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/etherip.pla: 0420: end
; libsrc/etherip.pla: 0421: //
; libsrc/etherip.pla: 0422: // Update notify param
; libsrc/etherip.pla: 0423: //
; libsrc/etherip.pla: 0424: def etherSetParam(port, param)
					; port -> [0]
					; param -> [2]
_C009 					; etherSetParam()
; libsrc/etherip.pla: 0425:     if isuge(port, @portsUDP) and isult(port, @portsUDP + MAX_UDP_NOTIFIES * t_notify)
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/etherip.pla: 0426:         //
; libsrc/etherip.pla: 0427:         // Update callback on this port
; libsrc/etherip.pla: 0428:         //
; libsrc/etherip.pla: 0429:         if port=>notify_port
; libsrc/etherip.pla: 0430:                 port=>notify_parm = param
; libsrc/etherip.pla: 0431:             return 0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D043+0
_F055 	!WORD	_D043+0		
	!BYTE	$54			; CALL	_X025
_F056 	!WORD	0		
	!BYTE	$AC			; BRAND	_B042
	!WORD	_B042-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D043+24
_F057 	!WORD	_D043+24		
	!BYTE	$54			; CALL	_X026
_F058 	!WORD	0		
_B042 
	!BYTE	$4C			; BRFLS	_B043
	!WORD	_B043-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B045
	!WORD	_B045-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/etherip.pla: 0432:         fin
_B045 
_B046 
; libsrc/etherip.pla: 0433:     fin
_B043 
_B044 
; libsrc/etherip.pla: 0434:     //
; libsrc/etherip.pla: 0435:     // Invalid port
; libsrc/etherip.pla: 0436:     //
; libsrc/etherip.pla: 0437:     return -1
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/etherip.pla: 0438: end
; libsrc/etherip.pla: 0439: //
; libsrc/etherip.pla: 0440: // Service incoming packets
; libsrc/etherip.pla: 0441: //
; libsrc/etherip.pla: 0442: def etherServiceIP
_P000 					; etherServiceIP()
_C010 					; etherServiceIP()
; libsrc/etherip.pla: 0443:     word rxsize, rxpacket, rxptr
					; rxsize -> [0]
					; rxpacket -> [2]
					; rxptr -> [4]
; libsrc/etherip.pla: 0444:     word iphdr, opt, optlen, port, lclport, remport
					; iphdr -> [6]
					; opt -> [8]
					; optlen -> [10]
					; port -> [12]
					; lclport -> [14]
					; remport -> [16]
; libsrc/etherip.pla: 0445:     byte i,   echolen
					; i -> [18]
					; echolen -> [19]
; libsrc/etherip.pla: 0446:     word[4]   seglist
					; seglist -> [20]
; libsrc/etherip.pla: 0447:     byte[128] echo_reply
					; echo_reply -> [28]
; libsrc/etherip.pla: 0448: 
; libsrc/etherip.pla: 0449:     //
; libsrc/etherip.pla: 0450:     // Check for received packet
; libsrc/etherip.pla: 0451:     //
; libsrc/etherip.pla: 0452:     rxsize = getFrameLen()
	!BYTE	$58,$9C,$00		; ENTER	156,0
; libsrc/etherip.pla: 0453:     if rxsize
; libsrc/etherip.pla: 0454:         //
; libsrc/etherip.pla: 0455:         // Read the entire packet into memory
; libsrc/etherip.pla: 0456:         //
; libsrc/etherip.pla: 0457:         rxpacket = heapalloc(rxsize)
; libsrc/etherip.pla: 0458:         readFrame(rxpacket, rxsize)
; libsrc/etherip.pla: 0459:         rxptr  = rxpacket + t_ethrhdr
; libsrc/etherip.pla: 0460:         rxsize = rxsize   - t_ethrhdr
; libsrc/etherip.pla: 0461:         //
; libsrc/etherip.pla: 0462:         // What kind of packet is it?
; libsrc/etherip.pla: 0463:         //
; libsrc/etherip.pla: 0464:         when rxpacket=>ethr_payload
	!BYTE	$6A			; LAW	_D048+0
_F059 	!WORD	_D048+0		
	!BYTE	$56			; ICAL
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4C			; BRFLS	_B047
	!WORD	_B047-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X014
_F060 	!WORD	0		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D049+0
_F061 	!WORD	_D049+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3A,$0E			; SUBI	14
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$62			; LW
	!BYTE	$52			; SEL
	!WORD	_B050-*
; libsrc/etherip.pla: 0465:             is PAYLOAD_IP
_B051 
; libsrc/etherip.pla: 0466:                 iphdr  = rxptr
; libsrc/etherip.pla: 0467:                 rxptr  = rxptr  + t_iphdr
; libsrc/etherip.pla: 0468:                 rxsize = rxsize - t_iphdr
; libsrc/etherip.pla: 0469:                 if iphdr->ip_vers_hlen <> $45
; libsrc/etherip.pla: 0470:                     optlen = iphdr=>ip_vers_hlen
; libsrc/etherip.pla: 0471:                     if optlen & $F0 <> $40
; libsrc/etherip.pla: 0472:                         //
; libsrc/etherip.pla: 0473:                         // Not IPv4, ignore
; libsrc/etherip.pla: 0474:                         //
; libsrc/etherip.pla: 0475:                         break
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$14			; ADDI	20
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3A,$14			; SUBI	20
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$60			; LB
	!BYTE	$2A,$45			; CB	69
	!BYTE	$22			; BREQ	_B052
	!WORD	_B052-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$62			; LW
	!BYTE	$6E,$0A			; DLW	[10]
	!BYTE	$3C,$F0			; ANDI	240
	!BYTE	$2A,$40			; CB	64
	!BYTE	$22			; BREQ	_B054
	!WORD	_B054-*
	!BYTE	$50			; BRNCH	_B049
	!WORD	_B049-*
; libsrc/etherip.pla: 0476:                     fin
_B054 
_B055 
; libsrc/etherip.pla: 0477:                     optlen = (optlen & $0F) << 2
; libsrc/etherip.pla: 0478:                     if optlen > t_iphdr
; libsrc/etherip.pla: 0479:                         //
; libsrc/etherip.pla: 0480:                         // Read the options and throw them on the ground!
; libsrc/etherip.pla: 0481:                         //
; libsrc/etherip.pla: 0482:                         rxptr  = rxptr + (optlen - t_iphdr)
; libsrc/etherip.pla: 0483:                         rxsize = rxsize - (optlen - t_iphdr)
; libsrc/etherip.pla: 0484:                     fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$04			; CN	2
	!BYTE	$9A			; SHL
	!BYTE	$6E,$0A			; DLW	[10]
	!BYTE	$2A,$14			; CB	20
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B056
	!WORD	_B056-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3A,$14			; SUBI	20
	!BYTE	$82			; ADD 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3A,$14			; SUBI	20
	!BYTE	$84			; SUB 
	!BYTE	$76,$00			; SLW	[0]
_B056 
_B057 
; libsrc/etherip.pla: 0485:                 fin
_B052 
_B053 
; libsrc/etherip.pla: 0486:                 //
; libsrc/etherip.pla: 0487:                 // Filter valid destination address
; libsrc/etherip.pla: 0488:                 //
; libsrc/etherip.pla: 0489:                 if iphdr=>ip_dst:2 <> localip:2 // Yes, this is a little lazy
; libsrc/etherip.pla: 0490:                     if (iphdr=>ip_dst:0|netmask:0) & (iphdr=>ip_dst:2|netmask:2) <> IP_BROADCAST
; libsrc/etherip.pla: 0491:                         break
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D037+2
_F062 	!WORD	_D037+2		
	!BYTE	$22			; BREQ	_B058
	!WORD	_B058-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D040+0
_F063 	!WORD	_D040+0		
	!BYTE	$96			; OR 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D040+2
_F064 	!WORD	_D040+2		
	!BYTE	$96			; OR 
	!BYTE	$94			; AND 
	!BYTE	$20			; MINUS ONE
	!BYTE	$22			; BREQ	_B060
	!WORD	_B060-*
	!BYTE	$50			; BRNCH	_B049
	!WORD	_B049-*
; libsrc/etherip.pla: 0492:                     fin
_B060 
_B061 
; libsrc/etherip.pla: 0493:                 fin
_B058 
_B059 
; libsrc/etherip.pla: 0494:                 //
; libsrc/etherip.pla: 0495:                 // What kind of IP protocol is it?
; libsrc/etherip.pla: 0496:                 //
; libsrc/etherip.pla: 0497:                 when iphdr->ip_proto
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$09			; ADDI	9
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B063-*
; libsrc/etherip.pla: 0498:                     is IP_PROTO_UDP
_B064 
; libsrc/etherip.pla: 0499:                         port = @portsUDP
; libsrc/etherip.pla: 0500:                         if port
; libsrc/etherip.pla: 0501:                             lclport = swab(rxptr=>udp_dst)
; libsrc/etherip.pla: 0502:                             for i = 1 to MAX_UDP_NOTIFIES
	!BYTE	$26			; LA	_D043+0
_F065 	!WORD	_D043+0		
	!BYTE	$6E,$0C			; DLW	[12]
	!BYTE	$4C			; BRFLS	_B065
	!WORD	_B065-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_A001
_F066 	!WORD	_A001		
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$08			; CN	4
	!BYTE	$02			; CN	1
_B068 
	!BYTE	$6C,$12			; DLB	[18]
; libsrc/etherip.pla: 0503:                                 if port=>notify_port == lclport
; libsrc/etherip.pla: 0504:                                 port=>notify_func(@iphdr=>ip_src,swab(rxptr=>udp_src),rxptr+t_udphdr,swab(rxptr=>udp_len)-t_udphdr,port=>notify_parm)
; libsrc/etherip.pla: 0505:                                 break
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$62			; LW
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$24			; BRNE	_B070
	!WORD	_B070-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_A001
_F067 	!WORD	_A001		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_A001
_F068 	!WORD	_A001		
	!BYTE	$3A,$08			; SUBI	8
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B067
	!WORD	_B067-*
; libsrc/etherip.pla: 0506:                             fin
_B070 
_B071 
; libsrc/etherip.pla: 0507:                             port = port + t_notify
; libsrc/etherip.pla: 0508:                             next
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$76,$0C			; SLW	[12]
_B069 
	!BYTE	$A4			; INCBRLE	_B068
	!WORD	_B068-*
_B067 
	!BYTE	$74,$12			; SLB	[18]
	!BYTE	$30			; DROP 
; libsrc/etherip.pla: 0509:                             fin
_B065 
_B066 
; libsrc/etherip.pla: 0510:                         break
	!BYTE	$50			; BRNCH	_B062
	!WORD	_B062-*
; libsrc/etherip.pla: 0511:                     is IP_PROTO_TCP
_B072 
; libsrc/etherip.pla: 0512:                         break
	!BYTE	$50			; BRNCH	_B062
	!WORD	_B062-*
; libsrc/etherip.pla: 0513:                     is IP_PROTO_ICMP
_B073 
; libsrc/etherip.pla: 0514:                         //
; libsrc/etherip.pla: 0515:                         // Service ICMP packets
; libsrc/etherip.pla: 0516:                         //
; libsrc/etherip.pla: 0517:                         if rxptr->icmp_type == ICMP_ECHO_REQST
; libsrc/etherip.pla: 0518:                             if rxsize > 128
; libsrc/etherip.pla: 0519:                                             echolen = 128
; libsrc/etherip.pla: 0520:                             else
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$10			; CN	8
	!BYTE	$24			; BRNE	_B074
	!WORD	_B074-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$80			; CB	128
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B076
	!WORD	_B076-*
	!BYTE	$2A,$80			; CB	128
	!BYTE	$74,$13			; SLB	[19]
	!BYTE	$50			; BRNCH	_B077
	!WORD	_B077-*
_B076 
; libsrc/etherip.pla: 0521:                             echolen = rxsize
; libsrc/etherip.pla: 0522:                             fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$74,$13			; SLB	[19]
_B077 
; libsrc/etherip.pla: 0523:                             memcpy(@echo_reply, rxptr, echolen)
; libsrc/etherip.pla: 0524:                             echo_reply.icmp_type  = ICMP_ECHO_REPLY
; libsrc/etherip.pla: 0525:                             echo_reply:icmp_chksm = 0
; libsrc/etherip.pla: 0526:                             seglist:seg_buf = @echo_reply
; libsrc/etherip.pla: 0527:                             seglist:seg_len = echolen
; libsrc/etherip.pla: 0528:                             etherSendIP(@iphdr=>ip_src, IP_PROTO_ICMP, @seglist, echolen)
; libsrc/etherip.pla: 0529:                         fin
	!BYTE	$28,$1C			; LLA	[28]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$54			; CALL	_X018
_F069 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$74,$1C			; SLB	[28]
	!BYTE	$00			; CN	0
	!BYTE	$76,$1E			; SLW	[30]
	!BYTE	$28,$1C			; LLA	[28]
	!BYTE	$76,$14			; SLW	[20]
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$02			; CN	1
	!BYTE	$28,$14			; LLA	[20]
	!BYTE	$64,$13			; LLB	[19]
	!BYTE	$54			; CALL	_C000
_F070 	!WORD	_C000		
	!BYTE	$30			; DROP 
_B074 
_B075 
; libsrc/etherip.pla: 0530:                         if hookICMP
; libsrc/etherip.pla: 0531:                             hookICMP(@iphdr=>ip_src, rxptr, rxsize)
; libsrc/etherip.pla: 0532:                         fin
	!BYTE	$6A			; LAW	_D045+0
_F071 	!WORD	_D045+0		
	!BYTE	$4C			; BRFLS	_B078
	!WORD	_B078-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D045+0
_F072 	!WORD	_D045+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B078 
_B079 
; libsrc/etherip.pla: 0533:                 wend
	!BYTE	$50			; BRNCH	_B062
	!WORD	_B062-*
_B063 
	!BYTE	$03			; CASEBLOCK
	!WORD	$0001
	!WORD	_B073-*
	!WORD	$0006
	!WORD	_B072-*
	!WORD	$0011
	!WORD	_B064-*
_B062 
; libsrc/etherip.pla: 0534:                 break
	!BYTE	$50			; BRNCH	_B049
	!WORD	_B049-*
; libsrc/etherip.pla: 0535:             is PAYLOAD_ARP
_B080 
; libsrc/etherip.pla: 0536:                 when rxptr=>arp_op
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$52			; SEL
	!WORD	_B082-*
; libsrc/etherip.pla: 0537:                     is ARP_REPLY
_B083 
; libsrc/etherip.pla: 0538:                         //
; libsrc/etherip.pla: 0539:                         // Fill in ARP cache
; libsrc/etherip.pla: 0540:                         //
; libsrc/etherip.pla: 0541:                         memcpy(@remoteha, @rxptr=>arp_senderha, 10) // copy ha and ip
; libsrc/etherip.pla: 0542:                         break
	!BYTE	$26			; LA	_D038+0
_F073 	!WORD	_D038+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F074 	!WORD	0		
	!BYTE	$50			; BRNCH	_B081
	!WORD	_B081-*
; libsrc/etherip.pla: 0543:                     is ARP_REQST
_B084 
; libsrc/etherip.pla: 0544:                         //
; libsrc/etherip.pla: 0545:                         // Is this a request for me?
; libsrc/etherip.pla: 0546:                         //
; libsrc/etherip.pla: 0547:                         if rxptr=>arp_targip:0 == localip:0 and rxptr=>arp_targip:2 == localip:2
; libsrc/etherip.pla: 0548:                             memcpy(@dstMAC,   @rxptr=>arp_senderha, MAC_SIZE)
; libsrc/etherip.pla: 0549:                             memcpy(@remoteha, @rxptr=>arp_senderha, 10) // copy ha and ip
; libsrc/etherip.pla: 0550:                             ePayload = PAYLOAD_ARP
; libsrc/etherip.pla: 0551:                             opARP    = ARP_REPLY
; libsrc/etherip.pla: 0552:                             setFrameLen(t_earp)
; libsrc/etherip.pla: 0553:                             writeFrame(@eFrame, t_earp)
; libsrc/etherip.pla: 0554:                         fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$18			; ADDI	24
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D037+0
_F075 	!WORD	_D037+0		
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B085
	!WORD	_B085-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$18			; ADDI	24
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D037+2
_F076 	!WORD	_D037+2		
	!BYTE	$40			; ISEQ
_B085 
	!BYTE	$4C			; BRFLS	_B086
	!WORD	_B086-*
	!BYTE	$26			; LA	_D031+0
_F077 	!WORD	_D031+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$0C			; CN	6
	!BYTE	$54			; CALL	_X018
_F078 	!WORD	0		
	!BYTE	$26			; LA	_D038+0
_F079 	!WORD	_D038+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X018
_F080 	!WORD	0		
	!BYTE	$2C,$08,$06		; CW	1544
	!BYTE	$7A			; SAW	_D033+0
_F081 	!WORD	_D033+0		
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$7A			; SAW	_D035+0
_F082 	!WORD	_D035+0		
	!BYTE	$2A,$2A			; CB	42
	!BYTE	$6A			; LAW	_D046+0
_F083 	!WORD	_D046+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D030+0
_F084 	!WORD	_D030+0		
	!BYTE	$2A,$2A			; CB	42
	!BYTE	$6A			; LAW	_D047+0
_F085 	!WORD	_D047+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B086 
_B087 
; libsrc/etherip.pla: 0555:                 wend
	!BYTE	$50			; BRNCH	_B081
	!WORD	_B081-*
_B082 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0100
	!WORD	_B084-*
	!WORD	$0200
	!WORD	_B083-*
_B081 
; libsrc/etherip.pla: 0556:         wend
	!BYTE	$50			; BRNCH	_B049
	!WORD	_B049-*
_B050 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0008
	!WORD	_B051-*
	!WORD	$0608
	!WORD	_B080-*
_B049 
; libsrc/etherip.pla: 0557:         heaprelease(rxpacket)
; libsrc/etherip.pla: 0558:     fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_X015
_F086 	!WORD	0		
	!BYTE	$30			; DROP 
_B047 
_B048 
; libsrc/etherip.pla: 0559:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$9C			; LEAVE	156
; libsrc/etherip.pla: 0560: end
; libsrc/etherip.pla: 0561: //
; libsrc/etherip.pla: 0562: // Initialize the driver interface
; libsrc/etherip.pla: 0563: //
; libsrc/etherip.pla: 0564: export def setEtherDriver(MAC, getlen, readfrm, setlen, writefrm)#0
					; MAC -> [0]
					; getlen -> [2]
					; readfrm -> [4]
					; setlen -> [6]
					; writefrm -> [8]
_C011 					; setEtherDriver()
; libsrc/etherip.pla: 0565:     memcpy(@myMAC,   MAC, MAC_SIZE)
	!BYTE	$58,$0A,$05		; ENTER	10,5
; libsrc/etherip.pla: 0566:     memcpy(@localha, MAC, MAC_SIZE)
; libsrc/etherip.pla: 0567:     getFrameLen = getlen
; libsrc/etherip.pla: 0568:     readFrame   = readfrm
; libsrc/etherip.pla: 0569:     setFrameLen = setlen
; libsrc/etherip.pla: 0570:     writeFrame  = writefrm
; libsrc/etherip.pla: 0571: end
	!BYTE	$26			; LA	_D032+0
_F087 	!WORD	_D032+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$0C			; CN	6
	!BYTE	$54			; CALL	_X018
_F088 	!WORD	0		
	!BYTE	$26			; LA	_D036+0
_F089 	!WORD	_D036+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$0C			; CN	6
	!BYTE	$54			; CALL	_X018
_F090 	!WORD	0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$7A			; SAW	_D048+0
_F091 	!WORD	_D048+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$7A			; SAW	_D049+0
_F092 	!WORD	_D049+0		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$7A			; SAW	_D046+0
_F093 	!WORD	_D046+0		
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$7A			; SAW	_D047+0
_F094 	!WORD	_D047+0		
	!BYTE	$5A,$0A			; LEAVE	10
; libsrc/etherip.pla: 0572: //
; libsrc/etherip.pla: 0573: // Set the local IP addresses
; libsrc/etherip.pla: 0574: //
; libsrc/etherip.pla: 0575: def setEtherIP(newIP, newNetmask, newGateway)
					; newIP -> [0]
					; newNetmask -> [2]
					; newGateway -> [4]
_C012 					; setEtherIP()
; libsrc/etherip.pla: 0576:     if newIP;      memcpy(@localip, newIP,      IP4ADR_SIZE); fin
	!BYTE	$58,$06,$03		; ENTER	6,3
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4C			; BRFLS	_B088
	!WORD	_B088-*
	!BYTE	$26			; LA	_D037+0
_F095 	!WORD	_D037+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_X018
_F096 	!WORD	0		
_B088 
_B089 
; libsrc/etherip.pla: 0577:     if newNetmask; memcpy(@netmask, newNetmask, IP4ADR_SIZE); fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B090
	!WORD	_B090-*
	!BYTE	$26			; LA	_D040+0
_F097 	!WORD	_D040+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_X018
_F098 	!WORD	0		
_B090 
_B091 
; libsrc/etherip.pla: 0578:     if newGateway; memcpy(@gateway, newGateway, IP4ADR_SIZE); fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$4C			; BRFLS	_B092
	!WORD	_B092-*
	!BYTE	$26			; LA	_D042+0
_F099 	!WORD	_D042+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$08			; CN	4
	!BYTE	$54			; CALL	_X018
_F100 	!WORD	0		
_B092 
_B093 
; libsrc/etherip.pla: 0579:     subnet:0 = netmask:0 & gateway:0
; libsrc/etherip.pla: 0580:     subnet:2 = netmask:2 & gateway:2
; libsrc/etherip.pla: 0581:     return 0
	!BYTE	$6A			; LAW	_D040+0
_F101 	!WORD	_D040+0		
	!BYTE	$6A			; LAW	_D042+0
_F102 	!WORD	_D042+0		
	!BYTE	$94			; AND 
	!BYTE	$7A			; SAW	_D041+0
_F103 	!WORD	_D041+0		
	!BYTE	$6A			; LAW	_D040+2
_F104 	!WORD	_D040+2		
	!BYTE	$6A			; LAW	_D042+2
_F105 	!WORD	_D042+2		
	!BYTE	$94			; AND 
	!BYTE	$7A			; SAW	_D041+2
_F106 	!WORD	_D041+2		
	!BYTE	$00			; CN	0
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/etherip.pla: 0582: end
; libsrc/etherip.pla: 0583: //
; libsrc/etherip.pla: 0584: // Get the interface hardware address
; libsrc/etherip.pla: 0585: //
; libsrc/etherip.pla: 0586: def getEtherHA(ha)
					; ha -> [0]
_C013 					; getEtherHA()
; libsrc/etherip.pla: 0587:     if ha; memcpy(ha, @myMAC, MAC_SIZE); fin
	!BYTE	$58,$02,$01		; ENTER	2,1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4C			; BRFLS	_B094
	!WORD	_B094-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D032+0
_F107 	!WORD	_D032+0		
	!BYTE	$0C			; CN	6
	!BYTE	$54			; CALL	_X018
_F108 	!WORD	0		
_B094 
_B095 
; libsrc/etherip.pla: 0588:     return MAC_SIZE
	!BYTE	$0C			; CN	6
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/etherip.pla: 0589: end
; libsrc/etherip.pla: 0590: //
; libsrc/etherip.pla: 0591: // Fill in iNet class
; libsrc/etherip.pla: 0592: //
; libsrc/etherip.pla: 0593: iNet:serviceIP      = @etherServiceIP
_INIT 
; libsrc/etherip.pla: 0594: iNet:openUDP        = @etherOpenUDP
; libsrc/etherip.pla: 0595: iNet:sendUDP        = @etherSendUDP
; libsrc/etherip.pla: 0596: iNet:closeUDP       = @etherCloseUDP
; libsrc/etherip.pla: 0597: iNet:listenTCP      = @etherListenTCP
; libsrc/etherip.pla: 0598: iNet:connectTCP     = @etherConnectTCP
; libsrc/etherip.pla: 0599: iNet:sendTCP        = @etherSendTCP
; libsrc/etherip.pla: 0600: iNet:closeTCP       = @etherCloseTCP
; libsrc/etherip.pla: 0601: iNet:setInterfaceIP = @setEtherIP
; libsrc/etherip.pla: 0602: iNet:getInterfaceHA = @getEtherHA
; libsrc/etherip.pla: 0603: iNet:setCallback    = @etherSetCallback
; libsrc/etherip.pla: 0604: iNet:setParam       = @etherSetParam
; libsrc/etherip.pla: 0605: done
	!BYTE	$26			; LA	_C010+0
_F109 	!WORD	_C010+0		
	!BYTE	$7A			; SAW	_X028+2
_F110 	!WORD	0+2		
	!BYTE	$26			; LA	_C002+0
_F111 	!WORD	_C002+0		
	!BYTE	$7A			; SAW	_X028+4
_F112 	!WORD	0+4		
	!BYTE	$26			; LA	_C001+0
_F113 	!WORD	_C001+0		
	!BYTE	$7A			; SAW	_X028+6
_F114 	!WORD	0+6		
	!BYTE	$26			; LA	_C003+0
_F115 	!WORD	_C003+0		
	!BYTE	$7A			; SAW	_X028+8
_F116 	!WORD	0+8		
	!BYTE	$26			; LA	_C004+0
_F117 	!WORD	_C004+0		
	!BYTE	$7A			; SAW	_X028+10
_F118 	!WORD	0+10		
	!BYTE	$26			; LA	_C005+0
_F119 	!WORD	_C005+0		
	!BYTE	$7A			; SAW	_X028+12
_F120 	!WORD	0+12		
	!BYTE	$26			; LA	_C006+0
_F121 	!WORD	_C006+0		
	!BYTE	$7A			; SAW	_X028+14
_F122 	!WORD	0+14		
	!BYTE	$26			; LA	_C007+0
_F123 	!WORD	_C007+0		
	!BYTE	$7A			; SAW	_X028+16
_F124 	!WORD	0+16		
	!BYTE	$26			; LA	_C012+0
_F125 	!WORD	_C012+0		
	!BYTE	$7A			; SAW	_X028+18
_F126 	!WORD	0+18		
	!BYTE	$26			; LA	_C013+0
_F127 	!WORD	_C013+0		
	!BYTE	$7A			; SAW	_X028+20
_F128 	!WORD	0+20		
	!BYTE	$26			; LA	_C008+0
_F129 	!WORD	_C008+0		
	!BYTE	$7A			; SAW	_X028+26
_F130 	!WORD	0+26		
	!BYTE	$26			; LA	_C009+0
_F131 	!WORD	_C009+0		
	!BYTE	$7A			; SAW	_X028+28
_F132 	!WORD	0+28		
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
_SYSFLAGS	=	0
_DEFCNT	=	15
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C010		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C011		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C012		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C013		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	25			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	26			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	25			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	26			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	25			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	26			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: PUTS
	!BYTE	$D0,$D5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	4			; ESD INDEX
	; DCI STRING: HEAPALLOC
	!BYTE	$C8,$C5,$C1,$D0,$C1,$CC,$CC,$CF,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	14			; ESD INDEX
	; DCI STRING: HEAPRELEASE
	!BYTE	$C8,$C5,$C1,$D0,$D2,$C5,$CC,$C5,$C1,$D3,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	15			; ESD INDEX
	; DCI STRING: MEMSET
	!BYTE	$CD,$C5,$CD,$D3,$C5,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	17			; ESD INDEX
	; DCI STRING: MEMCPY
	!BYTE	$CD,$C5,$CD,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	18			; ESD INDEX
	; DCI STRING: ISUGE
	!BYTE	$C9,$D3,$D5,$C7,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	25			; ESD INDEX
	; DCI STRING: ISULT
	!BYTE	$C9,$D3,$D5,$CC,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	26			; ESD INDEX
	; DCI STRING: INET
	!BYTE	$C9,$CE,$C5,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	28			; ESD INDEX
	; DCI STRING: LOCALHA
	!BYTE	$CC,$CF,$C3,$C1,$CC,$C8,$41
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D036		
	; DCI STRING: LOCALIP
	!BYTE	$CC,$CF,$C3,$C1,$CC,$C9,$50
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D037		
	; DCI STRING: HOOKICMP
	!BYTE	$C8,$CF,$CF,$CB,$C9,$C3,$CD,$50
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D045		
	; DCI STRING: SETETHERDRIVER
	!BYTE	$D3,$C5,$D4,$C5,$D4,$C8,$C5,$D2,$C4,$D2,$C9,$D6,$C5,$52
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C011		
	!BYTE	$00			; END OF ESD
