; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; libsrc/memmgr.pla: 0001: //
; libsrc/memmgr.pla: 0002: // Handle based swapping memory manager
; libsrc/memmgr.pla: 0003: //
; libsrc/memmgr.pla: 0004: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0200 // Version built against
					; _SYSVER_ = 512
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $03
					; MACHID_MEM = 3
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     //
; inc/cmdsys.plh: 0038:     // Module don't free memory
; inc/cmdsys.plh: 0039:     //
; inc/cmdsys.plh: 0040:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0041:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0042:     //
; inc/cmdsys.plh: 0043:     // CMD exported interface table
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     struc t_cmdsys
; inc/cmdsys.plh: 0046:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0047:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0048:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0049:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0050:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0051:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0052:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0053:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0054:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0055:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0056:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0057:         byte refcons    // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0058:         byte devcons    // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0059:     end
					; t_cmdsys = 21
; inc/cmdsys.plh: 0060:     //
; inc/cmdsys.plh: 0061:     // CMD exported functions
; inc/cmdsys.plh: 0062:     //
; inc/cmdsys.plh: 0063:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0064:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0065:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0066:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0067:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0068:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0069: end
; libsrc/memmgr.pla: 0004: 
; libsrc/memmgr.pla: 0005: include "inc/fileio.plh"
; inc/fileio.plh: 0001: import fileio
	; DCI STRING: FILEIO
	!BYTE	$C6,$C9,$CC,$C5,$C9,$4F
					; FILEIO -> X028
; inc/fileio.plh: 0002:     //
; inc/fileio.plh: 0003:     // Useful ProDOS values
; inc/fileio.plh: 0004:     //
; inc/fileio.plh: 0005:     // MACHID is defined in cmdsys.plh
; inc/fileio.plh: 0006:     // Which slot has a ROM
; inc/fileio.plh: 0007:     const SLTBYT = $BF99
					; SLTBYT = 49049
; inc/fileio.plh: 0008:     // Prefix active
; inc/fileio.plh: 0009:     const PFIXPTR = $BF9A
					; PFIXPTR = 49050
; inc/fileio.plh: 0010:     // Memory alocate bitmap
; inc/fileio.plh: 0011:     const MEMTABL = $BF58
					; MEMTABL = 48984
; inc/fileio.plh: 0012:     //
; inc/fileio.plh: 0013:     // SOS/ProDOS error codes
; inc/fileio.plh: 0014:     //
; inc/fileio.plh: 0015:     const FILE_ERR_OK            = $00
					; FILE_ERR_OK = 0
; inc/fileio.plh: 0016:     const FILE_ERR_BAD_CALL_NUM  = $01
					; FILE_ERR_BAD_CALL_NUM = 1
; inc/fileio.plh: 0017:     const FILE_ERR_BAD_PARAM_CNT = $04
					; FILE_ERR_BAD_PARAM_CNT = 4
; inc/fileio.plh: 0018:     const FILE_ERR_INT_TBL_FULL  = $25
					; FILE_ERR_INT_TBL_FULL = 37
; inc/fileio.plh: 0019:     const FILE_ERR_IO            = $27
					; FILE_ERR_IO = 39
; inc/fileio.plh: 0020:     //
; inc/fileio.plh: 0021:     // File entry struc
; inc/fileio.plh: 0022:     //
; inc/fileio.plh: 0023:     struc t_fileentry
; inc/fileio.plh: 0024:         byte store_namelen
					; store_namelen = 0
; inc/fileio.plh: 0025:         byte entry_name[15]
					; entry_name = 1
; inc/fileio.plh: 0026:         byte entry_type
					; entry_type = 16
; inc/fileio.plh: 0027:         word entry_keyptr
					; entry_keyptr = 17
; inc/fileio.plh: 0028:         word entry_blocks
					; entry_blocks = 19
; inc/fileio.plh: 0029:         word entry_EOFL
					; entry_EOFL = 21
; inc/fileio.plh: 0030:         byte entry_EOFH
					; entry_EOFH = 23
; inc/fileio.plh: 0031:         word entry_create[2]
					; entry_create = 24
; inc/fileio.plh: 0032:         byte entry_version
					; entry_version = 28
; inc/fileio.plh: 0033:         byte entry_minver
					; entry_minver = 29
; inc/fileio.plh: 0034:         byte entry_access
					; entry_access = 30
; inc/fileio.plh: 0035:         word entry_aux
					; entry_aux = 31
; inc/fileio.plh: 0036:         word entry_mod[2]
					; entry_mod = 33
; inc/fileio.plh: 0037:         word entry_headptr
					; entry_headptr = 37
; inc/fileio.plh: 0038:     end
					; t_fileentry = 39
; inc/fileio.plh: 0039:     //
; inc/fileio.plh: 0040:     // File info struc
; inc/fileio.plh: 0041:     //
; inc/fileio.plh: 0042:     struc t_fileinfo
; inc/fileio.plh: 0043:         byte file_access
					; file_access = 0
; inc/fileio.plh: 0044:         byte file_type
					; file_type = 1
; inc/fileio.plh: 0045:         word aux_type
					; aux_type = 2
; inc/fileio.plh: 0046:         byte storage_type
					; storage_type = 4
; inc/fileio.plh: 0047:         word blocks_used
					; blocks_used = 5
; inc/fileio.plh: 0048:         word mod_date
					; mod_date = 7
; inc/fileio.plh: 0049:         word mod_time
					; mod_time = 9
; inc/fileio.plh: 0050:         word create_date
					; create_date = 11
; inc/fileio.plh: 0051:         word create_time
					; create_time = 13
; inc/fileio.plh: 0052:     end
					; t_fileinfo = 15
; inc/fileio.plh: 0053:     //
; inc/fileio.plh: 0054:     // File functions
; inc/fileio.plh: 0055:     //
; inc/fileio.plh: 0056:     struc t_fileio
; inc/fileio.plh: 0057:         word getpfx
					; getpfx = 0
; inc/fileio.plh: 0058:         word setpfx
					; setpfx = 2
; inc/fileio.plh: 0059:         word getfileinfo
					; getfileinfo = 4
; inc/fileio.plh: 0060:         word setfileinfo
					; setfileinfo = 6
; inc/fileio.plh: 0061:         word geteof
					; geteof = 8
; inc/fileio.plh: 0062:         word seteof
					; seteof = 10
; inc/fileio.plh: 0063:         word iobufalloc
					; iobufalloc = 12
; inc/fileio.plh: 0064:         word open
					; open = 14
; inc/fileio.plh: 0065:         word close
					; close = 16
; inc/fileio.plh: 0066:         word read
					; read = 18
; inc/fileio.plh: 0067:         word write
					; write = 20
; inc/fileio.plh: 0068:         word create
					; create = 22
; inc/fileio.plh: 0069:         word destroy
					; destroy = 24
; inc/fileio.plh: 0070:         word rename
					; rename = 26
; inc/fileio.plh: 0071:         word newline
					; newline = 28
; inc/fileio.plh: 0072:         word online
					; online = 30
; inc/fileio.plh: 0073:         word readblock
					; readblock = 32
; inc/fileio.plh: 0074:         word writeblock
					; writeblock = 34
; inc/fileio.plh: 0075:     end
					; t_fileio = 36
; inc/fileio.plh: 0076:     //
; inc/fileio.plh: 0077:     // Globally accessible error code
; inc/fileio.plh: 0078:     //
; inc/fileio.plh: 0079:     byte perr
					; PERR -> X029
; inc/fileio.plh: 0080: end
; libsrc/memmgr.pla: 0005: 
; libsrc/memmgr.pla: 0006: 
; libsrc/memmgr.pla: 0007: struc t_initdata
	!BYTE	$00			; END OF MODULE DEPENDENCIES
; libsrc/memmgr.pla: 0008:     word    volptr
					; volptr = 0
; libsrc/memmgr.pla: 0009:     word    freeblks
					; freeblks = 2
; libsrc/memmgr.pla: 0010:     word    ramvol
					; ramvol = 4
; libsrc/memmgr.pla: 0011:     word    bestvol
					; bestvol = 6
; libsrc/memmgr.pla: 0012:     word    ramfree
					; ramfree = 8
; libsrc/memmgr.pla: 0013:     word    bestfree
					; bestfree = 10
; libsrc/memmgr.pla: 0014:     word    filecnt
					; filecnt = 12
; libsrc/memmgr.pla: 0015:     word    catentry
					; catentry = 14
; libsrc/memmgr.pla: 0016:     byte    catref
					; catref = 16
; libsrc/memmgr.pla: 0017:     byte    firstblk
					; firstblk = 17
; libsrc/memmgr.pla: 0018:     byte    entrylen
					; entrylen = 18
; libsrc/memmgr.pla: 0019:     byte    entriesblk
					; entriesblk = 19
; libsrc/memmgr.pla: 0020:     byte    swapstrlen
					; swapstrlen = 20
; libsrc/memmgr.pla: 0021:     byte[4] volparms
					; volparms = 21
; libsrc/memmgr.pla: 0022:     byte[]  volinfo
					; volinfo = 25
; libsrc/memmgr.pla: 0023:     byte[]  catalog
					; catalog = 25
; libsrc/memmgr.pla: 0024: end
					; t_initdata = 25
; libsrc/memmgr.pla: 0025: word initdata
_D030 	!FILL	2			; initdata
; libsrc/memmgr.pla: 0026: //
; libsrc/memmgr.pla: 0027: // Access bytes within a word
; libsrc/memmgr.pla: 0028: //
; libsrc/memmgr.pla: 0029: struc t_word
; libsrc/memmgr.pla: 0030:     byte lsb
					; lsb = 0
; libsrc/memmgr.pla: 0031:     byte msb
					; msb = 1
; libsrc/memmgr.pla: 0032: end
					; t_word = 2
; libsrc/memmgr.pla: 0033: //
; libsrc/memmgr.pla: 0034: // Alloced memory block structure
; libsrc/memmgr.pla: 0035: //
; libsrc/memmgr.pla: 0036: struc t_memblk
; libsrc/memmgr.pla: 0037:     word blksiz
					; blksiz = 0
; libsrc/memmgr.pla: 0038:     byte blkref
					; blkref = 2
; libsrc/memmgr.pla: 0039:     byte blklok
					; blklok = 3
; libsrc/memmgr.pla: 0040: end
					; t_memblk = 4
; libsrc/memmgr.pla: 0041: //
; libsrc/memmgr.pla: 0042: // Free memory block structure
; libsrc/memmgr.pla: 0043: //
; libsrc/memmgr.pla: 0044: struc t_freblk
; libsrc/memmgr.pla: 0045:     word fresiz
					; fresiz = 0
; libsrc/memmgr.pla: 0046:     word frenxt
					; frenxt = 2
; libsrc/memmgr.pla: 0047: end
					; t_freblk = 4
; libsrc/memmgr.pla: 0048: //
; libsrc/memmgr.pla: 0049: // Block size
; libsrc/memmgr.pla: 0050: //
; libsrc/memmgr.pla: 0051: const MAX_BLK_SIZE = $2010
					; MAX_BLK_SIZE = 8208
; libsrc/memmgr.pla: 0052: const MAX_BLK_MASK = $1FFF
					; MAX_BLK_MASK = 8191
; libsrc/memmgr.pla: 0053: const MIN_BLK_SIZE = $04
					; MIN_BLK_SIZE = 4
; libsrc/memmgr.pla: 0054: const MIN_BLK_MASK = $03
					; MIN_BLK_MASK = 3
; libsrc/memmgr.pla: 0055: //
; libsrc/memmgr.pla: 0056: // Block states
; libsrc/memmgr.pla: 0057: //
; libsrc/memmgr.pla: 0058: const HMEM_ADDR     = $FFFC
					; HMEM_ADDR = 65532
; libsrc/memmgr.pla: 0059: const HMEM_SIZE     = $FFFC
					; HMEM_SIZE = 65532
; libsrc/memmgr.pla: 0060: const HMEM_STATE    = $03
					; HMEM_STATE = 3
; libsrc/memmgr.pla: 0061: const HMEM_MOVEABLE = $00 // Many dependencies on this being $00
					; HMEM_MOVEABLE = 0
; libsrc/memmgr.pla: 0062: const HMEM_AVAIL    = $01
					; HMEM_AVAIL = 1
; libsrc/memmgr.pla: 0063: const HMEM_LOCKED   = $02
					; HMEM_LOCKED = 2
; libsrc/memmgr.pla: 0064: const HMEM_SWAPPED  = $03
					; HMEM_SWAPPED = 3
; libsrc/memmgr.pla: 0065: //
; libsrc/memmgr.pla: 0066: // Block flags
; libsrc/memmgr.pla: 0067: //
; libsrc/memmgr.pla: 0068: const HMEM_ACCESSED = $80
					; HMEM_ACCESSED = 128
; libsrc/memmgr.pla: 0069: //
; libsrc/memmgr.pla: 0070: // Handle modifier
; libsrc/memmgr.pla: 0071: //
; libsrc/memmgr.pla: 0072: const HMOD = $4321
					; HMOD = 17185
; libsrc/memmgr.pla: 0073: //
; libsrc/memmgr.pla: 0074: // Handle tables/lists
; libsrc/memmgr.pla: 0075: //
; libsrc/memmgr.pla: 0076: const PG_SIZE     = 512
					; PG_SIZE = 512
; libsrc/memmgr.pla: 0077: const PG_ENTRIES  = 256
					; PG_ENTRIES = 256
; libsrc/memmgr.pla: 0078: const PG_TBL_SIZE = 8
					; PG_TBL_SIZE = 8
; libsrc/memmgr.pla: 0079: word sysbuf
_D031 	!FILL	2			; sysbuf
; libsrc/memmgr.pla: 0080: word[PG_TBL_SIZE] hpgtbl // Handle page table
_D032 	!FILL	16			; hpgtbl // Handle page table
; libsrc/memmgr.pla: 0081: word pooladdr
_D033 	!FILL	2			; pooladdr
; libsrc/memmgr.pla: 0082: word poolsize
_D034 	!FILL	2			; poolsize
; libsrc/memmgr.pla: 0083: word frelst              // Free list
_D035 	!FILL	2			; frelst              // Free list
; libsrc/memmgr.pla: 0084: byte sweeppg, sweepen
_D036 	!FILL	1			; sweeppg, sweepen
_D037 	!FILL	1			; sweepen
; libsrc/memmgr.pla: 0085: byte[64] swapvol = "/"   // Swap volume
_D038 					; swapvol = "/"   // Swap volume
	!BYTE	$01
	!BYTE	$2F
	!FILL	$3E
; libsrc/memmgr.pla: 0086: byte swapdir = "/SWAP/"
_D039 					; swapdir = "/SWAP/"
	!BYTE	$06
	!BYTE	$2F,$53,$57,$41,$50,$2F
; libsrc/memmgr.pla: 0087: byte hexchar = '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
_D040 					; hexchar = '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
	!BYTE	$30
	!BYTE	$31
	!BYTE	$32
	!BYTE	$33
	!BYTE	$34
	!BYTE	$35
	!BYTE	$36
	!BYTE	$37
	!BYTE	$38
	!BYTE	$39
	!BYTE	$41
	!BYTE	$42
	!BYTE	$43
	!BYTE	$44
	!BYTE	$45
	!BYTE	$46
; libsrc/memmgr.pla: 0088: //
; libsrc/memmgr.pla: 0089: // DEBUG
; libsrc/memmgr.pla: 0090: //
; libsrc/memmgr.pla: 0091: //byte swapinstr = "Swap in:"
; libsrc/memmgr.pla: 0092: //byte swapoutstr = "Swap out:"
; libsrc/memmgr.pla: 0093: //byte getblkstr = "Get block = "
; libsrc/memmgr.pla: 0094: //byte allocpgstr = "Alloc page:"
; libsrc/memmgr.pla: 0095: //
; libsrc/memmgr.pla: 0096: //def putln
; libsrc/memmgr.pla: 0097: //    return putc($0D)
; libsrc/memmgr.pla: 0098: //end
; libsrc/memmgr.pla: 0099: //def putb(hexb)
; libsrc/memmgr.pla: 0100: //    return call($FDDA, hexb, 0, 0, 0)
; libsrc/memmgr.pla: 0101: //end
; libsrc/memmgr.pla: 0102: //def puth(hex)
; libsrc/memmgr.pla: 0103: //    return call($F941, hex >> 8, hex, 0, 0)
; libsrc/memmgr.pla: 0104: //end
; libsrc/memmgr.pla: 0105: //
; libsrc/memmgr.pla: 0106: // Fill block filename
; libsrc/memmgr.pla: 0107: //
; libsrc/memmgr.pla: 0108: def strcharadd(str, chr)#0
	!BYTE	$00			; PAD BYTE
_SUBSEG 				; BYTECODE STARTS
					; str -> [0]
					; chr -> [2]
_C000 					; strcharadd()
; libsrc/memmgr.pla: 0109:     ^str = ^str + 1
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/memmgr.pla: 0110:     str->.[^str] = chr
; libsrc/memmgr.pla: 0111: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$70			; SB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$34			; DUP
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/memmgr.pla: 0112: def swapfile(filestr, hmem)#0
					; filestr -> [0]
					; hmem -> [2]
_C001 					; swapfile()
; libsrc/memmgr.pla: 0113:     memcpy(filestr, @swapvol, swapvol + 1)
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/memmgr.pla: 0114:     strcharadd(filestr, 'H')
; libsrc/memmgr.pla: 0115:     strcharadd(filestr, hexchar[(hmem >> 12) & $0F])
; libsrc/memmgr.pla: 0116:     strcharadd(filestr, hexchar[(hmem >> 8)  & $0F])
; libsrc/memmgr.pla: 0117:     strcharadd(filestr, hexchar[(hmem >> 4)  & $0F])
; libsrc/memmgr.pla: 0118:     strcharadd(filestr, hexchar[ hmem        & $0F])
; libsrc/memmgr.pla: 0119: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D038+0
_F000 	!WORD	_D038+0		
	!BYTE	$68			; LAB	_D038+0
_F001 	!WORD	_D038+0		
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_X018
_F002 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$48			; CB	72
	!BYTE	$54			; CALL	_C000
_F003 	!WORD	_C000		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D040+0
_F004 	!WORD	_D040+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$18			; CN	12
	!BYTE	$9C			; SHR
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_C000
_F005 	!WORD	_C000		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D040+0
_F006 	!WORD	_D040+0		
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_C000
_F007 	!WORD	_C000		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D040+0
_F008 	!WORD	_D040+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$08			; CN	4
	!BYTE	$9C			; SHR
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_C000
_F009 	!WORD	_C000		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D040+0
_F010 	!WORD	_D040+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_C000
_F011 	!WORD	_C000		
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/memmgr.pla: 0120: //
; libsrc/memmgr.pla: 0121: // Find exact/best free memory match
; libsrc/memmgr.pla: 0122: //
; libsrc/memmgr.pla: 0123: def unlink(freblk, freprv)
					; freblk -> [0]
					; freprv -> [2]
_C002 					; unlink()
; libsrc/memmgr.pla: 0124:     //
; libsrc/memmgr.pla: 0125:     // Unlink free block
; libsrc/memmgr.pla: 0126:     //
; libsrc/memmgr.pla: 0127:     if freprv
	!BYTE	$58,$04,$02		; ENTER	4,2
; libsrc/memmgr.pla: 0128:         freprv=>frenxt = freblk=>frenxt
; libsrc/memmgr.pla: 0129:     else
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B001
	!WORD	_B001-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B002
	!WORD	_B002-*
_B001 
; libsrc/memmgr.pla: 0130:         frelst = freblk=>frenxt
; libsrc/memmgr.pla: 0131:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D035+0
_F012 	!WORD	_D035+0		
_B002 
; libsrc/memmgr.pla: 0132:     return freblk
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/memmgr.pla: 0133: end
; libsrc/memmgr.pla: 0134: def unfre(freblk, freprv, size)
					; freblk -> [0]
					; freprv -> [2]
					; size -> [4]
_C003 					; unfre()
; libsrc/memmgr.pla: 0135:     word shrink
					; shrink -> [6]
; libsrc/memmgr.pla: 0136: 
; libsrc/memmgr.pla: 0137:     if freblk=>fresiz == size
	!BYTE	$58,$08,$03		; ENTER	8,3
; libsrc/memmgr.pla: 0138:         //
; libsrc/memmgr.pla: 0139:     // Unlink free block
; libsrc/memmgr.pla: 0140:     //
; libsrc/memmgr.pla: 0141:         unlink(freblk, freprv)
; libsrc/memmgr.pla: 0142:     elsif freblk=>fresiz > size
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$24			; BRNE	_B003
	!WORD	_B003-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C002
_F013 	!WORD	_C002		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B004
	!WORD	_B004-*
_B003 
; libsrc/memmgr.pla: 0143:         //
; libsrc/memmgr.pla: 0144:     // Shrink free block
; libsrc/memmgr.pla: 0145:     //
; libsrc/memmgr.pla: 0146:     shrink = freblk + size
; libsrc/memmgr.pla: 0147:     if freprv
; libsrc/memmgr.pla: 0148:         freprv=>frenxt = shrink
; libsrc/memmgr.pla: 0149:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B005
	!WORD	_B005-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B006
	!WORD	_B006-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B007
	!WORD	_B007-*
_B006 
; libsrc/memmgr.pla: 0150:         frelst = shrink
; libsrc/memmgr.pla: 0151:     fin
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$7A			; SAW	_D035+0
_F014 	!WORD	_D035+0		
_B007 
; libsrc/memmgr.pla: 0152:     shrink=>fresiz = freblk=>fresiz - size
; libsrc/memmgr.pla: 0153:     shrink=>frenxt = freblk=>frenxt
; libsrc/memmgr.pla: 0154:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$84			; SUB 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B004
	!WORD	_B004-*
_B005 
; libsrc/memmgr.pla: 0155:         freblk = 0
; libsrc/memmgr.pla: 0156:     fin
	!BYTE	$00			; CN	0
	!BYTE	$76,$00			; SLW	[0]
_B004 
; libsrc/memmgr.pla: 0157:     return freblk
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$08			; LEAVE	8
; libsrc/memmgr.pla: 0158: end
; libsrc/memmgr.pla: 0159: def addfre(freblk)#0
					; freblk -> [0]
_C004 					; addfre()
; libsrc/memmgr.pla: 0160:     word srch
					; srch -> [2]
; libsrc/memmgr.pla: 0161: 
; libsrc/memmgr.pla: 0162:     //freblk=>fresiz = freblk=>blksiz
; libsrc/memmgr.pla: 0163:     if frelst and frelst < freblk
	!BYTE	$58,$04,$01		; ENTER	4,1
; libsrc/memmgr.pla: 0164:         srch = frelst
; libsrc/memmgr.pla: 0165:         while srch=>frenxt
	!BYTE	$6A			; LAW	_D035+0
_F015 	!WORD	_D035+0		
	!BYTE	$AC			; BRAND	_B008
	!WORD	_B008-*
	!BYTE	$6A			; LAW	_D035+0
_F016 	!WORD	_D035+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$46			; ISLT
_B008 
	!BYTE	$4C			; BRFLS	_B009
	!WORD	_B009-*
	!BYTE	$6A			; LAW	_D035+0
_F017 	!WORD	_D035+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B013
	!WORD	_B013-*
_B011 
; libsrc/memmgr.pla: 0166:             if srch=>frenxt > freblk
; libsrc/memmgr.pla: 0167:                 //
; libsrc/memmgr.pla: 0168:                 // Insert into list
; libsrc/memmgr.pla: 0169:                 //
; libsrc/memmgr.pla: 0170:                 freblk=>frenxt = srch=>frenxt
; libsrc/memmgr.pla: 0171:                 srch=>frenxt   = freblk
; libsrc/memmgr.pla: 0172:                 return
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B014
	!WORD	_B014-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/memmgr.pla: 0173:             fin
_B014 
_B015 
; libsrc/memmgr.pla: 0174:             srch = srch=>frenxt
; libsrc/memmgr.pla: 0175:         loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B013 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B011
	!WORD	_B011-*
_B012 
; libsrc/memmgr.pla: 0176:         //
; libsrc/memmgr.pla: 0177:         // Add to end of list
; libsrc/memmgr.pla: 0178:         //
; libsrc/memmgr.pla: 0179:         freblk=>frenxt = 0
; libsrc/memmgr.pla: 0180:         srch=>frenxt   = freblk
; libsrc/memmgr.pla: 0181:     else
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B010
	!WORD	_B010-*
_B009 
; libsrc/memmgr.pla: 0182:         //
; libsrc/memmgr.pla: 0183:         // Add to beginning of list
; libsrc/memmgr.pla: 0184:         //
; libsrc/memmgr.pla: 0185:         freblk=>frenxt = frelst
; libsrc/memmgr.pla: 0186:         frelst         = freblk
; libsrc/memmgr.pla: 0187:     fin
	!BYTE	$6A			; LAW	_D035+0
_F018 	!WORD	_D035+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D035+0
_F019 	!WORD	_D035+0		
_B010 
; libsrc/memmgr.pla: 0188: end
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/memmgr.pla: 0189: //
; libsrc/memmgr.pla: 0190: // Memory coallesce/compaction/swap out routines
; libsrc/memmgr.pla: 0191: //
; libsrc/memmgr.pla: 0192: def coallesce
_C005 					; coallesce()
; libsrc/memmgr.pla: 0193:     word srch, combined
					; srch -> [0]
					; combined -> [2]
; libsrc/memmgr.pla: 0194: 
; libsrc/memmgr.pla: 0195:     combined = 0
	!BYTE	$58,$04,$00		; ENTER	4,0
; libsrc/memmgr.pla: 0196:     srch = frelst
; libsrc/memmgr.pla: 0197:     while srch and srch=>frenxt
	!BYTE	$00			; CN	0
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$6A			; LAW	_D035+0
_F020 	!WORD	_D035+0		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B018
	!WORD	_B018-*
_B016 
; libsrc/memmgr.pla: 0198:         if srch + srch=>fresiz == srch=>frenxt
; libsrc/memmgr.pla: 0199:             //
; libsrc/memmgr.pla: 0200:             // Combine adjacent free space
; libsrc/memmgr.pla: 0201:             //
; libsrc/memmgr.pla: 0202:             //putc('C');putc(' ');puth(srch);putc('+');puth(srch=>frenxt);putc(' ')
; libsrc/memmgr.pla: 0203:             srch=>fresiz = srch=>fresiz + srch=>frenxt=>fresiz
; libsrc/memmgr.pla: 0204:             srch=>frenxt = srch=>frenxt=>frenxt
; libsrc/memmgr.pla: 0205:             combined = 1
; libsrc/memmgr.pla: 0206:         else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$34			; DUP
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$24			; BRNE	_B020
	!WORD	_B020-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B021
	!WORD	_B021-*
_B020 
; libsrc/memmgr.pla: 0207:             srch = srch=>frenxt
; libsrc/memmgr.pla: 0208:         fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
_B021 
; libsrc/memmgr.pla: 0209:     loop
_B018 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$AC			; BRAND	_B019
	!WORD	_B019-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
_B019 
	!BYTE	$4E			; BRTRU	_B016
	!WORD	_B016-*
_B017 
; libsrc/memmgr.pla: 0210:     return combined
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/memmgr.pla: 0211: end
; libsrc/memmgr.pla: 0212: def compact
_C006 					; compact()
; libsrc/memmgr.pla: 0213:     word page, entry, memblk, moveblk, size, srch, prev
					; page -> [0]
					; entry -> [2]
					; memblk -> [4]
					; moveblk -> [6]
					; size -> [8]
					; srch -> [10]
					; prev -> [12]
; libsrc/memmgr.pla: 0214:     byte moved
					; moved -> [14]
; libsrc/memmgr.pla: 0215: 
; libsrc/memmgr.pla: 0216:     moved = 0
	!BYTE	$58,$0F,$00		; ENTER	15,0
; libsrc/memmgr.pla: 0217:     for page = PG_TBL_SIZE - 1 downto 0
	!BYTE	$00			; CN	0
	!BYTE	$74,$0E			; SLB	[14]
	!BYTE	$00			; CN	0
	!BYTE	$0E			; CN	7
_B023 
	!BYTE	$6E,$00			; DLW	[0]
; libsrc/memmgr.pla: 0218:         if hpgtbl[page]
; libsrc/memmgr.pla: 0219:             for entry = 255 downto 0
	!BYTE	$26			; LA	_D032+0
_F021 	!WORD	_D032+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B025
	!WORD	_B025-*
	!BYTE	$00			; CN	0
	!BYTE	$2A,$FF			; CB	255
_B028 
	!BYTE	$6E,$02			; DLW	[2]
; libsrc/memmgr.pla: 0220:                 if hpgtbl:[page, entry].lsb & HMEM_STATE == HMEM_MOVEABLE
; libsrc/memmgr.pla: 0221:                     memblk = hpgtbl:[page, entry]
; libsrc/memmgr.pla: 0222:                     size    = memblk=>blksiz
; libsrc/memmgr.pla: 0223:                     moveblk = 0
; libsrc/memmgr.pla: 0224:                     prev    = 0
; libsrc/memmgr.pla: 0225:                     srch    = frelst
; libsrc/memmgr.pla: 0226:                     while srch and srch < memblk
	!BYTE	$26			; LA	_D032+0
_F022 	!WORD	_D032+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$60			; LB
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$4E			; BRTRU	_B030
	!WORD	_B030-*
	!BYTE	$26			; LA	_D032+0
_F023 	!WORD	_D032+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$00			; CN	0
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$6A			; LAW	_D035+0
_F024 	!WORD	_D035+0		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$50			; BRNCH	_B034
	!WORD	_B034-*
_B032 
; libsrc/memmgr.pla: 0227:                         if srch=>fresiz >= size
; libsrc/memmgr.pla: 0228:                             moveblk = unfre(srch, prev, size)
; libsrc/memmgr.pla: 0229:                             break
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$62			; LW
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B036
	!WORD	_B036-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$54			; CALL	_C003
_F025 	!WORD	_C003		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$50			; BRNCH	_B033
	!WORD	_B033-*
; libsrc/memmgr.pla: 0230:                         fin
_B036 
_B037 
; libsrc/memmgr.pla: 0231:                         prev = srch
; libsrc/memmgr.pla: 0232:                         srch = srch=>frenxt
; libsrc/memmgr.pla: 0233:                     loop
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$76,$0A			; SLW	[10]
_B034 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$AC			; BRAND	_B035
	!WORD	_B035-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$46			; ISLT
_B035 
	!BYTE	$4E			; BRTRU	_B032
	!WORD	_B032-*
_B033 
; libsrc/memmgr.pla: 0234:                     if moveblk
; libsrc/memmgr.pla: 0235:                         //putc('M');putc(' ');puth(moveblk);putc('=');puth(memblk);putc(' ')
; libsrc/memmgr.pla: 0236:                         memcpy(moveblk, memblk, size)
; libsrc/memmgr.pla: 0237:                         hpgtbl:[page, entry] = moveblk
; libsrc/memmgr.pla: 0238:                         addfre(memblk)
; libsrc/memmgr.pla: 0239:                         moved = 1
; libsrc/memmgr.pla: 0240:                     fin
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$4C			; BRFLS	_B038
	!WORD	_B038-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$54			; CALL	_X018
_F026 	!WORD	0		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$26			; LA	_D032+0
_F027 	!WORD	_D032+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C004
_F028 	!WORD	_C004		
	!BYTE	$02			; CN	1
	!BYTE	$74,$0E			; SLB	[14]
_B038 
_B039 
; libsrc/memmgr.pla: 0241:                 fin
_B030 
_B031 
; libsrc/memmgr.pla: 0242:             next
_B029 
	!BYTE	$A8			; DECBRGE	_B028
	!WORD	_B028-*
_B027 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$30			; DROP 
; libsrc/memmgr.pla: 0243:         else
	!BYTE	$50			; BRNCH	_B026
	!WORD	_B026-*
_B025 
; libsrc/memmgr.pla: 0244:             break
	!BYTE	$50			; BRNCH	_B022
	!WORD	_B022-*
; libsrc/memmgr.pla: 0245:         fin
_B026 
; libsrc/memmgr.pla: 0246:     next
_B024 
	!BYTE	$A8			; DECBRGE	_B023
	!WORD	_B023-*
_B022 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; libsrc/memmgr.pla: 0247:     if moved
; libsrc/memmgr.pla: 0248:         coallesce
; libsrc/memmgr.pla: 0249:     fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$4C			; BRFLS	_B040
	!WORD	_B040-*
	!BYTE	$54			; CALL	_C005
_F029 	!WORD	_C005		
	!BYTE	$30			; DROP 
_B040 
_B041 
; libsrc/memmgr.pla: 0250:     return moved
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$5A,$0F			; LEAVE	15
; libsrc/memmgr.pla: 0251: end
; libsrc/memmgr.pla: 0252: //
; libsrc/memmgr.pla: 0253: // Swap out memory block
; libsrc/memmgr.pla: 0254: //
; libsrc/memmgr.pla: 0255: def swapout(accessed)
					; accessed -> [0]
_C007 					; swapout()
; libsrc/memmgr.pla: 0256:     byte[64] filename
					; filename -> [2]
; libsrc/memmgr.pla: 0257:     byte ref
					; ref -> [66]
; libsrc/memmgr.pla: 0258:     word page, entry, memblk, hmem, size
					; page -> [67]
					; entry -> [69]
					; memblk -> [71]
					; hmem -> [73]
					; size -> [75]
; libsrc/memmgr.pla: 0259:     byte swapped
					; swapped -> [77]
; libsrc/memmgr.pla: 0260: 
; libsrc/memmgr.pla: 0261:     swapped = 0
	!BYTE	$58,$4E,$01		; ENTER	78,1
; libsrc/memmgr.pla: 0262:     for page = PG_TBL_SIZE - 1 downto 0
	!BYTE	$00			; CN	0
	!BYTE	$74,$4D			; SLB	[77]
	!BYTE	$00			; CN	0
	!BYTE	$0E			; CN	7
_B043 
	!BYTE	$6E,$43			; DLW	[67]
; libsrc/memmgr.pla: 0263:         if hpgtbl[page]
; libsrc/memmgr.pla: 0264:             for entry = 255 downto 0
	!BYTE	$26			; LA	_D032+0
_F030 	!WORD	_D032+0		
	!BYTE	$BA,$43			; IDXLW	[67]
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B045
	!WORD	_B045-*
	!BYTE	$00			; CN	0
	!BYTE	$2A,$FF			; CB	255
_B048 
	!BYTE	$6E,$45			; DLW	[69]
; libsrc/memmgr.pla: 0265:                 if hpgtbl:[page, entry].lsb & HMEM_STATE == HMEM_MOVEABLE
; libsrc/memmgr.pla: 0266:                     memblk = hpgtbl:[page, entry]
; libsrc/memmgr.pla: 0267:                     if not (memblk->blklok & accessed)
; libsrc/memmgr.pla: 0268:                         //
; libsrc/memmgr.pla: 0269:                         // Swap this block out
; libsrc/memmgr.pla: 0270:                         //
; libsrc/memmgr.pla: 0271:                         size     = memblk=>blksiz
; libsrc/memmgr.pla: 0272:                         hmem.lsb = page
; libsrc/memmgr.pla: 0273:                         hmem.msb = entry
; libsrc/memmgr.pla: 0274:                         swapfile(@filename, hmem)
; libsrc/memmgr.pla: 0275:                         fileio:create(@filename, $00, size) // embed size in aux type
; libsrc/memmgr.pla: 0276:                         //puts(@swapoutstr);puts(@filename);putc('@');puth(memblk);putc(':');puth(size);putln
; libsrc/memmgr.pla: 0277:                         ref = fileio:open(@filename)
; libsrc/memmgr.pla: 0278:                         if ref
; libsrc/memmgr.pla: 0279:                             //
; libsrc/memmgr.pla: 0280:                             // Write it out
; libsrc/memmgr.pla: 0281:                             //
; libsrc/memmgr.pla: 0282:                             if fileio:write(ref, memblk, size) == size
; libsrc/memmgr.pla: 0283:                                 //
; libsrc/memmgr.pla: 0284:                                 // Zero size in page table flags swapin to read from disk
; libsrc/memmgr.pla: 0285:                                 //
; libsrc/memmgr.pla: 0286:                                 hpgtbl:[page, entry] = HMEM_SWAPPED
; libsrc/memmgr.pla: 0287:                                 addfre(memblk)
; libsrc/memmgr.pla: 0288:                                 swapped = 1
; libsrc/memmgr.pla: 0289:                             fin
	!BYTE	$26			; LA	_D032+0
_F031 	!WORD	_D032+0		
	!BYTE	$BA,$43			; IDXLW	[67]
	!BYTE	$62			; LW
	!BYTE	$BA,$45			; IDXLW	[69]
	!BYTE	$60			; LB
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$4E			; BRTRU	_B050
	!WORD	_B050-*
	!BYTE	$26			; LA	_D032+0
_F032 	!WORD	_D032+0		
	!BYTE	$BA,$43			; IDXLW	[67]
	!BYTE	$62			; LW
	!BYTE	$BA,$45			; IDXLW	[69]
	!BYTE	$62			; LW
	!BYTE	$6E,$47			; DLW	[71]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$94			; AND 
	!BYTE	$4E			; BRTRU	_B052
	!WORD	_B052-*
	!BYTE	$66,$47			; LLW	[71]
	!BYTE	$62			; LW
	!BYTE	$76,$4B			; SLW	[75]
	!BYTE	$66,$43			; LLW	[67]
	!BYTE	$74,$49			; SLB	[73]
	!BYTE	$66,$45			; LLW	[69]
	!BYTE	$74,$4A			; SLB	[74]
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$66,$49			; LLW	[73]
	!BYTE	$54			; CALL	_C001
_F033 	!WORD	_C001		
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$00			; CN	0
	!BYTE	$66,$4B			; LLW	[75]
	!BYTE	$6A			; LAW	_X028+22
_F034 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$6A			; LAW	_X028+14
_F035 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$6C,$42			; DLB	[66]
	!BYTE	$4C			; BRFLS	_B054
	!WORD	_B054-*
	!BYTE	$64,$42			; LLB	[66]
	!BYTE	$66,$47			; LLW	[71]
	!BYTE	$66,$4B			; LLW	[75]
	!BYTE	$6A			; LAW	_X028+20
_F036 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$66,$4B			; LLW	[75]
	!BYTE	$24			; BRNE	_B056
	!WORD	_B056-*
	!BYTE	$06			; CN	3
	!BYTE	$26			; LA	_D032+0
_F037 	!WORD	_D032+0		
	!BYTE	$BA,$43			; IDXLW	[67]
	!BYTE	$62			; LW
	!BYTE	$BA,$45			; IDXLW	[69]
	!BYTE	$72			; SW
	!BYTE	$66,$47			; LLW	[71]
	!BYTE	$54			; CALL	_C004
_F038 	!WORD	_C004		
	!BYTE	$02			; CN	1
	!BYTE	$74,$4D			; SLB	[77]
_B056 
_B057 
; libsrc/memmgr.pla: 0290:                             fileio:close(ref)
; libsrc/memmgr.pla: 0291:                         fin
	!BYTE	$64,$42			; LLB	[66]
	!BYTE	$6A			; LAW	_X028+16
_F039 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B054 
_B055 
; libsrc/memmgr.pla: 0292:                     fin
_B052 
_B053 
; libsrc/memmgr.pla: 0293:                 fin
_B050 
_B051 
; libsrc/memmgr.pla: 0294:             next
_B049 
	!BYTE	$A8			; DECBRGE	_B048
	!WORD	_B048-*
_B047 
	!BYTE	$76,$45			; SLW	[69]
	!BYTE	$30			; DROP 
; libsrc/memmgr.pla: 0295:         else
	!BYTE	$50			; BRNCH	_B046
	!WORD	_B046-*
_B045 
; libsrc/memmgr.pla: 0296:             break
	!BYTE	$50			; BRNCH	_B042
	!WORD	_B042-*
; libsrc/memmgr.pla: 0297:         fin
_B046 
; libsrc/memmgr.pla: 0298:     next
_B044 
	!BYTE	$A8			; DECBRGE	_B043
	!WORD	_B043-*
_B042 
	!BYTE	$76,$43			; SLW	[67]
	!BYTE	$30			; DROP 
; libsrc/memmgr.pla: 0299:     if swapped
; libsrc/memmgr.pla: 0300:         coallesce
; libsrc/memmgr.pla: 0301:         compact
; libsrc/memmgr.pla: 0302:     fin
	!BYTE	$64,$4D			; LLB	[77]
	!BYTE	$4C			; BRFLS	_B058
	!WORD	_B058-*
	!BYTE	$54			; CALL	_C005
_F040 	!WORD	_C005		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C006
_F041 	!WORD	_C006		
	!BYTE	$30			; DROP 
_B058 
_B059 
; libsrc/memmgr.pla: 0303:     return swapped
	!BYTE	$64,$4D			; LLB	[77]
	!BYTE	$5A,$4E			; LEAVE	78
; libsrc/memmgr.pla: 0304: end
; libsrc/memmgr.pla: 0305: //
; libsrc/memmgr.pla: 0306: // Find a memory block
; libsrc/memmgr.pla: 0307: //
; libsrc/memmgr.pla: 0308: def findexact(size)
					; size -> [0]
_C008 					; findexact()
; libsrc/memmgr.pla: 0309:     word srch, prev
					; srch -> [2]
					; prev -> [4]
; libsrc/memmgr.pla: 0310: 
; libsrc/memmgr.pla: 0311:     srch = frelst
	!BYTE	$58,$06,$01		; ENTER	6,1
; libsrc/memmgr.pla: 0312:     prev = 0
; libsrc/memmgr.pla: 0313:     while srch
	!BYTE	$6A			; LAW	_D035+0
_F042 	!WORD	_D035+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B062
	!WORD	_B062-*
_B060 
; libsrc/memmgr.pla: 0314:         if srch=>fresiz == size
; libsrc/memmgr.pla: 0315:             //putc('E')
; libsrc/memmgr.pla: 0316:             return unlink(srch, prev)
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$24			; BRNE	_B063
	!WORD	_B063-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C002
_F043 	!WORD	_C002		
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/memmgr.pla: 0317:         fin
_B063 
_B064 
; libsrc/memmgr.pla: 0318:         prev = srch
; libsrc/memmgr.pla: 0319:         srch = srch=>frenxt
; libsrc/memmgr.pla: 0320:     loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B062 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B060
	!WORD	_B060-*
_B061 
; libsrc/memmgr.pla: 0321:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/memmgr.pla: 0322: end
; libsrc/memmgr.pla: 0323: def findbest(size)
					; size -> [0]
_C009 					; findbest()
; libsrc/memmgr.pla: 0324:     word srch, prev
					; srch -> [2]
					; prev -> [4]
; libsrc/memmgr.pla: 0325: 
; libsrc/memmgr.pla: 0326:     prev = 0
	!BYTE	$58,$06,$01		; ENTER	6,1
; libsrc/memmgr.pla: 0327:     srch = frelst
; libsrc/memmgr.pla: 0328:     while srch
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$6A			; LAW	_D035+0
_F044 	!WORD	_D035+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B067
	!WORD	_B067-*
_B065 
; libsrc/memmgr.pla: 0329:         if srch=>fresiz >= size
; libsrc/memmgr.pla: 0330:             //putc('B')
; libsrc/memmgr.pla: 0331:             return unfre(srch, prev, size)
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B068
	!WORD	_B068-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C003
_F045 	!WORD	_C003		
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/memmgr.pla: 0332:         fin
_B068 
_B069 
; libsrc/memmgr.pla: 0333:         prev = srch
; libsrc/memmgr.pla: 0334:         srch = srch=>frenxt
; libsrc/memmgr.pla: 0335:     loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B067 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B065
	!WORD	_B065-*
_B066 
; libsrc/memmgr.pla: 0336:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$06			; LEAVE	6
; libsrc/memmgr.pla: 0337: end
; libsrc/memmgr.pla: 0338: def findblk(size)
					; size -> [0]
_C010 					; findblk()
; libsrc/memmgr.pla: 0339:     word addr
					; addr -> [2]
; libsrc/memmgr.pla: 0340: 
; libsrc/memmgr.pla: 0341:     if size > MAX_BLK_SIZE; return 0; fin
	!BYTE	$58,$04,$01		; ENTER	4,1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$10,$20		; CW	8208
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B070
	!WORD	_B070-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
_B070 
_B071 
; libsrc/memmgr.pla: 0342:     addr = findexact(size)
; libsrc/memmgr.pla: 0343:     if !addr
; libsrc/memmgr.pla: 0344:         coallesce
; libsrc/memmgr.pla: 0345:         addr = findexact(size)
; libsrc/memmgr.pla: 0346:         if !addr
; libsrc/memmgr.pla: 0347:             compact
; libsrc/memmgr.pla: 0348:             addr = findbest(size)
; libsrc/memmgr.pla: 0349:             if !addr
; libsrc/memmgr.pla: 0350:                 swapout(HMEM_ACCESSED)
; libsrc/memmgr.pla: 0351:                 addr = findbest(size)
; libsrc/memmgr.pla: 0352:                 if !addr
; libsrc/memmgr.pla: 0353:                     swapout(0)
; libsrc/memmgr.pla: 0354:                     addr = findbest(size)
; libsrc/memmgr.pla: 0355:                 fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C008
_F046 	!WORD	_C008		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4E			; BRTRU	_B072
	!WORD	_B072-*
	!BYTE	$54			; CALL	_C005
_F047 	!WORD	_C005		
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C008
_F048 	!WORD	_C008		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4E			; BRTRU	_B074
	!WORD	_B074-*
	!BYTE	$54			; CALL	_C006
_F049 	!WORD	_C006		
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C009
_F050 	!WORD	_C009		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4E			; BRTRU	_B076
	!WORD	_B076-*
	!BYTE	$2A,$80			; CB	128
	!BYTE	$54			; CALL	_C007
_F051 	!WORD	_C007		
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C009
_F052 	!WORD	_C009		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4E			; BRTRU	_B078
	!WORD	_B078-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C007
_F053 	!WORD	_C007		
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C009
_F054 	!WORD	_C009		
	!BYTE	$76,$02			; SLW	[2]
_B078 
_B079 
; libsrc/memmgr.pla: 0356:             fin
_B076 
_B077 
; libsrc/memmgr.pla: 0357:         fin
_B074 
_B075 
; libsrc/memmgr.pla: 0358:     fin
_B072 
_B073 
; libsrc/memmgr.pla: 0359:     //
; libsrc/memmgr.pla: 0360:     // Fill in the block
; libsrc/memmgr.pla: 0361:     //
; libsrc/memmgr.pla: 0362:     //puts(@getblkstr);puth(addr);putc(':');puth(size);putln
; libsrc/memmgr.pla: 0363:     if addr
; libsrc/memmgr.pla: 0364:         addr=>blksiz = size
; libsrc/memmgr.pla: 0365:         addr->blkref = 1
; libsrc/memmgr.pla: 0366:         addr->blklok = 0
; libsrc/memmgr.pla: 0367:     fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B080
	!WORD	_B080-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
_B080 
_B081 
; libsrc/memmgr.pla: 0368:     return addr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/memmgr.pla: 0369: end
; libsrc/memmgr.pla: 0370: //
; libsrc/memmgr.pla: 0371: // Swap in a memory block (or allocate an uninitialized block)
; libsrc/memmgr.pla: 0372: //
; libsrc/memmgr.pla: 0373: def swapin(hmem)
					; hmem -> [0]
_C011 					; swapin()
; libsrc/memmgr.pla: 0374:     byte[64] filename
					; filename -> [2]
; libsrc/memmgr.pla: 0375:     byte[15] info
					; info -> [66]
; libsrc/memmgr.pla: 0376:     byte ref
					; ref -> [81]
; libsrc/memmgr.pla: 0377:     word memblk, size
					; memblk -> [82]
					; size -> [84]
; libsrc/memmgr.pla: 0378: 
; libsrc/memmgr.pla: 0379:     size = hpgtbl:[hmem.lsb, hmem.msb] & HMEM_SIZE
	!BYTE	$58,$56,$01		; ENTER	86,1
; libsrc/memmgr.pla: 0380:     if size
; libsrc/memmgr.pla: 0381:         //
; libsrc/memmgr.pla: 0382:         // This was just uninitialized memory, don't bother reading from file
; libsrc/memmgr.pla: 0383:         //
; libsrc/memmgr.pla: 0384:         memblk = findblk(size)
; libsrc/memmgr.pla: 0385:     else
	!BYTE	$26			; LA	_D032+0
_F055 	!WORD	_D032+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$62			; LW
	!BYTE	$5E,$FC			; CFFB	65532
	!BYTE	$94			; AND 
	!BYTE	$6E,$54			; DLW	[84]
	!BYTE	$4C			; BRFLS	_B082
	!WORD	_B082-*
	!BYTE	$66,$54			; LLW	[84]
	!BYTE	$54			; CALL	_C010
_F056 	!WORD	_C010		
	!BYTE	$76,$52			; SLW	[82]
	!BYTE	$50			; BRNCH	_B083
	!WORD	_B083-*
_B082 
; libsrc/memmgr.pla: 0386:         //
; libsrc/memmgr.pla: 0387:         // Swap this block back in
; libsrc/memmgr.pla: 0388:         //
; libsrc/memmgr.pla: 0389:         swapfile(@filename, hmem)
; libsrc/memmgr.pla: 0390:         fileio:getfileinfo(@filename, @info)
; libsrc/memmgr.pla: 0391:         size   = info:2 // Size encoded in aux type
; libsrc/memmgr.pla: 0392:         memblk = findblk(size)
; libsrc/memmgr.pla: 0393:         //puts(@swapinstr);puts(@filename);putc('@');puth(memblk);putc(':');puth(size);putln
; libsrc/memmgr.pla: 0394:         if memblk
; libsrc/memmgr.pla: 0395:             //
; libsrc/memmgr.pla: 0396:             // Read it in
; libsrc/memmgr.pla: 0397:             //
; libsrc/memmgr.pla: 0398:             ref = fileio:open(@filename)
; libsrc/memmgr.pla: 0399:             if ref
; libsrc/memmgr.pla: 0400:                 fileio:read(ref, memblk, size)
; libsrc/memmgr.pla: 0401:                 fileio:close(ref)
; libsrc/memmgr.pla: 0402:                 fileio:destroy(@filename)
; libsrc/memmgr.pla: 0403:             fin
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C001
_F057 	!WORD	_C001		
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$28,$42			; LLA	[66]
	!BYTE	$6A			; LAW	_X028+4
_F058 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$44			; LLW	[68]
	!BYTE	$6E,$54			; DLW	[84]
	!BYTE	$54			; CALL	_C010
_F059 	!WORD	_C010		
	!BYTE	$6E,$52			; DLW	[82]
	!BYTE	$4C			; BRFLS	_B084
	!WORD	_B084-*
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$6A			; LAW	_X028+14
_F060 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$6C,$51			; DLB	[81]
	!BYTE	$4C			; BRFLS	_B086
	!WORD	_B086-*
	!BYTE	$64,$51			; LLB	[81]
	!BYTE	$66,$52			; LLW	[82]
	!BYTE	$66,$54			; LLW	[84]
	!BYTE	$6A			; LAW	_X028+18
_F061 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$64,$51			; LLB	[81]
	!BYTE	$6A			; LAW	_X028+16
_F062 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$6A			; LAW	_X028+24
_F063 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B086 
_B087 
; libsrc/memmgr.pla: 0404:         fin
_B084 
_B085 
; libsrc/memmgr.pla: 0405:     fin
_B083 
; libsrc/memmgr.pla: 0406:     if memblk
; libsrc/memmgr.pla: 0407:         hpgtbl:[hmem.lsb, hmem.msb] = memblk
; libsrc/memmgr.pla: 0408:     fin
	!BYTE	$66,$52			; LLW	[82]
	!BYTE	$4C			; BRFLS	_B088
	!WORD	_B088-*
	!BYTE	$66,$52			; LLW	[82]
	!BYTE	$26			; LA	_D032+0
_F064 	!WORD	_D032+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$72			; SW
_B088 
_B089 
; libsrc/memmgr.pla: 0409:     return memblk
	!BYTE	$66,$52			; LLW	[82]
	!BYTE	$5A,$56			; LEAVE	86
; libsrc/memmgr.pla: 0410: end
; libsrc/memmgr.pla: 0411: //
; libsrc/memmgr.pla: 0412: // Incrementally clear the ACCESSED BIT
; libsrc/memmgr.pla: 0413: //
; libsrc/memmgr.pla: 0414: export def sweep#0
_C012 					; sweep()
; libsrc/memmgr.pla: 0415:     word memblk
					; memblk -> [0]
; libsrc/memmgr.pla: 0416: 
; libsrc/memmgr.pla: 0417:     if hpgtbl[sweeppg]
	!BYTE	$58,$02,$00		; ENTER	2,0
; libsrc/memmgr.pla: 0418:         memblk = hpgtbl:[sweeppg, sweepen]
; libsrc/memmgr.pla: 0419:         when memblk.lsb & HMEM_STATE
	!BYTE	$26			; LA	_D032+0
_F065 	!WORD	_D032+0		
	!BYTE	$BC			; IDXAB	_D036+0
_F066 	!WORD	_D036+0		
	!BYTE	$62			; LW
	!BYTE	$4C			; BRFLS	_B090
	!WORD	_B090-*
	!BYTE	$26			; LA	_D032+0
_F067 	!WORD	_D032+0		
	!BYTE	$BC			; IDXAB	_D036+0
_F068 	!WORD	_D036+0		
	!BYTE	$62			; LW
	!BYTE	$BC			; IDXAB	_D037+0
_F069 	!WORD	_D037+0		
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$52			; SEL
	!WORD	_B093-*
; libsrc/memmgr.pla: 0420:             is HMEM_MOVEABLE
_B094 
; libsrc/memmgr.pla: 0421:             is HMEM_LOCKED
_B095 
; libsrc/memmgr.pla: 0422:                 memblk = memblk & HMEM_ADDR
; libsrc/memmgr.pla: 0423:                 if memblk->blklok & HMEM_ACCESSED
; libsrc/memmgr.pla: 0424:                     memblk->blklok = memblk->blklok & $7F
; libsrc/memmgr.pla: 0425:                 fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5E,$FC			; CFFB	65532
	!BYTE	$94			; AND 
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B096
	!WORD	_B096-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
_B096 
_B097 
; libsrc/memmgr.pla: 0426:         wend
	!BYTE	$50			; BRNCH	_B092
	!WORD	_B092-*
_B093 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0000
	!WORD	_B094-*
	!WORD	$0002
	!WORD	_B095-*
_B092 
; libsrc/memmgr.pla: 0427:         if sweepen == 255
; libsrc/memmgr.pla: 0428:             sweepen = 0
; libsrc/memmgr.pla: 0429:             if sweeppg == 0
; libsrc/memmgr.pla: 0430:                 sweeppg = PG_TBL_SIZE - 1
; libsrc/memmgr.pla: 0431:             else
	!BYTE	$68			; LAB	_D037+0
_F070 	!WORD	_D037+0		
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$24			; BRNE	_B098
	!WORD	_B098-*
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D037+0
_F071 	!WORD	_D037+0		
	!BYTE	$68			; LAB	_D036+0
_F072 	!WORD	_D036+0		
	!BYTE	$4E			; BRTRU	_B100
	!WORD	_B100-*
	!BYTE	$0E			; CN	7
	!BYTE	$78			; SAB	_D036+0
_F073 	!WORD	_D036+0		
	!BYTE	$50			; BRNCH	_B101
	!WORD	_B101-*
_B100 
; libsrc/memmgr.pla: 0432:                 sweeppg = sweeppg - 1
; libsrc/memmgr.pla: 0433:             fin
	!BYTE	$68			; LAB	_D036+0
_F074 	!WORD	_D036+0		
	!BYTE	$8E			; DECR
	!BYTE	$78			; SAB	_D036+0
_F075 	!WORD	_D036+0		
_B101 
; libsrc/memmgr.pla: 0434:         else
	!BYTE	$50			; BRNCH	_B099
	!WORD	_B099-*
_B098 
; libsrc/memmgr.pla: 0435:             sweepen = sweepen + 1
; libsrc/memmgr.pla: 0436:         fin
	!BYTE	$68			; LAB	_D037+0
_F076 	!WORD	_D037+0		
	!BYTE	$8C			; INCR
	!BYTE	$78			; SAB	_D037+0
_F077 	!WORD	_D037+0		
_B099 
; libsrc/memmgr.pla: 0437:     else
	!BYTE	$50			; BRNCH	_B091
	!WORD	_B091-*
_B090 
; libsrc/memmgr.pla: 0438:         sweeppg = PG_TBL_SIZE - 1
; libsrc/memmgr.pla: 0439:     fin
	!BYTE	$0E			; CN	7
	!BYTE	$78			; SAB	_D036+0
_F078 	!WORD	_D036+0		
_B091 
; libsrc/memmgr.pla: 0440: end
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/memmgr.pla: 0441: //
; libsrc/memmgr.pla: 0442: // Set end of memory pool
; libsrc/memmgr.pla: 0443: //
; libsrc/memmgr.pla: 0444: export def brk(addr)
					; addr -> [0]
_C013 					; brk()
; libsrc/memmgr.pla: 0445:     word heapalign, brkblk, brksiz, srch
					; heapalign -> [2]
					; brkblk -> [4]
					; brksiz -> [6]
					; srch -> [8]
; libsrc/memmgr.pla: 0446: 
; libsrc/memmgr.pla: 0447:     //
; libsrc/memmgr.pla: 0448:     // Check if addr is too high or low
; libsrc/memmgr.pla: 0449:     //
; libsrc/memmgr.pla: 0450:     if isuge(addr, @heapalign); return 0; fin
	!BYTE	$58,$0A,$01		; ENTER	10,1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$54			; CALL	_X025
_F079 	!WORD	0		
	!BYTE	$4C			; BRFLS	_B102
	!WORD	_B102-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$0A			; LEAVE	10
_B102 
_B103 
; libsrc/memmgr.pla: 0451:     if isule(addr, heapmark); return 0; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X012
_F080 	!WORD	0		
	!BYTE	$54			; CALL	_X027
_F081 	!WORD	0		
	!BYTE	$4C			; BRFLS	_B104
	!WORD	_B104-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$0A			; LEAVE	10
_B104 
_B105 
; libsrc/memmgr.pla: 0452:     if not pooladdr
; libsrc/memmgr.pla: 0453:         //
; libsrc/memmgr.pla: 0454:         // Allocate the memory pool
; libsrc/memmgr.pla: 0455:         //
; libsrc/memmgr.pla: 0456:         heapalign = (heapmark | MIN_BLK_MASK) + 1
; libsrc/memmgr.pla: 0457:         brksiz    = addr - heapalign
; libsrc/memmgr.pla: 0458:         if isult(brksiz, MAX_BLK_SIZE); return 0; fin // Not enough heap
	!BYTE	$6A			; LAW	_D033+0
_F082 	!WORD	_D033+0		
	!BYTE	$4E			; BRTRU	_B106
	!WORD	_B106-*
	!BYTE	$54			; CALL	_X012
_F083 	!WORD	0		
	!BYTE	$3E,$03			; ORI	3
	!BYTE	$8C			; INCR
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$84			; SUB 
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$2C,$10,$20		; CW	8208
	!BYTE	$54			; CALL	_X026
_F084 	!WORD	0		
	!BYTE	$4C			; BRFLS	_B108
	!WORD	_B108-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$0A			; LEAVE	10
_B108 
_B109 
; libsrc/memmgr.pla: 0459:             poolsize = addr - heapmark
; libsrc/memmgr.pla: 0460:             pooladdr = heapalloc(poolsize)
; libsrc/memmgr.pla: 0461:             if pooladdr
; libsrc/memmgr.pla: 0462:                 frelst         = heapalign
; libsrc/memmgr.pla: 0463:                 frelst=>fresiz = brksiz
; libsrc/memmgr.pla: 0464:                 frelst=>frenxt = 0
; libsrc/memmgr.pla: 0465:             else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X012
_F085 	!WORD	0		
	!BYTE	$84			; SUB 
	!BYTE	$7E			; DAW	_D034+0
_F086 	!WORD	_D034+0		
	!BYTE	$54			; CALL	_X014
_F087 	!WORD	0		
	!BYTE	$7E			; DAW	_D033+0
_F088 	!WORD	_D033+0		
	!BYTE	$4C			; BRFLS	_B110
	!WORD	_B110-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$7A			; SAW	_D035+0
_F089 	!WORD	_D035+0		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$6A			; LAW	_D035+0
_F090 	!WORD	_D035+0		
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D035+0
_F091 	!WORD	_D035+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B111
	!WORD	_B111-*
_B110 
; libsrc/memmgr.pla: 0466:                 poolsize = 0
; libsrc/memmgr.pla: 0467:             fin
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D034+0
_F092 	!WORD	_D034+0		
_B111 
; libsrc/memmgr.pla: 0468:         else
	!BYTE	$50			; BRNCH	_B107
	!WORD	_B107-*
_B106 
; libsrc/memmgr.pla: 0469:         //
; libsrc/memmgr.pla: 0470:         // Can we extend the memory pool?
; libsrc/memmgr.pla: 0471:         //
; libsrc/memmgr.pla: 0472:         if pooladdr + poolsize == heapmark
; libsrc/memmgr.pla: 0473:             brksiz = addr - heapmark
; libsrc/memmgr.pla: 0474:             brkblk = heapalloc(brksiz)
; libsrc/memmgr.pla: 0475:             if brkblk
; libsrc/memmgr.pla: 0476:                 //
; libsrc/memmgr.pla: 0477:                 // Add block to end of free list
; libsrc/memmgr.pla: 0478:                 //
; libsrc/memmgr.pla: 0479:                 poolsize       = poolsize + brksiz
; libsrc/memmgr.pla: 0480:                 brkblk=>fresiz = brksiz
; libsrc/memmgr.pla: 0481:                 brkblk=>frenxt = 0
; libsrc/memmgr.pla: 0482:                 if frelst
; libsrc/memmgr.pla: 0483:                     srch = frelst
; libsrc/memmgr.pla: 0484:                     while srch=>frenxt; srch = srch=>frenxt; loop
	!BYTE	$6A			; LAW	_D033+0
_F093 	!WORD	_D033+0		
	!BYTE	$B6			; ADDAW	_D034+0
_F094 	!WORD	_D034+0		
	!BYTE	$54			; CALL	_X012
_F095 	!WORD	0		
	!BYTE	$24			; BRNE	_B112
	!WORD	_B112-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X012
_F096 	!WORD	0		
	!BYTE	$84			; SUB 
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$54			; CALL	_X014
_F097 	!WORD	0		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4C			; BRFLS	_B114
	!WORD	_B114-*
	!BYTE	$6A			; LAW	_D034+0
_F098 	!WORD	_D034+0		
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$7A			; SAW	_D034+0
_F099 	!WORD	_D034+0		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D035+0
_F100 	!WORD	_D035+0		
	!BYTE	$4C			; BRFLS	_B116
	!WORD	_B116-*
	!BYTE	$6A			; LAW	_D035+0
_F101 	!WORD	_D035+0		
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
_B118 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
_B120 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B118
	!WORD	_B118-*
_B119 
; libsrc/memmgr.pla: 0485:                     srch=>frenxt = brkblk
; libsrc/memmgr.pla: 0486:                 else
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B117
	!WORD	_B117-*
_B116 
; libsrc/memmgr.pla: 0487:                     frelst = brkblk
; libsrc/memmgr.pla: 0488:                 fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$7A			; SAW	_D035+0
_F102 	!WORD	_D035+0		
_B117 
; libsrc/memmgr.pla: 0489:                 coallesce // combine adjacent free space
; libsrc/memmgr.pla: 0490:             fin
	!BYTE	$54			; CALL	_C005
_F103 	!WORD	_C005		
	!BYTE	$30			; DROP 
_B114 
_B115 
; libsrc/memmgr.pla: 0491:         fin
_B112 
_B113 
; libsrc/memmgr.pla: 0492:     fin
_B107 
; libsrc/memmgr.pla: 0493:     return poolsize
	!BYTE	$6A			; LAW	_D034+0
_F104 	!WORD	_D034+0		
	!BYTE	$5A,$0A			; LEAVE	10
; libsrc/memmgr.pla: 0494: end
; libsrc/memmgr.pla: 0495: export def sbrk(size)
					; size -> [0]
_C014 					; sbrk()
; libsrc/memmgr.pla: 0496:     return brk((heapmark | MIN_BLK_MASK) + 1 + size + MIN_BLK_SIZE)
	!BYTE	$58,$02,$01		; ENTER	2,1
	!BYTE	$54			; CALL	_X012
_F105 	!WORD	0		
	!BYTE	$3E,$03			; ORI	3
	!BYTE	$8C			; INCR
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$54			; CALL	_C013
_F106 	!WORD	_C013		
	!BYTE	$5A,$02			; LEAVE	2
; libsrc/memmgr.pla: 0497: end
; libsrc/memmgr.pla: 0498: //
; libsrc/memmgr.pla: 0499: // Return the amount of free memory available, after garbage
; libsrc/memmgr.pla: 0500: // collection, swaps
; libsrc/memmgr.pla: 0501: //
; libsrc/memmgr.pla: 0502: export def hmemFre(lptr)
					; lptr -> [0]
_C015 					; hmemFre()
; libsrc/memmgr.pla: 0503:     word srch, free, largest
					; srch -> [2]
					; free -> [4]
					; largest -> [6]
; libsrc/memmgr.pla: 0504: 
; libsrc/memmgr.pla: 0505:     coallesce
	!BYTE	$58,$08,$01		; ENTER	8,1
; libsrc/memmgr.pla: 0506:     while compact; loop
	!BYTE	$54			; CALL	_C005
_F107 	!WORD	_C005		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B123
	!WORD	_B123-*
_B121 
_B123 
	!BYTE	$54			; CALL	_C006
_F108 	!WORD	_C006		
	!BYTE	$4E			; BRTRU	_B121
	!WORD	_B121-*
_B122 
; libsrc/memmgr.pla: 0507:     free    = 0
; libsrc/memmgr.pla: 0508:     largest = 0
; libsrc/memmgr.pla: 0509:     srch    = frelst
; libsrc/memmgr.pla: 0510:     while srch
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$00			; CN	0
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$6A			; LAW	_D035+0
_F109 	!WORD	_D035+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B126
	!WORD	_B126-*
_B124 
; libsrc/memmgr.pla: 0511:         //putc('F'); putc(' '); puth(srch); putc(':'); puth(srch=>fresiz); putln
; libsrc/memmgr.pla: 0512:         free = free + srch=>fresiz
; libsrc/memmgr.pla: 0513:         if srch=>fresiz > largest
; libsrc/memmgr.pla: 0514:             largest = srch=>fresiz
; libsrc/memmgr.pla: 0515:         fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B127
	!WORD	_B127-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
_B127 
_B128 
; libsrc/memmgr.pla: 0516:         srch = srch=>frenxt
; libsrc/memmgr.pla: 0517:     loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B126 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B124
	!WORD	_B124-*
_B125 
; libsrc/memmgr.pla: 0518:     if lptr
; libsrc/memmgr.pla: 0519:         *lptr = largest - MIN_BLK_SIZE
; libsrc/memmgr.pla: 0520:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4C			; BRFLS	_B129
	!WORD	_B129-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$3A,$04			; SUBI	4
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$72			; SW
_B129 
_B130 
; libsrc/memmgr.pla: 0521:     return free - MIN_BLK_SIZE
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$3A,$04			; SUBI	4
	!BYTE	$5A,$08			; LEAVE	8
; libsrc/memmgr.pla: 0522: end
; libsrc/memmgr.pla: 0523: //
; libsrc/memmgr.pla: 0524: // Allocate memory block
; libsrc/memmgr.pla: 0525: //
; libsrc/memmgr.pla: 0526: export def hmemNew(size)
					; size -> [0]
_C016 					; hmemNew()
; libsrc/memmgr.pla: 0527:     word page, entry, hnew, memblk
					; page -> [2]
					; entry -> [4]
					; hnew -> [6]
					; memblk -> [8]
; libsrc/memmgr.pla: 0528: 
; libsrc/memmgr.pla: 0529:     //
; libsrc/memmgr.pla: 0530:     // First, find a free handle
; libsrc/memmgr.pla: 0531:     //
; libsrc/memmgr.pla: 0532:     for page = PG_TBL_SIZE - 1 downto 0
	!BYTE	$58,$0A,$01		; ENTER	10,1
	!BYTE	$00			; CN	0
	!BYTE	$0E			; CN	7
_B132 
	!BYTE	$6E,$02			; DLW	[2]
; libsrc/memmgr.pla: 0533:         if !hpgtbl[page]
; libsrc/memmgr.pla: 0534:             //
; libsrc/memmgr.pla: 0535:             // Allocate a new page table
; libsrc/memmgr.pla: 0536:             //
; libsrc/memmgr.pla: 0537:             hpgtbl[page] = heapalloc(PG_SIZE)
; libsrc/memmgr.pla: 0538:             memset(hpgtbl[page], HMEM_AVAIL, PG_SIZE)
; libsrc/memmgr.pla: 0539:             //puts(@allocpgstr);puth(hpgtbl[page]);putln
; libsrc/memmgr.pla: 0540:             //
; libsrc/memmgr.pla: 0541:             // Check if we need to allocate the memory pool
; libsrc/memmgr.pla: 0542:             //
; libsrc/memmgr.pla: 0543:             if not pooladdr
; libsrc/memmgr.pla: 0544:                 //
; libsrc/memmgr.pla: 0545:                 // Allocate 3/4 of available heap on 128K machine, 1/2 on 64K machine
; libsrc/memmgr.pla: 0546:                 //
; libsrc/memmgr.pla: 0547:                 poolsize = (heapavail >> 1) & $7FFF
; libsrc/memmgr.pla: 0548:                 if MACHID & $30 == $30
; libsrc/memmgr.pla: 0549:                         poolsize = poolsize + (poolsize >> 1)
; libsrc/memmgr.pla: 0550:                 fin
	!BYTE	$26			; LA	_D032+0
_F110 	!WORD	_D032+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B134
	!WORD	_B134-*
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$54			; CALL	_X014
_F111 	!WORD	0		
	!BYTE	$26			; LA	_D032+0
_F112 	!WORD	_D032+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$72			; SW
	!BYTE	$26			; LA	_D032+0
_F113 	!WORD	_D032+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$54			; CALL	_X017
_F114 	!WORD	0		
	!BYTE	$6A			; LAW	_D033+0
_F115 	!WORD	_D033+0		
	!BYTE	$4E			; BRTRU	_B136
	!WORD	_B136-*
	!BYTE	$54			; CALL	_X016
_F116 	!WORD	0		
	!BYTE	$02			; CN	1
	!BYTE	$9C			; SHR
	!BYTE	$2C,$FF,$7F		; CW	32767
	!BYTE	$94			; AND 
	!BYTE	$7A			; SAW	_D034+0
_F117 	!WORD	_D034+0		
	!BYTE	$68			; LAB	_X001+0
_F118 	!WORD	0+0		
	!BYTE	$3C,$30			; ANDI	48
	!BYTE	$2A,$30			; CB	48
	!BYTE	$24			; BRNE	_B138
	!WORD	_B138-*
	!BYTE	$6A			; LAW	_D034+0
_F119 	!WORD	_D034+0		
	!BYTE	$34			; DUP
	!BYTE	$02			; CN	1
	!BYTE	$9C			; SHR
	!BYTE	$82			; ADD 
	!BYTE	$7A			; SAW	_D034+0
_F120 	!WORD	_D034+0		
_B138 
_B139 
; libsrc/memmgr.pla: 0551:                 if isult(poolsize, MAX_BLK_SIZE)
; libsrc/memmgr.pla: 0552:                     poolsize = MAX_BLK_SIZE
; libsrc/memmgr.pla: 0553:                 fin
	!BYTE	$6A			; LAW	_D034+0
_F121 	!WORD	_D034+0		
	!BYTE	$2C,$10,$20		; CW	8208
	!BYTE	$54			; CALL	_X026
_F122 	!WORD	0		
	!BYTE	$4C			; BRFLS	_B140
	!WORD	_B140-*
	!BYTE	$2C,$10,$20		; CW	8208
	!BYTE	$7A			; SAW	_D034+0
_F123 	!WORD	_D034+0		
_B140 
_B141 
; libsrc/memmgr.pla: 0554:                 sbrk(poolsize)
; libsrc/memmgr.pla: 0555:             fin
	!BYTE	$6A			; LAW	_D034+0
_F124 	!WORD	_D034+0		
	!BYTE	$54			; CALL	_C014
_F125 	!WORD	_C014		
	!BYTE	$30			; DROP 
_B136 
_B137 
; libsrc/memmgr.pla: 0556:         fin
_B134 
_B135 
; libsrc/memmgr.pla: 0557:         for entry = 255 downto 0
	!BYTE	$00			; CN	0
	!BYTE	$2A,$FF			; CB	255
_B143 
	!BYTE	$6E,$04			; DLW	[4]
; libsrc/memmgr.pla: 0558:             if hpgtbl:[page, entry].lsb == HMEM_AVAIL
; libsrc/memmgr.pla: 0559:                 //
; libsrc/memmgr.pla: 0560:                 // Reserve handle as swapped out block
; libsrc/memmgr.pla: 0561:                 // Nonzero size will flag swapin to not read from disk
; libsrc/memmgr.pla: 0562:                 //
; libsrc/memmgr.pla: 0563:                 //putc('N');putc(' ');putb(entry);putb(page);putc('@')
; libsrc/memmgr.pla: 0564:                 size = ((size + t_memblk) | MIN_BLK_MASK) + 1
; libsrc/memmgr.pla: 0565:                 hpgtbl:[page, entry] = size | HMEM_SWAPPED
; libsrc/memmgr.pla: 0566:                 hnew.lsb = page
; libsrc/memmgr.pla: 0567:                 hnew.msb = entry
; libsrc/memmgr.pla: 0568:                 return hnew
	!BYTE	$26			; LA	_D032+0
_F126 	!WORD	_D032+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$BA,$04			; IDXLW	[4]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$24			; BRNE	_B145
	!WORD	_B145-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$3E,$03			; ORI	3
	!BYTE	$8C			; INCR
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$3E,$03			; ORI	3
	!BYTE	$26			; LA	_D032+0
_F127 	!WORD	_D032+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$BA,$04			; IDXLW	[4]
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$74,$07			; SLB	[7]
	!BYTE	$32			; DROP2
	!BYTE	$32			; DROP2
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$5A,$0A			; LEAVE	10
; libsrc/memmgr.pla: 0569:             fin
_B145 
_B146 
; libsrc/memmgr.pla: 0570:         next
_B144 
	!BYTE	$A8			; DECBRGE	_B143
	!WORD	_B143-*
_B142 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$30			; DROP 
; libsrc/memmgr.pla: 0571:     next
_B133 
	!BYTE	$A8			; DECBRGE	_B132
	!WORD	_B132-*
_B131 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$30			; DROP 
; libsrc/memmgr.pla: 0572:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$0A			; LEAVE	10
; libsrc/memmgr.pla: 0573: end
; libsrc/memmgr.pla: 0574: //
; libsrc/memmgr.pla: 0575: // Lock memory block in place
; libsrc/memmgr.pla: 0576: //
; libsrc/memmgr.pla: 0577: export def hmemLock(hmem)
					; hmem -> [0]
_C017 					; hmemLock()
; libsrc/memmgr.pla: 0578:     word memblk
					; memblk -> [2]
; libsrc/memmgr.pla: 0579: 
; libsrc/memmgr.pla: 0580:     memblk = hpgtbl:[hmem.lsb, hmem.msb]
	!BYTE	$58,$04,$01		; ENTER	4,1
; libsrc/memmgr.pla: 0581:     when memblk.lsb & HMEM_STATE
	!BYTE	$26			; LA	_D032+0
_F128 	!WORD	_D032+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$52			; SEL
	!WORD	_B148-*
; libsrc/memmgr.pla: 0582:         is HMEM_SWAPPED
_B149 
; libsrc/memmgr.pla: 0583:             memblk = swapin(hmem)
; libsrc/memmgr.pla: 0584:             if not memblk; return 0; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C011
_F129 	!WORD	_C011		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4E			; BRTRU	_B150
	!WORD	_B150-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
_B150 
_B151 
; libsrc/memmgr.pla: 0585:         is HMEM_MOVEABLE
_B152 
; libsrc/memmgr.pla: 0586:             hpgtbl:[hmem.lsb, hmem.msb] = memblk | HMEM_LOCKED
; libsrc/memmgr.pla: 0587:         is HMEM_LOCKED
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$3E,$02			; ORI	2
	!BYTE	$26			; LA	_D032+0
_F130 	!WORD	_D032+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$72			; SW
_B153 
; libsrc/memmgr.pla: 0588:             memblk = memblk & HMEM_ADDR
; libsrc/memmgr.pla: 0589:             memblk->blklok = (memblk->blklok + 1) | HMEM_ACCESSED
; libsrc/memmgr.pla: 0590:             //putc('L');putc(' ');puth(hmem);putc('@');puth(memblk);putln
; libsrc/memmgr.pla: 0591:             return memblk + t_memblk
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5E,$FC			; CFFB	65532
	!BYTE	$94			; AND 
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/memmgr.pla: 0592:     wend
	!BYTE	$50			; BRNCH	_B147
	!WORD	_B147-*
_B148 
	!BYTE	$03			; CASEBLOCK
	!WORD	$0000
	!WORD	_B152-*
	!WORD	$0002
	!WORD	_B153-*
	!WORD	$0003
	!WORD	_B149-*
_B147 
; libsrc/memmgr.pla: 0593:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/memmgr.pla: 0594: end
; libsrc/memmgr.pla: 0595: //
; libsrc/memmgr.pla: 0596: // Unlock memory block
; libsrc/memmgr.pla: 0597: //
; libsrc/memmgr.pla: 0598: export def hmemUnlock(hmem)#0
					; hmem -> [0]
_C018 					; hmemUnlock()
; libsrc/memmgr.pla: 0599:     byte lock
					; lock -> [2]
; libsrc/memmgr.pla: 0600:     word memblk
					; memblk -> [3]
; libsrc/memmgr.pla: 0601: 
; libsrc/memmgr.pla: 0602:     memblk = hpgtbl:[hmem.lsb, hmem.msb]
	!BYTE	$58,$05,$01		; ENTER	5,1
; libsrc/memmgr.pla: 0603:     if memblk.lsb & HMEM_STATE == HMEM_LOCKED
; libsrc/memmgr.pla: 0604:         memblk = memblk & HMEM_ADDR
; libsrc/memmgr.pla: 0605:         lock = memblk->blklok - 1
; libsrc/memmgr.pla: 0606:         if lock == HMEM_ACCESSED
; libsrc/memmgr.pla: 0607:             //
; libsrc/memmgr.pla: 0608:             // Block is now moveable
; libsrc/memmgr.pla: 0609:             //
; libsrc/memmgr.pla: 0610:             hpgtbl:[hmem.lsb, hmem.msb] = memblk
; libsrc/memmgr.pla: 0611:         fin
	!BYTE	$26			; LA	_D032+0
_F131 	!WORD	_D032+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$62			; LW
	!BYTE	$76,$03			; SLW	[3]
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$04			; CN	2
	!BYTE	$24			; BRNE	_B154
	!WORD	_B154-*
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$5E,$FC			; CFFB	65532
	!BYTE	$94			; AND 
	!BYTE	$6E,$03			; DLW	[3]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$8E			; DECR
	!BYTE	$6C,$02			; DLB	[2]
	!BYTE	$2A,$80			; CB	128
	!BYTE	$24			; BRNE	_B156
	!WORD	_B156-*
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$26			; LA	_D032+0
_F132 	!WORD	_D032+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$72			; SW
_B156 
_B157 
; libsrc/memmgr.pla: 0612:         memblk->blklok = lock
; libsrc/memmgr.pla: 0613:         //putc('U');putc(' ');puth(hmem);putln
; libsrc/memmgr.pla: 0614:     fin
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
_B154 
_B155 
; libsrc/memmgr.pla: 0615: end
	!BYTE	$5A,$05			; LEAVE	5
; libsrc/memmgr.pla: 0616: //
; libsrc/memmgr.pla: 0617: // Increment reference count
; libsrc/memmgr.pla: 0618: //
; libsrc/memmgr.pla: 0619: export def hmemRef(hmem)#0
					; hmem -> [0]
_C019 					; hmemRef()
; libsrc/memmgr.pla: 0620:     word memblk
					; memblk -> [2]
; libsrc/memmgr.pla: 0621: 
; libsrc/memmgr.pla: 0622:     memblk = hpgtbl:[hmem.lsb, hmem.msb]
	!BYTE	$58,$04,$01		; ENTER	4,1
; libsrc/memmgr.pla: 0623:     when memblk.lsb & HMEM_STATE
	!BYTE	$26			; LA	_D032+0
_F133 	!WORD	_D032+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$52			; SEL
	!WORD	_B159-*
; libsrc/memmgr.pla: 0624:         is HMEM_SWAPPED
_B160 
; libsrc/memmgr.pla: 0625:             memblk = swapin(hmem)
; libsrc/memmgr.pla: 0626:         is HMEM_LOCKED
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C011
_F134 	!WORD	_C011		
	!BYTE	$76,$02			; SLW	[2]
_B161 
; libsrc/memmgr.pla: 0627:         is HMEM_MOVEABLE
_B162 
; libsrc/memmgr.pla: 0628:             memblk = memblk & HMEM_ADDR
; libsrc/memmgr.pla: 0629:             if not memblk; return; fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5E,$FC			; CFFB	65532
	!BYTE	$94			; AND 
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$4E			; BRTRU	_B163
	!WORD	_B163-*
	!BYTE	$5A,$04			; LEAVE	4
_B163 
_B164 
; libsrc/memmgr.pla: 0630:             memblk->blkref = memblk->blkref + 1
; libsrc/memmgr.pla: 0631:     wend
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B158
	!WORD	_B158-*
_B159 
	!BYTE	$03			; CASEBLOCK
	!WORD	$0000
	!WORD	_B162-*
	!WORD	$0002
	!WORD	_B161-*
	!WORD	$0003
	!WORD	_B160-*
_B158 
; libsrc/memmgr.pla: 0632: end
	!BYTE	$5A,$04			; LEAVE	4
; libsrc/memmgr.pla: 0633: //
; libsrc/memmgr.pla: 0634: // Decrement reference count
; libsrc/memmgr.pla: 0635: //
; libsrc/memmgr.pla: 0636: export def hmemDel(hmem)#0
					; hmem -> [0]
_C020 					; hmemDel()
; libsrc/memmgr.pla: 0637:     byte ref
					; ref -> [2]
; libsrc/memmgr.pla: 0638:     word memblk
					; memblk -> [3]
; libsrc/memmgr.pla: 0639: 
; libsrc/memmgr.pla: 0640:     memblk = hpgtbl:[hmem.lsb, hmem.msb]
	!BYTE	$58,$05,$01		; ENTER	5,1
; libsrc/memmgr.pla: 0641:     when memblk & HMEM_STATE
	!BYTE	$26			; LA	_D032+0
_F135 	!WORD	_D032+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$62			; LW
	!BYTE	$6E,$03			; DLW	[3]
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$52			; SEL
	!WORD	_B166-*
; libsrc/memmgr.pla: 0642:         is HMEM_SWAPPED
_B167 
; libsrc/memmgr.pla: 0643:         memblk = swapin(hmem)
; libsrc/memmgr.pla: 0644:         is HMEM_LOCKED
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C011
_F136 	!WORD	_C011		
	!BYTE	$76,$03			; SLW	[3]
_B168 
; libsrc/memmgr.pla: 0645:         is HMEM_MOVEABLE
_B169 
; libsrc/memmgr.pla: 0646:             memblk = memblk & HMEM_ADDR
; libsrc/memmgr.pla: 0647:             if not memblk; return; fin
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$5E,$FC			; CFFB	65532
	!BYTE	$94			; AND 
	!BYTE	$6E,$03			; DLW	[3]
	!BYTE	$4E			; BRTRU	_B170
	!WORD	_B170-*
	!BYTE	$5A,$05			; LEAVE	5
_B170 
_B171 
; libsrc/memmgr.pla: 0648:             ref = memblk->blkref - 1
; libsrc/memmgr.pla: 0649:             if ref == 0
; libsrc/memmgr.pla: 0650:                 //
; libsrc/memmgr.pla: 0651:                 // No more references, free block
; libsrc/memmgr.pla: 0652:                 //
; libsrc/memmgr.pla: 0653:                 hpgtbl:[hmem.lsb, hmem.msb] = HMEM_AVAIL
; libsrc/memmgr.pla: 0654:                 addfre(memblk)
; libsrc/memmgr.pla: 0655:             else
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$8E			; DECR
	!BYTE	$6C,$02			; DLB	[2]
	!BYTE	$4E			; BRTRU	_B172
	!WORD	_B172-*
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D032+0
_F137 	!WORD	_D032+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$B8,$01			; IDXLB	[1]
	!BYTE	$72			; SW
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$54			; CALL	_C004
_F138 	!WORD	_C004		
	!BYTE	$50			; BRNCH	_B173
	!WORD	_B173-*
_B172 
; libsrc/memmgr.pla: 0656:                 memblk->blkref = ref
; libsrc/memmgr.pla: 0657:             fin
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
_B173 
; libsrc/memmgr.pla: 0658:             break
	!BYTE	$50			; BRNCH	_B165
	!WORD	_B165-*
; libsrc/memmgr.pla: 0659:     wend
	!BYTE	$50			; BRNCH	_B165
	!WORD	_B165-*
_B166 
	!BYTE	$03			; CASEBLOCK
	!WORD	$0000
	!WORD	_B169-*
	!WORD	$0002
	!WORD	_B168-*
	!WORD	$0003
	!WORD	_B167-*
_B165 
; libsrc/memmgr.pla: 0660: end
	!BYTE	$5A,$05			; LEAVE	5
; libsrc/memmgr.pla: 0661: //
; libsrc/memmgr.pla: 0662: // Initialization:
; libsrc/memmgr.pla: 0663: //
; libsrc/memmgr.pla: 0664: // Search for best swap volume
; libsrc/memmgr.pla: 0665: //
; libsrc/memmgr.pla: 0666: // !!! Does this work on Apple ///???
; libsrc/memmgr.pla: 0667: //
; libsrc/memmgr.pla: 0668: sysbuf = $0800 // heapallocalign(1024, 8, 0)
_INIT 
; libsrc/memmgr.pla: 0669: initdata = heapalloc(t_initdata) // Use data on heap for initialization
; libsrc/memmgr.pla: 0670: initdata=>volparms.0 = 2
; libsrc/memmgr.pla: 0671: initdata=>volparms.1 = 0
; libsrc/memmgr.pla: 0672: initdata=>volparms:2 = sysbuf
; libsrc/memmgr.pla: 0673: syscall($C5, @initdata=>volparms)
; libsrc/memmgr.pla: 0674: initdata=>volptr   = sysbuf
; libsrc/memmgr.pla: 0675: initdata=>ramfree  = 0
; libsrc/memmgr.pla: 0676: initdata=>bestfree = 0
; libsrc/memmgr.pla: 0677: for sweepen = 0 to 15
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$7A			; SAW	_D031+0
_F139 	!WORD	_D031+0		
	!BYTE	$2A,$19			; CB	25
	!BYTE	$54			; CALL	_X014
_F140 	!WORD	0		
	!BYTE	$7A			; SAW	_D030+0
_F141 	!WORD	_D030+0		
	!BYTE	$04			; CN	2
	!BYTE	$6A			; LAW	_D030+0
_F142 	!WORD	_D030+0		
	!BYTE	$38,$15			; ADDI	21
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D030+0
_F143 	!WORD	_D030+0		
	!BYTE	$38,$15			; ADDI	21
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D031+0
_F144 	!WORD	_D031+0		
	!BYTE	$6A			; LAW	_D030+0
_F145 	!WORD	_D030+0		
	!BYTE	$38,$15			; ADDI	21
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$2A,$C5			; CB	197
	!BYTE	$6A			; LAW	_D030+0
_F146 	!WORD	_D030+0		
	!BYTE	$38,$15			; ADDI	21
	!BYTE	$54			; CALL	_X011
_F147 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D031+0
_F148 	!WORD	_D031+0		
	!BYTE	$6A			; LAW	_D030+0
_F149 	!WORD	_D030+0		
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D030+0
_F150 	!WORD	_D030+0		
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D030+0
_F151 	!WORD	_D030+0		
	!BYTE	$38,$0A			; ADDI	10
	!BYTE	$72			; SW
	!BYTE	$1E			; CN	15
	!BYTE	$00			; CN	0
_B175 
	!BYTE	$7C			; DAB	_D037+0
_F152 	!WORD	_D037+0		
; libsrc/memmgr.pla: 0678:     ^initdata=>volptr = ^initdata=>volptr & $0F
; libsrc/memmgr.pla: 0679:     if ^initdata=>volptr
; libsrc/memmgr.pla: 0680:         memcpy(@swapvol + 2, initdata=>volptr + 1, ^initdata=>volptr)
; libsrc/memmgr.pla: 0681:         swapvol = ^initdata=>volptr + 1
; libsrc/memmgr.pla: 0682:         fileio:getfileinfo(@swapvol, @initdata->volinfo)
; libsrc/memmgr.pla: 0683:         initdata=>freeblks = initdata=>volinfo:2 - initdata=>volinfo:5
; libsrc/memmgr.pla: 0684:         if initdata=>volptr:1 == $522F and initdata=>volptr:3 == $4D41 // '/RAM'
; libsrc/memmgr.pla: 0685:             if isugt(initdata=>freeblks, initdata=>ramfree)
; libsrc/memmgr.pla: 0686:                 initdata=>ramvol  = initdata=>volptr
; libsrc/memmgr.pla: 0687:                 initdata=>ramfree = initdata=>freeblks
; libsrc/memmgr.pla: 0688:             fin
	!BYTE	$6A			; LAW	_D030+0
_F153 	!WORD	_D030+0		
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$6A			; LAW	_D030+0
_F154 	!WORD	_D030+0		
	!BYTE	$62			; LW
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D030+0
_F155 	!WORD	_D030+0		
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B177
	!WORD	_B177-*
	!BYTE	$26			; LA	_D038+2
_F156 	!WORD	_D038+2		
	!BYTE	$6A			; LAW	_D030+0
_F157 	!WORD	_D030+0		
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$6A			; LAW	_D030+0
_F158 	!WORD	_D030+0		
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F159 	!WORD	0		
	!BYTE	$6A			; LAW	_D030+0
_F160 	!WORD	_D030+0		
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$78			; SAB	_D038+0
_F161 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D038+0
_F162 	!WORD	_D038+0		
	!BYTE	$6A			; LAW	_D030+0
_F163 	!WORD	_D030+0		
	!BYTE	$38,$19			; ADDI	25
	!BYTE	$6A			; LAW	_X028+4
_F164 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D030+0
_F165 	!WORD	_D030+0		
	!BYTE	$38,$19			; ADDI	25
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D030+0
_F166 	!WORD	_D030+0		
	!BYTE	$38,$19			; ADDI	25
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$62			; LW
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_D030+0
_F167 	!WORD	_D030+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D030+0
_F168 	!WORD	_D030+0		
	!BYTE	$8C			; INCR
	!BYTE	$62			; LW
	!BYTE	$2C,$2F,$52		; CW	21039
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B179
	!WORD	_B179-*
	!BYTE	$6A			; LAW	_D030+0
_F169 	!WORD	_D030+0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$62			; LW
	!BYTE	$2C,$41,$4D		; CW	19777
	!BYTE	$40			; ISEQ
_B179 
	!BYTE	$4C			; BRFLS	_B180
	!WORD	_B180-*
	!BYTE	$6A			; LAW	_D030+0
_F170 	!WORD	_D030+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D030+0
_F171 	!WORD	_D030+0		
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_X024
_F172 	!WORD	0		
	!BYTE	$4C			; BRFLS	_B182
	!WORD	_B182-*
	!BYTE	$6A			; LAW	_D030+0
_F173 	!WORD	_D030+0		
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D030+0
_F174 	!WORD	_D030+0		
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D030+0
_F175 	!WORD	_D030+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D030+0
_F176 	!WORD	_D030+0		
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$72			; SW
_B182 
_B183 
; libsrc/memmgr.pla: 0689:         elsif isugt(initdata=>freeblks, initdata=>bestfree)
	!BYTE	$50			; BRNCH	_B181
	!WORD	_B181-*
_B180 
; libsrc/memmgr.pla: 0690:             initdata=>bestvol  = initdata=>volptr
; libsrc/memmgr.pla: 0691:             initdata=>bestfree = initdata=>freeblks
; libsrc/memmgr.pla: 0692:         fin
	!BYTE	$6A			; LAW	_D030+0
_F177 	!WORD	_D030+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D030+0
_F178 	!WORD	_D030+0		
	!BYTE	$38,$0A			; ADDI	10
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_X024
_F179 	!WORD	0		
	!BYTE	$4C			; BRFLS	_B184
	!WORD	_B184-*
	!BYTE	$6A			; LAW	_D030+0
_F180 	!WORD	_D030+0		
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D030+0
_F181 	!WORD	_D030+0		
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D030+0
_F182 	!WORD	_D030+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D030+0
_F183 	!WORD	_D030+0		
	!BYTE	$38,$0A			; ADDI	10
	!BYTE	$72			; SW
_B184 
_B181 
; libsrc/memmgr.pla: 0693:     fin
_B177 
_B178 
; libsrc/memmgr.pla: 0694:     initdata=>volptr = initdata=>volptr + 16
; libsrc/memmgr.pla: 0695: next
	!BYTE	$6A			; LAW	_D030+0
_F184 	!WORD	_D030+0		
	!BYTE	$62			; LW
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$6A			; LAW	_D030+0
_F185 	!WORD	_D030+0		
	!BYTE	$72			; SW
_B176 
	!BYTE	$A4			; INCBRLE	_B175
	!WORD	_B175-*
_B174 
	!BYTE	$78			; SAB	_D037+0
_F186 	!WORD	_D037+0		
	!BYTE	$30			; DROP 
; libsrc/memmgr.pla: 0696: if isugt(initdata=>ramfree, $40) or isugt(initdata=>ramfree, initdata=>bestfree) // RAMdrive greater than 64K? Use it
; libsrc/memmgr.pla: 0697:     initdata=>bestvol  = initdata=>ramvol
; libsrc/memmgr.pla: 0698:     initdata=>bestfree = initdata=>ramfree
; libsrc/memmgr.pla: 0699: fin
	!BYTE	$6A			; LAW	_D030+0
_F187 	!WORD	_D030+0		
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$62			; LW
	!BYTE	$2A,$40			; CB	64
	!BYTE	$54			; CALL	_X024
_F188 	!WORD	0		
	!BYTE	$AE			; BROR	_B185
	!WORD	_B185-*
	!BYTE	$6A			; LAW	_D030+0
_F189 	!WORD	_D030+0		
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D030+0
_F190 	!WORD	_D030+0		
	!BYTE	$38,$0A			; ADDI	10
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_X024
_F191 	!WORD	0		
_B185 
	!BYTE	$4C			; BRFLS	_B186
	!WORD	_B186-*
	!BYTE	$6A			; LAW	_D030+0
_F192 	!WORD	_D030+0		
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D030+0
_F193 	!WORD	_D030+0		
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D030+0
_F194 	!WORD	_D030+0		
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D030+0
_F195 	!WORD	_D030+0		
	!BYTE	$38,$0A			; ADDI	10
	!BYTE	$72			; SW
_B186 
_B187 
; libsrc/memmgr.pla: 0700: memcpy(@swapvol + 2, initdata=>bestvol + 1, ^initdata=>bestvol)
; libsrc/memmgr.pla: 0701: swapvol = ^initdata=>bestvol + 1
; libsrc/memmgr.pla: 0702: memcpy(@swapvol + swapvol + 1, @swapdir + 1, swapdir)
; libsrc/memmgr.pla: 0703: swapvol = swapvol + swapdir
; libsrc/memmgr.pla: 0704: fileio:create(@swapvol, $0F, $0000) // Create the swap directory
; libsrc/memmgr.pla: 0705: //
; libsrc/memmgr.pla: 0706: // Clear out left over swap files
; libsrc/memmgr.pla: 0707: //
; libsrc/memmgr.pla: 0708: initdata->catref     = fileio:open(@swapvol)
; libsrc/memmgr.pla: 0709: initdata->firstblk   = 1
; libsrc/memmgr.pla: 0710: initdata->swapstrlen = swapvol
; libsrc/memmgr.pla: 0711: repeat
	!BYTE	$26			; LA	_D038+2
_F196 	!WORD	_D038+2		
	!BYTE	$6A			; LAW	_D030+0
_F197 	!WORD	_D030+0		
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$6A			; LAW	_D030+0
_F198 	!WORD	_D030+0		
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F199 	!WORD	0		
	!BYTE	$6A			; LAW	_D030+0
_F200 	!WORD	_D030+0		
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$78			; SAB	_D038+0
_F201 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D038+0
_F202 	!WORD	_D038+0		
	!BYTE	$B4			; ADDAB	_D038+0
_F203 	!WORD	_D038+0		
	!BYTE	$8C			; INCR
	!BYTE	$26			; LA	_D039+1
_F204 	!WORD	_D039+1		
	!BYTE	$68			; LAB	_D039+0
_F205 	!WORD	_D039+0		
	!BYTE	$54			; CALL	_X018
_F206 	!WORD	0		
	!BYTE	$68			; LAB	_D038+0
_F207 	!WORD	_D038+0		
	!BYTE	$B4			; ADDAB	_D039+0
_F208 	!WORD	_D039+0		
	!BYTE	$78			; SAB	_D038+0
_F209 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D038+0
_F210 	!WORD	_D038+0		
	!BYTE	$1E			; CN	15
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X028+22
_F211 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D038+0
_F212 	!WORD	_D038+0		
	!BYTE	$6A			; LAW	_X028+14
_F213 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_D030+0
_F214 	!WORD	_D030+0		
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_D030+0
_F215 	!WORD	_D030+0		
	!BYTE	$38,$11			; ADDI	17
	!BYTE	$70			; SB
	!BYTE	$68			; LAB	_D038+0
_F216 	!WORD	_D038+0		
	!BYTE	$6A			; LAW	_D030+0
_F217 	!WORD	_D030+0		
	!BYTE	$38,$14			; ADDI	20
	!BYTE	$70			; SB
_B189 
; libsrc/memmgr.pla: 0712:     if fileio:read(initdata->catref, @initdata->catalog, 512) == 512
; libsrc/memmgr.pla: 0713:         initdata=>catentry = @initdata->catalog.4
; libsrc/memmgr.pla: 0714:         if initdata->firstblk
; libsrc/memmgr.pla: 0715:             initdata->entrylen   = initdata->catalog.$23
; libsrc/memmgr.pla: 0716:             initdata->entriesblk = initdata->catalog.$24
; libsrc/memmgr.pla: 0717:             initdata=>filecnt    = initdata=>catalog:$25
; libsrc/memmgr.pla: 0718:             initdata=>catentry   = initdata=>catentry + initdata->entrylen
; libsrc/memmgr.pla: 0719:         fin
	!BYTE	$6A			; LAW	_D030+0
_F218 	!WORD	_D030+0		
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$60			; LB
	!BYTE	$6A			; LAW	_D030+0
_F219 	!WORD	_D030+0		
	!BYTE	$38,$19			; ADDI	25
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$6A			; LAW	_X028+18
_F220 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$24			; BRNE	_B191
	!WORD	_B191-*
	!BYTE	$6A			; LAW	_D030+0
_F221 	!WORD	_D030+0		
	!BYTE	$38,$19			; ADDI	25
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$6A			; LAW	_D030+0
_F222 	!WORD	_D030+0		
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D030+0
_F223 	!WORD	_D030+0		
	!BYTE	$38,$11			; ADDI	17
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B193
	!WORD	_B193-*
	!BYTE	$6A			; LAW	_D030+0
_F224 	!WORD	_D030+0		
	!BYTE	$38,$19			; ADDI	25
	!BYTE	$38,$23			; ADDI	35
	!BYTE	$60			; LB
	!BYTE	$6A			; LAW	_D030+0
_F225 	!WORD	_D030+0		
	!BYTE	$38,$12			; ADDI	18
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D030+0
_F226 	!WORD	_D030+0		
	!BYTE	$38,$19			; ADDI	25
	!BYTE	$38,$24			; ADDI	36
	!BYTE	$60			; LB
	!BYTE	$6A			; LAW	_D030+0
_F227 	!WORD	_D030+0		
	!BYTE	$38,$13			; ADDI	19
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D030+0
_F228 	!WORD	_D030+0		
	!BYTE	$38,$19			; ADDI	25
	!BYTE	$38,$25			; ADDI	37
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D030+0
_F229 	!WORD	_D030+0		
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D030+0
_F230 	!WORD	_D030+0		
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D030+0
_F231 	!WORD	_D030+0		
	!BYTE	$38,$12			; ADDI	18
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$6A			; LAW	_D030+0
_F232 	!WORD	_D030+0		
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$72			; SW
_B193 
_B194 
; libsrc/memmgr.pla: 0720:         for sweepen = initdata->firstblk to initdata->entriesblk
	!BYTE	$6A			; LAW	_D030+0
_F233 	!WORD	_D030+0		
	!BYTE	$38,$13			; ADDI	19
	!BYTE	$60			; LB
	!BYTE	$6A			; LAW	_D030+0
_F234 	!WORD	_D030+0		
	!BYTE	$38,$11			; ADDI	17
	!BYTE	$60			; LB
	!BYTE	$A0			; BRGT	_B195
	!WORD	_B195-*
_B196 
	!BYTE	$7C			; DAB	_D037+0
_F235 	!WORD	_D037+0		
; libsrc/memmgr.pla: 0721:             ^initdata=>catentry = ^initdata=>catentry & $0F
; libsrc/memmgr.pla: 0722:             if ^initdata=>catentry
; libsrc/memmgr.pla: 0723:                 memcpy(@swapvol + swapvol + 1, initdata=>catentry + 1, ^initdata=>catentry)
; libsrc/memmgr.pla: 0724:                 swapvol = swapvol + ^initdata=>catentry
; libsrc/memmgr.pla: 0725:                 fileio:destroy(@swapvol)
; libsrc/memmgr.pla: 0726:                 swapvol = initdata->swapstrlen
; libsrc/memmgr.pla: 0727:             fin
	!BYTE	$6A			; LAW	_D030+0
_F236 	!WORD	_D030+0		
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$6A			; LAW	_D030+0
_F237 	!WORD	_D030+0		
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$62			; LW
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D030+0
_F238 	!WORD	_D030+0		
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B198
	!WORD	_B198-*
	!BYTE	$26			; LA	_D038+0
_F239 	!WORD	_D038+0		
	!BYTE	$B4			; ADDAB	_D038+0
_F240 	!WORD	_D038+0		
	!BYTE	$8C			; INCR
	!BYTE	$6A			; LAW	_D030+0
_F241 	!WORD	_D030+0		
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$6A			; LAW	_D030+0
_F242 	!WORD	_D030+0		
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F243 	!WORD	0		
	!BYTE	$68			; LAB	_D038+0
_F244 	!WORD	_D038+0		
	!BYTE	$6A			; LAW	_D030+0
_F245 	!WORD	_D030+0		
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$78			; SAB	_D038+0
_F246 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D038+0
_F247 	!WORD	_D038+0		
	!BYTE	$6A			; LAW	_X028+24
_F248 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D030+0
_F249 	!WORD	_D030+0		
	!BYTE	$38,$14			; ADDI	20
	!BYTE	$60			; LB
	!BYTE	$78			; SAB	_D038+0
_F250 	!WORD	_D038+0		
_B198 
_B199 
; libsrc/memmgr.pla: 0728:             initdata=>catentry = initdata=>catentry + initdata->entrylen
; libsrc/memmgr.pla: 0729:         next
	!BYTE	$6A			; LAW	_D030+0
_F251 	!WORD	_D030+0		
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D030+0
_F252 	!WORD	_D030+0		
	!BYTE	$38,$12			; ADDI	18
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$6A			; LAW	_D030+0
_F253 	!WORD	_D030+0		
	!BYTE	$38,$0E			; ADDI	14
	!BYTE	$72			; SW
_B197 
	!BYTE	$A4			; INCBRLE	_B196
	!WORD	_B196-*
_B195 
	!BYTE	$78			; SAB	_D037+0
_F254 	!WORD	_D037+0		
	!BYTE	$30			; DROP 
; libsrc/memmgr.pla: 0730:         initdata->firstblk = 0
; libsrc/memmgr.pla: 0731:     else
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D030+0
_F255 	!WORD	_D030+0		
	!BYTE	$38,$11			; ADDI	17
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B192
	!WORD	_B192-*
_B191 
; libsrc/memmgr.pla: 0732:         initdata->filecnt = 0
; libsrc/memmgr.pla: 0733:     fin
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D030+0
_F256 	!WORD	_D030+0		
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$70			; SB
_B192 
; libsrc/memmgr.pla: 0734: until !initdata->filecnt
_B190 
	!BYTE	$6A			; LAW	_D030+0
_F257 	!WORD	_D030+0		
	!BYTE	$38,$0C			; ADDI	12
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B189
	!WORD	_B189-*
_B188 
; libsrc/memmgr.pla: 0735: fileio:close(initdata->catref)
; libsrc/memmgr.pla: 0736: heaprelease(initdata)
; libsrc/memmgr.pla: 0737: //puts(@swapvol); putln
; libsrc/memmgr.pla: 0738: done
	!BYTE	$6A			; LAW	_D030+0
_F258 	!WORD	_D030+0		
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$60			; LB
	!BYTE	$6A			; LAW	_X028+16
_F259 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D030+0
_F260 	!WORD	_D030+0		
	!BYTE	$54			; CALL	_X015
_F261 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
_SYSFLAGS	=	0
_DEFCNT	=	22
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C010		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C011		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C012		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C013		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C014		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C015		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C016		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C017		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C018		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C019		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C020		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	25			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	12			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	27			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	12			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	26			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	12			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	12			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	12			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	12			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	16			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	1			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	26			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F133-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F134-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F135-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F136-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F137-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F138-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F139-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F140-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F141-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F142-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F143-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F144-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F145-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F146-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F147-_SEGBEGIN		
	!BYTE	11			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F148-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F149-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F150-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F151-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F152-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F153-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F154-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F155-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F156-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F157-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F158-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F159-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F160-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F161-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F162-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F163-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F164-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F165-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F166-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F167-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F168-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F169-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F170-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F171-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F172-_SEGBEGIN		
	!BYTE	24			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F173-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F174-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F175-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F176-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F177-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F178-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F179-_SEGBEGIN		
	!BYTE	24			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F180-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F181-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F182-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F183-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F184-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F185-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F186-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F187-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F188-_SEGBEGIN		
	!BYTE	24			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F189-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F190-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F191-_SEGBEGIN		
	!BYTE	24			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F192-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F193-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F194-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F195-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F196-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F197-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F198-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F199-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F200-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F201-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F202-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F203-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F204-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F205-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F206-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F207-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F208-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F209-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F210-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F211-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F212-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F213-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F214-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F215-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F216-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F217-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F218-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F219-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F220-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F221-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F222-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F223-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F224-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F225-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F226-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F227-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F228-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F229-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F230-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F231-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F232-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F233-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F234-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F235-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F236-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F237-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F238-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F239-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F240-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F241-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F242-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F243-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F244-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F245-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F246-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F247-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F248-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F249-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F250-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F251-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F252-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F253-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F254-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F255-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F256-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F257-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F258-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F259-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F260-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F261-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: MACHID
	!BYTE	$CD,$C1,$C3,$C8,$C9,$44
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	1			; ESD INDEX
	; DCI STRING: SYSCALL
	!BYTE	$D3,$D9,$D3,$C3,$C1,$CC,$4C
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	11			; ESD INDEX
	; DCI STRING: HEAPMARK
	!BYTE	$C8,$C5,$C1,$D0,$CD,$C1,$D2,$4B
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	12			; ESD INDEX
	; DCI STRING: HEAPALLOC
	!BYTE	$C8,$C5,$C1,$D0,$C1,$CC,$CC,$CF,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	14			; ESD INDEX
	; DCI STRING: HEAPRELEASE
	!BYTE	$C8,$C5,$C1,$D0,$D2,$C5,$CC,$C5,$C1,$D3,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	15			; ESD INDEX
	; DCI STRING: HEAPAVAIL
	!BYTE	$C8,$C5,$C1,$D0,$C1,$D6,$C1,$C9,$4C
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	16			; ESD INDEX
	; DCI STRING: MEMSET
	!BYTE	$CD,$C5,$CD,$D3,$C5,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	17			; ESD INDEX
	; DCI STRING: MEMCPY
	!BYTE	$CD,$C5,$CD,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	18			; ESD INDEX
	; DCI STRING: ISUGT
	!BYTE	$C9,$D3,$D5,$C7,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	24			; ESD INDEX
	; DCI STRING: ISUGE
	!BYTE	$C9,$D3,$D5,$C7,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	25			; ESD INDEX
	; DCI STRING: ISULT
	!BYTE	$C9,$D3,$D5,$CC,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	26			; ESD INDEX
	; DCI STRING: ISULE
	!BYTE	$C9,$D3,$D5,$CC,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	27			; ESD INDEX
	; DCI STRING: FILEIO
	!BYTE	$C6,$C9,$CC,$C5,$C9,$4F
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	28			; ESD INDEX
	; DCI STRING: SWEEP
	!BYTE	$D3,$D7,$C5,$C5,$50
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C012		
	; DCI STRING: BRK
	!BYTE	$C2,$D2,$4B
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C013		
	; DCI STRING: SBRK
	!BYTE	$D3,$C2,$D2,$4B
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C014		
	; DCI STRING: HMEMFRE
	!BYTE	$C8,$CD,$C5,$CD,$C6,$D2,$45
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C015		
	; DCI STRING: HMEMNEW
	!BYTE	$C8,$CD,$C5,$CD,$CE,$C5,$57
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C016		
	; DCI STRING: HMEMLOCK
	!BYTE	$C8,$CD,$C5,$CD,$CC,$CF,$C3,$4B
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C017		
	; DCI STRING: HMEMUNLOCK
	!BYTE	$C8,$CD,$C5,$CD,$D5,$CE,$CC,$CF,$C3,$4B
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C018		
	; DCI STRING: HMEMREF
	!BYTE	$C8,$CD,$C5,$CD,$D2,$C5,$46
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C019		
	; DCI STRING: HMEMDEL
	!BYTE	$C8,$CD,$C5,$CD,$C4,$C5,$4C
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C020		
	!BYTE	$00			; END OF ESD
