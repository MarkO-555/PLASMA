include "inc/cmdsys.plh"
include "inc/int32.plh"
include "inc/fpstr.plh"

const TYPE_MASK  = $70
const NIL        = $00
const BOOL_FALSE = $00
const BOOL_TRUE  = $01
const CONS_TYPE  = $10
const SYM_TYPE   = $20
const SYM_LEN    = $0F
const NUM_TYPE   = $30
const NUM_INT    = $31
const NUM_FLOAT  = $32
const MARK_BIT   = $80
const MARK_MASK  = $7F

struc t_elem
  word link
  byte type
end
struc t_cons
  res[t_elem]
  word car
  word cdr
end
struc t_sym
  res[t_elem]
  word natv
  word lambda
  char[0] name
end
struc t_numint
  res[t_elem]
  word[2] intval
end
struc t_numfloat
  res[t_elem]
  res[10] floatval
end

predef eval_expr(expr)

var sym_quote, sym_lambda, sym_cond
res[t_elem]   pred_true  = 0, 0, BOOL_TRUE
res[t_elem]   pred_false = 0, 0, BOOL_FALSE

var cons_list  = NULL
var cons_free  = NULL
var int_list   = NULL
var int_free   = NULL
var float_list = NULL
var float_free = NULL
var sym_list   = NULL
var assoc_list = NULL // SYM->value association list

//
// Garbage collector
//

def mark_list(listptr)#0
  while listptr
    listptr->type = listptr->type | MARK_BIT
    listptr = listptr=>link
  loop
end

def mark_elems#0
  mark_list(cons_list)
  mark_list(int_list)
  mark_list(float_list)
end

def sweep_expr(expr)#0
  while expr
    expr->type = expr->type & MARK_MASK
    if expr->type == CONS_TYPE
      sweep_expr(expr=>car)
      expr = expr=>cdr
    else
      expr = NULL
    fin
  loop
end

def sweep_used#0
  var symptr

  sweep_expr(assoc_list)
  symptr = sym_list
  while symptr
    if symptr=>lambda
      sweep_expr(symptr=>lambda)
    fin
    symptr = symptr=>link
  loop
end

def collect_list(listhead, freehead)#2
  var listptr, prevptr

  prevptr = NULL
  listptr = listhead
  while listptr
    if listptr->type & MARK_BIT
      if prevptr
        prevptr=>link = listptr=>link
        listptr=>link = freehead
        freehead      = listptr
        listptr       = prevptr=>link
      else
        listhead      = listptr=>link
        listptr=>link = freehead
        freehead      = listptr
        listptr       = listhead
      fin
    else
      prevptr = listptr
      listptr = listptr=>link
    fin
  loop
  return listhead, freehead
end

def collect_unused#0
  cons_list,  cons_free  = collect_list(cons_list,  cons_free)
  int_list,   int_free   = collect_list(int_list,   int_free)
  float_list, float_free = collect_list(float_list, float_free)
end

export def gc#0
  mark_elems
  sweep_used
  collect_unused
end

//
// Build ATOMS
//

export def new_cons#1
  var consptr

  if cons_free
    consptr   = cons_free
    cons_free = cons_free=>link
  else
    consptr = heapalloc(t_cons)
  fin
  consptr=>link = cons_list
  cons_list     = consptr
  consptr->type = CONS_TYPE
  consptr=>car  = NULL
  consptr=>cdr  = NULL
  return consptr
end

def match_int(intlo, inthi)
  var intptr

  intptr = int_list
  while intptr
    if intptr=>intval[0] == intlo and intptr=>intval[1] == inthi
      return intptr
    fin
    intptr = intptr=>link
  loop
  return NULL
end

export def new_int(intlo, inthi)#1
  var intptr

  intptr = match_int(intlo, inthi)
  if intptr; return intptr; fin
  if int_free
    intptr   = int_free
    int_free = int_free=>link
  else
    intptr = heapalloc(t_numint)
  fin
  intptr=>link      = int_list
  int_list          = intptr
  intptr->type      = NUM_INT
  intptr=>intval[0] = intlo
  intptr=>intval[1] = inthi
  return intptr
end

def match_float(extptr)
  var floatptr
  byte i

  floatptr = float_list
  while floatptr
    for i = 0 to 4
      if floatptr=>floatval[i] <> extptr=>[i]
        break
      fin
    next
    if i > 4
      return floatptr
    fin
    floatptr = floatptr=>link
  loop
  return NULL
end

export def new_float(extptr)#1
  var floatptr

  floatptr = match_float(extptr)
  if floatptr; return floatptr; fin
  if float_free
    floatptr   = float_free
    float_free = float_free=>link
  else
    floatptr = heapalloc(t_numfloat)
  fin
  floatptr=>link = float_list
  float_list     = floatptr
  floatptr->type = NUM_FLOAT
  memcpy(floatptr + floatval, extptr, 10)
  return floatptr
end

def match_sym(symstr)
  var symptr
  byte len, typelen, i

  len     = ^symstr
  typelen = SYM_TYPE | len
  len--; symstr++
  symptr  = sym_list
  while symptr
    if symptr->type == typelen
      for i = 0 to len
        if symptr->name[i] <> symstr->[i]; break; fin
      next
      if i > len
        return symptr
      fin
    fin
    symptr = symptr=>link
  loop
  return NULL
end

export def new_sym(symstr)#1
  var symptr

  symptr = match_sym(symstr)
  if symptr; return symptr; fin // Return already existing symbol
  symptr         = heapalloc(t_sym + ^symstr)
  symptr=>link   = sym_list
  sym_list       = symptr
  symptr->type   = ^symstr | SYM_TYPE
  symptr=>natv   = NULL
  symptr=>lambda = NULL
  memcpy(symptr + name, symstr + 1, ^symstr)
  return symptr
end

//
// Build/set association between symbols and values
//

def assoc(symptr)
  var pair

  if symptr->type & TYPE_MASK == SYM_TYPE
    //
    // Search association list for symbol
    //
    pair = assoc_list
    while pair
      if (pair=>car=>car == symptr)
        return pair=>car
      fin
      pair = pair=>cdr
    loop
  fin
  return NULL // SYM not associated
end

export def new_assoc(symptr, valptr)#0
  var pair, addlist

  if symptr and (symptr->type & TYPE_MASK <> SYM_TYPE)
    puts("Not a SYM in new_assoc\n")
    return
  fin
  pair         = new_cons
  pair=>car    = symptr
  pair=>cdr    = valptr
  if assoc_list // Add to end of assoc_list
    addlist = assoc_list
    while addlist=>cdr
      addlist = addlist=>cdr
    loop
    addlist=>cdr = new_cons
    addlist      = addlist=>cdr
  else // New list
    assoc_list = new_cons
    addlist    = assoc_list
  fin
  addlist=>car = pair
end

export def set_assoc(symptr, valptr)#0
  var pair

  //
  // Search association list for symbol
  //
  pair = assoc(symptr)
  if pair
    pair=>cdr = valptr // update association
  else
    new_assoc(symptr, valptr) // add association if unknown
  fin
end

//
// Print textual representation of S-expression
//

def print_atom(atom)#0
  char prstr[32]

  if not atom
    puts("NIL")
  else
    when atom->type & TYPE_MASK
      is NIL
        putc(atom->type ?? 'T' :: 'F')
        break
      is NUM_TYPE
        when atom->type
          is NUM_INT
            if atom=>intval[1] >= 0; putc(' '); fin // Add space for pos
            puti32(atom + intval)
            break
          is NUM_FLOAT
            puts(ext2str(atom + floatval, @prstr, 6, 4, FPSTR_FIXED|FPSTR_STRIP|FPSTR_FLEX))
            break
        wend
        break
      is SYM_TYPE
        prstr = atom->type & SYM_LEN
        memcpy(@prstr + 1, atom + name, prstr)
        puts(@prstr)
        break;
      otherwise
        puts("Unkown atom type\n")
    wend
  fin
end

export def print_expr(expr)#0
  if not expr
    puts("NIL")
  else
    if expr->type == CONS_TYPE
      putc('(')
      while expr and expr->type == CONS_TYPE
        print_expr(expr=>car)
        expr = expr=>cdr
        if expr
          if expr->type <> CONS_TYPE
            putc('.')
            print_atom(expr)
            expr = NULL
          else
            putc(' ')
          fin
        fin
      loop
      putc(')')
    else
      print_atom(expr)
    fin
  fin
end

//
// Parse textual representation of S-expression
//

def is_num(cptr)
  if ^cptr == '-' or ^cptr == '+'; cptr++; fin
  return ^cptr >= '0' and ^cptr <= '9'
end

def is_alphasym(c)
  return (c >= '*' and c <= 'z') and (c <> '.') and (c <> ',')
end

def parse_num(evalptr)#2 // return evalptr, intptr
  var startptr
  var int[2], ext[5]
  byte sign

  sign = FALSE
  if ^evalptr == '-'
    sign = TRUE
    evalptr++
  elsif ^evalptr == '+'
    evalptr++
  fin
  startptr = evalptr
  while ^evalptr >= '0' and ^evalptr <= '9'
    evalptr++
  loop
  if (evalptr - startptr > 10) or ^evalptr == '.' or toupper(^evalptr) == 'E'
    if ^evalptr == '.'
      evalptr++
      while ^evalptr >= '0' and ^evalptr <= '9'
        evalptr++
      loop
    fin
    if toupper(^evalptr) == 'E'
      evalptr++
      if ^evalptr == '-' or ^evalptr == '+'; evalptr++; fin
      while ^evalptr >= '0' and ^evalptr <= '9'
        evalptr++
      loop
    fin
    if sign; startptr--; fin
    ^(startptr - 1) = evalptr - startptr
    str2ext(startptr - 1, @ext)
    return evalptr, new_float(@ext)
  fin
  zero32
  while startptr <> evalptr
    muli16(10); addi16(^startptr - '0')
    startptr++
  loop
  if sign; neg32; fin
  store32(@int)
  return evalptr, new_int(int[0], int[1])
end

def parse_sym(evalptr)#2 // return evalptr, symptr
  var symstr

  symstr = evalptr - 1
  while is_alphasym(^evalptr)
    ^evalptr = toupper(^evalptr)
    evalptr++
  loop
  ^symstr = evalptr - symstr - 1
  if ^symstr > 31; ^symstr = 31; fin
  return evalptr, new_sym(symstr)
end

export def parse_expr(evalptr, level, refill)#2 // return evalptr, exprptr
  var exprptr, consptr, elemptr, quotecons

  exprptr = NULL
  consptr = NULL
  while TRUE
    //
    // Parse textual S-expression
    //
    elemptr = NULL
    when ^evalptr
      is 0
        if level
          evalptr = refill() // Refill input buffer
        else
          return evalptr, exprptr
        fin
        break
      is ' '
      is ','
        evalptr++
        break
      is ')'
        if not exprptr
          exprptr = new_cons // NIL
        fin
        return evalptr + 1, exprptr
      is '('
        evalptr++
        if level == 0
          level++
        else
          evalptr, elemptr = parse_expr(evalptr, 1, refill)
        fin
        break
      is '\''
        evalptr++
        evalptr, elemptr    = parse_expr(evalptr, 0, refill)
        quotecons           = new_cons
        quotecons=>car      = sym_quote
        quotecons=>cdr      = new_cons
        quotecons=>cdr=>car = elemptr
        elemptr             = quotecons
        if level == 0
          return evalptr, elemptr
        fin
        break
      is '.'
        evalptr++
        evalptr, elemptr = parse_expr(evalptr, 0, refill)
        //
        // Add expression to CDR
        //
        if not (consptr and consptr=>car)
          puts("Invalid . operator\n")
          return evalptr, exprptr
        fin
        consptr=>cdr = elemptr
        elemptr = NULL
        break
      otherwise
        if is_num(evalptr)
          evalptr, elemptr = parse_num(evalptr)
        elsif is_alphasym(^evalptr)
          evalptr, elemptr = parse_sym(evalptr)
        else
          putc('\\')
          putc(^evalptr)
          evalptr++
        fin
        if level == 0
          return evalptr, elemptr
        fin
    wend
    if elemptr
      //
      // Add element to S-expression
      //
      if not consptr
        consptr = new_cons
        exprptr = consptr
      else
        if consptr=>cdr
          puts("Improperly formed .\n")
          return evalptr, exprptr
        fin
        consptr=>cdr = new_cons
        consptr      = consptr=>cdr
      fin
      //
      // Add element to CAR
      //
      consptr=>car = elemptr
    fin
  loop
  return evalptr, exprptr
end

//
// Evaluate expression
//

def enter_lambda(curl, expr, params)#2 // curl, expr
  var args, arglist, pairlist, pair

  if !expr or expr=>car <> sym_lambda
    puts("Invalid LAMBDA expression: ")
    print_expr(expr)
    return NULL, NULL
  fin
  args = expr=>cdr=>car
  if curl == expr
    //
    // Update current associations during tail recursion
    //
    while args
      assoc(args=>car)=>cdr = eval_expr(params=>car)
      args                  = args=>cdr
      params                = params=>cdr
    loop
  else
    //
    // Build arg list before prepending to assoc_list
    //
    arglist = NULL
    while args
      if arglist
        pairlist=>cdr = new_cons
        pairlist      = pairlist=>cdr
      else
        arglist  = new_cons
        pairlist = arglist
      fin
      pair          = new_cons
      pair=>car     = args=>car
      pair=>cdr     = eval_expr(params=>car)
      pairlist=>car = pair
      args          = args=>cdr
      params        = params=>cdr
    loop
    if arglist
      pairlist=>cdr = assoc_list
      assoc_list    = arglist
    fin
  fin
  return expr, expr=>cdr=>cdr=>car
end

export def eval_expr(expr)#1
  var alist_enter, curl, expr_car

  curl        = NULL // Current lambda
  alist_enter = assoc_list
  while expr
    if expr->type == CONS_TYPE
      //
      // List - first element better be a function
      //
      expr_car = expr=>car
      if expr_car->type & TYPE_MASK == SYM_TYPE
        if expr_car=>natv
          expr = expr_car=>natv(expr=>cdr) // Native function
          break
        elsif expr_car=>lambda // DEFINEd lambda S-expression
          curl, expr = enter_lambda(curl, expr_car=>lambda, expr=>cdr)
        elsif expr_car == sym_cond // Inline cond() evaluation
          expr = expr=>cdr
          while expr
            if eval_expr(expr=>car=>car) == @pred_true
              expr = expr=>car=>cdr=>car
              break
            fin
            expr = expr=>cdr
          loop
        else // Symbol associated with lambda
          curl, expr = enter_lambda(curl, assoc(expr_car)=>cdr, expr=>cdr)
        fin
      elsif expr_car->type == CONS_TYPE and expr_car=>car == sym_lambda
          curl, expr = enter_lambda(NULL, expr_car, expr=>cdr) // Inline lambda
      fin
    else
      //
      // Atom
      //
      if expr->type & TYPE_MASK == SYM_TYPE; expr = assoc(expr)=>cdr; fin
      break
    fin
  loop
  assoc_list = alist_enter
  return expr
end

//
// Base native functions
//

export def bool_pred(bool)
  return bool ?? @pred_true :: @pred_false
end

def natv_atom(expr)
  var result

  result = eval_expr(expr=>car)
  return bool_pred(!result or result->type <> CONS_TYPE))
end

def natv_null(expr)
  var result

  result = eval_expr(expr=>car)
  return bool_pred(!result or !result->type)
end

def natv_eq(expr)
  return bool_pred(eval_expr(expr=>car) == eval_expr(expr=>cdr=>car))
end

def natv_not(expr)
  return bool_pred(eval_expr(expr=>car) == @pred_false)
end

def natv_and(expr)
  while (expr and eval_expr(expr=>car) == @pred_true)
    expr = expr=>cdr
  loop
  return bool_pred(!expr)
end

def natv_or(expr)
  while (expr and eval_expr(expr=>car) == @pred_false)
    expr = expr=>cdr
  loop
  return bool_pred(expr)
end

def natv_cons(expr)
  var consptr

  consptr = new_cons
  consptr=>car = eval_expr(expr=>car)
  consptr=>cdr = eval_expr(expr=>cdr=>car)
  return consptr
end

def natv_car(expr)
  return eval_expr(expr=>car)=>car
end

def natv_cdr(expr)
  return eval_expr(expr=>car)=>cdr
end

def natv_quote(expr)
  return expr=>car
end

def natv_label(expr)
  var valptr

  valptr = expr=>cdr=>car
  set_assoc(expr=>car, valptr)
  return valptr
end

def natv_define(expr)

  var symptr, funclist, funcptr

  funclist = NULL
  if expr
    funclist = new_cons
    funcptr  = funclist
  fin
  while expr
    symptr         = expr=>car=>car
    symptr=>lambda = expr=>car=>cdr=>car
    funcptr=>car   = symptr
    expr           = expr=>cdr
    if expr
      funcptr=>cdr   = new_cons
      funcptr        = funcptr=>cdr
    fin
  loop
  return funclist
end

def natv_print(expr)
  expr = eval_expr(expr=>car)
  print_expr(expr)
  putln
  return expr
end

//
// Install default functions
//

new_assoc(new_sym("NIL"), NULL)
new_assoc(new_sym("T"),   @pred_true)
new_assoc(new_sym("F"),   @pred_false)
sym_lambda = new_sym("LAMBDA")
sym_quote  = new_sym("QUOTE")
sym_cond   = new_sym("COND")
sym_quote=>natv         = @natv_quote
new_sym("CAR")=>natv    = @natv_car
new_sym("CDR")=>natv    = @natv_cdr
new_sym("CONS")=>natv   = @natv_cons
new_sym("ATOM")=>natv   = @natv_atom
new_sym("EQ")=>natv     = @natv_eq
new_sym("NOT")=>natv    = @natv_not
new_sym("AND")=>natv    = @natv_and
new_sym("OR")=>natv     = @natv_or
new_sym("NULL")=>natv   = @natv_null
new_sym("LABEL")=>natv  = @natv_label
new_sym("DEFINE")=>natv = @natv_define
new_sym("PRINT")=>natv  = @natv_print
return modkeep | modinitkeep
done
