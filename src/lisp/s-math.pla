include "inc/cmdsys.plh"
include "inc/int32.plh"
include "inc/fpu.plh"

import sexpr
  const TYPE_MASK  = $70
  const NIL        = $00
  const BOOL_FALSE = $00
  const BOOL_TRUE  = $01
  const CONS_TYPE  = $10
  const SYM_TYPE   = $20
  const SYM_LEN    = $0F
  const NUM_TYPE   = $30
  const NUM_INT    = $31
  const NUM_FLOAT  = $32
  const ARRAY_TYPE = $40
  const MARK_BIT   = $80
  const MARK_MASK  = $7F
  const NULL_HACK  = 1  // Hack so we can set APVALs to NULL

  struc t_elem
    word link
    byte type
  end
  struc t_cons
    res[t_elem]
    word car
    word cdr
  end
  struc t_sym
    res[t_elem]
    word natv
    word lambda
    word array
    word apval
    char name[0]
  end
  struc t_numint
    res[t_elem]
    word intval[2]
  end
  struc t_numfloat
    res[t_elem]
    res floatval[10]
  end

  predef new_sym(symstr)#1
  predef new_int(intlo, inthi)#1
  predef new_float(extptr)#1
  predef print_expr(expr)#0
  predef eval_expr(expr)#1
  predef bool_pred(bool)#1
end

res[t_numint] nan = 0, 0, NUM_INT, 0, 0, 0, 128 // NaN

res[10] tempext

def eval_num(expr)
  var result

  result = eval_expr(expr=>car)
  if result and result->type & TYPE_MASK == NUM_TYPE
    return result
  fin
  puts("Evaluated not an number type: "); print_expr(expr=>car); putln
  return @nan
end

export def eval_int(expr)#1 // Always return an int
  var result
  var[2] int

  result = eval_num(expr)
  if result->type == NUM_FLOAT
    fpu:pushExt(result + floatval)
    fpu:pullInt(@int)
    int[1] = int[0] < 0 ?? -1 :: 0
    return new_int(int[0], int[1])
  fin
  return result
end

def push_int32(intptr)#0
  var[2] int
  byte isneg

  isneg = FALSE
  if intptr=>[1] < 0
    load32(intptr)
    isneg = TRUE
    neg32
    store32(@int)
  else
    int[0] = intptr=>[0]
    int[1] = intptr=>[1]
  fin
  fpu:pushInt(@int[1])
  fpu:scalebXInt(16)
  fpu:pushInt(@int[0])
  fpu:addXY()
  if isneg
    fpu:negX()
  fin
end

def push_num(numptr)#0
  var int

  if numptr->type == NUM_FLOAT
    fpu:pushExt(numptr + floatval)
  elsif numptr->type == NUM_INT
    push_int32(numptr + intval)
  else
    puts("Pushing non number type: $"); putb(numptr->type); putln
    int = 0
    fpu:pushInt(@int)
  fin
end

def natv_sum(symptr, expr)
  var num
  var[2] intsum
  var[5] extsum

  intsum[0] = 0
  intsum[1] = 0
  num       = eval_num(expr)
  expr      = expr=>cdr
  if num->type == NUM_INT
    //
    // Sum as integers unless a float is encountered
    //
    intsum[0] = num=>intval[0]
    intsum[1] = num=>intval[1]
    while expr
      num  = eval_num(expr)
      expr = expr=>cdr
      if num->type == NUM_FLOAT
        break
      fin
      load32(@intsum)
      add32(num + intval)
      store32(@intsum)
    loop
  fin
  if num->type == NUM_FLOAT
    //
    // Sum as floating point numbers
    //
    push_int32(@intsum)
    push_num(num)
    fpu:addXY()
    fpu:pullExt(@extsum)
    while expr
      push_num(eval_num(expr))
      fpu:pushExt(@extsum)
      fpu:addXY()
      fpu:pullExt(@extsum)
      expr = expr=>cdr
    loop
    return new_float(@extsum)
  fin
  return new_int(intsum[0], intsum[1])
end

def natv_sub(symptr, expr)
  res[t_numfloat] num1, num2
  var[2] dif
  var[5] ext

  memcpy(@num1, eval_num(expr),      t_numfloat)
  memcpy(@num2, eval_num(expr=>cdr), t_numfloat)
  if num1.type == NUM_INT and num2.type == NUM_INT
    load32(@num1 + intval)
    sub32(@num2 + intval)
    store32(@dif)
    return new_int(dif[0], dif[1])
  fin
  push_num(@num1)
  push_num(@num2)
  fpu:subXY()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_mul(symptr, expr)
  res[t_numfloat] num1, num2
  var[2] mul
  var[5] ext

  memcpy(@num1, eval_num(expr),      t_numfloat)
  memcpy(@num2, eval_num(expr=>cdr), t_numfloat)
  if num1.type == NUM_INT and num2.type == NUM_INT
    load32(@num1 + intval)
    mul32(@num2 + intval)
    store32(@mul)
    return new_int(mul[0], mul[1])
  fin
  push_num(@num1)
  push_num(@num2)
  fpu:mulXY()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_div(symptr, expr)
  res[t_numfloat] num1, num2
  var[2] div
  var[5] ext

  memcpy(@num1, eval_num(expr),      t_numfloat)
  memcpy(@num2, eval_num(expr=>cdr), t_numfloat)
  if num1.type == NUM_INT and num2.type == NUM_INT
    load32(@num1 + intval)
    div32(@num2 + intval)
    store32(@div)
    return new_int(div[0], div[1])
  fin
  push_num(@num1)
  push_num(@num2)
  fpu:divXY()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_rem(symptr, expr)
  res[t_numfloat] num1, num2
  var[2] rem, div
  var[5] ext

  memcpy(@num1, eval_num(expr),      t_numfloat)
  memcpy(@num2, eval_num(expr=>cdr), t_numfloat)
  if num1.type == NUM_INT and num2.type == NUM_INT
    load32(@num1 + intval)
    rem[1], rem[0] = div32(@num2 + intval)
    return new_int(rem[0], rem[1])
  fin
  push_num(@num1)
  push_num(@num2)
  fpu:remXY()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_neg(symptr, expr)
  var num
  var[2] neg
  var[5] ext

  num = eval_num(expr)
  if num->type == NUM_INT
    load32(num + intval)
    neg32
    store32(@neg)
    return new_int(neg[0], neg[1])
  fin
  num->floatval[9] = num->floatval[9] ^ $80 // Fun with float bits
  return new_float(num + floatval)
end

def natv_abs(symptr, expr)
  var num
  var[2] abs
  var[5] ext

  num = eval_num(expr)
  if num->type == NUM_INT
    if num=>intval[1] < 0
      load32(num + intval)
      neg32
      store32(@abs)
    else
      abs[0] = num=>intval[0]
      abs[1] = num=>intval[1]
    fin
    return new_int(abs[0], abs[1])
  fin
  num->floatval[9] = num->floatval[9] & $7F // Fun with float bits
  return new_float(num + floatval)
end

def natv_gt(symptr, expr)
  res[t_numfloat] num1, num2
  byte[10] ext

  memcpy(@num1, eval_num(expr),      t_numfloat)
  memcpy(@num2, eval_num(expr=>cdr), t_numfloat)
  if num1.type == NUM_INT and num2.type == NUM_INT
    load32(@num1 + intval)
    return bool_pred(isgt32(@num2 + intval))
  fin
  push_num(@num2)
  push_num(@num1)
  fpu:subXY()
  fpu:pullExt(@ext)
  return bool_pred(ext[9] & $80) // Check sign bit
end

def natv_lt(symptr, expr)
  res[t_numfloat] num1, num2
  byte[10] ext

  memcpy(@num1, eval_num(expr),      t_numfloat)
  memcpy(@num2, eval_num(expr=>cdr), t_numfloat)
  if num1.type == NUM_INT and num2.type == NUM_INT
    load32(@num1 + intval)
    return bool_pred(islt32(@num2 + intval))
  fin
  push_num(@num1)
  push_num(@num2)
  fpu:subXY()
  fpu:pullExt(@ext)
  return bool_pred(ext[9] & $80) // Check sign bit
end

def natv_min(symptr, expr)
  var num
  var[2] intmin
  var[5] extmin, ext

  num  = eval_num(expr)
  expr = expr=>cdr
  if num->type == NUM_INT
    //
    // Find min as integers unless a float is encountered
    //
    intmin[0] = num=>intval[0]
    intmin[1] = num=>intval[1]
    while expr
      num = eval_num(expr)
      if num->type == NUM_FLOAT
        push_int32(@intmin)
        fpu:pullExt(@extmin)
        break
      fin
      load32(@intmin)
      if isgt32(num + intval)
        intmin[0] = num=>intval[0]
        intmin[1] = num=>intval[1]
      fin
      expr = expr=>cdr
    loop
    if !expr; return new_int(intmin[0], intmin[1]); fin
  else
    extmin[0] = num=>floatval[0]
    extmin[1] = num=>floatval[1]
    extmin[2] = num=>floatval[2]
    extmin[3] = num=>floatval[3]
    extmin[4] = num=>floatval[4]
    if expr; num = eval_num(expr); fin
  fin
  while expr
    push_num(num)
    fpu:pushExt(@extmin)
    fpu:subXY()
    fpu:pullExt(@ext)
    if ext[4] < 0
      if num->type == NUM_INT
        push_int32(num + intval)
        fpu:pullExt(@ext)
        extmin[0] = ext[0]
        extmin[1] = ext[1]
        extmin[2] = ext[2]
        extmin[3] = ext[3]
        extmin[4] = ext[4]
      else
        extmin[0] = num=>floatval[0]
        extmin[1] = num=>floatval[1]
        extmin[2] = num=>floatval[2]
        extmin[3] = num=>floatval[3]
        extmin[4] = num=>floatval[4]
      fin
    fin
    expr = expr=>cdr
    if expr; num = eval_num(expr); fin
  loop
  return new_float(@extmin)
end

def natv_max(symptr, expr)
  var num
  var[2] intmax
  var[5] extmax, ext

  num  = eval_num(expr)
  expr = expr=>cdr
  if num->type == NUM_INT
    //
    // Find max as integers unless a float is encountered
    //
    intmax[0] = num=>intval[0]
    intmax[1] = num=>intval[1]
    while expr
      num = eval_num(expr)
      if num->type == NUM_FLOAT
        push_int32(@intmax)
        fpu:pullExt(@extmax)
        break
      fin
      load32(@intmax)
      if islt32(num + intval)
        intmax[0] = num=>intval[0]
        intmax[1] = num=>intval[1]
      fin
      expr = expr=>cdr
    loop
    if !expr; return new_int(intmax[0], intmax[1]); fin
  else
    extmax[0] = num=>floatval[0]
    extmax[1] = num=>floatval[1]
    extmax[2] = num=>floatval[2]
    extmax[3] = num=>floatval[3]
    extmax[4] = num=>floatval[4]
    if expr; num = eval_num(expr); fin
  fin
  while expr
    fpu:pushExt(@extmax)
    push_num(num)
    fpu:subXY()
    fpu:pullExt(@ext)
    if ext[4] < 0
      if num->type == NUM_INT
        push_int32(num + intval)
        fpu:pullExt(@ext)
        extmax[0] = ext[0]
        extmax[1] = ext[1]
        extmax[2] = ext[2]
        extmax[3] = ext[3]
        extmax[4] = ext[4]
      else
        extmax[0] = num=>floatval[0]
        extmax[1] = num=>floatval[1]
        extmax[2] = num=>floatval[2]
        extmax[3] = num=>floatval[3]
        extmax[4] = num=>floatval[4]
      fin
    fin
    expr = expr=>cdr
    if expr; num = eval_num(expr); fin
  loop
  return new_float(@extmax)
end

def natv_logb(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:logbX()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_scalebI(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  push_int32(eval_expr(expr=>cdr) + intval)
  fpu:scalebXInt()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_trunc(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:truncX()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_round(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:roundX()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_sqrt(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:sqrtX()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_cos(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:cosX()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_sin(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:sinX()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_tan(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:tanX()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_atan(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:atanX()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_log2(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:log2X()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_log21(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:log21X()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_ln(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:lnX()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_ln1(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:ln1X()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_pow2(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:pow2X()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_pow21(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:pow21X()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_powE(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:powEX()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_powE1(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:powE1X()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_powE21(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  fpu:powE21X()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_powI(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  push_int32(eval_int(expr=>cdr) + intval)
  fpu:powXInt()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_powY(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  push_num(eval_num(expr=>cdr))
  fpu:pow2X()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_compY(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  push_num(eval_num(expr=>cdr))
  fpu:pow2X()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

def natv_annuityY(symptr, expr)
  var[5] ext

  push_num(eval_num(expr))
  push_num(eval_num(expr=>cdr))
  fpu:annuityXY()
  fpu:pullExt(@ext)
  return new_float(@ext)
end

//
// Bit-wise operations
//

def natv_bitnot(symptr, expr)
  symptr = eval_int(expr)
  return new_int(~symptr=>intval[0], ~symptr=>intval[1])
end

def natv_bitand(symptr, expr)
  var[2] bitval

  symptr    = eval_int(expr)
  bitval[0] = symptr=>intval[0]
  bitval[1] = symptr=>intval[1]
  symptr    = eval_int(expr=>cdr)
  return new_int(bitval[0] & symptr=>intval[0], bitval[1] & symptr=>intval[1])
end

def natv_bitor(symptr, expr)
  var[2] bitval

  symptr    = eval_int(expr)
  bitval[0] = symptr=>intval[0]
  bitval[1] = symptr=>intval[1]
  symptr    = eval_int(expr=>cdr)
  return new_int(bitval[0] | symptr=>intval[0], bitval[1] | symptr=>intval[1])
end

def natv_bitxor(symptr, expr)
  var[2] bitval

  symptr    = eval_int(expr)
  bitval[0] = symptr=>intval[0]
  bitval[1] = symptr=>intval[1]
  symptr    = eval_int(expr=>cdr)
  return new_int(bitval[0] ^ symptr=>intval[0], bitval[1] ^ symptr=>intval[1])
end

def natv_shift(symptr, expr)
  var[2] bitval
  var shift

  symptr    = eval_int(expr)
  bitval[0] = symptr=>intval[0]
  bitval[1] = symptr=>intval[1]
  symptr    = eval_int(expr=>cdr)
  shift     = symptr=>intval[0]
  if shift < 0
    //
    // Shift right
    //
    if shift < -31
      bitval[1] = bitval[1] < 0 ?? $FFFF :: 0
      bitval[0] = bitval[1]
    else
      while shift < 0
        bitval[0] = bitval[0] >> 1
        if bitval[1] & 1
          bitval[0] = bitval[0] | $8000
        else
          bitval[0] = bitval[0] & $7FFF
        fin
        bitval[1] = bitval[1] >> 1
        shift++
      loop
    fin
  else
    //
    // Shift left
    //
    if shift > 31
      bitval[0] = 0
      bitval[1] = 0
    else
      while shift > 0
        bitval[1] = bitval[1] << 1
        if bitval[0] & $8000
          bitval[1] = bitval[1] | 1
        fin
        bitval[0] = bitval[0] << 1
        shift--
      loop
    fin
  fin
  return new_int(bitval[0], bitval[1])
end

def natv_rotate(symptr, expr)
  var[2] bitval
  var rotate, wrap

  symptr    = eval_int(expr)
  bitval[0] = symptr=>intval[0]
  bitval[1] = symptr=>intval[1]
  symptr    = eval_int(expr=>cdr)
  rotate    = symptr=>intval[0]
  if rotate < 0
    rotate = rotate | $FFFFFFE0
    while rotate < 0
      wrap      = bitval[0] & 1 ?? $8000 :: 0
      bitval[0] = bitval[0] >> 1
      if bitval[1] & 1
        bitval[0] = bitval[0] | $8000
      else
        bitval[0] = bitval[0] & $7FFF
      fin
      bitval[1] = wrap | (bitval[1] >> 1)
      rotate++
    loop
  else
    rotate = rotate & $0000001F
    while rotate > 0
      wrap      = bitval[1] & $8000 ?? 1 :: 0
      bitval[1] = bitval[1] << 1
      if bitval[0] & $8000
        bitval[1] = bitval[1] | 1
      fin
      bitval[0] = wrap | (bitval[0] << 1)
      rotate--
    loop
  fin
  return new_int(bitval[0], bitval[1])
end

//
// Install numerical constants and functions
//


fpu:reset()
fpu:constPi()
fpu:pullExt(@tempext)
new_sym("PI")=>apval      = new_float(@tempext) ^ NULL_HACK
fpu:constE()
fpu:pullExt(@tempext)
new_sym("MATH_E")=>apval  = new_float(@tempext) ^ NULL_HACK
fpu:sinX() // Force load of ELEMS library
new_sym("SUM")=>natv      = @natv_sum
new_sym("+")=>natv        = @natv_sum
new_sym("-")=>natv        = @natv_sub
new_sym("*")=>natv        = @natv_mul
new_sym("/")=>natv        = @natv_div
new_sym("REM")=>natv      = @natv_rem
new_sym("NEG")=>natv      = @natv_neg
new_sym("ABS")=>natv      = @natv_abs
new_sym(">")=>natv        = @natv_gt
new_sym("<")=>natv        = @natv_lt
new_sym("MIN")=>natv      = @natv_min
new_sym("MAX")=>natv      = @natv_max
new_sym("LOGB")=>natv     = @natv_logb
new_sym("SCALEB_I")=>natv = @natv_scalebI
new_sym("TRUNCATE")=>natv = @natv_trunc
new_sym("ROUND")=>natv    = @natv_round
new_sym("SQRT")=>natv     = @natv_sqrt
new_sym("COS")=>natv      = @natv_cos
new_sym("SIN")=>natv      = @natv_sin
new_sym("TAN")=>natv      = @natv_tan
new_sym("ATAN")=>natv     = @natv_atan
new_sym("LOG2")=>natv     = @natv_log2
new_sym("LOG2_1")=>natv   = @natv_log21
new_sym("LN")=>natv       = @natv_ln
new_sym("LN_1")=>natv     = @natv_ln1
new_sym("POW2")=>natv     = @natv_pow2
new_sym("POW2_1")=>natv   = @natv_pow21
new_sym("POWE")=>natv     = @natv_powE
new_sym("POWE_1")=>natv   = @natv_powE1
new_sym("POWE2_1")=>natv  = @natv_powE21
new_sym("POW_I")=>natv    = @natv_powI
new_sym("POWY")=>natv     = @natv_powY
new_sym("COMP")=>natv     = @natv_compY
new_sym("ANNUITY")=>natv  = @natv_annuityY
new_sym("BITNOT")=>natv   = @natv_bitnot
new_sym("BITAND")=>natv   = @natv_bitand
new_sym("BITOR")=>natv    = @natv_bitor
new_sym("BITXOR")=>natv   = @natv_bitxor
new_sym("SHIFT")=>natv    = @natv_shift
new_sym("ROTATE")=>natv   = @natv_rotate
return modkeep | modinitkeep
done
