include "inc/cmdsys.plh"
include "inc/dcgrlib.plh"
include "inc/dcgrutils.plh"
include "inc/args.plh"
include "inc/fileio.plh"

sysflags resxtxt1|reshgr1|resxhgr1

const RED = 0
const GRN = 1
const BLU = 2
const RGB_MAX = 63
const ERR_MAX = 32
const ERR_DIV = 2

byte[] ntscChroma
// Imperical 0-255       R    G    B
//byte[]              =  64,  51, 127 // BLUE
//byte[]              =   0, 108,  64 // GREEN
//byte[]              =  64,  77,   1 // BROWN
//byte[]              = 128,  20,  64 // RED
// Imperical 0-63        R   G   B
byte[]              = 16, 12, 32 // BLUE
byte[]              =  0, 28, 16 // GREEN
byte[]              = 16, 20,  0 // BROWN
byte[]              = 32,  4, 16 // RED
// Ideal/simplified 0-63 R   G   B
//byte[]                = 16, 16, 32 // BLUE
//byte[]                =  0, 32, 16 // GREEN
//byte[]                = 16, 16,  0 // BROWN
//byte[]                = 32,  0, 16 // RED
// Test             0-63 R   G   B
//byte[]              = 12, 10, 24 // BLUE 872
//byte[]              =  8, 26, 16 // GREEN 996
//byte[]              = 20, 22,  8 // BROWN 872
//byte[]              = 24,  6, 16 // RED 868
byte[12] ntscCycle
byte[256] gamma
var rgbErr // Running color error array
var arg

def abs(n)
  return n < 0 ?? -n :: n
end

def max(a, b)
  return a < b ?? b :: a
end

def min(a, b)
  return a < b ?? a :: b
end

def dist(x1, y1, z1, x2, y2, z2)
    x2 = x2 - x1
    y2 = y2 - y1
    z2 = z2 - z1
    return x2*x2 + y2*y2 + z2*z2
end

def dotprod(x1, y1, z1, x2, y2, z2)
  return x1*x2 + y1*y2 + z1*z2
end

def rgbPix(r, g, b, x, y)#0
  var errptr
  var pr, pg, pb
  var nr, ng, nb
  var cr, cg, cb, cx
  var pd, cd, nd
  byte i

  // Error propogation
  errptr = rgbErr + x * 3 * 2
  r = r + errptr=>[RED] / ERR_DIV
  g = g + errptr=>[GRN] / ERR_DIV
  b = b + errptr=>[BLU] / ERR_DIV
  //r = min(RGB_MAX, max(-RGB_MAX, r))
  //g = min(RGB_MAX, max(-RGB_MAX, g))
  //b = min(RGB_MAX, max(-RGB_MAX, b))
  pr = 0
  pg = 0
  pb = 0
  // Project RGB on previous 3/4 chroma cycle
  for cx = x - 1 downto x - 3
    i  = (cx & 3) * 3
    pr = pr + ntscCycle[i+RED]
    pg = pg + ntscCycle[i+GRN]
    pb = pb + ntscCycle[i+BLU]
  next
  pd = dist(r, g, b, pr, pg, pb)
  // Look ahead for possible better match
  i  = ((x + 1) & 3) * 3
  nr = pr - ntscCycle[i+RED] + ntscChroma[i+RED]
  ng = pg - ntscCycle[i+GRN] + ntscChroma[i+GRN]
  nb = pb - ntscCycle[i+BLU] + ntscChroma[i+BLU]
  nd = dist(r, g, b, nr, ng, nb)
  // Add current 1/4 chroma color
  i  = (x & 3) * 3
  cr = pr + ntscChroma[i+RED]
  cg = pg + ntscChroma[i+GRN]
  cb = pb + ntscChroma[i+BLU]
  cd = dist(r, g, b, cr, cg, cb)
  if cd < pd and cd < nd
    // RGB better matched with current 1/4 chroma color
    r = (r - cr + 1) / 2
    g = (g - cg + 1) / 2
    b = (b - cb + 1) / 2
    ntscCycle[i+RED] = ntscChroma[i+RED]
    ntscCycle[i+GRN] = ntscChroma[i+GRN]
    ntscCycle[i+BLU] = ntscChroma[i+BLU]
    dhgrSet(x, y)
  else
    // RGB closer to black
    r = (r - pr + 1) / 2
    g = (g - pg + 1) / 2
    b = (b - pb + 1) / 2
    ntscCycle[i+RED] = 0
    ntscCycle[i+GRN] = 0
    ntscCycle[i+BLU] = 0
  fin
  // Propogate error down and forward
  //r = min(ERR_MAX, max(-ERR_MAX, r))
  //g = min(ERR_MAX, max(-ERR_MAX, g))
  //b = min(ERR_MAX, max(-ERR_MAX, b))
  errptr=>[RED] = r
  errptr=>[GRN] = g
  errptr=>[BLU] = b
  errptr = errptr + 6
  errptr=>[RED] = r + errptr=>[RED]
  errptr=>[GRN] = g + errptr=>[GRN]
  errptr=>[BLU] = b + errptr=>[BLU]
end

def rgbInit#0
  var i

  for i = 1 to 255
    gamma[i] = (i / 4) * (i / 4) / 63
  next
  dcgrMode(0)
  // Init error propogation array
  rgbErr = heapalloc(561 * 3 * 2)
  memset(rgberr, 0, 560 * 3 * 2)
  rgberr=>[RED] = -1
  rgberr=>[GRN] = -1
  rgberr=>[BLU] = -1
end

def rgbExit#0
  dcgrMode(-1)
end

def rgb3Spans(rs, gs, bs, re, ge, be, rm, gm, bm, y)#0
  var i, j

  memset(@ntscCycle, 0, 12)
  for j = y to y + 2
    for i = 0 to 63
      rgbPix((i>>rs)|re, (i>>gs)|ge, (i>>bs)|be, i, j)
    next
    for i = 64 to 127
      rgbPix(rm, gm, bm, i, j)
    next
  next
end

def rgbTest#0
  var i

  rgbInit
  rgb3Spans(0,5,5,  0, 0, 0, 63, 0, 0, 0)
  rgb3Spans(5,0,5,  0, 0, 0,  0,63, 0, 3)
  rgb3Spans(5,5,0,  0, 0, 0,  0, 0,63, 6)
  rgb3Spans(0,0,0,  0, 0, 0, 63,63,63, 9)
  rgb3Spans(0,1,1,  0, 0, 0, 63,31,31, 12)
  rgb3Spans(1,0,1,  0, 0, 0, 31,63,31, 15)
  rgb3Spans(1,1,0,  0, 0, 0, 31,31,63, 18)
  rgb3Spans(5,5,5, 16,16,16, 16,16,16, 21)
  rgb3Spans(5,5,5, 32,32,32, 32,32,32, 24)
  rgb3Spans(5,5,5, 48,48,48, 48,48,48, 27)
  rgb3Spans(5,5,5, 63,63,63, 63,63,63, 30)
  getc
  rgbExit
end

def rgbImportExport(rgbfile, dhgrfile)#0
  byte refnum, r, g, b
  var i, j
  var rgbScanline, rgbptr

  refnum = fileio:open(rgbfile)
  if refnum
    rgbScanline = heapalloc(560 * 3)
    if rgbScanline
      rgbInit
      for j = 0 to 191
        fileio:read(refnum, rgbScanline,  560 * 3)
        rgbptr = rgbScanline
        for i = 0 to 559
          r = gamma[rgbptr->RED]
          g = gamma[rgbptr->GRN]
          b = gamma[rgbptr->BLU]
          rgbptr = rgbptr + 3
          rgbPix(r, g, b, i, j)
        next
        if ^$C000 == $83
          break
        fin
      next
      fileio:close(refnum)
      if ^dhgrfile
        screenWrite(dhgrfile)
      fin
      getc
      rgbExit
    fin
  else
    puts("Unable to read: "); puts(arg); putln
  fin
end

arg = argNext(argFirst)
if ^arg
  if ^(arg + 1) == '-'
    if toupper(^(arg + 2)) == 'T'
      rgbTest
    fin
    arg = argNext(arg)
  fin
  if ^arg
    rgbImportExport(arg, argNext(arg))
  fin
  return 0
fin
puts("Usage: DCGRRGB [-T] RGBFILE [DHGRFILE]\n")
done
