include "inc/cmdsys.plh"
include "inc/dcgrlib.plh"
include "inc/dcgrutils.plh"

sysflags resxtxt1|reshgr1|resxhgr1

const BLU_MSK = $001F
const GRN_MSK = $03E0
const RED_MSK = $7C00
const BLU = 0
const GRN = 1
const RED = 2
const ERR_MIN = 31
byte[12] ntscCycle
byte[] ntscChroma

// Imperical 0-255       B    G    R
//byte[]              = 127,  51,  64 // BLUE
//byte[]              =  64, 108,   0 // GREEN
//byte[]              =   1,  77,  64 // BROWN
//byte[]              =  64,  20, 128 // RED
// Imperical 0-63        B   G   R
//byte[]              = 32, 14, 16 // BLUE
//byte[]              = 16, 28,  0 // GREEN
//byte[]              =  0, 18, 16 // BROWN
//byte[]              = 16,  4, 32 // RED
// Ideal/simplified 0-63 B   G   R
//byte[]                = 32, 16, 16 // BLUE
//byte[]                = 16, 32,  0 // GREEN
//byte[]                =  0, 16, 16 // BROWN
//byte[]                = 16,  0, 32 // RED
// Test             0-63 B   G   R
byte[]                = 63,  0,  0 // BLUE
byte[]                =  0, 63,  0 // GREEN
byte[]                =  0, 31, 31 // BROWN
byte[]                =  0,  0, 63 // RED
//byte[]              = 64, 28, 32 // BLUE
//byte[]              = 32, 56,  0 // GREEN
//byte[]              =  0, 36, 32 // BROWN
//byte[]              = 32,  8, 64 // RED
//byte[]                = 64, 32, 32 // BLUE
//byte[]                = 32, 26,  0 // GREEN
//byte[]                =  0, 32, 32 // BROWN
//byte[]                = 32,  0, 64 // RED

var er, eg, eb // Running error

def rgb24to16(r, g, b)
  return (b>>2)|((g&$F8)<<2)|((r&$F8)<<7)
end

def abs(n)
    return n < 0 ?? -n :: n
end

def max(a, b)
    return a < b ?? b :: a
end

def min(a, b)
    return a < b ?? a :: b
end

def errmin(v)
    return v >= 0
end

def dotprod(x1, y1, z1, x2, y2, z2)
    return X1*x2 + y1*y2 + z1*z2
end

def rgbpix(r, g, b, x, y)#0
  var cr, cg, cb, cx
  var zdot, cdot
  byte i

  // Error propogation
  r = r + er/2
  g = g + eg/2
  b = b + eb/2
  cr = 0
  cg = 0
  cb = 0
  // Project RGB on chroma cycle with zero current 1/4 chroma
  for cx = x - 1 downto x - 3
    i = (cx & 3) * 3
    cr = cr + ntscCycle[i+RED]
    cg = cg + ntscCycle[i+GRN]
    cb = cb + ntscCycle[i+BLU]
  next
  zdot = dotprod(r, g, b, cr, cg, cb)
  // Save error for zero 1/4 cycle
  er = r - cr
  eg = g - cg
  eb = b - cb
  // Add current 1/4 chroma color
  i = (x & 3) * 3
  cr = cr + ntscChroma[i+RED]
  cg = cg + ntscChroma[i+GRN]
  cb = cb + ntscChroma[i+BLU]
  cdot = dotprod(r, g, b, cr, cg, cb)
  if cdot > zdot
    // RGB better matched with 1/4 chroma color
    er = r - cr
    eg = g - cg
    eb = b - cb
    ntscCycle[i+RED] = ntscChroma[i+RED]
    ntscCycle[i+GRN] = ntscChroma[i+GRN]
    ntscCycle[i+BLU] = ntscChroma[i+BLU]
    dhgrSet(x, y)
  else
    // RGB closer to black
    ntscCycle[i+RED] = 0
    ntscCycle[i+GRN] = 0
    ntscCycle[i+BLU] = 0
  fin
  //er = min(63, max(-63, er))
  //eg = min(63, max(-63, eg))
  //eb = min(63, max(-63, eb))
end

def rgbTest#0
  var i

  for i = 0 to 63
    rgbpix(i, 0, 0, i, 0)
  next
  er, eg, eb, = 0, 0, 0
  memset(@ntscCycle, 0, 12)
  for i = 0 to 63
    rgbpix(0, i, 0, i, 2)
  next
  er, eg, eb, = 0, 0, 0
  memset(@ntscCycle, 0, 12)
  for i = 0 to 63
    rgbpix(0, 0, i, i, 4)
  next
  er, eg, eb, = 0, 0, 0
  memset(@ntscCycle, 0, 12)
  for i = 0 to 63
    rgbpix(i, i, i, i, 6)
  next
  er, eg, eb, = 0, 0, 0
  memset(@ntscCycle, 0, 12)
  for i = 0 to 63
    rgbpix(i, i>>2, i>>2, i, 8)
  next
  er, eg, eb, = 0, 0, 0
  memset(@ntscCycle, 0, 12)
  for i = 0 to 63
    rgbpix(i>>2, i, i>>2, i, 10)
  next
  er, eg, eb, = 0, 0, 0
  memset(@ntscCycle, 0, 12)
  for i = 0 to 63
    rgbpix(i>>2, i>>2, i, i, 12)
  next
end

dcgrMode(0)
rgbTest
getc
dcgrMode(-1)
done
