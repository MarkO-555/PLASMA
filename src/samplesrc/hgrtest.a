; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; samplesrc/hgrtest.pla: 0001: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0200 // Version built against
					; _SYSVER_ = 512
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $03
					; MACHID_MEM = 3
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     //
; inc/cmdsys.plh: 0038:     // Module don't free memory
; inc/cmdsys.plh: 0039:     //
; inc/cmdsys.plh: 0040:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0041:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0042:     //
; inc/cmdsys.plh: 0043:     // CMD exported interface table
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     struc t_cmdsys
; inc/cmdsys.plh: 0046:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0047:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0048:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0049:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0050:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0051:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0052:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0053:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0054:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0055:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0056:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0057:         byte refcons    // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0058:         byte devcons    // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0059:     end
					; t_cmdsys = 21
; inc/cmdsys.plh: 0060:     //
; inc/cmdsys.plh: 0061:     // CMD exported functions
; inc/cmdsys.plh: 0062:     //
; inc/cmdsys.plh: 0063:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0064:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0065:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0066:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0067:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0068:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0069: end
; samplesrc/hgrtest.pla: 0001: 
; samplesrc/hgrtest.pla: 0002: include "inc/hgrlib.plh"
; inc/hgrlib.plh: 0001: import hgrlib
	; DCI STRING: HGRLIB
	!BYTE	$C8,$C7,$D2,$CC,$C9,$42
					; HGRLIB -> X028
; inc/hgrlib.plh: 0002:     predef divmod7(x)#2
					; DIVMOD7 -> X029
; inc/hgrlib.plh: 0003:     predef hgrPlot(x, y)#0
					; HGRPLOT -> X030
; inc/hgrlib.plh: 0004:     predef hgrOrPlot(x, y)#0
					; HGRORPLOT -> X031
; inc/hgrlib.plh: 0005:     predef hgrXorPlot(x, y)#0
					; HGRXORPLOT -> X032
; inc/hgrlib.plh: 0006:     predef hgrHLin(x1, x2, y)#0
					; HGRHLIN -> X033
; inc/hgrlib.plh: 0007:     predef hgrVLin(y1, y2, x)#0
					; HGRVLIN -> X034
; inc/hgrlib.plh: 0008:     predef hgrXorHLin(x1, x2, y)#0
					; HGRXORHLIN -> X035
; inc/hgrlib.plh: 0009:     predef hgrXorVLin(y1, y2, x)#0
					; HGRXORVLIN -> X036
; inc/hgrlib.plh: 0010:     predef hgrRect(x1, y1, x2, y2)#0
					; HGRRECT -> X037
; inc/hgrlib.plh: 0011:     predef hgrXorRect(x1, y1, x2, y2)#0
					; HGRXORRECT -> X038
; inc/hgrlib.plh: 0012:     predef hgrBLT(x, y, width, height, srcptr)#0
					; HGRBLT -> X039
; inc/hgrlib.plh: 0013:     predef hgrCopySrc(ofst, y, w, h, srcptr)#0
					; HGRCOPYSRC -> X040
; inc/hgrlib.plh: 0014:     predef hgrAndSrc(ofst, y, w, h, srcptr)#0
					; HGRANDSRC -> X041
; inc/hgrlib.plh: 0015:     predef hgrXorSrc(ofst, y, w, h, srcptr)#0
					; HGRXORSRC -> X042
; inc/hgrlib.plh: 0016:     predef hgrOrSrc(ofst, y, w, h, srcptr)#0
					; HGRORSRC -> X043
; inc/hgrlib.plh: 0017:     predef hgrCopyDst(ofst, y, w, h, dstptr)#0
					; HGRCOPYDST -> X044
; inc/hgrlib.plh: 0018:     predef hgrMode(mode)#1
					; HGRMODE -> X045
; inc/hgrlib.plh: 0019:     predef hgrClear#0
					; HGRCLEAR -> X046
; inc/hgrlib.plh: 0020:     predef hgrShow(page)#1
					; HGRSHOW -> X047
; inc/hgrlib.plh: 0021:     predef hgrSwap#1
					; HGRSWAP -> X048
; inc/hgrlib.plh: 0022:     predef hgrDrawBuf(page)#1
					; HGRDRAWBUF -> X049
; inc/hgrlib.plh: 0023:     predef hgrColor(clr)#0
					; HGRCOLOR -> X050
; inc/hgrlib.plh: 0024: end
; samplesrc/hgrtest.pla: 0002: 
; samplesrc/hgrtest.pla: 0003: include "inc/hgrsprite.plh"
; inc/hgrsprite.plh: 0001: import hgrsprite
	; DCI STRING: HGRSPRITE
	!BYTE	$C8,$C7,$D2,$D3,$D0,$D2,$C9,$D4,$45
					; HGRSPRITE -> X051
; inc/hgrsprite.plh: 0002:     predef spriteCompile(w, h, xcenter, ycenter, srcptr)#1
					; SPRITECOMPILE -> X052
; inc/hgrsprite.plh: 0003:     predef spriteDup(sprtsrc)#1
					; SPRITEDUP -> X053
; inc/hgrsprite.plh: 0004:     predef spriteRead(filestr)#1
					; SPRITEREAD -> X054
; inc/hgrsprite.plh: 0005:     predef spriteSave(filestr, sprtptr)#1
					; SPRITESAVE -> X055
; inc/hgrsprite.plh: 0006:     predef spriteDraw(sprtptr)#0
					; SPRITEDRAW -> X056
; inc/hgrsprite.plh: 0007:     predef spriteDrawXor(sprtptr)#0
					; SPRITEDRAWXOR -> X057
; inc/hgrsprite.plh: 0008:     predef spriteUnDraw(sprtptr)#0
					; SPRITEUNDRAW -> X058
; inc/hgrsprite.plh: 0009:     predef spriteUnDrawXor(sprtptr)#0
					; SPRITEUNDRAWXOR -> X059
; inc/hgrsprite.plh: 0010:     predef spritePos(x, y, sprtptr)#0
					; SPRITEPOS -> X060
; inc/hgrsprite.plh: 0011:     predef spritePosIndex(x, y, i)#0
					; SPRITEPOSINDEX -> X061
; inc/hgrsprite.plh: 0012:     predef spriteUnDrawList#0
					; SPRITEUNDRAWLIST -> X062
; inc/hgrsprite.plh: 0013:     predef spriteUnDrawXorList#0
					; SPRITEUNDRAWXORLIST -> X063
; inc/hgrsprite.plh: 0014:     predef spriteDrawList#0
					; SPRITEDRAWLIST -> X064
; inc/hgrsprite.plh: 0015:     predef spriteDrawXorList#0
					; SPRITEDRAWXORLIST -> X065
; inc/hgrsprite.plh: 0016:     predef spriteAdd(i, sprtptr)#1
					; SPRITEADD -> X066
; inc/hgrsprite.plh: 0017:     predef spriteDel(i)#1
					; SPRITEDEL -> X067
; inc/hgrsprite.plh: 0018:     predef spriteDrawBuf(page)#1
					; SPRITEDRAWBUF -> X068
; inc/hgrsprite.plh: 0019: end
; samplesrc/hgrtest.pla: 0003: 
; samplesrc/hgrtest.pla: 0004: include "inc/lines.plh"
; inc/lines.plh: 0001: import lines
	; DCI STRING: LINES
	!BYTE	$CC,$C9,$CE,$C5,$53
					; LINES -> X069
; inc/lines.plh: 0002:     predef setlinespans(h, v)#0 
					; SETLINESPANS -> X070
; inc/lines.plh: 0003:     predef linespans(x1, y1, x2, y2)#0
					; LINESPANS -> X071
; inc/lines.plh: 0004:     predef setlineplot(p)#0
					; SETLINEPLOT -> X072
; inc/lines.plh: 0005:     predef line(x1, y1, x2, y2)#0
					; LINE -> X073
; inc/lines.plh: 0006: end
; samplesrc/hgrtest.pla: 0004: 
; samplesrc/hgrtest.pla: 0005: sysflags reshgr1|reshgr2 // Reserve HGR page 1 and 2
	!BYTE	$00			; END OF MODULE DEPENDENCIES
_SYSFLAGS	=	$0030		; SYSTEM FLAGS
; samplesrc/hgrtest.pla: 0006: 
; samplesrc/hgrtest.pla: 0007: byte ball = $88, $83, $33, $38, $88
_D074 					; ball = $88, $83, $33, $38, $88
	!BYTE	$88
	!BYTE	$83
	!BYTE	$33
	!BYTE	$38
	!BYTE	$88
; samplesrc/hgrtest.pla: 0008: byte      = $88, $33, $11, $33, $88
	!BYTE	$88
	!BYTE	$33
	!BYTE	$11
	!BYTE	$33
	!BYTE	$88
; samplesrc/hgrtest.pla: 0009: byte      = $83, $31, $11, $13, $38
	!BYTE	$83
	!BYTE	$31
	!BYTE	$11
	!BYTE	$13
	!BYTE	$38
; samplesrc/hgrtest.pla: 0010: byte      = $33, $11, $11, $11, $33
	!BYTE	$33
	!BYTE	$11
	!BYTE	$11
	!BYTE	$11
	!BYTE	$33
; samplesrc/hgrtest.pla: 0011: byte      = $33, $11, $11, $11, $33
	!BYTE	$33
	!BYTE	$11
	!BYTE	$11
	!BYTE	$11
	!BYTE	$33
; samplesrc/hgrtest.pla: 0012: byte      = $33, $11, $11, $11, $33
	!BYTE	$33
	!BYTE	$11
	!BYTE	$11
	!BYTE	$11
	!BYTE	$33
; samplesrc/hgrtest.pla: 0013: byte      = $33, $11, $11, $11, $33
	!BYTE	$33
	!BYTE	$11
	!BYTE	$11
	!BYTE	$11
	!BYTE	$33
; samplesrc/hgrtest.pla: 0014: byte      = $83, $31, $11, $13, $38
	!BYTE	$83
	!BYTE	$31
	!BYTE	$11
	!BYTE	$13
	!BYTE	$38
; samplesrc/hgrtest.pla: 0015: byte      = $88, $33, $11, $33, $88
	!BYTE	$88
	!BYTE	$33
	!BYTE	$11
	!BYTE	$33
	!BYTE	$88
; samplesrc/hgrtest.pla: 0016: byte      = $88, $83, $33, $38, $88
	!BYTE	$88
	!BYTE	$83
	!BYTE	$33
	!BYTE	$38
	!BYTE	$88
; samplesrc/hgrtest.pla: 0017: var sprtBall
_D075 	!FILL	2			; sprtBall
; samplesrc/hgrtest.pla: 0018: def testline#0
_SUBSEG 				; BYTECODE STARTS
_C000 					; testline()
; samplesrc/hgrtest.pla: 0019:   var i
					; i -> [0]
; samplesrc/hgrtest.pla: 0020: 
; samplesrc/hgrtest.pla: 0021:   setlinespans(@hgrHlin, @hgrVlin)
	!BYTE	$58,$02,$00		; ENTER	2,0
; samplesrc/hgrtest.pla: 0022:   setlineplot(@hgrXorPlot)
; samplesrc/hgrtest.pla: 0023:   hgrColor(7)
; samplesrc/hgrtest.pla: 0024:   for i = 0 to 191 step 8
	!BYTE	$26			; LA	_X033+0
_F000 	!WORD	0+0		
	!BYTE	$26			; LA	_X034+0
_F001 	!WORD	0+0		
	!BYTE	$54			; CALL	_X070
_F002 	!WORD	0		
	!BYTE	$26			; LA	_X032+0
_F003 	!WORD	0+0		
	!BYTE	$54			; CALL	_X072
_F004 	!WORD	0		
	!BYTE	$0E			; CN	7
	!BYTE	$54			; CALL	_X050
_F005 	!WORD	0		
	!BYTE	$2A,$BF			; CB	191
	!BYTE	$00			; CN	0
_B002 
	!BYTE	$6E,$00			; DLW	[0]
; samplesrc/hgrtest.pla: 0025:     linespans(0, i, 279, 191 - i)
; samplesrc/hgrtest.pla: 0026:     //line(0, i, 279, 191 - i)
; samplesrc/hgrtest.pla: 0027:   next
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$17,$01		; CW	279
	!BYTE	$2A,$BF			; CB	191
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X071
_F006 	!WORD	0		
_B003 
	!BYTE	$10			; CN	8
	!BYTE	$A6			; ADDBRLE	_B002
	!WORD	_B002-*
_B001 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; samplesrc/hgrtest.pla: 0028:   for i = 0 to 279 step 9
	!BYTE	$2C,$17,$01		; CW	279
	!BYTE	$00			; CN	0
_B005 
	!BYTE	$6E,$00			; DLW	[0]
; samplesrc/hgrtest.pla: 0029:     linespans(i, 0, 279 - i, 191)
; samplesrc/hgrtest.pla: 0030:     //line(i, 0, 279 - i, 191)
; samplesrc/hgrtest.pla: 0031:   next
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$2C,$17,$01		; CW	279
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$2A,$BF			; CB	191
	!BYTE	$54			; CALL	_X071
_F007 	!WORD	0		
_B006 
	!BYTE	$12			; CN	9
	!BYTE	$A6			; ADDBRLE	_B005
	!WORD	_B005-*
_B004 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; samplesrc/hgrtest.pla: 0032: end
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/hgrtest.pla: 0033: def testblt(sprtnum)#0
					; sprtnum -> [0]
_C001 					; testblt()
; samplesrc/hgrtest.pla: 0034:   var[16] i, j, ii, jj
					; i -> [2]
					; j -> [34]
					; ii -> [66]
					; jj -> [98]
; samplesrc/hgrtest.pla: 0035:   byte k
					; k -> [130]
; samplesrc/hgrtest.pla: 0036: 
; samplesrc/hgrtest.pla: 0037:   sprtnum = sprtnum - 1
	!BYTE	$58,$83,$01		; ENTER	131,1
; samplesrc/hgrtest.pla: 0038:   i[0] = 100
; samplesrc/hgrtest.pla: 0039:   ii[0] = 1
; samplesrc/hgrtest.pla: 0040:   j[0] = 80
; samplesrc/hgrtest.pla: 0041:   jj[0] = -1
; samplesrc/hgrtest.pla: 0042:   if sprtnum
; samplesrc/hgrtest.pla: 0043:     for k = 1 to sprtnum
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8E			; DECR
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$2A,$64			; CB	100
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$02			; CN	1
	!BYTE	$76,$42			; SLW	[66]
	!BYTE	$2A,$50			; CB	80
	!BYTE	$76,$22			; SLW	[34]
	!BYTE	$20			; MINUS ONE
	!BYTE	$76,$62			; SLW	[98]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4C			; BRFLS	_B007
	!WORD	_B007-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B009
	!WORD	_B009-*
_B010 
	!BYTE	$6C,$82			; DLB	[130]
; samplesrc/hgrtest.pla: 0044:       spriteAdd(k, spriteDup(sprtBall))
; samplesrc/hgrtest.pla: 0045:       i[k] = ((i[k - 1] ^ 37) + 97) % 270
; samplesrc/hgrtest.pla: 0046:       ii[k] = -ii[k - 1]
; samplesrc/hgrtest.pla: 0047:       j[k] = ((j[k - 1] ^ 29) + 53) % 180
; samplesrc/hgrtest.pla: 0048:       jj[k] = -jj[k - 1]
; samplesrc/hgrtest.pla: 0049:     next
	!BYTE	$64,$82			; LLB	[130]
	!BYTE	$6A			; LAW	_D075+0
_F008 	!WORD	_D075+0		
	!BYTE	$54			; CALL	_X053
_F009 	!WORD	0		
	!BYTE	$54			; CALL	_X066
_F010 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$64,$82			; LLB	[130]
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$25			; CB	37
	!BYTE	$98			; XOR
	!BYTE	$38,$61			; ADDI	97
	!BYTE	$2C,$0E,$01		; CW	270
	!BYTE	$8A			; MOD
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$72			; SW
	!BYTE	$28,$42			; LLA	[66]
	!BYTE	$64,$82			; LLB	[130]
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$90			; NEG
	!BYTE	$28,$42			; LLA	[66]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$72			; SW
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$64,$82			; LLB	[130]
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$1D			; CB	29
	!BYTE	$98			; XOR
	!BYTE	$38,$35			; ADDI	53
	!BYTE	$2A,$B4			; CB	180
	!BYTE	$8A			; MOD
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$72			; SW
	!BYTE	$28,$62			; LLA	[98]
	!BYTE	$64,$82			; LLB	[130]
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$90			; NEG
	!BYTE	$28,$62			; LLA	[98]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$72			; SW
_B011 
	!BYTE	$A4			; INCBRLE	_B010
	!WORD	_B010-*
_B009 
	!BYTE	$74,$82			; SLB	[130]
	!BYTE	$30			; DROP 
; samplesrc/hgrtest.pla: 0050:   fin
_B007 
_B008 
; samplesrc/hgrtest.pla: 0051:   while ^$C000 < 128
	!BYTE	$50			; BRNCH	_B014
	!WORD	_B014-*
_B012 
; samplesrc/hgrtest.pla: 0052:     for k = 0 to sprtnum
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B015
	!WORD	_B015-*
_B016 
	!BYTE	$6C,$82			; DLB	[130]
; samplesrc/hgrtest.pla: 0053:       i[k] = i[k] + ii[k]
; samplesrc/hgrtest.pla: 0054:       if i[k] < -5 or i[k] > 284
; samplesrc/hgrtest.pla: 0055:         ii[k] = -ii[k]
; samplesrc/hgrtest.pla: 0056:       fin
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$62			; LW
	!BYTE	$28,$42			; LLA	[66]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$72			; SW
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$62			; LW
	!BYTE	$5E,$FB			; CFFB	-5
	!BYTE	$46			; ISLT
	!BYTE	$AE			; BROR	_B018
	!WORD	_B018-*
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$62			; LW
	!BYTE	$2C,$1C,$01		; CW	284
	!BYTE	$44			; ISGT
_B018 
	!BYTE	$4C			; BRFLS	_B019
	!WORD	_B019-*
	!BYTE	$28,$42			; LLA	[66]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$62			; LW
	!BYTE	$90			; NEG
	!BYTE	$28,$42			; LLA	[66]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$72			; SW
_B019 
_B020 
; samplesrc/hgrtest.pla: 0057:       j[k] = j[k] + jj[k]
; samplesrc/hgrtest.pla: 0058:       if j[k] < -5 or j[k] > 196
; samplesrc/hgrtest.pla: 0059:         jj[k] = -jj[k]
; samplesrc/hgrtest.pla: 0060:       fin
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$62			; LW
	!BYTE	$28,$62			; LLA	[98]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$72			; SW
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$62			; LW
	!BYTE	$5E,$FB			; CFFB	-5
	!BYTE	$46			; ISLT
	!BYTE	$AE			; BROR	_B021
	!WORD	_B021-*
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$62			; LW
	!BYTE	$2A,$C4			; CB	196
	!BYTE	$44			; ISGT
_B021 
	!BYTE	$4C			; BRFLS	_B022
	!WORD	_B022-*
	!BYTE	$28,$62			; LLA	[98]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$62			; LW
	!BYTE	$90			; NEG
	!BYTE	$28,$62			; LLA	[98]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$72			; SW
_B022 
_B023 
; samplesrc/hgrtest.pla: 0061:       spritePosIndex(i[k], j[k], k)
; samplesrc/hgrtest.pla: 0062:     next
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$62			; LW
	!BYTE	$28,$22			; LLA	[34]
	!BYTE	$B8,$82			; IDXLB	[130]
	!BYTE	$62			; LW
	!BYTE	$64,$82			; LLB	[130]
	!BYTE	$54			; CALL	_X061
_F011 	!WORD	0		
_B017 
	!BYTE	$A4			; INCBRLE	_B016
	!WORD	_B016-*
_B015 
	!BYTE	$74,$82			; SLB	[130]
	!BYTE	$30			; DROP 
; samplesrc/hgrtest.pla: 0063:     spriteDrawList()
; samplesrc/hgrtest.pla: 0064:     spriteDrawBuf(hgrSwap())
; samplesrc/hgrtest.pla: 0065:   loop
	!BYTE	$54			; CALL	_X064
_F012 	!WORD	0		
	!BYTE	$54			; CALL	_X048
_F013 	!WORD	0		
	!BYTE	$54			; CALL	_X068
_F014 	!WORD	0		
	!BYTE	$30			; DROP 
_B014 
	!BYTE	$68,$00,$C0		; LAB	49152
	!BYTE	$2A,$80			; CB	128
	!BYTE	$46			; ISLT
	!BYTE	$4E			; BRTRU	_B012
	!WORD	_B012-*
_B013 
; samplesrc/hgrtest.pla: 0066: end
	!BYTE	$5A,$83			; LEAVE	131
; samplesrc/hgrtest.pla: 0067: 
; samplesrc/hgrtest.pla: 0068: hgrMode(TRUE)
_INIT 
; samplesrc/hgrtest.pla: 0069: spriteDrawBuf(hgrDrawBuf(0)) // So we can see the compile process
; samplesrc/hgrtest.pla: 0070: sprtBall = spriteCompile(10, 10, 5, 5, @ball)
; samplesrc/hgrtest.pla: 0071: hgrColor(0)
; samplesrc/hgrtest.pla: 0072: hgrClear()
; samplesrc/hgrtest.pla: 0073: testline
; samplesrc/hgrtest.pla: 0074: memcpy($4000, $2000, $2000) // Copy to both buffers
; samplesrc/hgrtest.pla: 0075: spriteDrawBuf(hgrDrawBuf(1))
; samplesrc/hgrtest.pla: 0076: spriteAdd(0, sprtBall)
; samplesrc/hgrtest.pla: 0077: testblt(16)
; samplesrc/hgrtest.pla: 0078: getc
; samplesrc/hgrtest.pla: 0079: hgrMode(FALSE)
; samplesrc/hgrtest.pla: 0080: done
	!BYTE	$20			; MINUS ONE
	!BYTE	$54			; CALL	_X045
_F015 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_X049
_F016 	!WORD	0		
	!BYTE	$54			; CALL	_X068
_F017 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$14			; CN	10
	!BYTE	$34			; DUP
	!BYTE	$0A			; CN	5
	!BYTE	$34			; DUP
	!BYTE	$26			; LA	_D074+0
_F018 	!WORD	_D074+0		
	!BYTE	$54			; CALL	_X052
_F019 	!WORD	0		
	!BYTE	$7A			; SAW	_D075+0
_F020 	!WORD	_D075+0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_X050
_F021 	!WORD	0		
	!BYTE	$54			; CALL	_X046
_F022 	!WORD	0		
	!BYTE	$54			; CALL	_C000
_F023 	!WORD	_C000		
	!BYTE	$2C,$00,$40		; CW	16384
	!BYTE	$2C,$00,$20		; CW	8192
	!BYTE	$34			; DUP
	!BYTE	$54			; CALL	_X018
_F024 	!WORD	0		
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_X049
_F025 	!WORD	0		
	!BYTE	$54			; CALL	_X068
_F026 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D075+0
_F027 	!WORD	_D075+0		
	!BYTE	$54			; CALL	_X066
_F028 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$2A,$10			; CB	16
	!BYTE	$54			; CALL	_C001
_F029 	!WORD	_C001		
	!BYTE	$54			; CALL	_X006
_F030 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_X045
_F031 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
_DEFCNT	=	3
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	34			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	70			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	72			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	50			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	71			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	71			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	53			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	61			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	64			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	48			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	68			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	45			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	49			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	68			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	52			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	50			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	46			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	49			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	68			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	66			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	6			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	45			; ESD INDEX
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: GETC
	!BYTE	$C7,$C5,$D4,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	6			; ESD INDEX
	; DCI STRING: MEMCPY
	!BYTE	$CD,$C5,$CD,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	18			; ESD INDEX
	; DCI STRING: HGRXORPLOT
	!BYTE	$C8,$C7,$D2,$D8,$CF,$D2,$D0,$CC,$CF,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	32			; ESD INDEX
	; DCI STRING: HGRHLIN
	!BYTE	$C8,$C7,$D2,$C8,$CC,$C9,$4E
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	33			; ESD INDEX
	; DCI STRING: HGRVLIN
	!BYTE	$C8,$C7,$D2,$D6,$CC,$C9,$4E
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	34			; ESD INDEX
	; DCI STRING: HGRMODE
	!BYTE	$C8,$C7,$D2,$CD,$CF,$C4,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	45			; ESD INDEX
	; DCI STRING: HGRCLEAR
	!BYTE	$C8,$C7,$D2,$C3,$CC,$C5,$C1,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	46			; ESD INDEX
	; DCI STRING: HGRSWAP
	!BYTE	$C8,$C7,$D2,$D3,$D7,$C1,$50
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	48			; ESD INDEX
	; DCI STRING: HGRDRAWBUF
	!BYTE	$C8,$C7,$D2,$C4,$D2,$C1,$D7,$C2,$D5,$46
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	49			; ESD INDEX
	; DCI STRING: HGRCOLOR
	!BYTE	$C8,$C7,$D2,$C3,$CF,$CC,$CF,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	50			; ESD INDEX
	; DCI STRING: SPRITECOMPILE
	!BYTE	$D3,$D0,$D2,$C9,$D4,$C5,$C3,$CF,$CD,$D0,$C9,$CC,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	52			; ESD INDEX
	; DCI STRING: SPRITEDUP
	!BYTE	$D3,$D0,$D2,$C9,$D4,$C5,$C4,$D5,$50
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	53			; ESD INDEX
	; DCI STRING: SPRITEPOSINDEX
	!BYTE	$D3,$D0,$D2,$C9,$D4,$C5,$D0,$CF,$D3,$C9,$CE,$C4,$C5,$58
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	61			; ESD INDEX
	; DCI STRING: SPRITEDRAWLIST
	!BYTE	$D3,$D0,$D2,$C9,$D4,$C5,$C4,$D2,$C1,$D7,$CC,$C9,$D3,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	64			; ESD INDEX
	; DCI STRING: SPRITEADD
	!BYTE	$D3,$D0,$D2,$C9,$D4,$C5,$C1,$C4,$44
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	66			; ESD INDEX
	; DCI STRING: SPRITEDRAWBUF
	!BYTE	$D3,$D0,$D2,$C9,$D4,$C5,$C4,$D2,$C1,$D7,$C2,$D5,$46
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	68			; ESD INDEX
	; DCI STRING: SETLINESPANS
	!BYTE	$D3,$C5,$D4,$CC,$C9,$CE,$C5,$D3,$D0,$C1,$CE,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	70			; ESD INDEX
	; DCI STRING: LINESPANS
	!BYTE	$CC,$C9,$CE,$C5,$D3,$D0,$C1,$CE,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	71			; ESD INDEX
	; DCI STRING: SETLINEPLOT
	!BYTE	$D3,$C5,$D4,$CC,$C9,$CE,$C5,$D0,$CC,$CF,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	72			; ESD INDEX
	!BYTE	$00			; END OF ESD
