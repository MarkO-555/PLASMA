; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; samplesrc/rogue.pla: 0001: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0200 // Version built against
					; _SYSVER_ = 512
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $03
					; MACHID_MEM = 3
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     //
; inc/cmdsys.plh: 0038:     // Module don't free memory
; inc/cmdsys.plh: 0039:     //
; inc/cmdsys.plh: 0040:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0041:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0042:     //
; inc/cmdsys.plh: 0043:     // CMD exported interface table
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     struc t_cmdsys
; inc/cmdsys.plh: 0046:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0047:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0048:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0049:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0050:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0051:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0052:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0053:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0054:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0055:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0056:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0057:         byte refcons    // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0058:         byte devcons    // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0059:     end
					; t_cmdsys = 21
; inc/cmdsys.plh: 0060:     //
; inc/cmdsys.plh: 0061:     // CMD exported functions
; inc/cmdsys.plh: 0062:     //
; inc/cmdsys.plh: 0063:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0064:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0065:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0066:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0067:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0068:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0069: end
; samplesrc/rogue.pla: 0001: 
; samplesrc/rogue.pla: 0002: include "inc/conio.plh"
; inc/conio.plh: 0001: import conio
	; DCI STRING: CONIO
	!BYTE	$C3,$CF,$CE,$C9,$4F
					; CONIO -> X028
; inc/conio.plh: 0002:     const NORMAL   = $FF
					; NORMAL = 255
; inc/conio.plh: 0003:     const INVERSE  = $3F
					; INVERSE = 63
; inc/conio.plh: 0004:     const FLASH    = $7F
					; FLASH = 127
; inc/conio.plh: 0005:     const ECHO_ON  = $80
					; ECHO_ON = 128
; inc/conio.plh: 0006:     const ECHO_OFF = $00
					; ECHO_OFF = 0
; inc/conio.plh: 0007:     struc t_conio
; inc/conio.plh: 0008:         word keypressed
					; keypressed = 0
; inc/conio.plh: 0009:         word getkey
					; getkey = 2
; inc/conio.plh: 0010:         word echo
					; echo = 4
; inc/conio.plh: 0011:         word home
					; home = 6
; inc/conio.plh: 0012:         word gotoxy
					; gotoxy = 8
; inc/conio.plh: 0013:         word viewport
					; viewport = 10
; inc/conio.plh: 0014:         word texttype
					; texttype = 12
; inc/conio.plh: 0015:         word textmode
					; textmode = 14
; inc/conio.plh: 0016:         word grmode
					; grmode = 16
; inc/conio.plh: 0017:         word grcolor
					; grcolor = 18
; inc/conio.plh: 0018:         word grplot
					; grplot = 20
; inc/conio.plh: 0019:         word tone
					; tone = 22
; inc/conio.plh: 0020:         word rnd
					; rnd = 24
; inc/conio.plh: 0021:     end
					; t_conio = 26
; inc/conio.plh: 0022: end
; samplesrc/rogue.pla: 0002: 
; samplesrc/rogue.pla: 0003: 
; samplesrc/rogue.pla: 0004: import roguemap
	; DCI STRING: ROGUEMAP
	!BYTE	$D2,$CF,$C7,$D5,$C5,$CD,$C1,$50
					; ROGUEMAP -> X029
; samplesrc/rogue.pla: 0005:   const xcentr     = 20
					; xcentr = 20
; samplesrc/rogue.pla: 0006:   const ycentr     = 12
					; ycentr = 12
; samplesrc/rogue.pla: 0007:   const scrnwidth  = 40
					; scrnwidth = 40
; samplesrc/rogue.pla: 0008:   const scrnheight = 22
					; scrnheight = 22
; samplesrc/rogue.pla: 0009:   const maprows    = 64
					; maprows = 64
; samplesrc/rogue.pla: 0010:   const mapcols    = 64
					; mapcols = 64
; samplesrc/rogue.pla: 0011:   const mapsize    = maprows*mapcols
					; mapsize = 4096
; samplesrc/rogue.pla: 0012: 
; samplesrc/rogue.pla: 0013:   const FLOOR_TILE  = '.'
					; FLOOR_TILE = 46
; samplesrc/rogue.pla: 0014:   const WALL_TILE   = '#'
					; WALL_TILE = 35
; samplesrc/rogue.pla: 0015:   const TORCH_TILE  = '*'
					; TORCH_TILE = 42
; samplesrc/rogue.pla: 0016:   const PIT_TILE    = ' '
					; PIT_TILE = 32
; samplesrc/rogue.pla: 0017:   const DOOR_TILE   = '+'
					; DOOR_TILE = 43
; samplesrc/rogue.pla: 0018:   const LOCKED_TILE = '%'
					; LOCKED_TILE = 37
; samplesrc/rogue.pla: 0019:   const WATER1_TILE = '>'
					; WATER1_TILE = 62
; samplesrc/rogue.pla: 0020:   const WATER2_TILE = '<'
					; WATER2_TILE = 60
; samplesrc/rogue.pla: 0021:   const KEY_TILE    = ','
					; KEY_TILE = 44
; samplesrc/rogue.pla: 0022:   const RAFT_TILE   = '@'
					; RAFT_TILE = 64
; samplesrc/rogue.pla: 0023:   const GOLD_TILE   = '$'
					; GOLD_TILE = 36
; samplesrc/rogue.pla: 0024:   const FOOD_TILE   = '&'
					; FOOD_TILE = 38
; samplesrc/rogue.pla: 0025:   const ENTER_TILE  = '-'
					; ENTER_TILE = 45
; samplesrc/rogue.pla: 0026:   const EXIT_TILE   = '='
					; EXIT_TILE = 61
; samplesrc/rogue.pla: 0027:   const OPAQUE_TILE = $01
					; OPAQUE_TILE = 1
; samplesrc/rogue.pla: 0028:   const VIEWED_TILE = $80
					; VIEWED_TILE = 128
; samplesrc/rogue.pla: 0029:   const LIT_TILE    = $80
					; LIT_TILE = 128
; samplesrc/rogue.pla: 0030:   const INV_TILE    = $3F
					; INV_TILE = 63
; samplesrc/rogue.pla: 0031:   const MAP_TILE    = $7F
					; MAP_TILE = 127
; samplesrc/rogue.pla: 0032: 
; samplesrc/rogue.pla: 0033:   predef loadmap(level), getmaptile(xmap, ymap), setmaptile(xmap, ymap, tile)#0
					; LOADMAP -> X030
					; GETMAPTILE -> X031
					; SETMAPTILE -> X032
; samplesrc/rogue.pla: 0034:   predef updtmaptile(xmap, ymap, tile)#0, lighttorches#0
					; UPDTMAPTILE -> X033
					; LIGHTTORCHES -> X034
; samplesrc/rogue.pla: 0035:   predef drawmap(xorg, yorg, viewfield, viewdir, lightdist, viewdist)
					; DRAWMAP -> X035
; samplesrc/rogue.pla: 0036:   predef drawvisentity(xofst, yofst, tile)#0, drawplayer(tile)#0
					; DRAWVISENTITY -> X036
					; DRAWPLAYER -> X037
; samplesrc/rogue.pla: 0037:   predef updatescreen#0
					; UPDATESCREEN -> X038
; samplesrc/rogue.pla: 0038: end
; samplesrc/rogue.pla: 0039: 
; samplesrc/rogue.pla: 0040: import roguecombat
	; DCI STRING: ROGUECOMBAT
	!BYTE	$D2,$CF,$C7,$D5,$C5,$C3,$CF,$CD,$C2,$C1,$54
					; ROGUECOMBAT -> X039
; samplesrc/rogue.pla: 0041:   predef fight(player, enemy)
					; FIGHT -> X040
; samplesrc/rogue.pla: 0042:   word entity, entities
					; ENTITY -> X041
					; ENTITIES -> X042
; samplesrc/rogue.pla: 0043: end
; samplesrc/rogue.pla: 0044: 
; samplesrc/rogue.pla: 0045: const maxlight = 10
	!BYTE	$00			; END OF MODULE DEPENDENCIES
					; maxlight = 10
; samplesrc/rogue.pla: 0046: const maxview  = 19
					; maxview = 19
; samplesrc/rogue.pla: 0047: 
; samplesrc/rogue.pla: 0048: word xdir =  0,  1,  1,  1,  0, -1, -1, -1
_D043 					; xdir =  0,  1,  1,  1,  0, -1, -1, -1
	!WORD	$0000
	!WORD	$0001
	!WORD	$0001
	!WORD	$0001
	!WORD	$0000
	!WORD	$FFFF
	!WORD	$FFFF
	!WORD	$FFFF
; samplesrc/rogue.pla: 0049: word ydir = -1, -1,  0,  1,  1,  1,  0, -1
_D044 					; ydir = -1, -1,  0,  1,  1,  1,  0, -1
	!WORD	$FFFF
	!WORD	$FFFF
	!WORD	$0000
	!WORD	$0001
	!WORD	$0001
	!WORD	$0001
	!WORD	$0000
	!WORD	$FFFF
; samplesrc/rogue.pla: 0050: byte vplayer = '^', '\\', '>', '/', 'v', '\\', '<', '/'
_D045 					; vplayer = '^', '\\', '>', '/', 'v', '\\', '<', '/'
	!BYTE	$5E
	!BYTE	$5C
	!BYTE	$3E
	!BYTE	$2F
	!BYTE	$76
	!BYTE	$5C
	!BYTE	$3C
	!BYTE	$2F
; samplesrc/rogue.pla: 0051: byte totaldarkness = 0
_D046 					; totaldarkness = 0
	!BYTE	$00
; samplesrc/rogue.pla: 0052: byte level = 0
_D047 					; level = 0
	!BYTE	$00
; samplesrc/rogue.pla: 0053: word free_entities
_D048 	!FILL	2			; free_entities
; samplesrc/rogue.pla: 0054: 
; samplesrc/rogue.pla: 0055: //
; samplesrc/rogue.pla: 0056: // Power-ups
; samplesrc/rogue.pla: 0057: //
; samplesrc/rogue.pla: 0058: 
; samplesrc/rogue.pla: 0059: const TORCH_OIL  = 250
					; TORCH_OIL = 250
; samplesrc/rogue.pla: 0060: const MANA       = 50
					; MANA = 50
; samplesrc/rogue.pla: 0061: const RUN_ENERGY = 4
					; RUN_ENERGY = 4
; samplesrc/rogue.pla: 0062: 
; samplesrc/rogue.pla: 0063: struc t_pos
; samplesrc/rogue.pla: 0064:   byte xpos
					; xpos = 0
; samplesrc/rogue.pla: 0065:   byte ypos
					; ypos = 1
; samplesrc/rogue.pla: 0066: end
					; t_pos = 2
; samplesrc/rogue.pla: 0067: 
; samplesrc/rogue.pla: 0068: //
; samplesrc/rogue.pla: 0069: // Player
; samplesrc/rogue.pla: 0070: //
; samplesrc/rogue.pla: 0071: 
; samplesrc/rogue.pla: 0072: struc t_player
; samplesrc/rogue.pla: 0073:   byte[t_pos]
; samplesrc/rogue.pla: 0074:   byte     angle
					; angle = 2
; samplesrc/rogue.pla: 0075:   byte     lamp
					; lamp = 3
; samplesrc/rogue.pla: 0076:   byte     fov
					; fov = 4
; samplesrc/rogue.pla: 0077:   byte     skill
					; skill = 5
; samplesrc/rogue.pla: 0078:   byte     health
					; health = 6
; samplesrc/rogue.pla: 0079:   byte     energy
					; energy = 7
; samplesrc/rogue.pla: 0080:   word     oil
					; oil = 8
; samplesrc/rogue.pla: 0081:   byte     gold
					; gold = 10
; samplesrc/rogue.pla: 0082:   byte     key
					; key = 11
; samplesrc/rogue.pla: 0083:   byte     raft
					; raft = 12
; samplesrc/rogue.pla: 0084:   byte[16] name
					; name = 13
; samplesrc/rogue.pla: 0085: end
					; t_player = 29
; samplesrc/rogue.pla: 0086: 
; samplesrc/rogue.pla: 0087: byte player = 0   // xpos
_D049 					; player = 0   // xpos
	!BYTE	$00
; samplesrc/rogue.pla: 0088: byte        = 0   // ypos
	!BYTE	$00
; samplesrc/rogue.pla: 0089: byte        = 4   // angle
	!BYTE	$04
; samplesrc/rogue.pla: 0090: byte        = 4   // lamp
	!BYTE	$04
; samplesrc/rogue.pla: 0091: byte        = 1   // fov
	!BYTE	$01
; samplesrc/rogue.pla: 0092: byte        = 15  // skill
	!BYTE	$0F
; samplesrc/rogue.pla: 0093: byte        = 100 // health
	!BYTE	$64
; samplesrc/rogue.pla: 0094: byte        = 100 // energy
	!BYTE	$64
; samplesrc/rogue.pla: 0095: word        = 500 // oil
	!WORD	$01F4
; samplesrc/rogue.pla: 0096: byte        = 0   // gold
	!BYTE	$00
; samplesrc/rogue.pla: 0097: byte        = 0   // key
	!BYTE	$00
; samplesrc/rogue.pla: 0098: byte        = 0   // raft
	!BYTE	$00
; samplesrc/rogue.pla: 0099: byte[16]    = "Player"
	!BYTE	$06
	!BYTE	$50,$6C,$61,$79,$65,$72
	!FILL	$09
; samplesrc/rogue.pla: 0100: 
; samplesrc/rogue.pla: 0101: predef moveplayer(dir)#0
; samplesrc/rogue.pla: 0102: 
; samplesrc/rogue.pla: 0103: //
; samplesrc/rogue.pla: 0104: // Other monsters
; samplesrc/rogue.pla: 0105: //
; samplesrc/rogue.pla: 0106: 
; samplesrc/rogue.pla: 0107: struc t_other
; samplesrc/rogue.pla: 0108:   byte[t_pos]
; samplesrc/rogue.pla: 0109:   byte kind
					; kind = 2
; samplesrc/rogue.pla: 0110:   byte tileid
					; tileid = 3
; samplesrc/rogue.pla: 0111:   byte life
					; life = 4
; samplesrc/rogue.pla: 0112:   byte power
					; power = 5
; samplesrc/rogue.pla: 0113:   word prev_other
					; prev_other = 6
; samplesrc/rogue.pla: 0114:   word next_other
					; next_other = 8
; samplesrc/rogue.pla: 0115: end
					; t_other = 10
; samplesrc/rogue.pla: 0116: 
; samplesrc/rogue.pla: 0117: //
; samplesrc/rogue.pla: 0118: // One line status strings
; samplesrc/rogue.pla: 0119: //
; samplesrc/rogue.pla: 0120: 
; samplesrc/rogue.pla: 0121: const statusline = 23
					; statusline = 23
; samplesrc/rogue.pla: 0122: 
; samplesrc/rogue.pla: 0123: byte helthstr = "Hlth:"
_D051 					; helthstr = "Hlth:"
	!BYTE	$05
	!BYTE	$48,$6C,$74,$68,$3A
; samplesrc/rogue.pla: 0124: byte enrgystr = "NRG:"
_D052 					; enrgystr = "NRG:"
	!BYTE	$04
	!BYTE	$4E,$52,$47,$3A
; samplesrc/rogue.pla: 0125: byte oilstr   = "Oil:"
_D053 					; oilstr   = "Oil:"
	!BYTE	$04
	!BYTE	$4F,$69,$6C,$3A
; samplesrc/rogue.pla: 0126: byte goldstr  = "Gld:"
_D054 					; goldstr  = "Gld:"
	!BYTE	$04
	!BYTE	$47,$6C,$64,$3A
; samplesrc/rogue.pla: 0127: byte keystr   = "Key"
_D055 					; keystr   = "Key"
	!BYTE	$03
	!BYTE	$4B,$65,$79
; samplesrc/rogue.pla: 0128: byte raftstr  = "Flt"
_D056 					; raftstr  = "Flt"
	!BYTE	$03
	!BYTE	$46,$6C,$74
; samplesrc/rogue.pla: 0129: 
; samplesrc/rogue.pla: 0130: //
; samplesrc/rogue.pla: 0131: // Messages
; samplesrc/rogue.pla: 0132: //
; samplesrc/rogue.pla: 0133: 
; samplesrc/rogue.pla: 0134: word instr
_D057 	!FILL	2			; instr
; samplesrc/rogue.pla: 0135: byte namestr      = "\nGreetings Warrior,\n  what is your name"
_D058 					; namestr      = "\nGreetings Warrior,\n  what is your name"
	!BYTE	$27
	!BYTE	$0D,$47,$72,$65,$65,$74,$69,$6E
	!BYTE	$67,$73,$20,$57,$61,$72,$72,$69
	!BYTE	$6F,$72,$2C,$0D,$20,$20,$77,$68
	!BYTE	$61,$74,$20,$69,$73,$20,$79,$6F
	!BYTE	$75,$72,$20,$6E,$61,$6D,$65
; samplesrc/rogue.pla: 0136: byte prepstr      = "\nPrepare."
_D059 					; prepstr      = "\nPrepare."
	!BYTE	$09
	!BYTE	$0D,$50,$72,$65,$70,$61,$72,$65
	!BYTE	$2E
; samplesrc/rogue.pla: 0137: byte quitstr      = "Are you sure you want to quit?"
_D060 					; quitstr      = "Are you sure you want to quit?"
	!BYTE	$1E
	!BYTE	$41,$72,$65,$20,$79,$6F,$75,$20
	!BYTE	$73,$75,$72,$65,$20,$79,$6F,$75
	!BYTE	$20,$77,$61,$6E,$74,$20,$74,$6F
	!BYTE	$20,$71,$75,$69,$74,$3F
; samplesrc/rogue.pla: 0138: byte youmadeitstr = "You made it out alive with $"
_D061 					; youmadeitstr = "You made it out alive with $"
	!BYTE	$1C
	!BYTE	$59,$6F,$75,$20,$6D,$61,$64,$65
	!BYTE	$20,$69,$74,$20,$6F,$75,$74,$20
	!BYTE	$61,$6C,$69,$76,$65,$20,$77,$69
	!BYTE	$74,$68,$20,$24
; samplesrc/rogue.pla: 0139: byte youdiedstr   = "You perished inside the catacombs :-("
_D062 					; youdiedstr   = "You perished inside the catacombs :-("
	!BYTE	$25
	!BYTE	$59,$6F,$75,$20,$70,$65,$72,$69
	!BYTE	$73,$68,$65,$64,$20,$69,$6E,$73
	!BYTE	$69,$64,$65,$20,$74,$68,$65,$20
	!BYTE	$63,$61,$74,$61,$63,$6F,$6D,$62
	!BYTE	$73,$20,$3A,$2D,$28
; samplesrc/rogue.pla: 0140: byte againstr     = "\n\nPlay again by typing: +rogue\n"
_D063 					; againstr     = "\n\nPlay again by typing: +rogue\n"
	!BYTE	$1F
	!BYTE	$0D,$0D,$50,$6C,$61,$79,$20,$61
	!BYTE	$67,$61,$69,$6E,$20,$62,$79,$20
	!BYTE	$74,$79,$70,$69,$6E,$67,$3A,$20
	!BYTE	$2B,$72,$6F,$67,$75,$65,$0D
; samplesrc/rogue.pla: 0141: 
; samplesrc/rogue.pla: 0142: //
; samplesrc/rogue.pla: 0143: // Utility functions
; samplesrc/rogue.pla: 0144: //
; samplesrc/rogue.pla: 0145: 
; samplesrc/rogue.pla: 0146: def abs(i)
	!BYTE	$00			; PAD BYTE
_SUBSEG 				; BYTECODE STARTS
					; i -> [0]
_C000 					; abs()
; samplesrc/rogue.pla: 0147:   if i < 0
	!BYTE	$58,$02,$01		; ENTER	2,1
; samplesrc/rogue.pla: 0148:     i = -i
; samplesrc/rogue.pla: 0149:   fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B001
	!WORD	_B001-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$90			; NEG
	!BYTE	$76,$00			; SLW	[0]
_B001 
_B002 
; samplesrc/rogue.pla: 0150:   return i
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rogue.pla: 0151: end
; samplesrc/rogue.pla: 0152: 
; samplesrc/rogue.pla: 0153: //
; samplesrc/rogue.pla: 0154: // Sound functions
; samplesrc/rogue.pla: 0155: //
; samplesrc/rogue.pla: 0156: 
; samplesrc/rogue.pla: 0157: def ouch#0
_C001 					; ouch()
; samplesrc/rogue.pla: 0158:   conio:tone(128,5)
; samplesrc/rogue.pla: 0159: end
	!BYTE	$2A,$80			; CB	128
	!BYTE	$0A			; CN	5
	!BYTE	$6A			; LAW	_X028+22
_F000 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$5C			; RET
; samplesrc/rogue.pla: 0160: 
; samplesrc/rogue.pla: 0161: def gotit#0
_C002 					; gotit()
; samplesrc/rogue.pla: 0162:   conio:tone(10,8)
; samplesrc/rogue.pla: 0163:   conio:tone(80,2)
; samplesrc/rogue.pla: 0164: end
	!BYTE	$14			; CN	10
	!BYTE	$10			; CN	8
	!BYTE	$6A			; LAW	_X028+22
_F001 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$50			; CB	80
	!BYTE	$04			; CN	2
	!BYTE	$6A			; LAW	_X028+22
_F002 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$5C			; RET
; samplesrc/rogue.pla: 0165: 
; samplesrc/rogue.pla: 0166: def fall#0
_C003 					; fall()
; samplesrc/rogue.pla: 0167:   byte i
					; i -> [0]
; samplesrc/rogue.pla: 0168: 
; samplesrc/rogue.pla: 0169:   for i = 0 to 10
	!BYTE	$58,$01,$00		; ENTER	1,0
	!BYTE	$14			; CN	10
	!BYTE	$00			; CN	0
_B004 
	!BYTE	$6C,$00			; DLB	[0]
; samplesrc/rogue.pla: 0170:     conio:tone(50, i)
; samplesrc/rogue.pla: 0171:   next
	!BYTE	$2A,$32			; CB	50
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$6A			; LAW	_X028+22
_F003 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B005 
	!BYTE	$A4			; INCBRLE	_B004
	!WORD	_B004-*
_B003 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; samplesrc/rogue.pla: 0172: end
	!BYTE	$5A,$01			; LEAVE	1
; samplesrc/rogue.pla: 0173: 
; samplesrc/rogue.pla: 0174: def drown#0
_C004 					; drown()
; samplesrc/rogue.pla: 0175:   word i
					; i -> [0]
; samplesrc/rogue.pla: 0176: 
; samplesrc/rogue.pla: 0177:   conio:tone(10,20)
	!BYTE	$58,$02,$00		; ENTER	2,0
; samplesrc/rogue.pla: 0178:   conio:tone(10,1)
; samplesrc/rogue.pla: 0179:   for i = 0 to 1000
	!BYTE	$14			; CN	10
	!BYTE	$2A,$14			; CB	20
	!BYTE	$6A			; LAW	_X028+22
_F004 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$14			; CN	10
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_X028+22
_F005 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$E8,$03		; CW	1000
	!BYTE	$00			; CN	0
_B007 
	!BYTE	$6E,$00			; DLW	[0]
; samplesrc/rogue.pla: 0180:   next
_B008 
	!BYTE	$A4			; INCBRLE	_B007
	!WORD	_B007-*
_B006 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; samplesrc/rogue.pla: 0181:   conio:tone(10,25)
; samplesrc/rogue.pla: 0182:   conio:tone(10,2)
; samplesrc/rogue.pla: 0183:   for i = 0 to 1000
	!BYTE	$14			; CN	10
	!BYTE	$2A,$19			; CB	25
	!BYTE	$6A			; LAW	_X028+22
_F006 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$14			; CN	10
	!BYTE	$04			; CN	2
	!BYTE	$6A			; LAW	_X028+22
_F007 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2C,$E8,$03		; CW	1000
	!BYTE	$00			; CN	0
_B010 
	!BYTE	$6E,$00			; DLW	[0]
; samplesrc/rogue.pla: 0184:   next
_B011 
	!BYTE	$A4			; INCBRLE	_B010
	!WORD	_B010-*
_B009 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; samplesrc/rogue.pla: 0185:   conio:tone(10,30)
; samplesrc/rogue.pla: 0186:   conio:tone(10,3)
; samplesrc/rogue.pla: 0187: end
	!BYTE	$14			; CN	10
	!BYTE	$2A,$1E			; CB	30
	!BYTE	$6A			; LAW	_X028+22
_F008 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$14			; CN	10
	!BYTE	$06			; CN	3
	!BYTE	$6A			; LAW	_X028+22
_F009 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rogue.pla: 0188: 
; samplesrc/rogue.pla: 0189: def groan#0
_C005 					; groan()
; samplesrc/rogue.pla: 0190:   byte i
					; i -> [0]
; samplesrc/rogue.pla: 0191: 
; samplesrc/rogue.pla: 0192:   for i = 0 to 5
	!BYTE	$58,$01,$00		; ENTER	1,0
	!BYTE	$0A			; CN	5
	!BYTE	$00			; CN	0
_B013 
	!BYTE	$6C,$00			; DLB	[0]
; samplesrc/rogue.pla: 0193:     conio:tone(5, 40 + i)
; samplesrc/rogue.pla: 0194:   next
	!BYTE	$0A			; CN	5
	!BYTE	$2A,$28			; CB	40
	!BYTE	$B0,$00			; ADDLB	[0]
	!BYTE	$6A			; LAW	_X028+22
_F010 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B014 
	!BYTE	$A4			; INCBRLE	_B013
	!WORD	_B013-*
_B012 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; samplesrc/rogue.pla: 0195: end
	!BYTE	$5A,$01			; LEAVE	1
; samplesrc/rogue.pla: 0196: 
; samplesrc/rogue.pla: 0197: //
; samplesrc/rogue.pla: 0198: // Update status line
; samplesrc/rogue.pla: 0199: //
; samplesrc/rogue.pla: 0200: 
; samplesrc/rogue.pla: 0201: def status#0
_C006 					; status()
; samplesrc/rogue.pla: 0202:   memset($07D0, $A0A0, 40)
; samplesrc/rogue.pla: 0203:   conio:gotoxy(0, statusline)
; samplesrc/rogue.pla: 0204:   puts(@helthstr)
; samplesrc/rogue.pla: 0205:   puti(player.health)
; samplesrc/rogue.pla: 0206:   conio:gotoxy(9, statusline)
; samplesrc/rogue.pla: 0207:   puts(@enrgystr)
; samplesrc/rogue.pla: 0208:   puti(player.energy)
; samplesrc/rogue.pla: 0209:   conio:gotoxy(17, statusline)
; samplesrc/rogue.pla: 0210:   puts(@oilstr)
; samplesrc/rogue.pla: 0211:   puti(player:oil/10)
; samplesrc/rogue.pla: 0212:   conio:gotoxy(25, statusline)
; samplesrc/rogue.pla: 0213:   puts(@goldstr)
; samplesrc/rogue.pla: 0214:   puti(player.gold)
; samplesrc/rogue.pla: 0215:   if player.raft
; samplesrc/rogue.pla: 0216:     conio:gotoxy(32, statusline)
; samplesrc/rogue.pla: 0217:     puts(@raftstr)
; samplesrc/rogue.pla: 0218:   fin
	!BYTE	$2C,$D0,$07		; CW	2000
	!BYTE	$2C,$A0,$A0		; CW	41120
	!BYTE	$2A,$28			; CB	40
	!BYTE	$54			; CALL	_X017
_F011 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$2A,$17			; CB	23
	!BYTE	$6A			; LAW	_X028+8
_F012 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D051+0
_F013 	!WORD	_D051+0		
	!BYTE	$54			; CALL	_X004
_F014 	!WORD	0		
	!BYTE	$68			; LAB	_D049+6
_F015 	!WORD	_D049+6		
	!BYTE	$54			; CALL	_X005
_F016 	!WORD	0		
	!BYTE	$12			; CN	9
	!BYTE	$2A,$17			; CB	23
	!BYTE	$6A			; LAW	_X028+8
_F017 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D052+0
_F018 	!WORD	_D052+0		
	!BYTE	$54			; CALL	_X004
_F019 	!WORD	0		
	!BYTE	$68			; LAB	_D049+7
_F020 	!WORD	_D049+7		
	!BYTE	$54			; CALL	_X005
_F021 	!WORD	0		
	!BYTE	$2A,$11			; CB	17
	!BYTE	$2A,$17			; CB	23
	!BYTE	$6A			; LAW	_X028+8
_F022 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D053+0
_F023 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_X004
_F024 	!WORD	0		
	!BYTE	$6A			; LAW	_D049+8
_F025 	!WORD	_D049+8		
	!BYTE	$14			; CN	10
	!BYTE	$88			; DIV
	!BYTE	$54			; CALL	_X005
_F026 	!WORD	0		
	!BYTE	$2A,$19			; CB	25
	!BYTE	$2A,$17			; CB	23
	!BYTE	$6A			; LAW	_X028+8
_F027 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D054+0
_F028 	!WORD	_D054+0		
	!BYTE	$54			; CALL	_X004
_F029 	!WORD	0		
	!BYTE	$68			; LAB	_D049+10
_F030 	!WORD	_D049+10		
	!BYTE	$54			; CALL	_X005
_F031 	!WORD	0		
	!BYTE	$68			; LAB	_D049+12
_F032 	!WORD	_D049+12		
	!BYTE	$4C			; BRFLS	_B015
	!WORD	_B015-*
	!BYTE	$2A,$20			; CB	32
	!BYTE	$2A,$17			; CB	23
	!BYTE	$6A			; LAW	_X028+8
_F033 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D056+0
_F034 	!WORD	_D056+0		
	!BYTE	$54			; CALL	_X004
_F035 	!WORD	0		
_B015 
_B016 
; samplesrc/rogue.pla: 0219:   if player.key
; samplesrc/rogue.pla: 0220:     conio:gotoxy(36, statusline)
; samplesrc/rogue.pla: 0221:     puts(@keystr)
; samplesrc/rogue.pla: 0222:   fin
	!BYTE	$68			; LAB	_D049+11
_F036 	!WORD	_D049+11		
	!BYTE	$4C			; BRFLS	_B017
	!WORD	_B017-*
	!BYTE	$2A,$24			; CB	36
	!BYTE	$2A,$17			; CB	23
	!BYTE	$6A			; LAW	_X028+8
_F037 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D055+0
_F038 	!WORD	_D055+0		
	!BYTE	$54			; CALL	_X004
_F039 	!WORD	0		
_B017 
_B018 
; samplesrc/rogue.pla: 0223: end
	!BYTE	$5C			; RET
; samplesrc/rogue.pla: 0224: 
; samplesrc/rogue.pla: 0225: def clearstatus#0
_C007 					; clearstatus()
; samplesrc/rogue.pla: 0226:   memset($07D0, $A0A0, 40)
; samplesrc/rogue.pla: 0227: end
	!BYTE	$2C,$D0,$07		; CW	2000
	!BYTE	$2C,$A0,$A0		; CW	41120
	!BYTE	$2A,$28			; CB	40
	!BYTE	$54			; CALL	_X017
_F040 	!WORD	0		
	!BYTE	$5C			; RET
; samplesrc/rogue.pla: 0228: 
; samplesrc/rogue.pla: 0229: //
; samplesrc/rogue.pla: 0230: // Move player, check for obstacles
; samplesrc/rogue.pla: 0231: //
; samplesrc/rogue.pla: 0232: 
; samplesrc/rogue.pla: 0233: def moveplayer(dir)#0
					; dir -> [0]
_P000 					; moveplayer(dir)#0()
_C008 					; moveplayer()
; samplesrc/rogue.pla: 0234:   byte xmove, ymove
					; xmove -> [2]
					; ymove -> [3]
; samplesrc/rogue.pla: 0235: 
; samplesrc/rogue.pla: 0236:   xmove = player.xpos + dir * xdir[player.angle]
	!BYTE	$58,$04,$01		; ENTER	4,1
; samplesrc/rogue.pla: 0237:   ymove = player.ypos + dir * ydir[player.angle]
; samplesrc/rogue.pla: 0238:   when getmaptile(xmove, ymove) & MAP_TILE
	!BYTE	$68			; LAB	_D049+0
_F041 	!WORD	_D049+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D043+0
_F042 	!WORD	_D043+0		
	!BYTE	$BC			; IDXAB	_D049+2
_F043 	!WORD	_D049+2		
	!BYTE	$62			; LW
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$68			; LAB	_D049+1
_F044 	!WORD	_D049+1		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D044+0
_F045 	!WORD	_D044+0		
	!BYTE	$BC			; IDXAB	_D049+2
_F046 	!WORD	_D049+2		
	!BYTE	$62			; LW
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$54			; CALL	_X031
_F047 	!WORD	0		
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$52			; SEL
	!WORD	_B020-*
; samplesrc/rogue.pla: 0239:     is PIT_TILE
_B021 
; samplesrc/rogue.pla: 0240:       fall
; samplesrc/rogue.pla: 0241:       player.energy = 0
; samplesrc/rogue.pla: 0242:       player.health = 0
; samplesrc/rogue.pla: 0243:       break
	!BYTE	$54			; CALL	_C003
_F048 	!WORD	_C003		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D049+7
_F049 	!WORD	_D049+7		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D049+6
_F050 	!WORD	_D049+6		
	!BYTE	$50			; BRNCH	_B019
	!WORD	_B019-*
; samplesrc/rogue.pla: 0244:     is WATER1_TILE
_B022 
; samplesrc/rogue.pla: 0245:     is WATER2_TILE
_B023 
; samplesrc/rogue.pla: 0246:       if not player.raft
; samplesrc/rogue.pla: 0247:         drown
; samplesrc/rogue.pla: 0248:         player.energy = 0
; samplesrc/rogue.pla: 0249:         player.health = 0
; samplesrc/rogue.pla: 0250:         break
	!BYTE	$68			; LAB	_D049+12
_F051 	!WORD	_D049+12		
	!BYTE	$4E			; BRTRU	_B024
	!WORD	_B024-*
	!BYTE	$54			; CALL	_C004
_F052 	!WORD	_C004		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D049+7
_F053 	!WORD	_D049+7		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D049+6
_F054 	!WORD	_D049+6		
	!BYTE	$50			; BRNCH	_B019
	!WORD	_B019-*
; samplesrc/rogue.pla: 0251:       fin
_B024 
_B025 
; samplesrc/rogue.pla: 0252:     is FLOOR_TILE
_B026 
; samplesrc/rogue.pla: 0253:     is TORCH_TILE
_B027 
; samplesrc/rogue.pla: 0254:     is KEY_TILE
_B028 
; samplesrc/rogue.pla: 0255:     is RAFT_TILE
_B029 
; samplesrc/rogue.pla: 0256:     is GOLD_TILE
_B030 
; samplesrc/rogue.pla: 0257:     is FOOD_TILE
_B031 
; samplesrc/rogue.pla: 0258:       if player.energy < 10
; samplesrc/rogue.pla: 0259:         player.fov = 0
; samplesrc/rogue.pla: 0260:       fin
	!BYTE	$68			; LAB	_D049+7
_F055 	!WORD	_D049+7		
	!BYTE	$14			; CN	10
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B032
	!WORD	_B032-*
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D049+4
_F056 	!WORD	_D049+4		
_B032 
_B033 
; samplesrc/rogue.pla: 0261:       if player.energy
; samplesrc/rogue.pla: 0262:         player.energy = player.energy - 1
; samplesrc/rogue.pla: 0263:       fin
	!BYTE	$68			; LAB	_D049+7
_F057 	!WORD	_D049+7		
	!BYTE	$4C			; BRFLS	_B034
	!WORD	_B034-*
	!BYTE	$68			; LAB	_D049+7
_F058 	!WORD	_D049+7		
	!BYTE	$8E			; DECR
	!BYTE	$78			; SAB	_D049+7
_F059 	!WORD	_D049+7		
_B034 
_B035 
; samplesrc/rogue.pla: 0264:       player.xpos = xmove
; samplesrc/rogue.pla: 0265:       player.ypos = ymove
; samplesrc/rogue.pla: 0266:       break
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$78			; SAB	_D049+0
_F060 	!WORD	_D049+0		
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$78			; SAB	_D049+1
_F061 	!WORD	_D049+1		
	!BYTE	$50			; BRNCH	_B019
	!WORD	_B019-*
; samplesrc/rogue.pla: 0267:     otherwise
_B020 
	!BYTE	$09			; CASEBLOCK
	!WORD	$0020
	!WORD	_B021-*
	!WORD	$0024
	!WORD	_B030-*
	!WORD	$0026
	!WORD	_B031-*
	!WORD	$002A
	!WORD	_B027-*
	!WORD	$002C
	!WORD	_B028-*
	!WORD	$002E
	!WORD	_B026-*
	!WORD	$003C
	!WORD	_B023-*
	!WORD	$003E
	!WORD	_B022-*
	!WORD	$0040
	!WORD	_B029-*
; samplesrc/rogue.pla: 0268:       ouch
; samplesrc/rogue.pla: 0269:   wend
	!BYTE	$54			; CALL	_C001
_F062 	!WORD	_C001		
_B019 
; samplesrc/rogue.pla: 0270: end
	!BYTE	$5A,$04			; LEAVE	4
; samplesrc/rogue.pla: 0271: 
; samplesrc/rogue.pla: 0272: //
; samplesrc/rogue.pla: 0273: // Find other entities in map and put in database
; samplesrc/rogue.pla: 0274: //
; samplesrc/rogue.pla: 0275: 
; samplesrc/rogue.pla: 0276: def findentities#0
_C009 					; findentities()
; samplesrc/rogue.pla: 0277:   word newother
					; newother -> [0]
; samplesrc/rogue.pla: 0278:   byte xmap, ymap, what
					; xmap -> [2]
					; ymap -> [3]
					; what -> [4]
; samplesrc/rogue.pla: 0279: 
; samplesrc/rogue.pla: 0280:   for ymap = 1 to maprows - 2
	!BYTE	$58,$05,$00		; ENTER	5,0
	!BYTE	$2A,$3E			; CB	62
	!BYTE	$02			; CN	1
_B037 
	!BYTE	$6C,$03			; DLB	[3]
; samplesrc/rogue.pla: 0281:     for xmap = 2 to mapcols - 2
	!BYTE	$2A,$3E			; CB	62
	!BYTE	$04			; CN	2
_B040 
	!BYTE	$6C,$02			; DLB	[2]
; samplesrc/rogue.pla: 0282:       what = 0
; samplesrc/rogue.pla: 0283:       when getmaptile(xmap, ymap) & MAP_TILE
	!BYTE	$00			; CN	0
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$54			; CALL	_X031
_F063 	!WORD	0		
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$52			; SEL
	!WORD	_B043-*
; samplesrc/rogue.pla: 0284:         is ENTER_TILE
_B044 
; samplesrc/rogue.pla: 0285:           player.xpos = xmap
; samplesrc/rogue.pla: 0286:           player.ypos = ymap
; samplesrc/rogue.pla: 0287:           if getmaptile(xmap, ymap - 1) & MAP_TILE == FLOOR_TILE
; samplesrc/rogue.pla: 0288:             player.angle = 0
; samplesrc/rogue.pla: 0289:           else
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$78			; SAB	_D049+0
_F064 	!WORD	_D049+0		
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$78			; SAB	_D049+1
_F065 	!WORD	_D049+1		
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_X031
_F066 	!WORD	0		
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$24			; BRNE	_B045
	!WORD	_B045-*
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D049+2
_F067 	!WORD	_D049+2		
	!BYTE	$50			; BRNCH	_B046
	!WORD	_B046-*
_B045 
; samplesrc/rogue.pla: 0290:             player.angle = 4
; samplesrc/rogue.pla: 0291:           fin
	!BYTE	$08			; CN	4
	!BYTE	$78			; SAB	_D049+2
_F068 	!WORD	_D049+2		
_B046 
; samplesrc/rogue.pla: 0292:           break
	!BYTE	$50			; BRNCH	_B042
	!WORD	_B042-*
; samplesrc/rogue.pla: 0293:     is 'R' // Rogue
_B047 
; samplesrc/rogue.pla: 0294:       what = what + 1
; samplesrc/rogue.pla: 0295:     is 'Z' // Zombie
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8C			; INCR
	!BYTE	$74,$04			; SLB	[4]
_B048 
; samplesrc/rogue.pla: 0296:       what = what + 1
; samplesrc/rogue.pla: 0297:         is 'O' // Ogre
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8C			; INCR
	!BYTE	$74,$04			; SLB	[4]
_B049 
; samplesrc/rogue.pla: 0298:       what = what + 1
; samplesrc/rogue.pla: 0299:         is 'T' // Thief
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8C			; INCR
	!BYTE	$74,$04			; SLB	[4]
_B050 
; samplesrc/rogue.pla: 0300:       newother         = heapalloc(t_other)
; samplesrc/rogue.pla: 0301:       newother->xpos   = xmap
; samplesrc/rogue.pla: 0302:       newother->ypos   = ymap
; samplesrc/rogue.pla: 0303:       newother->kind   = what
; samplesrc/rogue.pla: 0304:       newother->tileid = ^(entity[what] + 1) // First character of name string
; samplesrc/rogue.pla: 0305:       newother->power  = ^(entity[what] + ^entity[what] + 1)
; samplesrc/rogue.pla: 0306:       newother->life   = 100
; samplesrc/rogue.pla: 0307:       //
; samplesrc/rogue.pla: 0308:       // Insert into head of entities list
; samplesrc/rogue.pla: 0309:       //
; samplesrc/rogue.pla: 0310:       newother=>prev_other = 0
; samplesrc/rogue.pla: 0311:       newother=>next_other = entities
; samplesrc/rogue.pla: 0312:       if entities
; samplesrc/rogue.pla: 0313:         entities=>prev_other = newother
; samplesrc/rogue.pla: 0314:       fin
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X014
_F069 	!WORD	0		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$70			; SB
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$26			; LA	_X041+0
_F070 	!WORD	0+0		
	!BYTE	$B8,$04			; IDXLB	[4]
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
	!BYTE	$26			; LA	_X041+0
_F071 	!WORD	0+0		
	!BYTE	$B8,$04			; IDXLB	[4]
	!BYTE	$62			; LW
	!BYTE	$26			; LA	_X041+0
_F072 	!WORD	0+0		
	!BYTE	$B8,$04			; IDXLB	[4]
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$70			; SB
	!BYTE	$2A,$64			; CB	100
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_X042+0
_F073 	!WORD	0+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_X042+0
_F074 	!WORD	0+0		
	!BYTE	$4C			; BRFLS	_B051
	!WORD	_B051-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X042+0
_F075 	!WORD	0+0		
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
_B051 
_B052 
; samplesrc/rogue.pla: 0315:       entities = newother
; samplesrc/rogue.pla: 0316:       //
; samplesrc/rogue.pla: 0317:       // Clear entity from map, replace with floor
; samplesrc/rogue.pla: 0318:       //
; samplesrc/rogue.pla: 0319:       setmaptile(xmap, ymap, FLOOR_TILE)
; samplesrc/rogue.pla: 0320:       wend
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_X042+0
_F076 	!WORD	0+0		
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X032
_F077 	!WORD	0		
	!BYTE	$50			; BRNCH	_B042
	!WORD	_B042-*
_B043 
	!BYTE	$05			; CASEBLOCK
	!WORD	$002D
	!WORD	_B044-*
	!WORD	$004F
	!WORD	_B049-*
	!WORD	$0052
	!WORD	_B047-*
	!WORD	$0054
	!WORD	_B050-*
	!WORD	$005A
	!WORD	_B048-*
_B042 
; samplesrc/rogue.pla: 0321:     next
_B041 
	!BYTE	$A4			; INCBRLE	_B040
	!WORD	_B040-*
_B039 
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$30			; DROP 
; samplesrc/rogue.pla: 0322:     if not (ymap & 7)
; samplesrc/rogue.pla: 0323:       putc('.')
; samplesrc/rogue.pla: 0324:     fin
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$4E			; BRTRU	_B053
	!WORD	_B053-*
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X002
_F078 	!WORD	0		
_B053 
_B054 
; samplesrc/rogue.pla: 0325:   next
_B038 
	!BYTE	$A4			; INCBRLE	_B037
	!WORD	_B037-*
_B036 
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$30			; DROP 
; samplesrc/rogue.pla: 0326: end
	!BYTE	$5A,$05			; LEAVE	5
; samplesrc/rogue.pla: 0327: 
; samplesrc/rogue.pla: 0328: //
; samplesrc/rogue.pla: 0329: // Draw other entities on map if visible
; samplesrc/rogue.pla: 0330: //
; samplesrc/rogue.pla: 0331: 
; samplesrc/rogue.pla: 0332: def drawentities#0
_C010 					; drawentities()
; samplesrc/rogue.pla: 0333:   word other, xofst, yofst
					; other -> [0]
					; xofst -> [2]
					; yofst -> [4]
; samplesrc/rogue.pla: 0334: 
; samplesrc/rogue.pla: 0335:   other = entities
	!BYTE	$58,$06,$00		; ENTER	6,0
; samplesrc/rogue.pla: 0336:   while other
	!BYTE	$6A			; LAW	_X042+0
_F079 	!WORD	0+0		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B057
	!WORD	_B057-*
_B055 
; samplesrc/rogue.pla: 0337:     xofst = other->xpos - player.xpos
; samplesrc/rogue.pla: 0338:     yofst = other->ypos - player.ypos
; samplesrc/rogue.pla: 0339:     if abs(xofst) < 20 and abs(yofst) < 12
; samplesrc/rogue.pla: 0340:       drawvisentity(xofst, yofst, other->tileid)
; samplesrc/rogue.pla: 0341:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$68			; LAB	_D049+0
_F080 	!WORD	_D049+0		
	!BYTE	$84			; SUB 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$68			; LAB	_D049+1
_F081 	!WORD	_D049+1		
	!BYTE	$84			; SUB 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C000
_F082 	!WORD	_C000		
	!BYTE	$2A,$14			; CB	20
	!BYTE	$46			; ISLT
	!BYTE	$AC			; BRAND	_B058
	!WORD	_B058-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C000
_F083 	!WORD	_C000		
	!BYTE	$18			; CN	12
	!BYTE	$46			; ISLT
_B058 
	!BYTE	$4C			; BRFLS	_B059
	!WORD	_B059-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X036
_F084 	!WORD	0		
_B059 
_B060 
; samplesrc/rogue.pla: 0342:     other = other=>next_other
; samplesrc/rogue.pla: 0343:   loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
_B057 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B055
	!WORD	_B055-*
_B056 
; samplesrc/rogue.pla: 0344: end
	!BYTE	$5A,$06			; LEAVE	6
; samplesrc/rogue.pla: 0345: 
; samplesrc/rogue.pla: 0346: //
; samplesrc/rogue.pla: 0347: // Move entitiess
; samplesrc/rogue.pla: 0348: //
; samplesrc/rogue.pla: 0349: 
; samplesrc/rogue.pla: 0350: def lineofsight(x1, y1, x2, y2)
					; x1 -> [0]
					; y1 -> [2]
					; x2 -> [4]
					; y2 -> [6]
_C011 					; lineofsight()
; samplesrc/rogue.pla: 0351:   word sx, sy, dx, dy, dx2, dy2, dd2, err
					; sx -> [8]
					; sy -> [10]
					; dx -> [12]
					; dy -> [14]
					; dx2 -> [16]
					; dy2 -> [18]
					; dd2 -> [20]
					; err -> [22]
; samplesrc/rogue.pla: 0352: 
; samplesrc/rogue.pla: 0353:   dx = x2 - x1
	!BYTE	$58,$18,$04		; ENTER	24,4
; samplesrc/rogue.pla: 0354:   if dx < 0
; samplesrc/rogue.pla: 0355:     dx = -dx
; samplesrc/rogue.pla: 0356:     sx = -1
; samplesrc/rogue.pla: 0357:   else
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$6E,$0C			; DLW	[12]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B061
	!WORD	_B061-*
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$90			; NEG
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$20			; MINUS ONE
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B062
	!WORD	_B062-*
_B061 
; samplesrc/rogue.pla: 0358:     sx = 1
; samplesrc/rogue.pla: 0359:   fin
	!BYTE	$02			; CN	1
	!BYTE	$76,$08			; SLW	[8]
_B062 
; samplesrc/rogue.pla: 0360:   dy = y2 - y1
; samplesrc/rogue.pla: 0361:   if dy < 0
; samplesrc/rogue.pla: 0362:     dy = -dy
; samplesrc/rogue.pla: 0363:     sy = -1
; samplesrc/rogue.pla: 0364:   else
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$84			; SUB 
	!BYTE	$6E,$0E			; DLW	[14]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B063
	!WORD	_B063-*
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$90			; NEG
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$20			; MINUS ONE
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$50			; BRNCH	_B064
	!WORD	_B064-*
_B063 
; samplesrc/rogue.pla: 0365:     sy = 1
; samplesrc/rogue.pla: 0366:   fin
	!BYTE	$02			; CN	1
	!BYTE	$76,$0A			; SLW	[10]
_B064 
; samplesrc/rogue.pla: 0367:   if dx > maxview or dy > maxview
; samplesrc/rogue.pla: 0368:     return FALSE
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$2A,$13			; CB	19
	!BYTE	$44			; ISGT
	!BYTE	$AE			; BROR	_B065
	!WORD	_B065-*
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$2A,$13			; CB	19
	!BYTE	$44			; ISGT
_B065 
	!BYTE	$4C			; BRFLS	_B066
	!WORD	_B066-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$18			; LEAVE	24
; samplesrc/rogue.pla: 0369:   fin
_B066 
_B067 
; samplesrc/rogue.pla: 0370:   dx2 = dx << 1
; samplesrc/rogue.pla: 0371:   dy2 = dy << 1
; samplesrc/rogue.pla: 0372:   if dx > dy
; samplesrc/rogue.pla: 0373:     dd2 = dx2 - dy2
; samplesrc/rogue.pla: 0374:     err = dx  - dy2
; samplesrc/rogue.pla: 0375:     while x1 <> x2
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$76,$10			; SLW	[16]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$76,$12			; SLW	[18]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B068
	!WORD	_B068-*
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$84			; SUB 
	!BYTE	$76,$14			; SLW	[20]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$84			; SUB 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$50			; BRNCH	_B072
	!WORD	_B072-*
_B070 
; samplesrc/rogue.pla: 0376:       if err < 0
; samplesrc/rogue.pla: 0377:         y1 = y1 + sy
; samplesrc/rogue.pla: 0378:         err = err + dd2
; samplesrc/rogue.pla: 0379:       else
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B073
	!WORD	_B073-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$B2,$14			; ADDLW	[20]
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$50			; BRNCH	_B074
	!WORD	_B074-*
_B073 
; samplesrc/rogue.pla: 0380:         err = err - dy2
; samplesrc/rogue.pla: 0381:       fin
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$84			; SUB 
	!BYTE	$76,$16			; SLW	[22]
_B074 
; samplesrc/rogue.pla: 0382:       x1 = x1 + sx
; samplesrc/rogue.pla: 0383:       if getmaptile(x1, y1) & OPAQUE_TILE
; samplesrc/rogue.pla: 0384:         return FALSE
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_X031
_F085 	!WORD	0		
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B075
	!WORD	_B075-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$18			; LEAVE	24
; samplesrc/rogue.pla: 0385:       fin
_B075 
_B076 
; samplesrc/rogue.pla: 0386:     loop
_B072 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$24			; BRNE	_B070
	!WORD	_B070-*
_B071 
; samplesrc/rogue.pla: 0387:   else
	!BYTE	$50			; BRNCH	_B069
	!WORD	_B069-*
_B068 
; samplesrc/rogue.pla: 0388:     dd2 = dy2 - dx2
; samplesrc/rogue.pla: 0389:     err = dy  - dx2
; samplesrc/rogue.pla: 0390:     while y1 <> y2
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$84			; SUB 
	!BYTE	$76,$14			; SLW	[20]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$84			; SUB 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
_B077 
; samplesrc/rogue.pla: 0391:       if err < 0
; samplesrc/rogue.pla: 0392:         x1 = x1 + sx
; samplesrc/rogue.pla: 0393:         err = err + dd2
; samplesrc/rogue.pla: 0394:       else
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B080
	!WORD	_B080-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$B2,$14			; ADDLW	[20]
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$50			; BRNCH	_B081
	!WORD	_B081-*
_B080 
; samplesrc/rogue.pla: 0395:         err = err - dx2
; samplesrc/rogue.pla: 0396:       fin
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$84			; SUB 
	!BYTE	$76,$16			; SLW	[22]
_B081 
; samplesrc/rogue.pla: 0397:       y1 = y1 + sy
; samplesrc/rogue.pla: 0398:       if getmaptile(x1, y1) & OPAQUE_TILE
; samplesrc/rogue.pla: 0399:         return FALSE
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_X031
_F086 	!WORD	0		
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B082
	!WORD	_B082-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$18			; LEAVE	24
; samplesrc/rogue.pla: 0400:       fin
_B082 
_B083 
; samplesrc/rogue.pla: 0401:     loop
_B079 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$24			; BRNE	_B077
	!WORD	_B077-*
_B078 
; samplesrc/rogue.pla: 0402:   fin
_B069 
; samplesrc/rogue.pla: 0403:   return TRUE
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$18			; LEAVE	24
; samplesrc/rogue.pla: 0404: end
; samplesrc/rogue.pla: 0405: 
; samplesrc/rogue.pla: 0406: def moveentities(playerisvis)#0
					; playerisvis -> [0]
_C012 					; moveentities()
; samplesrc/rogue.pla: 0407:   byte xmove, ymove
					; xmove -> [2]
					; ymove -> [3]
; samplesrc/rogue.pla: 0408:   word other
					; other -> [4]
; samplesrc/rogue.pla: 0409: 
; samplesrc/rogue.pla: 0410:   other = entities
	!BYTE	$58,$06,$01		; ENTER	6,1
; samplesrc/rogue.pla: 0411:   while other
	!BYTE	$6A			; LAW	_X042+0
_F087 	!WORD	0+0		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B086
	!WORD	_B086-*
_B084 
; samplesrc/rogue.pla: 0412:     if playerisvis
; samplesrc/rogue.pla: 0413:       if lineofsight(player.xpos, player.ypos, other->xpos, other->ypos)
; samplesrc/rogue.pla: 0414:         xmove = other->xpos
; samplesrc/rogue.pla: 0415:         ymove = other->ypos
; samplesrc/rogue.pla: 0416:         if player.xpos > other->xpos
; samplesrc/rogue.pla: 0417:           xmove = other->xpos + 1
; samplesrc/rogue.pla: 0418:         elsif player.xpos < other->xpos
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4C			; BRFLS	_B087
	!WORD	_B087-*
	!BYTE	$68			; LAB	_D049+0
_F088 	!WORD	_D049+0		
	!BYTE	$68			; LAB	_D049+1
_F089 	!WORD	_D049+1		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_C011
_F090 	!WORD	_C011		
	!BYTE	$4C			; BRFLS	_B089
	!WORD	_B089-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$68			; LAB	_D049+0
_F091 	!WORD	_D049+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B091
	!WORD	_B091-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$50			; BRNCH	_B092
	!WORD	_B092-*
_B091 
; samplesrc/rogue.pla: 0419:           xmove = other->xpos - 1
; samplesrc/rogue.pla: 0420:         fin
	!BYTE	$68			; LAB	_D049+0
_F092 	!WORD	_D049+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B093
	!WORD	_B093-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$8E			; DECR
	!BYTE	$74,$02			; SLB	[2]
_B093 
_B092 
; samplesrc/rogue.pla: 0421:         if player.ypos > other->ypos
; samplesrc/rogue.pla: 0422:           ymove = other->ypos + 1
; samplesrc/rogue.pla: 0423:         elsif player.ypos < other->ypos
	!BYTE	$68			; LAB	_D049+1
_F093 	!WORD	_D049+1		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B094
	!WORD	_B094-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$50			; BRNCH	_B095
	!WORD	_B095-*
_B094 
; samplesrc/rogue.pla: 0424:           ymove = other->ypos - 1
; samplesrc/rogue.pla: 0425:         fin
	!BYTE	$68			; LAB	_D049+1
_F094 	!WORD	_D049+1		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B096
	!WORD	_B096-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$8E			; DECR
	!BYTE	$74,$03			; SLB	[3]
_B096 
_B095 
; samplesrc/rogue.pla: 0426:         when getmaptile(xmove, ymove) & MAP_TILE
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$54			; CALL	_X031
_F095 	!WORD	0		
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$52			; SEL
	!WORD	_B098-*
; samplesrc/rogue.pla: 0427:           is FLOOR_TILE
_B099 
; samplesrc/rogue.pla: 0428:           is TORCH_TILE
_B100 
; samplesrc/rogue.pla: 0429:           is KEY_TILE
_B101 
; samplesrc/rogue.pla: 0430:           is GOLD_TILE
_B102 
; samplesrc/rogue.pla: 0431:           is FOOD_TILE
_B103 
; samplesrc/rogue.pla: 0432:             other->xpos = xmove
; samplesrc/rogue.pla: 0433:             other->ypos = ymove
; samplesrc/rogue.pla: 0434:             groan
; samplesrc/rogue.pla: 0435:         wend
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$54			; CALL	_C005
_F096 	!WORD	_C005		
	!BYTE	$50			; BRNCH	_B097
	!WORD	_B097-*
_B098 
	!BYTE	$05			; CASEBLOCK
	!WORD	$0024
	!WORD	_B102-*
	!WORD	$0026
	!WORD	_B103-*
	!WORD	$002A
	!WORD	_B100-*
	!WORD	$002C
	!WORD	_B101-*
	!WORD	$002E
	!WORD	_B099-*
_B097 
; samplesrc/rogue.pla: 0436:       fin
_B089 
_B090 
; samplesrc/rogue.pla: 0437:     fin
_B087 
_B088 
; samplesrc/rogue.pla: 0438:     if other->xpos == player.xpos and other->ypos == player.ypos
; samplesrc/rogue.pla: 0439:       if fight(@player, other)
; samplesrc/rogue.pla: 0440:         //
; samplesrc/rogue.pla: 0441:         // Player trying to run away
; samplesrc/rogue.pla: 0442:         //
; samplesrc/rogue.pla: 0443:         if player.energy > RUN_ENERGY
; samplesrc/rogue.pla: 0444:           moveplayer(1)
; samplesrc/rogue.pla: 0445:         fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$68			; LAB	_D049+0
_F097 	!WORD	_D049+0		
	!BYTE	$40			; ISEQ
	!BYTE	$AC			; BRAND	_B104
	!WORD	_B104-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$68			; LAB	_D049+1
_F098 	!WORD	_D049+1		
	!BYTE	$40			; ISEQ
_B104 
	!BYTE	$4C			; BRFLS	_B105
	!WORD	_B105-*
	!BYTE	$26			; LA	_D049+0
_F099 	!WORD	_D049+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_X040
_F100 	!WORD	0		
	!BYTE	$4C			; BRFLS	_B107
	!WORD	_B107-*
	!BYTE	$68			; LAB	_D049+7
_F101 	!WORD	_D049+7		
	!BYTE	$08			; CN	4
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B109
	!WORD	_B109-*
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C008
_F102 	!WORD	_C008		
_B109 
_B110 
; samplesrc/rogue.pla: 0446:         moveplayer(1)
; samplesrc/rogue.pla: 0447:       fin
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C008
_F103 	!WORD	_C008		
_B107 
_B108 
; samplesrc/rogue.pla: 0448:       return
	!BYTE	$5A,$06			; LEAVE	6
; samplesrc/rogue.pla: 0449:     fin
_B105 
_B106 
; samplesrc/rogue.pla: 0450:     other = other=>next_other
; samplesrc/rogue.pla: 0451:   loop
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
_B086 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$4E			; BRTRU	_B084
	!WORD	_B084-*
_B085 
; samplesrc/rogue.pla: 0452: end
	!BYTE	$5A,$06			; LEAVE	6
; samplesrc/rogue.pla: 0453: 
; samplesrc/rogue.pla: 0454: //
; samplesrc/rogue.pla: 0455: // Draw entire map view
; samplesrc/rogue.pla: 0456: //
; samplesrc/rogue.pla: 0457: 
; samplesrc/rogue.pla: 0458: def drawview#0
_C013 					; drawview()
; samplesrc/rogue.pla: 0459:   totaldarkness = drawmap(player.xpos, player.ypos, player.fov, player.angle, player.lamp, maxview)
; samplesrc/rogue.pla: 0460:   if not totaldarkness
; samplesrc/rogue.pla: 0461:     drawentities
; samplesrc/rogue.pla: 0462:     drawplayer(vplayer[player.angle])
; samplesrc/rogue.pla: 0463:   fin
	!BYTE	$68			; LAB	_D049+0
_F104 	!WORD	_D049+0		
	!BYTE	$68			; LAB	_D049+1
_F105 	!WORD	_D049+1		
	!BYTE	$68			; LAB	_D049+4
_F106 	!WORD	_D049+4		
	!BYTE	$68			; LAB	_D049+2
_F107 	!WORD	_D049+2		
	!BYTE	$68			; LAB	_D049+3
_F108 	!WORD	_D049+3		
	!BYTE	$2A,$13			; CB	19
	!BYTE	$54			; CALL	_X035
_F109 	!WORD	0		
	!BYTE	$7C			; DAB	_D046+0
_F110 	!WORD	_D046+0		
	!BYTE	$4E			; BRTRU	_B111
	!WORD	_B111-*
	!BYTE	$54			; CALL	_C010
_F111 	!WORD	_C010		
	!BYTE	$26			; LA	_D045+0
_F112 	!WORD	_D045+0		
	!BYTE	$B4			; ADDAB	_D049+2
_F113 	!WORD	_D049+2		
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X037
_F114 	!WORD	0		
_B111 
_B112 
; samplesrc/rogue.pla: 0464:   updatescreen
; samplesrc/rogue.pla: 0465: end
	!BYTE	$54			; CALL	_X038
_F115 	!WORD	0		
	!BYTE	$5C			; RET
; samplesrc/rogue.pla: 0466: 
; samplesrc/rogue.pla: 0467: //
; samplesrc/rogue.pla: 0468: // Read player input and do something
; samplesrc/rogue.pla: 0469: //
; samplesrc/rogue.pla: 0470: 
; samplesrc/rogue.pla: 0471: def waitkey
_C014 					; waitkey()
; samplesrc/rogue.pla: 0472:   word delay
					; delay -> [0]
; samplesrc/rogue.pla: 0473: 
; samplesrc/rogue.pla: 0474:   delay = 200
	!BYTE	$58,$02,$00		; ENTER	2,0
; samplesrc/rogue.pla: 0475:   while not conio:keypressed()
	!BYTE	$2A,$C8			; CB	200
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B115
	!WORD	_B115-*
_B113 
; samplesrc/rogue.pla: 0476:     delay--
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8E			; DECR
; samplesrc/rogue.pla: 0477:     if delay == 0
; samplesrc/rogue.pla: 0478:       drawview
; samplesrc/rogue.pla: 0479:       delay = 200
; samplesrc/rogue.pla: 0480:     fin
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4E			; BRTRU	_B116
	!WORD	_B116-*
	!BYTE	$54			; CALL	_C013
_F116 	!WORD	_C013		
	!BYTE	$2A,$C8			; CB	200
	!BYTE	$76,$00			; SLW	[0]
_B116 
_B117 
; samplesrc/rogue.pla: 0481:   loop
_B115 
	!BYTE	$6A			; LAW	_X028+0
_F117 	!WORD	0+0		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B113
	!WORD	_B113-*
_B114 
; samplesrc/rogue.pla: 0482:   return toupper(conio:getkey())
	!BYTE	$6A			; LAW	_X028+2
_F118 	!WORD	0+2		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_X021
_F119 	!WORD	0		
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rogue.pla: 0483: end
; samplesrc/rogue.pla: 0484: 
; samplesrc/rogue.pla: 0485: def play
_C015 					; play()
; samplesrc/rogue.pla: 0486:   byte xt, yt
					; xt -> [0]
					; yt -> [1]
; samplesrc/rogue.pla: 0487: 
; samplesrc/rogue.pla: 0488:   if player.health == 0
	!BYTE	$58,$02,$00		; ENTER	2,0
; samplesrc/rogue.pla: 0489:     return FALSE
	!BYTE	$68			; LAB	_D049+6
_F120 	!WORD	_D049+6		
	!BYTE	$4E			; BRTRU	_B118
	!WORD	_B118-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rogue.pla: 0490:   fin
_B118 
_B119 
; samplesrc/rogue.pla: 0491:   conio:gotoxy(xcentr, ycentr)
; samplesrc/rogue.pla: 0492:   when waitkey
	!BYTE	$2A,$14			; CB	20
	!BYTE	$18			; CN	12
	!BYTE	$6A			; LAW	_X028+8
_F121 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C014
_F122 	!WORD	_C014		
	!BYTE	$52			; SEL
	!WORD	_B121-*
; samplesrc/rogue.pla: 0493:     is 'I'
_B122 
; samplesrc/rogue.pla: 0494:       if totaldarkness
; samplesrc/rogue.pla: 0495:         player.angle = conio:rnd() & 7
; samplesrc/rogue.pla: 0496:       else
	!BYTE	$68			; LAB	_D046+0
_F123 	!WORD	_D046+0		
	!BYTE	$4C			; BRFLS	_B123
	!WORD	_B123-*
	!BYTE	$6A			; LAW	_X028+24
_F124 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$78			; SAB	_D049+2
_F125 	!WORD	_D049+2		
	!BYTE	$50			; BRNCH	_B124
	!WORD	_B124-*
_B123 
; samplesrc/rogue.pla: 0497:         player.angle = 0
; samplesrc/rogue.pla: 0498:       fin
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D049+2
_F126 	!WORD	_D049+2		
_B124 
; samplesrc/rogue.pla: 0499:       moveplayer(1)
; samplesrc/rogue.pla: 0500:       break
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C008
_F127 	!WORD	_C008		
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
; samplesrc/rogue.pla: 0501:     is 'J'
_B125 
; samplesrc/rogue.pla: 0502:       if totaldarkness
; samplesrc/rogue.pla: 0503:         player.angle = conio:rnd() & 7
; samplesrc/rogue.pla: 0504:       else
	!BYTE	$68			; LAB	_D046+0
_F128 	!WORD	_D046+0		
	!BYTE	$4C			; BRFLS	_B126
	!WORD	_B126-*
	!BYTE	$6A			; LAW	_X028+24
_F129 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$78			; SAB	_D049+2
_F130 	!WORD	_D049+2		
	!BYTE	$50			; BRNCH	_B127
	!WORD	_B127-*
_B126 
; samplesrc/rogue.pla: 0505:         player.angle = 6
; samplesrc/rogue.pla: 0506:       fin
	!BYTE	$0C			; CN	6
	!BYTE	$78			; SAB	_D049+2
_F131 	!WORD	_D049+2		
_B127 
; samplesrc/rogue.pla: 0507:       moveplayer(1)
; samplesrc/rogue.pla: 0508:       break
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C008
_F132 	!WORD	_C008		
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
; samplesrc/rogue.pla: 0509:     is 'K'
_B128 
; samplesrc/rogue.pla: 0510:       if totaldarkness
; samplesrc/rogue.pla: 0511:         player.angle = conio:rnd() & 7
; samplesrc/rogue.pla: 0512:       else
	!BYTE	$68			; LAB	_D046+0
_F133 	!WORD	_D046+0		
	!BYTE	$4C			; BRFLS	_B129
	!WORD	_B129-*
	!BYTE	$6A			; LAW	_X028+24
_F134 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$78			; SAB	_D049+2
_F135 	!WORD	_D049+2		
	!BYTE	$50			; BRNCH	_B130
	!WORD	_B130-*
_B129 
; samplesrc/rogue.pla: 0513:         player.angle = 2
; samplesrc/rogue.pla: 0514:       fin
	!BYTE	$04			; CN	2
	!BYTE	$78			; SAB	_D049+2
_F136 	!WORD	_D049+2		
_B130 
; samplesrc/rogue.pla: 0515:       moveplayer(1)
; samplesrc/rogue.pla: 0516:       break
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C008
_F137 	!WORD	_C008		
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
; samplesrc/rogue.pla: 0517:     is 'M'
_B131 
; samplesrc/rogue.pla: 0518:       if totaldarkness
; samplesrc/rogue.pla: 0519:         player.angle = conio:rnd() & 7
; samplesrc/rogue.pla: 0520:       else
	!BYTE	$68			; LAB	_D046+0
_F138 	!WORD	_D046+0		
	!BYTE	$4C			; BRFLS	_B132
	!WORD	_B132-*
	!BYTE	$6A			; LAW	_X028+24
_F139 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$78			; SAB	_D049+2
_F140 	!WORD	_D049+2		
	!BYTE	$50			; BRNCH	_B133
	!WORD	_B133-*
_B132 
; samplesrc/rogue.pla: 0521:         player.angle = 4
; samplesrc/rogue.pla: 0522:       fin
	!BYTE	$08			; CN	4
	!BYTE	$78			; SAB	_D049+2
_F141 	!WORD	_D049+2		
_B133 
; samplesrc/rogue.pla: 0523:       moveplayer(1)
; samplesrc/rogue.pla: 0524:       break
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C008
_F142 	!WORD	_C008		
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
; samplesrc/rogue.pla: 0525:     is 'Q'
_B134 
; samplesrc/rogue.pla: 0526:       if player.energy > RUN_ENERGY
; samplesrc/rogue.pla: 0527:         player.energy = player.energy - RUN_ENERGY
; samplesrc/rogue.pla: 0528:         moveplayer(1)
; samplesrc/rogue.pla: 0529:       fin
	!BYTE	$68			; LAB	_D049+7
_F143 	!WORD	_D049+7		
	!BYTE	$08			; CN	4
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B135
	!WORD	_B135-*
	!BYTE	$68			; LAB	_D049+7
_F144 	!WORD	_D049+7		
	!BYTE	$3A,$04			; SUBI	4
	!BYTE	$78			; SAB	_D049+7
_F145 	!WORD	_D049+7		
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C008
_F146 	!WORD	_C008		
_B135 
_B136 
; samplesrc/rogue.pla: 0530:     is 'W'
_B137 
; samplesrc/rogue.pla: 0531:     is $0B // Up Arrow
_B138 
; samplesrc/rogue.pla: 0532:       moveplayer(1)
; samplesrc/rogue.pla: 0533:       break
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C008
_F147 	!WORD	_C008		
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
; samplesrc/rogue.pla: 0534:     is 'S'
_B139 
; samplesrc/rogue.pla: 0535:     is $0A // Down Arrow
_B140 
; samplesrc/rogue.pla: 0536:       moveplayer(-1)
; samplesrc/rogue.pla: 0537:       break
	!BYTE	$20			; MINUS ONE
	!BYTE	$54			; CALL	_C008
_F148 	!WORD	_C008		
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
; samplesrc/rogue.pla: 0538:     is 'A'
_B141 
; samplesrc/rogue.pla: 0539:     is $08 // Left Arrow
_B142 
; samplesrc/rogue.pla: 0540:       player.angle = (player.angle - 1) & 7
; samplesrc/rogue.pla: 0541:       break
	!BYTE	$68			; LAB	_D049+2
_F149 	!WORD	_D049+2		
	!BYTE	$8E			; DECR
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$78			; SAB	_D049+2
_F150 	!WORD	_D049+2		
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
; samplesrc/rogue.pla: 0542:     is 'D'
_B143 
; samplesrc/rogue.pla: 0543:     is $15 // Right Arrow
_B144 
; samplesrc/rogue.pla: 0544:       player.angle = (player.angle + 1) & 7
; samplesrc/rogue.pla: 0545:       break
	!BYTE	$68			; LAB	_D049+2
_F151 	!WORD	_D049+2		
	!BYTE	$8C			; INCR
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$78			; SAB	_D049+2
_F152 	!WORD	_D049+2		
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
; samplesrc/rogue.pla: 0546:     is ' '
_B145 
; samplesrc/rogue.pla: 0547:       when getmaptile(player.xpos + xdir[player.angle], player.ypos + ydir[player.angle]) & MAP_TILE
	!BYTE	$68			; LAB	_D049+0
_F153 	!WORD	_D049+0		
	!BYTE	$26			; LA	_D043+0
_F154 	!WORD	_D043+0		
	!BYTE	$BC			; IDXAB	_D049+2
_F155 	!WORD	_D049+2		
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$68			; LAB	_D049+1
_F156 	!WORD	_D049+1		
	!BYTE	$26			; LA	_D044+0
_F157 	!WORD	_D044+0		
	!BYTE	$BC			; IDXAB	_D049+2
_F158 	!WORD	_D049+2		
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X031
_F159 	!WORD	0		
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$52			; SEL
	!WORD	_B147-*
; samplesrc/rogue.pla: 0548:         is LOCKED_TILE
_B148 
; samplesrc/rogue.pla: 0549:           if not player.key
; samplesrc/rogue.pla: 0550:             ouch
; samplesrc/rogue.pla: 0551:             break
	!BYTE	$68			; LAB	_D049+11
_F160 	!WORD	_D049+11		
	!BYTE	$4E			; BRTRU	_B149
	!WORD	_B149-*
	!BYTE	$54			; CALL	_C001
_F161 	!WORD	_C001		
	!BYTE	$50			; BRNCH	_B146
	!WORD	_B146-*
; samplesrc/rogue.pla: 0552:           fin
_B149 
_B150 
; samplesrc/rogue.pla: 0553:         is DOOR_TILE
_B151 
; samplesrc/rogue.pla: 0554:           updtmaptile(player.xpos + xdir[player.angle], player.ypos + ydir[player.angle], FLOOR_TILE)
; samplesrc/rogue.pla: 0555:       break
	!BYTE	$68			; LAB	_D049+0
_F162 	!WORD	_D049+0		
	!BYTE	$26			; LA	_D043+0
_F163 	!WORD	_D043+0		
	!BYTE	$BC			; IDXAB	_D049+2
_F164 	!WORD	_D049+2		
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$68			; LAB	_D049+1
_F165 	!WORD	_D049+1		
	!BYTE	$26			; LA	_D044+0
_F166 	!WORD	_D044+0		
	!BYTE	$BC			; IDXAB	_D049+2
_F167 	!WORD	_D049+2		
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X033
_F168 	!WORD	0		
	!BYTE	$50			; BRNCH	_B146
	!WORD	_B146-*
; samplesrc/rogue.pla: 0556:     is ENTER_TILE
_B152 
; samplesrc/rogue.pla: 0557:       break
	!BYTE	$50			; BRNCH	_B146
	!WORD	_B146-*
; samplesrc/rogue.pla: 0558:     is EXIT_TILE
_B153 
; samplesrc/rogue.pla: 0559:       return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rogue.pla: 0560:       wend
	!BYTE	$50			; BRNCH	_B146
	!WORD	_B146-*
_B147 
	!BYTE	$04			; CASEBLOCK
	!WORD	$0025
	!WORD	_B148-*
	!WORD	$002B
	!WORD	_B151-*
	!WORD	$002D
	!WORD	_B152-*
	!WORD	$003D
	!WORD	_B153-*
_B146 
; samplesrc/rogue.pla: 0561:       break
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
; samplesrc/rogue.pla: 0562:     is $0D // Return
_B154 
; samplesrc/rogue.pla: 0563:       when getmaptile(player.xpos, player.ypos) & MAP_TILE
	!BYTE	$68			; LAB	_D049+0
_F169 	!WORD	_D049+0		
	!BYTE	$68			; LAB	_D049+1
_F170 	!WORD	_D049+1		
	!BYTE	$54			; CALL	_X031
_F171 	!WORD	0		
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$52			; SEL
	!WORD	_B156-*
; samplesrc/rogue.pla: 0564:         is KEY_TILE
_B157 
; samplesrc/rogue.pla: 0565:           player.key = 1
; samplesrc/rogue.pla: 0566:           updtmaptile(player.xpos, player.ypos, FLOOR_TILE)
; samplesrc/rogue.pla: 0567:           gotit
; samplesrc/rogue.pla: 0568:           break
	!BYTE	$02			; CN	1
	!BYTE	$78			; SAB	_D049+11
_F172 	!WORD	_D049+11		
	!BYTE	$68			; LAB	_D049+0
_F173 	!WORD	_D049+0		
	!BYTE	$68			; LAB	_D049+1
_F174 	!WORD	_D049+1		
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X033
_F175 	!WORD	0		
	!BYTE	$54			; CALL	_C002
_F176 	!WORD	_C002		
	!BYTE	$50			; BRNCH	_B155
	!WORD	_B155-*
; samplesrc/rogue.pla: 0569:         is RAFT_TILE
_B158 
; samplesrc/rogue.pla: 0570:           player.raft = 1
; samplesrc/rogue.pla: 0571:           updtmaptile(player.xpos, player.ypos, FLOOR_TILE)
; samplesrc/rogue.pla: 0572:           gotit
; samplesrc/rogue.pla: 0573:           break
	!BYTE	$02			; CN	1
	!BYTE	$78			; SAB	_D049+12
_F177 	!WORD	_D049+12		
	!BYTE	$68			; LAB	_D049+0
_F178 	!WORD	_D049+0		
	!BYTE	$68			; LAB	_D049+1
_F179 	!WORD	_D049+1		
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X033
_F180 	!WORD	0		
	!BYTE	$54			; CALL	_C002
_F181 	!WORD	_C002		
	!BYTE	$50			; BRNCH	_B155
	!WORD	_B155-*
; samplesrc/rogue.pla: 0574:         is GOLD_TILE
_B159 
; samplesrc/rogue.pla: 0575:           player.gold = player.gold + 1
; samplesrc/rogue.pla: 0576:           updtmaptile(player.xpos, player.ypos, FLOOR_TILE)
; samplesrc/rogue.pla: 0577:           gotit
; samplesrc/rogue.pla: 0578:           break
	!BYTE	$68			; LAB	_D049+10
_F182 	!WORD	_D049+10		
	!BYTE	$8C			; INCR
	!BYTE	$78			; SAB	_D049+10
_F183 	!WORD	_D049+10		
	!BYTE	$68			; LAB	_D049+0
_F184 	!WORD	_D049+0		
	!BYTE	$68			; LAB	_D049+1
_F185 	!WORD	_D049+1		
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X033
_F186 	!WORD	0		
	!BYTE	$54			; CALL	_C002
_F187 	!WORD	_C002		
	!BYTE	$50			; BRNCH	_B155
	!WORD	_B155-*
; samplesrc/rogue.pla: 0579:         is TORCH_TILE
_B160 
; samplesrc/rogue.pla: 0580:           if player.oil < 1000
; samplesrc/rogue.pla: 0581:             player:oil = player:oil + TORCH_OIL
; samplesrc/rogue.pla: 0582:             if player:oil > 1000
; samplesrc/rogue.pla: 0583:               player:oil = 1000
; samplesrc/rogue.pla: 0584:             fin
	!BYTE	$68			; LAB	_D049+8
_F188 	!WORD	_D049+8		
	!BYTE	$2C,$E8,$03		; CW	1000
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B161
	!WORD	_B161-*
	!BYTE	$6A			; LAW	_D049+8
_F189 	!WORD	_D049+8		
	!BYTE	$38,$FA			; ADDI	250
	!BYTE	$7E			; DAW	_D049+8
_F190 	!WORD	_D049+8		
	!BYTE	$2C,$E8,$03		; CW	1000
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B163
	!WORD	_B163-*
	!BYTE	$2C,$E8,$03		; CW	1000
	!BYTE	$7A			; SAW	_D049+8
_F191 	!WORD	_D049+8		
_B163 
_B164 
; samplesrc/rogue.pla: 0585:             setmaptile(player.xpos, player.ypos, FLOOR_TILE)
; samplesrc/rogue.pla: 0586:             for yt = player.ypos - 1 to player.ypos + 1
	!BYTE	$68			; LAB	_D049+0
_F192 	!WORD	_D049+0		
	!BYTE	$68			; LAB	_D049+1
_F193 	!WORD	_D049+1		
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X032
_F194 	!WORD	0		
	!BYTE	$68			; LAB	_D049+1
_F195 	!WORD	_D049+1		
	!BYTE	$8C			; INCR
	!BYTE	$68			; LAB	_D049+1
_F196 	!WORD	_D049+1		
	!BYTE	$8E			; DECR
	!BYTE	$A0			; BRGT	_B165
	!WORD	_B165-*
_B166 
	!BYTE	$6C,$01			; DLB	[1]
; samplesrc/rogue.pla: 0587:               for xt = player.xpos - 1 to player.xpos + 1
	!BYTE	$68			; LAB	_D049+0
_F197 	!WORD	_D049+0		
	!BYTE	$8C			; INCR
	!BYTE	$68			; LAB	_D049+0
_F198 	!WORD	_D049+0		
	!BYTE	$8E			; DECR
	!BYTE	$A0			; BRGT	_B168
	!WORD	_B168-*
_B169 
	!BYTE	$6C,$00			; DLB	[0]
; samplesrc/rogue.pla: 0588:                 setmaptile(xt, yt, getmaptile(xt, yt) & MAP_TILE)
; samplesrc/rogue.pla: 0589:               next
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$54			; CALL	_X031
_F199 	!WORD	0		
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$54			; CALL	_X032
_F200 	!WORD	0		
_B170 
	!BYTE	$A4			; INCBRLE	_B169
	!WORD	_B169-*
_B168 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; samplesrc/rogue.pla: 0590:             next
_B167 
	!BYTE	$A4			; INCBRLE	_B166
	!WORD	_B166-*
_B165 
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$30			; DROP 
; samplesrc/rogue.pla: 0591:             gotit
; samplesrc/rogue.pla: 0592:           fin
	!BYTE	$54			; CALL	_C002
_F201 	!WORD	_C002		
_B161 
_B162 
; samplesrc/rogue.pla: 0593:           break
	!BYTE	$50			; BRNCH	_B155
	!WORD	_B155-*
; samplesrc/rogue.pla: 0594:         is FOOD_TILE
_B171 
; samplesrc/rogue.pla: 0595:           if player.health < 100 or player.energy < 100
; samplesrc/rogue.pla: 0596:             player.health = player.health + MANA/2
; samplesrc/rogue.pla: 0597:             if player.health > 100
; samplesrc/rogue.pla: 0598:               player.health = 100
; samplesrc/rogue.pla: 0599:             fin
	!BYTE	$68			; LAB	_D049+6
_F202 	!WORD	_D049+6		
	!BYTE	$2A,$64			; CB	100
	!BYTE	$46			; ISLT
	!BYTE	$AE			; BROR	_B172
	!WORD	_B172-*
	!BYTE	$68			; LAB	_D049+7
_F203 	!WORD	_D049+7		
	!BYTE	$2A,$64			; CB	100
	!BYTE	$46			; ISLT
_B172 
	!BYTE	$4C			; BRFLS	_B173
	!WORD	_B173-*
	!BYTE	$68			; LAB	_D049+6
_F204 	!WORD	_D049+6		
	!BYTE	$38,$19			; ADDI	25
	!BYTE	$7C			; DAB	_D049+6
_F205 	!WORD	_D049+6		
	!BYTE	$2A,$64			; CB	100
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B175
	!WORD	_B175-*
	!BYTE	$2A,$64			; CB	100
	!BYTE	$78			; SAB	_D049+6
_F206 	!WORD	_D049+6		
_B175 
_B176 
; samplesrc/rogue.pla: 0600:             player.energy = player.energy + MANA
; samplesrc/rogue.pla: 0601:             if player.energy > 100
; samplesrc/rogue.pla: 0602:               player.energy = 100
; samplesrc/rogue.pla: 0603:             fin
	!BYTE	$68			; LAB	_D049+7
_F207 	!WORD	_D049+7		
	!BYTE	$38,$32			; ADDI	50
	!BYTE	$7C			; DAB	_D049+7
_F208 	!WORD	_D049+7		
	!BYTE	$2A,$64			; CB	100
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B177
	!WORD	_B177-*
	!BYTE	$2A,$64			; CB	100
	!BYTE	$78			; SAB	_D049+7
_F209 	!WORD	_D049+7		
_B177 
_B178 
; samplesrc/rogue.pla: 0604:             updtmaptile(player.xpos, player.ypos, FLOOR_TILE)
; samplesrc/rogue.pla: 0605:             player.fov = 1
; samplesrc/rogue.pla: 0606:             gotit
; samplesrc/rogue.pla: 0607:           fin
	!BYTE	$68			; LAB	_D049+0
_F210 	!WORD	_D049+0		
	!BYTE	$68			; LAB	_D049+1
_F211 	!WORD	_D049+1		
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X033
_F212 	!WORD	0		
	!BYTE	$02			; CN	1
	!BYTE	$78			; SAB	_D049+4
_F213 	!WORD	_D049+4		
	!BYTE	$54			; CALL	_C002
_F214 	!WORD	_C002		
_B173 
_B174 
; samplesrc/rogue.pla: 0608:           break
	!BYTE	$50			; BRNCH	_B155
	!WORD	_B155-*
; samplesrc/rogue.pla: 0609:       wend
	!BYTE	$50			; BRNCH	_B155
	!WORD	_B155-*
_B156 
	!BYTE	$05			; CASEBLOCK
	!WORD	$0024
	!WORD	_B159-*
	!WORD	$0026
	!WORD	_B171-*
	!WORD	$002A
	!WORD	_B160-*
	!WORD	$002C
	!WORD	_B157-*
	!WORD	$0040
	!WORD	_B158-*
_B155 
; samplesrc/rogue.pla: 0610:       break
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
; samplesrc/rogue.pla: 0611:     is 'O'
_B179 
; samplesrc/rogue.pla: 0612:       player.lamp = 0
; samplesrc/rogue.pla: 0613:       break
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D049+3
_F215 	!WORD	_D049+3		
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
; samplesrc/rogue.pla: 0614:     is '<'
_B180 
; samplesrc/rogue.pla: 0615:     is ','
_B181 
; samplesrc/rogue.pla: 0616:       if player.lamp > 0
; samplesrc/rogue.pla: 0617:         player.lamp = player.lamp - 1
; samplesrc/rogue.pla: 0618:       fin
	!BYTE	$68			; LAB	_D049+3
_F216 	!WORD	_D049+3		
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B182
	!WORD	_B182-*
	!BYTE	$68			; LAB	_D049+3
_F217 	!WORD	_D049+3		
	!BYTE	$8E			; DECR
	!BYTE	$78			; SAB	_D049+3
_F218 	!WORD	_D049+3		
_B182 
_B183 
; samplesrc/rogue.pla: 0619:       break
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
; samplesrc/rogue.pla: 0620:     is '>'
_B184 
; samplesrc/rogue.pla: 0621:     is '.'
_B185 
; samplesrc/rogue.pla: 0622:       if player.lamp < maxlight - 1
; samplesrc/rogue.pla: 0623:         player.lamp = player.lamp + 1
; samplesrc/rogue.pla: 0624:       fin
	!BYTE	$68			; LAB	_D049+3
_F219 	!WORD	_D049+3		
	!BYTE	$12			; CN	9
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B186
	!WORD	_B186-*
	!BYTE	$68			; LAB	_D049+3
_F220 	!WORD	_D049+3		
	!BYTE	$8C			; INCR
	!BYTE	$78			; SAB	_D049+3
_F221 	!WORD	_D049+3		
_B186 
_B187 
; samplesrc/rogue.pla: 0625:       break
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
; samplesrc/rogue.pla: 0626:     is 'X'
_B188 
; samplesrc/rogue.pla: 0627:       clearstatus
; samplesrc/rogue.pla: 0628:       conio:gotoxy(0, statusline)
; samplesrc/rogue.pla: 0629:       puts(@quitstr)
; samplesrc/rogue.pla: 0630:       if toupper(conio:getkey()) == 'Y'
; samplesrc/rogue.pla: 0631:         player.health = 0
; samplesrc/rogue.pla: 0632:     return FALSE
	!BYTE	$54			; CALL	_C007
_F222 	!WORD	_C007		
	!BYTE	$00			; CN	0
	!BYTE	$2A,$17			; CB	23
	!BYTE	$6A			; LAW	_X028+8
_F223 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D060+0
_F224 	!WORD	_D060+0		
	!BYTE	$54			; CALL	_X004
_F225 	!WORD	0		
	!BYTE	$6A			; LAW	_X028+2
_F226 	!WORD	0+2		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_X021
_F227 	!WORD	0		
	!BYTE	$2A,$59			; CB	89
	!BYTE	$24			; BRNE	_B189
	!WORD	_B189-*
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D049+6
_F228 	!WORD	_D049+6		
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rogue.pla: 0633:       fin
_B189 
_B190 
; samplesrc/rogue.pla: 0634:   wend
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
_B121 
	!BYTE	$15			; CASEBLOCK
	!WORD	$0008
	!WORD	_B142-*
	!WORD	$000A
	!WORD	_B140-*
	!WORD	$000B
	!WORD	_B138-*
	!WORD	$000D
	!WORD	_B154-*
	!WORD	$0015
	!WORD	_B144-*
	!WORD	$0020
	!WORD	_B145-*
	!WORD	$002C
	!WORD	_B181-*
	!WORD	$002E
	!WORD	_B185-*
	!WORD	$003C
	!WORD	_B180-*
	!WORD	$003E
	!WORD	_B184-*
	!WORD	$0041
	!WORD	_B141-*
	!WORD	$0044
	!WORD	_B143-*
	!WORD	$0049
	!WORD	_B122-*
	!WORD	$004A
	!WORD	_B125-*
	!WORD	$004B
	!WORD	_B128-*
	!WORD	$004D
	!WORD	_B131-*
	!WORD	$004F
	!WORD	_B179-*
	!WORD	$0051
	!WORD	_B134-*
	!WORD	$0053
	!WORD	_B139-*
	!WORD	$0057
	!WORD	_B137-*
	!WORD	$0058
	!WORD	_B188-*
_B120 
; samplesrc/rogue.pla: 0635:   if player.energy and player.health < 100
; samplesrc/rogue.pla: 0636:     player.health = player.health + 1
; samplesrc/rogue.pla: 0637:   fin
	!BYTE	$68			; LAB	_D049+7
_F229 	!WORD	_D049+7		
	!BYTE	$AC			; BRAND	_B191
	!WORD	_B191-*
	!BYTE	$68			; LAB	_D049+6
_F230 	!WORD	_D049+6		
	!BYTE	$2A,$64			; CB	100
	!BYTE	$46			; ISLT
_B191 
	!BYTE	$4C			; BRFLS	_B192
	!WORD	_B192-*
	!BYTE	$68			; LAB	_D049+6
_F231 	!WORD	_D049+6		
	!BYTE	$8C			; INCR
	!BYTE	$78			; SAB	_D049+6
_F232 	!WORD	_D049+6		
_B192 
_B193 
; samplesrc/rogue.pla: 0638:   if player:oil > player.lamp
; samplesrc/rogue.pla: 0639:     player:oil = player:oil - player.lamp
; samplesrc/rogue.pla: 0640:   else
	!BYTE	$6A			; LAW	_D049+8
_F233 	!WORD	_D049+8		
	!BYTE	$68			; LAB	_D049+3
_F234 	!WORD	_D049+3		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B194
	!WORD	_B194-*
	!BYTE	$6A			; LAW	_D049+8
_F235 	!WORD	_D049+8		
	!BYTE	$68			; LAB	_D049+3
_F236 	!WORD	_D049+3		
	!BYTE	$84			; SUB 
	!BYTE	$7A			; SAW	_D049+8
_F237 	!WORD	_D049+8		
	!BYTE	$50			; BRNCH	_B195
	!WORD	_B195-*
_B194 
; samplesrc/rogue.pla: 0641:     player:oil  = 0
; samplesrc/rogue.pla: 0642:     player.lamp = 0
; samplesrc/rogue.pla: 0643:   fin
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D049+8
_F238 	!WORD	_D049+8		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D049+3
_F239 	!WORD	_D049+3		
_B195 
; samplesrc/rogue.pla: 0644:   return player.health
	!BYTE	$68			; LAB	_D049+6
_F240 	!WORD	_D049+6		
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rogue.pla: 0645: end
; samplesrc/rogue.pla: 0646: 
; samplesrc/rogue.pla: 0647: //
; samplesrc/rogue.pla: 0648: // Main loop
; samplesrc/rogue.pla: 0649: //
; samplesrc/rogue.pla: 0650: 
; samplesrc/rogue.pla: 0651: puts(@namestr)
_INIT 
; samplesrc/rogue.pla: 0652: instr = gets($BA)
; samplesrc/rogue.pla: 0653: if ^instr > 15
; samplesrc/rogue.pla: 0654:   ^instr = 15
; samplesrc/rogue.pla: 0655: fin
	!BYTE	$26			; LA	_D058+0
_F241 	!WORD	_D058+0		
	!BYTE	$54			; CALL	_X004
_F242 	!WORD	0		
	!BYTE	$2A,$BA			; CB	186
	!BYTE	$54			; CALL	_X007
_F243 	!WORD	0		
	!BYTE	$7A			; SAW	_D057+0
_F244 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D057+0
_F245 	!WORD	_D057+0		
	!BYTE	$60			; LB
	!BYTE	$1E			; CN	15
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B196
	!WORD	_B196-*
	!BYTE	$1E			; CN	15
	!BYTE	$6A			; LAW	_D057+0
_F246 	!WORD	_D057+0		
	!BYTE	$70			; SB
_B196 
_B197 
; samplesrc/rogue.pla: 0656: memcpy(@player.name, instr, ^instr + 1)
; samplesrc/rogue.pla: 0657: conio:echo(ECHO_OFF)
; samplesrc/rogue.pla: 0658: while loadmap(level)
	!BYTE	$26			; LA	_D049+13
_F247 	!WORD	_D049+13		
	!BYTE	$6A			; LAW	_D057+0
_F248 	!WORD	_D057+0		
	!BYTE	$34			; DUP
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_X018
_F249 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X028+4
_F250 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B200
	!WORD	_B200-*
_B198 
; samplesrc/rogue.pla: 0659:   puts(@prepstr)
; samplesrc/rogue.pla: 0660:   free_entities = heapmark()
; samplesrc/rogue.pla: 0661:   findentities
; samplesrc/rogue.pla: 0662:   lighttorches
; samplesrc/rogue.pla: 0663:   repeat
	!BYTE	$26			; LA	_D059+0
_F251 	!WORD	_D059+0		
	!BYTE	$54			; CALL	_X004
_F252 	!WORD	0		
	!BYTE	$54			; CALL	_X012
_F253 	!WORD	0		
	!BYTE	$7A			; SAW	_D048+0
_F254 	!WORD	_D048+0		
	!BYTE	$54			; CALL	_C009
_F255 	!WORD	_C009		
	!BYTE	$54			; CALL	_X034
_F256 	!WORD	0		
_B202 
; samplesrc/rogue.pla: 0664:     moveentities(player.lamp or getmaptile(player.xpos, player.ypos) & LIT_TILE))
; samplesrc/rogue.pla: 0665:     drawview
; samplesrc/rogue.pla: 0666:     status
; samplesrc/rogue.pla: 0667:   until not play
	!BYTE	$68			; LAB	_D049+3
_F257 	!WORD	_D049+3		
	!BYTE	$AE			; BROR	_B205
	!WORD	_B205-*
	!BYTE	$68			; LAB	_D049+0
_F258 	!WORD	_D049+0		
	!BYTE	$68			; LAB	_D049+1
_F259 	!WORD	_D049+1		
	!BYTE	$54			; CALL	_X031
_F260 	!WORD	0		
	!BYTE	$3C,$80			; ANDI	128
_B205 
	!BYTE	$54			; CALL	_C012
_F261 	!WORD	_C012		
	!BYTE	$54			; CALL	_C013
_F262 	!WORD	_C013		
	!BYTE	$54			; CALL	_C006
_F263 	!WORD	_C006		
_B203 
	!BYTE	$54			; CALL	_C015
_F264 	!WORD	_C015		
	!BYTE	$4E			; BRTRU	_B202
	!WORD	_B202-*
_B201 
; samplesrc/rogue.pla: 0668:   heaprelease(free_entities)
; samplesrc/rogue.pla: 0669:   entities = 0
; samplesrc/rogue.pla: 0670:   player.key = 0
; samplesrc/rogue.pla: 0671:   level = level + 1
; samplesrc/rogue.pla: 0672:   clearstatus
; samplesrc/rogue.pla: 0673:   conio:gotoxy(0, statusline)
; samplesrc/rogue.pla: 0674:   if player.health == 0
; samplesrc/rogue.pla: 0675:     break
	!BYTE	$6A			; LAW	_D048+0
_F265 	!WORD	_D048+0		
	!BYTE	$54			; CALL	_X015
_F266 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_X042+0
_F267 	!WORD	0+0		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D049+11
_F268 	!WORD	_D049+11		
	!BYTE	$68			; LAB	_D047+0
_F269 	!WORD	_D047+0		
	!BYTE	$8C			; INCR
	!BYTE	$78			; SAB	_D047+0
_F270 	!WORD	_D047+0		
	!BYTE	$54			; CALL	_C007
_F271 	!WORD	_C007		
	!BYTE	$00			; CN	0
	!BYTE	$2A,$17			; CB	23
	!BYTE	$6A			; LAW	_X028+8
_F272 	!WORD	0+8		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$68			; LAB	_D049+6
_F273 	!WORD	_D049+6		
	!BYTE	$4E			; BRTRU	_B206
	!WORD	_B206-*
	!BYTE	$50			; BRNCH	_B199
	!WORD	_B199-*
; samplesrc/rogue.pla: 0676:   fin
_B206 
_B207 
; samplesrc/rogue.pla: 0677: loop
_B200 
	!BYTE	$68			; LAB	_D047+0
_F274 	!WORD	_D047+0		
	!BYTE	$54			; CALL	_X030
_F275 	!WORD	0		
	!BYTE	$4E			; BRTRU	_B198
	!WORD	_B198-*
_B199 
; samplesrc/rogue.pla: 0678: conio:echo(ECHO_ON)
; samplesrc/rogue.pla: 0679: if player.health > 0
; samplesrc/rogue.pla: 0680:   puts(@youmadeitstr)
; samplesrc/rogue.pla: 0681:   puti(player.gold)
; samplesrc/rogue.pla: 0682: else
	!BYTE	$2A,$80			; CB	128
	!BYTE	$6A			; LAW	_X028+4
_F276 	!WORD	0+4		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$68			; LAB	_D049+6
_F277 	!WORD	_D049+6		
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B208
	!WORD	_B208-*
	!BYTE	$26			; LA	_D061+0
_F278 	!WORD	_D061+0		
	!BYTE	$54			; CALL	_X004
_F279 	!WORD	0		
	!BYTE	$68			; LAB	_D049+10
_F280 	!WORD	_D049+10		
	!BYTE	$54			; CALL	_X005
_F281 	!WORD	0		
	!BYTE	$50			; BRNCH	_B209
	!WORD	_B209-*
_B208 
; samplesrc/rogue.pla: 0683:   puts(@youdiedstr)
; samplesrc/rogue.pla: 0684: fin
	!BYTE	$26			; LA	_D062+0
_F282 	!WORD	_D062+0		
	!BYTE	$54			; CALL	_X004
_F283 	!WORD	0		
_B209 
; samplesrc/rogue.pla: 0685: puts(@againstr)
; samplesrc/rogue.pla: 0686: done
	!BYTE	$26			; LA	_D063+0
_F284 	!WORD	_D063+0		
	!BYTE	$54			; CALL	_X004
_F285 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
_SYSFLAGS	=	0
_DEFCNT	=	17
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C010		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C011		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C012		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C013		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C014		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C015		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	41			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	41			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	41			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	42			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	42			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	42			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	42			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	42			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	36			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	42			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	40			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	35			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	37			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	38			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F133-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F134-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F135-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F136-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F137-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F138-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F139-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F140-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F141-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F142-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F143-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F144-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F145-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F146-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F147-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F148-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F149-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F150-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F151-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F152-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F153-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F154-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F155-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F156-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F157-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F158-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F159-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F160-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F161-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F162-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F163-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F164-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F165-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F166-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F167-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F168-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F169-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F170-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F171-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F172-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F173-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F174-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F175-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F176-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F177-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F178-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F179-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F180-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F181-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F182-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F183-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F184-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F185-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F186-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F187-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F188-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F189-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F190-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F191-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F192-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F193-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F194-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F195-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F196-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F197-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F198-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F199-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F200-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F201-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F202-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F203-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F204-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F205-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F206-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F207-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F208-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F209-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F210-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F211-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F212-_SEGBEGIN		
	!BYTE	33			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F213-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F214-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F215-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F216-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F217-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F218-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F219-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F220-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F221-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F222-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F223-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F224-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F225-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F226-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F227-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F228-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F229-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F230-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F231-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F232-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F233-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F234-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F235-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F236-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F237-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F238-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F239-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F240-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F241-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F242-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F243-_SEGBEGIN		
	!BYTE	7			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F244-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F245-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F246-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F247-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F248-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F249-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F250-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F251-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F252-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F253-_SEGBEGIN		
	!BYTE	12			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F254-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F255-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F256-_SEGBEGIN		
	!BYTE	34			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F257-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F258-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F259-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F260-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F261-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F262-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F263-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F264-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F265-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F266-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F267-_SEGBEGIN		
	!BYTE	42			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F268-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F269-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F270-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F271-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F272-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F273-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F274-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F275-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F276-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F277-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F278-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F279-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F280-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F281-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F282-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F283-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F284-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F285-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: PUTC
	!BYTE	$D0,$D5,$D4,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	2			; ESD INDEX
	; DCI STRING: PUTS
	!BYTE	$D0,$D5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	4			; ESD INDEX
	; DCI STRING: PUTI
	!BYTE	$D0,$D5,$D4,$49
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	5			; ESD INDEX
	; DCI STRING: GETS
	!BYTE	$C7,$C5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	7			; ESD INDEX
	; DCI STRING: HEAPMARK
	!BYTE	$C8,$C5,$C1,$D0,$CD,$C1,$D2,$4B
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	12			; ESD INDEX
	; DCI STRING: HEAPALLOC
	!BYTE	$C8,$C5,$C1,$D0,$C1,$CC,$CC,$CF,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	14			; ESD INDEX
	; DCI STRING: HEAPRELEASE
	!BYTE	$C8,$C5,$C1,$D0,$D2,$C5,$CC,$C5,$C1,$D3,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	15			; ESD INDEX
	; DCI STRING: MEMSET
	!BYTE	$CD,$C5,$CD,$D3,$C5,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	17			; ESD INDEX
	; DCI STRING: MEMCPY
	!BYTE	$CD,$C5,$CD,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	18			; ESD INDEX
	; DCI STRING: TOUPPER
	!BYTE	$D4,$CF,$D5,$D0,$D0,$C5,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	21			; ESD INDEX
	; DCI STRING: CONIO
	!BYTE	$C3,$CF,$CE,$C9,$4F
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	28			; ESD INDEX
	; DCI STRING: LOADMAP
	!BYTE	$CC,$CF,$C1,$C4,$CD,$C1,$50
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	30			; ESD INDEX
	; DCI STRING: GETMAPTILE
	!BYTE	$C7,$C5,$D4,$CD,$C1,$D0,$D4,$C9,$CC,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	31			; ESD INDEX
	; DCI STRING: SETMAPTILE
	!BYTE	$D3,$C5,$D4,$CD,$C1,$D0,$D4,$C9,$CC,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	32			; ESD INDEX
	; DCI STRING: UPDTMAPTILE
	!BYTE	$D5,$D0,$C4,$D4,$CD,$C1,$D0,$D4,$C9,$CC,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	33			; ESD INDEX
	; DCI STRING: LIGHTTORCHES
	!BYTE	$CC,$C9,$C7,$C8,$D4,$D4,$CF,$D2,$C3,$C8,$C5,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	34			; ESD INDEX
	; DCI STRING: DRAWMAP
	!BYTE	$C4,$D2,$C1,$D7,$CD,$C1,$50
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	35			; ESD INDEX
	; DCI STRING: DRAWVISENTITY
	!BYTE	$C4,$D2,$C1,$D7,$D6,$C9,$D3,$C5,$CE,$D4,$C9,$D4,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	36			; ESD INDEX
	; DCI STRING: DRAWPLAYER
	!BYTE	$C4,$D2,$C1,$D7,$D0,$CC,$C1,$D9,$C5,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	37			; ESD INDEX
	; DCI STRING: UPDATESCREEN
	!BYTE	$D5,$D0,$C4,$C1,$D4,$C5,$D3,$C3,$D2,$C5,$C5,$4E
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	38			; ESD INDEX
	; DCI STRING: FIGHT
	!BYTE	$C6,$C9,$C7,$C8,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	40			; ESD INDEX
	; DCI STRING: ENTITY
	!BYTE	$C5,$CE,$D4,$C9,$D4,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	41			; ESD INDEX
	; DCI STRING: ENTITIES
	!BYTE	$C5,$CE,$D4,$C9,$D4,$C9,$C5,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	42			; ESD INDEX
	!BYTE	$00			; END OF ESD
