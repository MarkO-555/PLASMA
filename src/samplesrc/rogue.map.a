; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; samplesrc/rogue.map.pla: 0001: //
; samplesrc/rogue.map.pla: 0002: // Map module
; samplesrc/rogue.map.pla: 0003: //
; samplesrc/rogue.map.pla: 0004: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0200 // Version built against
					; _SYSVER_ = 512
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $03
					; MACHID_MEM = 3
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     //
; inc/cmdsys.plh: 0038:     // Module don't free memory
; inc/cmdsys.plh: 0039:     //
; inc/cmdsys.plh: 0040:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0041:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0042:     //
; inc/cmdsys.plh: 0043:     // CMD exported interface table
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     struc t_cmdsys
; inc/cmdsys.plh: 0046:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0047:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0048:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0049:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0050:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0051:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0052:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0053:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0054:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0055:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0056:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0057:         byte refcons    // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0058:         byte devcons    // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0059:     end
					; t_cmdsys = 21
; inc/cmdsys.plh: 0060:     //
; inc/cmdsys.plh: 0061:     // CMD exported functions
; inc/cmdsys.plh: 0062:     //
; inc/cmdsys.plh: 0063:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0064:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0065:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0066:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0067:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0068:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0069: end
; samplesrc/rogue.map.pla: 0004: 
; samplesrc/rogue.map.pla: 0005: include "inc/conio.plh"
; inc/conio.plh: 0001: import conio
	; DCI STRING: CONIO
	!BYTE	$C3,$CF,$CE,$C9,$4F
					; CONIO -> X028
; inc/conio.plh: 0002:     const NORMAL   = $FF
					; NORMAL = 255
; inc/conio.plh: 0003:     const INVERSE  = $3F
					; INVERSE = 63
; inc/conio.plh: 0004:     const FLASH    = $7F
					; FLASH = 127
; inc/conio.plh: 0005:     const ECHO_ON  = $80
					; ECHO_ON = 128
; inc/conio.plh: 0006:     const ECHO_OFF = $00
					; ECHO_OFF = 0
; inc/conio.plh: 0007:     struc t_conio
; inc/conio.plh: 0008:         word keypressed
					; keypressed = 0
; inc/conio.plh: 0009:         word getkey
					; getkey = 2
; inc/conio.plh: 0010:         word echo
					; echo = 4
; inc/conio.plh: 0011:         word home
					; home = 6
; inc/conio.plh: 0012:         word gotoxy
					; gotoxy = 8
; inc/conio.plh: 0013:         word viewport
					; viewport = 10
; inc/conio.plh: 0014:         word texttype
					; texttype = 12
; inc/conio.plh: 0015:         word textmode
					; textmode = 14
; inc/conio.plh: 0016:         word grmode
					; grmode = 16
; inc/conio.plh: 0017:         word grcolor
					; grcolor = 18
; inc/conio.plh: 0018:         word grplot
					; grplot = 20
; inc/conio.plh: 0019:         word tone
					; tone = 22
; inc/conio.plh: 0020:         word rnd
					; rnd = 24
; inc/conio.plh: 0021:     end
					; t_conio = 26
; inc/conio.plh: 0022: end
; samplesrc/rogue.map.pla: 0005: 
; samplesrc/rogue.map.pla: 0006: include "inc/fileio.plh"
; inc/fileio.plh: 0001: import fileio
	; DCI STRING: FILEIO
	!BYTE	$C6,$C9,$CC,$C5,$C9,$4F
					; FILEIO -> X029
; inc/fileio.plh: 0002:     //
; inc/fileio.plh: 0003:     // Useful ProDOS values
; inc/fileio.plh: 0004:     //
; inc/fileio.plh: 0005:     // MACHID is defined in cmdsys.plh
; inc/fileio.plh: 0006:     // Which slot has a ROM
; inc/fileio.plh: 0007:     const SLTBYT = $BF99
					; SLTBYT = 49049
; inc/fileio.plh: 0008:     // Prefix active
; inc/fileio.plh: 0009:     const PFIXPTR = $BF9A
					; PFIXPTR = 49050
; inc/fileio.plh: 0010:     // Memory alocate bitmap
; inc/fileio.plh: 0011:     const MEMTABL = $BF58
					; MEMTABL = 48984
; inc/fileio.plh: 0012:     //
; inc/fileio.plh: 0013:     // SOS/ProDOS error codes
; inc/fileio.plh: 0014:     //
; inc/fileio.plh: 0015:     const FILE_ERR_OK            = $00
					; FILE_ERR_OK = 0
; inc/fileio.plh: 0016:     const FILE_ERR_BAD_CALL_NUM  = $01
					; FILE_ERR_BAD_CALL_NUM = 1
; inc/fileio.plh: 0017:     const FILE_ERR_BAD_PARAM_CNT = $04
					; FILE_ERR_BAD_PARAM_CNT = 4
; inc/fileio.plh: 0018:     const FILE_ERR_INT_TBL_FULL  = $25
					; FILE_ERR_INT_TBL_FULL = 37
; inc/fileio.plh: 0019:     const FILE_ERR_IO            = $27
					; FILE_ERR_IO = 39
; inc/fileio.plh: 0020:     //
; inc/fileio.plh: 0021:     // File entry struc
; inc/fileio.plh: 0022:     //
; inc/fileio.plh: 0023:     struc t_fileentry
; inc/fileio.plh: 0024:         byte store_namelen
					; store_namelen = 0
; inc/fileio.plh: 0025:         byte entry_name[15]
					; entry_name = 1
; inc/fileio.plh: 0026:         byte entry_type
					; entry_type = 16
; inc/fileio.plh: 0027:         word entry_keyptr
					; entry_keyptr = 17
; inc/fileio.plh: 0028:         word entry_blocks
					; entry_blocks = 19
; inc/fileio.plh: 0029:         word entry_EOFL
					; entry_EOFL = 21
; inc/fileio.plh: 0030:         byte entry_EOFH
					; entry_EOFH = 23
; inc/fileio.plh: 0031:         word entry_create[2]
					; entry_create = 24
; inc/fileio.plh: 0032:         byte entry_version
					; entry_version = 28
; inc/fileio.plh: 0033:         byte entry_minver
					; entry_minver = 29
; inc/fileio.plh: 0034:         byte entry_access
					; entry_access = 30
; inc/fileio.plh: 0035:         word entry_aux
					; entry_aux = 31
; inc/fileio.plh: 0036:         word entry_mod[2]
					; entry_mod = 33
; inc/fileio.plh: 0037:         word entry_headptr
					; entry_headptr = 37
; inc/fileio.plh: 0038:     end
					; t_fileentry = 39
; inc/fileio.plh: 0039:     //
; inc/fileio.plh: 0040:     // File info struc
; inc/fileio.plh: 0041:     //
; inc/fileio.plh: 0042:     struc t_fileinfo
; inc/fileio.plh: 0043:         byte file_access
					; file_access = 0
; inc/fileio.plh: 0044:         byte file_type
					; file_type = 1
; inc/fileio.plh: 0045:         word aux_type
					; aux_type = 2
; inc/fileio.plh: 0046:         byte storage_type
					; storage_type = 4
; inc/fileio.plh: 0047:         word blocks_used
					; blocks_used = 5
; inc/fileio.plh: 0048:         word mod_date
					; mod_date = 7
; inc/fileio.plh: 0049:         word mod_time
					; mod_time = 9
; inc/fileio.plh: 0050:         word create_date
					; create_date = 11
; inc/fileio.plh: 0051:         word create_time
					; create_time = 13
; inc/fileio.plh: 0052:     end
					; t_fileinfo = 15
; inc/fileio.plh: 0053:     //
; inc/fileio.plh: 0054:     // File functions
; inc/fileio.plh: 0055:     //
; inc/fileio.plh: 0056:     struc t_fileio
; inc/fileio.plh: 0057:         word getpfx
					; getpfx = 0
; inc/fileio.plh: 0058:         word setpfx
					; setpfx = 2
; inc/fileio.plh: 0059:         word getfileinfo
					; getfileinfo = 4
; inc/fileio.plh: 0060:         word setfileinfo
					; setfileinfo = 6
; inc/fileio.plh: 0061:         word geteof
					; geteof = 8
; inc/fileio.plh: 0062:         word seteof
					; seteof = 10
; inc/fileio.plh: 0063:         word iobufalloc
					; iobufalloc = 12
; inc/fileio.plh: 0064:         word open
					; open = 14
; inc/fileio.plh: 0065:         word close
					; close = 16
; inc/fileio.plh: 0066:         word read
					; read = 18
; inc/fileio.plh: 0067:         word write
					; write = 20
; inc/fileio.plh: 0068:         word create
					; create = 22
; inc/fileio.plh: 0069:         word destroy
					; destroy = 24
; inc/fileio.plh: 0070:         word rename
					; rename = 26
; inc/fileio.plh: 0071:         word newline
					; newline = 28
; inc/fileio.plh: 0072:         word online
					; online = 30
; inc/fileio.plh: 0073:         word readblock
					; readblock = 32
; inc/fileio.plh: 0074:         word writeblock
					; writeblock = 34
; inc/fileio.plh: 0075:     end
					; t_fileio = 36
; inc/fileio.plh: 0076:     //
; inc/fileio.plh: 0077:     // Globally accessible error code
; inc/fileio.plh: 0078:     //
; inc/fileio.plh: 0079:     byte perr
					; PERR -> X030
; inc/fileio.plh: 0080: end
; samplesrc/rogue.map.pla: 0006: 
; samplesrc/rogue.map.pla: 0007: 
; samplesrc/rogue.map.pla: 0008: //
; samplesrc/rogue.map.pla: 0009: // Title page
; samplesrc/rogue.map.pla: 0010: //
; samplesrc/rogue.map.pla: 0011: 
; samplesrc/rogue.map.pla: 0012: byte[] initstr
	!BYTE	$00			; END OF MODULE DEPENDENCIES
_D031 					; initstr
; samplesrc/rogue.map.pla: 0013: byte = " (        )\n"
	!BYTE	$0C
	!BYTE	$20,$28,$20,$20,$20,$20,$20,$20
	!BYTE	$20,$20,$29,$0D
; samplesrc/rogue.map.pla: 0014: byte = " )\\ )  ( /(  (\n"
	!BYTE	$0F
	!BYTE	$20,$29,$5C,$20,$29,$20,$20,$28
	!BYTE	$20,$2F,$28,$20,$20,$28,$0D
; samplesrc/rogue.map.pla: 0015: byte = "(()/(  )\\()) )\\ )       (   (\n"
	!BYTE	$1E
	!BYTE	$28,$28,$29,$2F,$28,$20,$20,$29
	!BYTE	$5C,$28,$29,$29,$20,$29,$5C,$20
	!BYTE	$29,$20,$20,$20,$20,$20,$20,$20
	!BYTE	$28,$20,$20,$20,$28,$0D
; samplesrc/rogue.map.pla: 0016: byte = " /(_))((_)\\ (()/(       )\\  )\\\n"
	!BYTE	$1F
	!BYTE	$20,$2F,$28,$5F,$29,$29,$28,$28
	!BYTE	$5F,$29,$5C,$20,$28,$28,$29,$2F
	!BYTE	$28,$20,$20,$20,$20,$20,$20,$20
	!BYTE	$29,$5C,$20,$20,$29,$5C,$0D
; samplesrc/rogue.map.pla: 0017: byte = "(_))    ((_) /(_))_  _ ((_)((_)\n"
	!BYTE	$20
	!BYTE	$28,$5F,$29,$29,$20,$20,$20,$20
	!BYTE	$28,$28,$5F,$29,$20,$2F,$28,$5F
	!BYTE	$29,$29,$5F,$20,$20,$5F,$20,$28
	!BYTE	$28,$5F,$29,$28,$28,$5F,$29,$0D
; samplesrc/rogue.map.pla: 0018: byte = "| _ \\  / _ \\(_)) __|| | | || __|\n"
	!BYTE	$21
	!BYTE	$7C,$20,$5F,$20,$5C,$20,$20,$2F
	!BYTE	$20,$5F,$20,$5C,$28,$5F,$29,$29
	!BYTE	$20,$5F,$5F,$7C,$7C,$20,$7C,$20
	!BYTE	$7C,$20,$7C,$7C,$20,$5F,$5F,$7C
	!BYTE	$0D
; samplesrc/rogue.map.pla: 0019: byte = "|   / | (_) | | (_ || |_| || _|\n"
	!BYTE	$20
	!BYTE	$7C,$20,$20,$20,$2F,$20,$7C,$20
	!BYTE	$28,$5F,$29,$20,$7C,$20,$7C,$20
	!BYTE	$28,$5F,$20,$7C,$7C,$20,$7C,$5F
	!BYTE	$7C,$20,$7C,$7C,$20,$5F,$7C,$0D
; samplesrc/rogue.map.pla: 0020: byte = "|_|_\\  \\___/   \\___| \\___/ |___|\n"
	!BYTE	$21
	!BYTE	$7C,$5F,$7C,$5F,$5C,$20,$20,$5C
	!BYTE	$5F,$5F,$5F,$2F,$20,$20,$20,$5C
	!BYTE	$5F,$5F,$5F,$7C,$20,$5C,$5F,$5F
	!BYTE	$5F,$2F,$20,$7C,$5F,$5F,$5F,$7C
	!BYTE	$0D
; samplesrc/rogue.map.pla: 0021: byte = "\n"
	!BYTE	$01
	!BYTE	$0D
; samplesrc/rogue.map.pla: 0022: byte = "       By Resman\n"
	!BYTE	$11
	!BYTE	$20,$20,$20,$20,$20,$20,$20,$42
	!BYTE	$79,$20,$52,$65,$73,$6D,$61,$6E
	!BYTE	$0D
; samplesrc/rogue.map.pla: 0023: byte = "       Artwork by Seth Sternberger\n"
	!BYTE	$23
	!BYTE	$20,$20,$20,$20,$20,$20,$20,$41
	!BYTE	$72,$74,$77,$6F,$72,$6B,$20,$62
	!BYTE	$79,$20,$53,$65,$74,$68,$20,$53
	!BYTE	$74,$65,$72,$6E,$62,$65,$72,$67
	!BYTE	$65,$72,$0D
; samplesrc/rogue.map.pla: 0024: byte = ""
	!BYTE	$00
; samplesrc/rogue.map.pla: 0025: word titlestr = @initstr
_D032 					; titlestr = @initstr
_F000 	!WORD	_D031
; samplesrc/rogue.map.pla: 0026: 
; samplesrc/rogue.map.pla: 0027: //
; samplesrc/rogue.map.pla: 0028: // Animated tile sequence
; samplesrc/rogue.map.pla: 0029: //
; samplesrc/rogue.map.pla: 0030: 
; samplesrc/rogue.map.pla: 0031: byte animseq = 0
_D033 					; animseq = 0
	!BYTE	$00
; samplesrc/rogue.map.pla: 0032: 
; samplesrc/rogue.map.pla: 0033: //
; samplesrc/rogue.map.pla: 0034: // Octant beam parameters
; samplesrc/rogue.map.pla: 0035: //
; samplesrc/rogue.map.pla: 0036: 
; samplesrc/rogue.map.pla: 0037: const beamdepth = 23
					; beamdepth = 23
; samplesrc/rogue.map.pla: 0038: 
; samplesrc/rogue.map.pla: 0039: byte dbeam = 0,2,4,8,12,17,22,28,37,44,53,63,72,83,96,109,123,137,151,166,183,202,220,239
_D034 					; dbeam = 0,2,4,8,12,17,22,28,37,44,53,63,72,83,96,109,123,137,151,166,183,202,220,239
	!BYTE	$00
	!BYTE	$02
	!BYTE	$04
	!BYTE	$08
	!BYTE	$0C
	!BYTE	$11
	!BYTE	$16
	!BYTE	$1C
	!BYTE	$25
	!BYTE	$2C
	!BYTE	$35
	!BYTE	$3F
	!BYTE	$48
	!BYTE	$53
	!BYTE	$60
	!BYTE	$6D
	!BYTE	$7B
	!BYTE	$89
	!BYTE	$97
	!BYTE	$A6
	!BYTE	$B7
	!BYTE	$CA
	!BYTE	$DC
	!BYTE	$EF
; samplesrc/rogue.map.pla: 0040: const beampts = 240
					; beampts = 240
; samplesrc/rogue.map.pla: 0041: 
; samplesrc/rogue.map.pla: 0042: byte[] xbeam
_D035 					; xbeam
; samplesrc/rogue.map.pla: 0043: byte = 0
	!BYTE	$00
; samplesrc/rogue.map.pla: 0044: byte = 1,0
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0045: byte = 1,0
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0046: byte = 2,2,1,0
	!BYTE	$02
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0047: byte = 3,2,1,0
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0048: byte = 4,3,2,1,0
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0049: byte = 4,3,2,1,0
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0050: byte = 5,4,3,2,1,0
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0051: byte = 6,5,5,4,3,3,2,1,0
	!BYTE	$06
	!BYTE	$05
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0052: byte = 6,5,4,3,2,1,0
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0053: byte = 7,7,6,5,4,3,2,1,0
	!BYTE	$07
	!BYTE	$07
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0054: byte = 8,7,6,6,5,4,3,2,1,0
	!BYTE	$08
	!BYTE	$07
	!BYTE	$06
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0055: byte = 8,7,6,5,4,3,2,1,0
	!BYTE	$08
	!BYTE	$07
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0056: byte = 9,9,8,7,6,5,4,3,2,1,0
	!BYTE	$09
	!BYTE	$09
	!BYTE	$08
	!BYTE	$07
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0057: byte = 10,9,8,8,7,6,5,4,4,3,2,1,0
	!BYTE	$0A
	!BYTE	$09
	!BYTE	$08
	!BYTE	$08
	!BYTE	$07
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0058: byte = 11,10,10,9,8,7,6,5,4,3,2,1,0
	!BYTE	$0B
	!BYTE	$0A
	!BYTE	$0A
	!BYTE	$09
	!BYTE	$08
	!BYTE	$07
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0059: byte = 11,10,9,9,8,7,7,6,5,4,3,2,1,0
	!BYTE	$0B
	!BYTE	$0A
	!BYTE	$09
	!BYTE	$09
	!BYTE	$08
	!BYTE	$07
	!BYTE	$07
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0060: byte = 12,12,11,10,9,8,7,6,5,4,3,2,1,0
	!BYTE	$0C
	!BYTE	$0C
	!BYTE	$0B
	!BYTE	$0A
	!BYTE	$09
	!BYTE	$08
	!BYTE	$07
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0061: byte = 13,12,11,10,9,8,7,6,5,4,3,2,1,0
	!BYTE	$0D
	!BYTE	$0C
	!BYTE	$0B
	!BYTE	$0A
	!BYTE	$09
	!BYTE	$08
	!BYTE	$07
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0062: byte = 13,12,11,11,10,9,8,7,6,5,4,3,2,1,0
	!BYTE	$0D
	!BYTE	$0C
	!BYTE	$0B
	!BYTE	$0B
	!BYTE	$0A
	!BYTE	$09
	!BYTE	$08
	!BYTE	$07
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0063: byte = 14,14,13,12,11,10,10,9,8,7,6,5,4,3,2,1,0
	!BYTE	$0E
	!BYTE	$0E
	!BYTE	$0D
	!BYTE	$0C
	!BYTE	$0B
	!BYTE	$0A
	!BYTE	$0A
	!BYTE	$09
	!BYTE	$08
	!BYTE	$07
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0064: byte = 15,14,13,13,12,12,11,10,9,8,8,7,6,5,4,3,2,1,0
	!BYTE	$0F
	!BYTE	$0E
	!BYTE	$0D
	!BYTE	$0D
	!BYTE	$0C
	!BYTE	$0C
	!BYTE	$0B
	!BYTE	$0A
	!BYTE	$09
	!BYTE	$08
	!BYTE	$08
	!BYTE	$07
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0065: byte = 16,15,14,13,12,11,10,9,8,7,6,5,5,4,3,2,1,0
	!BYTE	$10
	!BYTE	$0F
	!BYTE	$0E
	!BYTE	$0D
	!BYTE	$0C
	!BYTE	$0B
	!BYTE	$0A
	!BYTE	$09
	!BYTE	$08
	!BYTE	$07
	!BYTE	$06
	!BYTE	$05
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0066: byte = 16,15,15,14,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0
	!BYTE	$10
	!BYTE	$0F
	!BYTE	$0F
	!BYTE	$0E
	!BYTE	$0E
	!BYTE	$0D
	!BYTE	$0C
	!BYTE	$0B
	!BYTE	$0A
	!BYTE	$09
	!BYTE	$08
	!BYTE	$07
	!BYTE	$06
	!BYTE	$05
	!BYTE	$04
	!BYTE	$03
	!BYTE	$02
	!BYTE	$01
	!BYTE	$00
; samplesrc/rogue.map.pla: 0067: 
; samplesrc/rogue.map.pla: 0068: byte[] ybeam
_D036 					; ybeam
; samplesrc/rogue.map.pla: 0069: byte = 0
	!BYTE	$00
; samplesrc/rogue.map.pla: 0070: byte = 1,1
	!BYTE	$01
	!BYTE	$01
; samplesrc/rogue.map.pla: 0071: byte = 2,2
	!BYTE	$02
	!BYTE	$02
; samplesrc/rogue.map.pla: 0072: byte = 2,3,3,3
	!BYTE	$02
	!BYTE	$03
	!BYTE	$03
	!BYTE	$03
; samplesrc/rogue.map.pla: 0073: byte = 3,4,4,4
	!BYTE	$03
	!BYTE	$04
	!BYTE	$04
	!BYTE	$04
; samplesrc/rogue.map.pla: 0074: byte = 4,4,5,5,5
	!BYTE	$04
	!BYTE	$04
	!BYTE	$05
	!BYTE	$05
	!BYTE	$05
; samplesrc/rogue.map.pla: 0075: byte = 5,5,6,6,6
	!BYTE	$05
	!BYTE	$05
	!BYTE	$06
	!BYTE	$06
	!BYTE	$06
; samplesrc/rogue.map.pla: 0076: byte = 5,6,6,7,7,7
	!BYTE	$05
	!BYTE	$06
	!BYTE	$06
	!BYTE	$07
	!BYTE	$07
	!BYTE	$07
; samplesrc/rogue.map.pla: 0077: byte = 6,6,7,7,7,8,8,8,8
	!BYTE	$06
	!BYTE	$06
	!BYTE	$07
	!BYTE	$07
	!BYTE	$07
	!BYTE	$08
	!BYTE	$08
	!BYTE	$08
	!BYTE	$08
; samplesrc/rogue.map.pla: 0078: byte = 7,8,8,9,9,9,9
	!BYTE	$07
	!BYTE	$08
	!BYTE	$08
	!BYTE	$09
	!BYTE	$09
	!BYTE	$09
	!BYTE	$09
; samplesrc/rogue.map.pla: 0079: byte = 7,8,8,9,9,10,10,10,10
	!BYTE	$07
	!BYTE	$08
	!BYTE	$08
	!BYTE	$09
	!BYTE	$09
	!BYTE	$0A
	!BYTE	$0A
	!BYTE	$0A
	!BYTE	$0A
; samplesrc/rogue.map.pla: 0080: byte = 8,9,9,10,10,10,11,11,11,11
	!BYTE	$08
	!BYTE	$09
	!BYTE	$09
	!BYTE	$0A
	!BYTE	$0A
	!BYTE	$0A
	!BYTE	$0B
	!BYTE	$0B
	!BYTE	$0B
	!BYTE	$0B
; samplesrc/rogue.map.pla: 0081: byte = 9,10,11,11,11,12,12,12,12
	!BYTE	$09
	!BYTE	$0A
	!BYTE	$0B
	!BYTE	$0B
	!BYTE	$0B
	!BYTE	$0C
	!BYTE	$0C
	!BYTE	$0C
	!BYTE	$0C
; samplesrc/rogue.map.pla: 0082: byte = 9,10,10,11,12,12,12,13,13,13,13
	!BYTE	$09
	!BYTE	$0A
	!BYTE	$0A
	!BYTE	$0B
	!BYTE	$0C
	!BYTE	$0C
	!BYTE	$0C
	!BYTE	$0D
	!BYTE	$0D
	!BYTE	$0D
	!BYTE	$0D
; samplesrc/rogue.map.pla: 0083: byte = 10,11,11,12,12,13,13,13,14,14,14,14,14
	!BYTE	$0A
	!BYTE	$0B
	!BYTE	$0B
	!BYTE	$0C
	!BYTE	$0C
	!BYTE	$0D
	!BYTE	$0D
	!BYTE	$0D
	!BYTE	$0E
	!BYTE	$0E
	!BYTE	$0E
	!BYTE	$0E
	!BYTE	$0E
; samplesrc/rogue.map.pla: 0084: byte = 11,11,12,12,13,13,14,14,15,15,15,15,15
	!BYTE	$0B
	!BYTE	$0B
	!BYTE	$0C
	!BYTE	$0C
	!BYTE	$0D
	!BYTE	$0D
	!BYTE	$0E
	!BYTE	$0E
	!BYTE	$0F
	!BYTE	$0F
	!BYTE	$0F
	!BYTE	$0F
	!BYTE	$0F
; samplesrc/rogue.map.pla: 0085: byte = 12,13,13,14,14,14,15,15,15,16,16,16,16,16
	!BYTE	$0C
	!BYTE	$0D
	!BYTE	$0D
	!BYTE	$0E
	!BYTE	$0E
	!BYTE	$0E
	!BYTE	$0F
	!BYTE	$0F
	!BYTE	$0F
	!BYTE	$10
	!BYTE	$10
	!BYTE	$10
	!BYTE	$10
	!BYTE	$10
; samplesrc/rogue.map.pla: 0086: byte = 12,13,13,14,15,15,16,16,16,17,17,17,17,17
	!BYTE	$0C
	!BYTE	$0D
	!BYTE	$0D
	!BYTE	$0E
	!BYTE	$0F
	!BYTE	$0F
	!BYTE	$10
	!BYTE	$10
	!BYTE	$10
	!BYTE	$11
	!BYTE	$11
	!BYTE	$11
	!BYTE	$11
	!BYTE	$11
; samplesrc/rogue.map.pla: 0087: byte = 13,14,14,15,16,16,17,17,17,18,18,18,18,18
	!BYTE	$0D
	!BYTE	$0E
	!BYTE	$0E
	!BYTE	$0F
	!BYTE	$10
	!BYTE	$10
	!BYTE	$11
	!BYTE	$11
	!BYTE	$11
	!BYTE	$12
	!BYTE	$12
	!BYTE	$12
	!BYTE	$12
	!BYTE	$12
; samplesrc/rogue.map.pla: 0088: byte = 14,15,15,16,16,17,17,18,18,18,19,19,19,19,19
	!BYTE	$0E
	!BYTE	$0F
	!BYTE	$0F
	!BYTE	$10
	!BYTE	$10
	!BYTE	$11
	!BYTE	$11
	!BYTE	$12
	!BYTE	$12
	!BYTE	$12
	!BYTE	$13
	!BYTE	$13
	!BYTE	$13
	!BYTE	$13
	!BYTE	$13
; samplesrc/rogue.map.pla: 0089: byte = 14,15,15,16,17,17,18,18,18,19,19,19,20,20,20,20,20
	!BYTE	$0E
	!BYTE	$0F
	!BYTE	$0F
	!BYTE	$10
	!BYTE	$11
	!BYTE	$11
	!BYTE	$12
	!BYTE	$12
	!BYTE	$12
	!BYTE	$13
	!BYTE	$13
	!BYTE	$13
	!BYTE	$14
	!BYTE	$14
	!BYTE	$14
	!BYTE	$14
	!BYTE	$14
; samplesrc/rogue.map.pla: 0090: byte = 15,16,16,17,17,18,18,19,19,19,20,20,20,20,21,21,21,21,21
	!BYTE	$0F
	!BYTE	$10
	!BYTE	$10
	!BYTE	$11
	!BYTE	$11
	!BYTE	$12
	!BYTE	$12
	!BYTE	$13
	!BYTE	$13
	!BYTE	$13
	!BYTE	$14
	!BYTE	$14
	!BYTE	$14
	!BYTE	$14
	!BYTE	$15
	!BYTE	$15
	!BYTE	$15
	!BYTE	$15
	!BYTE	$15
; samplesrc/rogue.map.pla: 0091: byte = 16,16,17,18,19,19,20,20,21,21,21,21,22,22,22,22,22,22
	!BYTE	$10
	!BYTE	$10
	!BYTE	$11
	!BYTE	$12
	!BYTE	$13
	!BYTE	$13
	!BYTE	$14
	!BYTE	$14
	!BYTE	$15
	!BYTE	$15
	!BYTE	$15
	!BYTE	$15
	!BYTE	$16
	!BYTE	$16
	!BYTE	$16
	!BYTE	$16
	!BYTE	$16
	!BYTE	$16
; samplesrc/rogue.map.pla: 0092: byte = 17,17,18,18,19,19,20,20,21,21,22,22,22,23,23,23,23,23,23
	!BYTE	$11
	!BYTE	$11
	!BYTE	$12
	!BYTE	$12
	!BYTE	$13
	!BYTE	$13
	!BYTE	$14
	!BYTE	$14
	!BYTE	$15
	!BYTE	$15
	!BYTE	$16
	!BYTE	$16
	!BYTE	$16
	!BYTE	$17
	!BYTE	$17
	!BYTE	$17
	!BYTE	$17
	!BYTE	$17
	!BYTE	$17
; samplesrc/rogue.map.pla: 0093: 
; samplesrc/rogue.map.pla: 0094: byte[] vbeam
_D037 					; vbeam
; samplesrc/rogue.map.pla: 0095: byte = 0
	!BYTE	$00
; samplesrc/rogue.map.pla: 0096: byte = 0,0
	!BYTE	$00
	!BYTE	$00
; samplesrc/rogue.map.pla: 0097: byte = 2,2
	!BYTE	$02
	!BYTE	$02
; samplesrc/rogue.map.pla: 0098: byte = 1,3,4,4
	!BYTE	$01
	!BYTE	$03
	!BYTE	$04
	!BYTE	$04
; samplesrc/rogue.map.pla: 0099: byte = 5,7,7,8
	!BYTE	$05
	!BYTE	$07
	!BYTE	$07
	!BYTE	$08
; samplesrc/rogue.map.pla: 0100: byte = 9,6,11,11,12
	!BYTE	$09
	!BYTE	$06
	!BYTE	$0B
	!BYTE	$0B
	!BYTE	$0C
; samplesrc/rogue.map.pla: 0101: byte = 14,10,16,16,17
	!BYTE	$0E
	!BYTE	$0A
	!BYTE	$10
	!BYTE	$10
	!BYTE	$11
; samplesrc/rogue.map.pla: 0102: byte = 13,19,15,21,21,22
	!BYTE	$0D
	!BYTE	$13
	!BYTE	$0F
	!BYTE	$15
	!BYTE	$15
	!BYTE	$16
; samplesrc/rogue.map.pla: 0103: byte = 23,18,24,25,20,26,26,27,28
	!BYTE	$17
	!BYTE	$12
	!BYTE	$18
	!BYTE	$19
	!BYTE	$14
	!BYTE	$1A
	!BYTE	$1A
	!BYTE	$1B
	!BYTE	$1C
; samplesrc/rogue.map.pla: 0104: byte = 30,32,33,35,35,36,37
	!BYTE	$1E
	!BYTE	$20
	!BYTE	$21
	!BYTE	$23
	!BYTE	$23
	!BYTE	$24
	!BYTE	$25
; samplesrc/rogue.map.pla: 0105: byte = 29,38,31,40,34,42,42,43,44
	!BYTE	$1D
	!BYTE	$26
	!BYTE	$1F
	!BYTE	$28
	!BYTE	$22
	!BYTE	$2A
	!BYTE	$2A
	!BYTE	$2B
	!BYTE	$2C
; samplesrc/rogue.map.pla: 0106: byte = 45,47,39,48,49,41,51,51,52,53
	!BYTE	$2D
	!BYTE	$2F
	!BYTE	$27
	!BYTE	$30
	!BYTE	$31
	!BYTE	$29
	!BYTE	$33
	!BYTE	$33
	!BYTE	$34
	!BYTE	$35
; samplesrc/rogue.map.pla: 0107: byte = 46,56,58,59,50,60,61,62,63
	!BYTE	$2E
	!BYTE	$38
	!BYTE	$3A
	!BYTE	$3B
	!BYTE	$32
	!BYTE	$3C
	!BYTE	$3D
	!BYTE	$3E
	!BYTE	$3F
; samplesrc/rogue.map.pla: 0108: byte = 54,64,55,57,67,68,60,69,70,71,72
	!BYTE	$36
	!BYTE	$40
	!BYTE	$37
	!BYTE	$39
	!BYTE	$43
	!BYTE	$44
	!BYTE	$3C
	!BYTE	$45
	!BYTE	$46
	!BYTE	$47
	!BYTE	$48
; samplesrc/rogue.map.pla: 0109: byte = 73,75,65,76,66,78,79,69,80,80,81,82,83
	!BYTE	$49
	!BYTE	$4B
	!BYTE	$41
	!BYTE	$4C
	!BYTE	$42
	!BYTE	$4E
	!BYTE	$4F
	!BYTE	$45
	!BYTE	$50
	!BYTE	$50
	!BYTE	$51
	!BYTE	$52
	!BYTE	$53
; samplesrc/rogue.map.pla: 0110: byte = 84,74,85,86,88,77,90,91,93,93,94,95,96
	!BYTE	$54
	!BYTE	$4A
	!BYTE	$55
	!BYTE	$56
	!BYTE	$58
	!BYTE	$4D
	!BYTE	$5A
	!BYTE	$5B
	!BYTE	$5D
	!BYTE	$5D
	!BYTE	$5E
	!BYTE	$5F
	!BYTE	$60
; samplesrc/rogue.map.pla: 0111: byte = 98,100,87,101,102,89,103,104,92,105,106,107,108,109
	!BYTE	$62
	!BYTE	$64
	!BYTE	$57
	!BYTE	$65
	!BYTE	$66
	!BYTE	$59
	!BYTE	$67
	!BYTE	$68
	!BYTE	$5C
	!BYTE	$69
	!BYTE	$6A
	!BYTE	$6B
	!BYTE	$6C
	!BYTE	$6D
; samplesrc/rogue.map.pla: 0112: byte = 97,110,99,112,114,115,117,118,105,119,120,121,122,123
	!BYTE	$61
	!BYTE	$6E
	!BYTE	$63
	!BYTE	$70
	!BYTE	$72
	!BYTE	$73
	!BYTE	$75
	!BYTE	$76
	!BYTE	$69
	!BYTE	$77
	!BYTE	$78
	!BYTE	$79
	!BYTE	$7A
	!BYTE	$7B
; samplesrc/rogue.map.pla: 0113: byte = 124,126,111,113,129,116,131,132,119,133,134,135,136,137
	!BYTE	$7C
	!BYTE	$7E
	!BYTE	$6F
	!BYTE	$71
	!BYTE	$81
	!BYTE	$74
	!BYTE	$83
	!BYTE	$84
	!BYTE	$77
	!BYTE	$85
	!BYTE	$86
	!BYTE	$87
	!BYTE	$88
	!BYTE	$89
; samplesrc/rogue.map.pla: 0114: byte = 125,140,127,141,128,143,130,145,146,133,147,148,149,150,151
	!BYTE	$7D
	!BYTE	$8C
	!BYTE	$7F
	!BYTE	$8D
	!BYTE	$80
	!BYTE	$8F
	!BYTE	$82
	!BYTE	$91
	!BYTE	$92
	!BYTE	$85
	!BYTE	$93
	!BYTE	$94
	!BYTE	$95
	!BYTE	$96
	!BYTE	$97
; samplesrc/rogue.map.pla: 0115: byte = 138,152,139,154,156,142,157,158,144,160,161,147,162,163,164,165,166
	!BYTE	$8A
	!BYTE	$98
	!BYTE	$8B
	!BYTE	$9A
	!BYTE	$9C
	!BYTE	$8E
	!BYTE	$9D
	!BYTE	$9E
	!BYTE	$90
	!BYTE	$A0
	!BYTE	$A1
	!BYTE	$93
	!BYTE	$A2
	!BYTE	$A3
	!BYTE	$A4
	!BYTE	$A5
	!BYTE	$A6
; samplesrc/rogue.map.pla: 0116: byte = 167,169,153,170,155,171,172,174,175,159,176,177,178,178,179,180,181,182,183
	!BYTE	$A7
	!BYTE	$A9
	!BYTE	$99
	!BYTE	$AA
	!BYTE	$9B
	!BYTE	$AB
	!BYTE	$AC
	!BYTE	$AE
	!BYTE	$AF
	!BYTE	$9F
	!BYTE	$B0
	!BYTE	$B1
	!BYTE	$B2
	!BYTE	$B2
	!BYTE	$B3
	!BYTE	$B4
	!BYTE	$B5
	!BYTE	$B6
	!BYTE	$B7
; samplesrc/rogue.map.pla: 0117: byte = 184,168,186,188,190,173,192,193,195,196,197,197,214,198,199,200,201,202
	!BYTE	$B8
	!BYTE	$A8
	!BYTE	$BA
	!BYTE	$BC
	!BYTE	$BE
	!BYTE	$AD
	!BYTE	$C0
	!BYTE	$C1
	!BYTE	$C3
	!BYTE	$C4
	!BYTE	$C5
	!BYTE	$C5
	!BYTE	$D6
	!BYTE	$C6
	!BYTE	$C7
	!BYTE	$C8
	!BYTE	$C9
	!BYTE	$CA
; samplesrc/rogue.map.pla: 0118: byte = 204,185,205,187,206,189,208,191,210,194,212,213,214,215,216,217,218,219,220
	!BYTE	$CC
	!BYTE	$B9
	!BYTE	$CD
	!BYTE	$BB
	!BYTE	$CE
	!BYTE	$BD
	!BYTE	$D0
	!BYTE	$BF
	!BYTE	$D2
	!BYTE	$C2
	!BYTE	$D4
	!BYTE	$D5
	!BYTE	$D6
	!BYTE	$D7
	!BYTE	$D8
	!BYTE	$D9
	!BYTE	$DA
	!BYTE	$DB
	!BYTE	$DC
; samplesrc/rogue.map.pla: 0119: 
; samplesrc/rogue.map.pla: 0120: byte[beampts] vispix = 1
_D038 					; vispix = 1
	!BYTE	$01
	!FILL	$EF
; samplesrc/rogue.map.pla: 0121: 
; samplesrc/rogue.map.pla: 0122: const rowshift = 6
					; rowshift = 6
; samplesrc/rogue.map.pla: 0123: const maprows  = 64
					; maprows = 64
; samplesrc/rogue.map.pla: 0124: const mapcols  = 64
					; mapcols = 64
; samplesrc/rogue.map.pla: 0125: const mapsize  = maprows*mapcols
					; mapsize = 4096
; samplesrc/rogue.map.pla: 0126: 
; samplesrc/rogue.map.pla: 0127: const WALL_TILE   = '#'
					; WALL_TILE = 35
; samplesrc/rogue.map.pla: 0128: const FLOOR_TILE  = '.'
					; FLOOR_TILE = 46
; samplesrc/rogue.map.pla: 0129: const TORCH_TILE  = '*'
					; TORCH_TILE = 42
; samplesrc/rogue.map.pla: 0130: const PIT_TILE    = ' '
					; PIT_TILE = 32
; samplesrc/rogue.map.pla: 0131: const DOOR_TILE   = '+'
					; DOOR_TILE = 43
; samplesrc/rogue.map.pla: 0132: const LOCKED_TILE = '%'
					; LOCKED_TILE = 37
; samplesrc/rogue.map.pla: 0133: const WATER1_TILE = '>'
					; WATER1_TILE = 62
; samplesrc/rogue.map.pla: 0134: const WATER2_TILE = '<'
					; WATER2_TILE = 60
; samplesrc/rogue.map.pla: 0135: const KEY_TILE    = ','
					; KEY_TILE = 44
; samplesrc/rogue.map.pla: 0136: const RAFT_TILE   = '@'
					; RAFT_TILE = 64
; samplesrc/rogue.map.pla: 0137: const GOLD_TILE   = '$'
					; GOLD_TILE = 36
; samplesrc/rogue.map.pla: 0138: const FOOD_TILE   = '&'
					; FOOD_TILE = 38
; samplesrc/rogue.map.pla: 0139: const ENTER_TILE  = '-'
					; ENTER_TILE = 45
; samplesrc/rogue.map.pla: 0140: const EXIT_TILE   = '='
					; EXIT_TILE = 61
; samplesrc/rogue.map.pla: 0141: const OPAQUE_TILE = $01
					; OPAQUE_TILE = 1
; samplesrc/rogue.map.pla: 0142: const VIEWED_TILE = $80
					; VIEWED_TILE = 128
; samplesrc/rogue.map.pla: 0143: const LIT_TILE    = $80
					; LIT_TILE = 128
; samplesrc/rogue.map.pla: 0144: const INV_TILE    = $3F
					; INV_TILE = 63
; samplesrc/rogue.map.pla: 0145: const MAP_TILE    = $7F
					; MAP_TILE = 127
; samplesrc/rogue.map.pla: 0146: 
; samplesrc/rogue.map.pla: 0147: byte catacomb = "LEVEL0"
_D039 					; catacomb = "LEVEL0"
	!BYTE	$06
	!BYTE	$4C,$45,$56,$45,$4C,$30
; samplesrc/rogue.map.pla: 0148: word map, viewmap
_D040 	!FILL	2			; map, viewmap
_D041 	!FILL	2			; viewmap
; samplesrc/rogue.map.pla: 0149: 
; samplesrc/rogue.map.pla: 0150: const xcentr     = 20
					; xcentr = 20
; samplesrc/rogue.map.pla: 0151: const ycentr     = 12
					; ycentr = 12
; samplesrc/rogue.map.pla: 0152: const scrnwidth  = 40
					; scrnwidth = 40
; samplesrc/rogue.map.pla: 0153: const scrnheight = 22
					; scrnheight = 22
; samplesrc/rogue.map.pla: 0154: 
; samplesrc/rogue.map.pla: 0155: //
; samplesrc/rogue.map.pla: 0156: // Screen buffer
; samplesrc/rogue.map.pla: 0157: //
; samplesrc/rogue.map.pla: 0158: 
; samplesrc/rogue.map.pla: 0159: byte[scrnheight * scrnwidth] screenbuffer
_D042 	!FILL	880			; screenbuffer
; samplesrc/rogue.map.pla: 0160: 
; samplesrc/rogue.map.pla: 0161: //
; samplesrc/rogue.map.pla: 0162: // Buffer to void checks in octant caster
; samplesrc/rogue.map.pla: 0163: //
; samplesrc/rogue.map.pla: 0164: 
; samplesrc/rogue.map.pla: 0165: byte[scrnwidth] linebuffer
_D043 	!FILL	40			; linebuffer
; samplesrc/rogue.map.pla: 0166: 
; samplesrc/rogue.map.pla: 0167: word = @linebuffer, @linebuffer, @linebuffer, @linebuffer, @linebuffer
_F001 	!WORD	_D043
_F002 	!WORD	_D043
_F003 	!WORD	_D043
_F004 	!WORD	_D043
_F005 	!WORD	_D043
; samplesrc/rogue.map.pla: 0168: word = @linebuffer, @linebuffer, @linebuffer, @linebuffer, @linebuffer
_F006 	!WORD	_D043
_F007 	!WORD	_D043
_F008 	!WORD	_D043
_F009 	!WORD	_D043
_F010 	!WORD	_D043
; samplesrc/rogue.map.pla: 0169: 
; samplesrc/rogue.map.pla: 0170: word[scrnheight] screen
_D044 	!FILL	44			; screen
; samplesrc/rogue.map.pla: 0171: 
; samplesrc/rogue.map.pla: 0172: word = @linebuffer, @linebuffer, @linebuffer, @linebuffer, @linebuffer
_F011 	!WORD	_D043
_F012 	!WORD	_D043
_F013 	!WORD	_D043
_F014 	!WORD	_D043
_F015 	!WORD	_D043
; samplesrc/rogue.map.pla: 0173: word = @linebuffer, @linebuffer, @linebuffer, @linebuffer, @linebuffer
_F016 	!WORD	_D043
_F017 	!WORD	_D043
_F018 	!WORD	_D043
_F019 	!WORD	_D043
_F020 	!WORD	_D043
; samplesrc/rogue.map.pla: 0174: 
; samplesrc/rogue.map.pla: 0175: //
; samplesrc/rogue.map.pla: 0176: // Visisble screen row addresses
; samplesrc/rogue.map.pla: 0177: //
; samplesrc/rogue.map.pla: 0178: 
; samplesrc/rogue.map.pla: 0179: word[] viscreen
_D045 					; viscreen
; samplesrc/rogue.map.pla: 0180: word = $400, $480, $500, $580, $600, $680, $700, $780
	!WORD	$0400
	!WORD	$0480
	!WORD	$0500
	!WORD	$0580
	!WORD	$0600
	!WORD	$0680
	!WORD	$0700
	!WORD	$0780
; samplesrc/rogue.map.pla: 0181: word = $428, $4A8, $528, $5A8, $628, $6A8, $728, $7A8
	!WORD	$0428
	!WORD	$04A8
	!WORD	$0528
	!WORD	$05A8
	!WORD	$0628
	!WORD	$06A8
	!WORD	$0728
	!WORD	$07A8
; samplesrc/rogue.map.pla: 0182: word = $450, $4D0, $550, $5D0, $650, $6D0, $750, @linebuffer // $7D0
	!WORD	$0450
	!WORD	$04D0
	!WORD	$0550
	!WORD	$05D0
	!WORD	$0650
	!WORD	$06D0
	!WORD	$0750
_F021 	!WORD	_D043
; samplesrc/rogue.map.pla: 0183: 
; samplesrc/rogue.map.pla: 0184: //
; samplesrc/rogue.map.pla: 0185: // Load map - levels 0 to 9
; samplesrc/rogue.map.pla: 0186: //
; samplesrc/rogue.map.pla: 0187: 
; samplesrc/rogue.map.pla: 0188: export def loadmap(level)
	!BYTE	$00			; PAD BYTE
_SUBSEG 				; BYTECODE STARTS
					; level -> [0]
_C000 					; loadmap()
; samplesrc/rogue.map.pla: 0189:   byte mapref, row, l
					; mapref -> [2]
					; row -> [3]
					; l -> [4]
; samplesrc/rogue.map.pla: 0190: 
; samplesrc/rogue.map.pla: 0191:   //
; samplesrc/rogue.map.pla: 0192:   // Init the view map
; samplesrc/rogue.map.pla: 0193:   //
; samplesrc/rogue.map.pla: 0194:   if not viewmap
	!BYTE	$58,$05,$01		; ENTER	5,1
; samplesrc/rogue.map.pla: 0195:     viewmap = heapalloc(mapsize)
; samplesrc/rogue.map.pla: 0196:   fin
	!BYTE	$6A			; LAW	_D041+0
_F022 	!WORD	_D041+0		
	!BYTE	$4E			; BRTRU	_B001
	!WORD	_B001-*
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$54			; CALL	_X014
_F023 	!WORD	0		
	!BYTE	$7A			; SAW	_D041+0
_F024 	!WORD	_D041+0		
_B001 
_B002 
; samplesrc/rogue.map.pla: 0197:   memset(viewmap, $A0A0, mapsize)
; samplesrc/rogue.map.pla: 0198:   //
; samplesrc/rogue.map.pla: 0199:   // Load catacomb map from file
; samplesrc/rogue.map.pla: 0200:   //
; samplesrc/rogue.map.pla: 0201:   if not map
; samplesrc/rogue.map.pla: 0202:     map = heapalloc(mapsize)
; samplesrc/rogue.map.pla: 0203:   fin
	!BYTE	$6A			; LAW	_D041+0
_F025 	!WORD	_D041+0		
	!BYTE	$2C,$A0,$A0		; CW	41120
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$54			; CALL	_X017
_F026 	!WORD	0		
	!BYTE	$6A			; LAW	_D040+0
_F027 	!WORD	_D040+0		
	!BYTE	$4E			; BRTRU	_B003
	!WORD	_B003-*
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$54			; CALL	_X014
_F028 	!WORD	0		
	!BYTE	$7A			; SAW	_D040+0
_F029 	!WORD	_D040+0		
_B003 
_B004 
; samplesrc/rogue.map.pla: 0204:   memset(map, $2323, mapsize) // Solid walls
; samplesrc/rogue.map.pla: 0205:   //
; samplesrc/rogue.map.pla: 0206:   // Set level map and read it
; samplesrc/rogue.map.pla: 0207:   //
; samplesrc/rogue.map.pla: 0208:   catacomb[catacomb] = '0' + level
; samplesrc/rogue.map.pla: 0209:   mapref = fileio:open(@catacomb)
; samplesrc/rogue.map.pla: 0210:   if mapref
; samplesrc/rogue.map.pla: 0211:     fileio:newline(mapref, $7F, $0D)
; samplesrc/rogue.map.pla: 0212:     for row = 1 to maprows - 2
	!BYTE	$6A			; LAW	_D040+0
_F030 	!WORD	_D040+0		
	!BYTE	$2C,$23,$23		; CW	8995
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$54			; CALL	_X017
_F031 	!WORD	0		
	!BYTE	$2A,$30			; CB	48
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D039+0
_F032 	!WORD	_D039+0		
	!BYTE	$B4			; ADDAB	_D039+0
_F033 	!WORD	_D039+0		
	!BYTE	$70			; SB
	!BYTE	$26			; LA	_D039+0
_F034 	!WORD	_D039+0		
	!BYTE	$6A			; LAW	_X029+14
_F035 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$6C,$02			; DLB	[2]
	!BYTE	$4C			; BRFLS	_B005
	!WORD	_B005-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$1A			; CN	13
	!BYTE	$6A			; LAW	_X029+28
_F036 	!WORD	0+28		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$2A,$3E			; CB	62
	!BYTE	$02			; CN	1
_B008 
	!BYTE	$6C,$03			; DLB	[3]
; samplesrc/rogue.map.pla: 0213:       l = fileio:read(mapref, map + (row << 6) + 1, mapcols)
; samplesrc/rogue.map.pla: 0214:       ^(map + (row << 6) + l) = WALL_TILE
; samplesrc/rogue.map.pla: 0215:     next
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$6A			; LAW	_D040+0
_F037 	!WORD	_D040+0		
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$82			; ADD 
	!BYTE	$8C			; INCR
	!BYTE	$2A,$40			; CB	64
	!BYTE	$6A			; LAW	_X029+18
_F038 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$2A,$23			; CB	35
	!BYTE	$6A			; LAW	_D040+0
_F039 	!WORD	_D040+0		
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$82			; ADD 
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$70			; SB
_B009 
	!BYTE	$A4			; INCBRLE	_B008
	!WORD	_B008-*
_B007 
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0216:     fileio:close(mapref)
; samplesrc/rogue.map.pla: 0217:     return TRUE
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$6A			; LAW	_X029+16
_F040 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$05			; LEAVE	5
; samplesrc/rogue.map.pla: 0218:   fin
_B005 
_B006 
; samplesrc/rogue.map.pla: 0219:   return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$05			; LEAVE	5
; samplesrc/rogue.map.pla: 0220: end
; samplesrc/rogue.map.pla: 0221: 
; samplesrc/rogue.map.pla: 0222: //
; samplesrc/rogue.map.pla: 0223: // Tile access to map
; samplesrc/rogue.map.pla: 0224: //
; samplesrc/rogue.map.pla: 0225: 
; samplesrc/rogue.map.pla: 0226: export def getmaptile(xmap, ymap)
					; xmap -> [0]
					; ymap -> [2]
_C001 					; getmaptile()
; samplesrc/rogue.map.pla: 0227:   return ^(map + (ymap << rowshift) + xmap)
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$6A			; LAW	_D040+0
_F041 	!WORD	_D040+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$82			; ADD 
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$5A,$04			; LEAVE	4
; samplesrc/rogue.map.pla: 0228: end
; samplesrc/rogue.map.pla: 0229: 
; samplesrc/rogue.map.pla: 0230: export def setmaptile(xmap, ymap, tile)#0
					; xmap -> [0]
					; ymap -> [2]
					; tile -> [4]
_C002 					; setmaptile()
; samplesrc/rogue.map.pla: 0231:   word imap
					; imap -> [6]
; samplesrc/rogue.map.pla: 0232: 
; samplesrc/rogue.map.pla: 0233:   imap = (ymap << rowshift) + xmap
	!BYTE	$58,$08,$03		; ENTER	8,3
; samplesrc/rogue.map.pla: 0234:   ^(map + imap) = tile
; samplesrc/rogue.map.pla: 0235:   if ^(viewmap + imap) <> $A0
; samplesrc/rogue.map.pla: 0236:     ^(viewmap + imap) = tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0237:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$6A			; LAW	_D040+0
_F042 	!WORD	_D040+0		
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D041+0
_F043 	!WORD	_D041+0		
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$60			; LB
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$22			; BREQ	_B010
	!WORD	_B010-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F044 	!WORD	_D041+0		
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$70			; SB
_B010 
_B011 
; samplesrc/rogue.map.pla: 0238: end
	!BYTE	$5A,$08			; LEAVE	8
; samplesrc/rogue.map.pla: 0239: 
; samplesrc/rogue.map.pla: 0240: export def updtmaptile(xmap, ymap, tile)#0
					; xmap -> [0]
					; ymap -> [2]
					; tile -> [4]
_C003 					; updtmaptile()
; samplesrc/rogue.map.pla: 0241:   word imap
					; imap -> [6]
; samplesrc/rogue.map.pla: 0242: 
; samplesrc/rogue.map.pla: 0243:   imap = (ymap << rowshift) + xmap
	!BYTE	$58,$08,$03		; ENTER	8,3
; samplesrc/rogue.map.pla: 0244:   ^(map + imap) = (^(map + imap) & LIT_TILE) | tile
; samplesrc/rogue.map.pla: 0245:   if ^(viewmap + imap) <> $A0
; samplesrc/rogue.map.pla: 0246:     ^(viewmap + imap) = tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0247:   fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$6A			; LAW	_D040+0
_F045 	!WORD	_D040+0		
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$60			; LB
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$96			; OR 
	!BYTE	$6A			; LAW	_D040+0
_F046 	!WORD	_D040+0		
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D041+0
_F047 	!WORD	_D041+0		
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$60			; LB
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$22			; BREQ	_B012
	!WORD	_B012-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F048 	!WORD	_D041+0		
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$70			; SB
_B012 
_B013 
; samplesrc/rogue.map.pla: 0248: end
	!BYTE	$5A,$08			; LEAVE	8
; samplesrc/rogue.map.pla: 0249: 
; samplesrc/rogue.map.pla: 0250: //
; samplesrc/rogue.map.pla: 0251: // Light torches in map
; samplesrc/rogue.map.pla: 0252: //
; samplesrc/rogue.map.pla: 0253: 
; samplesrc/rogue.map.pla: 0254: export def lighttorches#0
_C004 					; lighttorches()
; samplesrc/rogue.map.pla: 0255:   word imap, tmap, rowmap
					; imap -> [0]
					; tmap -> [2]
					; rowmap -> [4]
; samplesrc/rogue.map.pla: 0256:   byte xmap, ymap, xt, yt
					; xmap -> [6]
					; ymap -> [7]
					; xt -> [8]
					; yt -> [9]
; samplesrc/rogue.map.pla: 0257: 
; samplesrc/rogue.map.pla: 0258:   for ymap = 1 to maprows - 2
	!BYTE	$58,$0A,$00		; ENTER	10,0
	!BYTE	$2A,$3E			; CB	62
	!BYTE	$02			; CN	1
_B015 
	!BYTE	$6C,$07			; DLB	[7]
; samplesrc/rogue.map.pla: 0259:     rowmap = map + (ymap << rowshift)
; samplesrc/rogue.map.pla: 0260:     for xmap = 1 to mapcols - 2
	!BYTE	$6A			; LAW	_D040+0
_F049 	!WORD	_D040+0		
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$82			; ADD 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$2A,$3E			; CB	62
	!BYTE	$02			; CN	1
_B018 
	!BYTE	$6C,$06			; DLB	[6]
; samplesrc/rogue.map.pla: 0261:       imap = rowmap + xmap
; samplesrc/rogue.map.pla: 0262:       if ^imap & MAP_TILE == TORCH_TILE
; samplesrc/rogue.map.pla: 0263:         for yt = ymap - 1 to ymap + 1
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$B0,$06			; ADDLB	[6]
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$2A,$2A			; CB	42
	!BYTE	$24			; BRNE	_B020
	!WORD	_B020-*
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$8C			; INCR
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$8E			; DECR
	!BYTE	$A0			; BRGT	_B022
	!WORD	_B022-*
_B023 
	!BYTE	$6C,$09			; DLB	[9]
; samplesrc/rogue.map.pla: 0264:           imap = map + (yt << rowshift)
; samplesrc/rogue.map.pla: 0265:           for xt = xmap - 1 to xmap + 1
	!BYTE	$6A			; LAW	_D040+0
_F050 	!WORD	_D040+0		
	!BYTE	$64,$09			; LLB	[9]
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$82			; ADD 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$8C			; INCR
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$8E			; DECR
	!BYTE	$A0			; BRGT	_B025
	!WORD	_B025-*
_B026 
	!BYTE	$6C,$08			; DLB	[8]
; samplesrc/rogue.map.pla: 0266:             tmap = imap + xt
; samplesrc/rogue.map.pla: 0267:             ^tmap = ^tmap | LIT_TILE
; samplesrc/rogue.map.pla: 0268:           next
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$08			; ADDLB	[8]
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$60			; LB
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
_B027 
	!BYTE	$A4			; INCBRLE	_B026
	!WORD	_B026-*
_B025 
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0269:         next
_B024 
	!BYTE	$A4			; INCBRLE	_B023
	!WORD	_B023-*
_B022 
	!BYTE	$74,$09			; SLB	[9]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0270:       fin
_B020 
_B021 
; samplesrc/rogue.map.pla: 0271:     next
_B019 
	!BYTE	$A4			; INCBRLE	_B018
	!WORD	_B018-*
_B017 
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0272:     if not (ymap & 7)
; samplesrc/rogue.map.pla: 0273:       putc('.')
; samplesrc/rogue.map.pla: 0274:     fin
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$4E			; BRTRU	_B028
	!WORD	_B028-*
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X002
_F051 	!WORD	0		
_B028 
_B029 
; samplesrc/rogue.map.pla: 0275:   next
_B016 
	!BYTE	$A4			; INCBRLE	_B015
	!WORD	_B015-*
_B014 
	!BYTE	$74,$07			; SLB	[7]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0276: end
	!BYTE	$5A,$0A			; LEAVE	10
; samplesrc/rogue.map.pla: 0277: 
; samplesrc/rogue.map.pla: 0278: //
; samplesrc/rogue.map.pla: 0279: // Animate tiles in map
; samplesrc/rogue.map.pla: 0280: //
; samplesrc/rogue.map.pla: 0281: 
; samplesrc/rogue.map.pla: 0282: export def animate(tile)
					; tile -> [0]
_C005 					; animate()
; samplesrc/rogue.map.pla: 0283:   if animseq
	!BYTE	$58,$02,$01		; ENTER	2,1
; samplesrc/rogue.map.pla: 0284:     when tile & MAP_TILE
	!BYTE	$68			; LAB	_D033+0
_F052 	!WORD	_D033+0		
	!BYTE	$4C			; BRFLS	_B030
	!WORD	_B030-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$52			; SEL
	!WORD	_B033-*
; samplesrc/rogue.map.pla: 0285:       is TORCH_TILE
_B034 
; samplesrc/rogue.map.pla: 0286:         tile = 'X'
; samplesrc/rogue.map.pla: 0287:         break
	!BYTE	$2A,$58			; CB	88
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B032
	!WORD	_B032-*
; samplesrc/rogue.map.pla: 0288:       is WATER1_TILE
_B035 
; samplesrc/rogue.map.pla: 0289:         tile = '('
; samplesrc/rogue.map.pla: 0290:         break         
	!BYTE	$2A,$28			; CB	40
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B032
	!WORD	_B032-*
; samplesrc/rogue.map.pla: 0291:       is WATER2_TILE
_B036 
; samplesrc/rogue.map.pla: 0292:         tile = ')'
; samplesrc/rogue.map.pla: 0293:         break
	!BYTE	$2A,$29			; CB	41
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B032
	!WORD	_B032-*
; samplesrc/rogue.map.pla: 0294:     wend
	!BYTE	$50			; BRNCH	_B032
	!WORD	_B032-*
_B033 
	!BYTE	$03			; CASEBLOCK
	!WORD	$002A
	!WORD	_B034-*
	!WORD	$003C
	!WORD	_B036-*
	!WORD	$003E
	!WORD	_B035-*
_B032 
; samplesrc/rogue.map.pla: 0295:   else
	!BYTE	$50			; BRNCH	_B031
	!WORD	_B031-*
_B030 
; samplesrc/rogue.map.pla: 0296:     when tile & MAP_TILE
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$52			; SEL
	!WORD	_B038-*
; samplesrc/rogue.map.pla: 0297:       is WATER1_TILE
_B039 
; samplesrc/rogue.map.pla: 0298:         tile = ')'
; samplesrc/rogue.map.pla: 0299:         break         
	!BYTE	$2A,$29			; CB	41
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B037
	!WORD	_B037-*
; samplesrc/rogue.map.pla: 0300:       is WATER2_TILE
_B040 
; samplesrc/rogue.map.pla: 0301:         tile = '('
; samplesrc/rogue.map.pla: 0302:         break
	!BYTE	$2A,$28			; CB	40
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B037
	!WORD	_B037-*
; samplesrc/rogue.map.pla: 0303:     wend
	!BYTE	$50			; BRNCH	_B037
	!WORD	_B037-*
_B038 
	!BYTE	$02			; CASEBLOCK
	!WORD	$003C
	!WORD	_B040-*
	!WORD	$003E
	!WORD	_B039-*
_B037 
; samplesrc/rogue.map.pla: 0304:   fin
_B031 
; samplesrc/rogue.map.pla: 0305:   return tile & INV_TILE
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$3F			; ANDI	63
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rogue.map.pla: 0306: end
; samplesrc/rogue.map.pla: 0307: 
; samplesrc/rogue.map.pla: 0308: //
; samplesrc/rogue.map.pla: 0309: // Draw the map. Return 0 if any light visible, 1 if in complete darkness
; samplesrc/rogue.map.pla: 0310: //
; samplesrc/rogue.map.pla: 0311: 
; samplesrc/rogue.map.pla: 0312: export def drawmap(xorg, yorg, viewfield, viewdir, lightdist, viewdist)
					; xorg -> [0]
					; yorg -> [2]
					; viewfield -> [4]
					; viewdir -> [6]
					; lightdist -> [8]
					; viewdist -> [10]
_C006 					; drawmap()
; samplesrc/rogue.map.pla: 0313:   byte l, dist, tile, adjtile, occluded, darkness
					; l -> [12]
					; dist -> [13]
					; tile -> [14]
					; adjtile -> [15]
					; occluded -> [16]
					; darkness -> [17]
; samplesrc/rogue.map.pla: 0314:   word ymap, xmap, imap, o
					; ymap -> [18]
					; xmap -> [20]
					; imap -> [22]
					; o -> [24]
; samplesrc/rogue.map.pla: 0315:   byte yscr, xscr
					; yscr -> [26]
					; xscr -> [27]
; samplesrc/rogue.map.pla: 0316: 
; samplesrc/rogue.map.pla: 0317:   if viewdist > beamdepth
	!BYTE	$58,$1C,$06		; ENTER	28,6
; samplesrc/rogue.map.pla: 0318:     viewdist = beamdepth
; samplesrc/rogue.map.pla: 0319:   fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$2A,$17			; CB	23
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B041
	!WORD	_B041-*
	!BYTE	$2A,$17			; CB	23
	!BYTE	$76,$0A			; SLW	[10]
_B041 
_B042 
; samplesrc/rogue.map.pla: 0320:   if lightdist > viewdist
; samplesrc/rogue.map.pla: 0321:     lightdist = viewdist
; samplesrc/rogue.map.pla: 0322:   fin
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B043
	!WORD	_B043-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$76,$08			; SLW	[8]
_B043 
_B044 
; samplesrc/rogue.map.pla: 0323:   //
; samplesrc/rogue.map.pla: 0324:   // Clear screen
; samplesrc/rogue.map.pla: 0325:   //
; samplesrc/rogue.map.pla: 0326:   memset(@screenbuffer, $A0A0, scrnheight * scrnwidth)
; samplesrc/rogue.map.pla: 0327:   //
; samplesrc/rogue.map.pla: 0328:   // Draw background map if in light
; samplesrc/rogue.map.pla: 0329:   //
; samplesrc/rogue.map.pla: 0330:   darkness = 1
; samplesrc/rogue.map.pla: 0331:   imap     = (yorg << rowshift) + xorg
; samplesrc/rogue.map.pla: 0332:   if lightdist or ^(map + imap) & LIT_TILE
; samplesrc/rogue.map.pla: 0333:     //
; samplesrc/rogue.map.pla: 0334:     // Update current spot in viewmap
; samplesrc/rogue.map.pla: 0335:     //
; samplesrc/rogue.map.pla: 0336:     ^(viewmap + imap) = ^(map + imap) | VIEWED_TILE
; samplesrc/rogue.map.pla: 0337:     //
; samplesrc/rogue.map.pla: 0338:     // Draw the viewmap
; samplesrc/rogue.map.pla: 0339:     //
; samplesrc/rogue.map.pla: 0340:     xmap = xorg - xcentr
; samplesrc/rogue.map.pla: 0341:     if xmap < 0
; samplesrc/rogue.map.pla: 0342:       l    = mapcols
; samplesrc/rogue.map.pla: 0343:       xscr = -xmap
; samplesrc/rogue.map.pla: 0344:       xmap = 0
; samplesrc/rogue.map.pla: 0345:     else
	!BYTE	$26			; LA	_D042+0
_F053 	!WORD	_D042+0		
	!BYTE	$2C,$A0,$A0		; CW	41120
	!BYTE	$2C,$70,$03		; CW	880
	!BYTE	$54			; CALL	_X017
_F054 	!WORD	0		
	!BYTE	$02			; CN	1
	!BYTE	$74,$11			; SLB	[17]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$AE			; BROR	_B045
	!WORD	_B045-*
	!BYTE	$6A			; LAW	_D040+0
_F055 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$3C,$80			; ANDI	128
_B045 
	!BYTE	$4C			; BRFLS	_B046
	!WORD	_B046-*
	!BYTE	$6A			; LAW	_D040+0
_F056 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F057 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3A,$14			; SUBI	20
	!BYTE	$6E,$14			; DLW	[20]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B048
	!WORD	_B048-*
	!BYTE	$2A,$40			; CB	64
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$90			; NEG
	!BYTE	$74,$1B			; SLB	[27]
	!BYTE	$00			; CN	0
	!BYTE	$76,$14			; SLW	[20]
	!BYTE	$50			; BRNCH	_B049
	!WORD	_B049-*
_B048 
; samplesrc/rogue.map.pla: 0346:       l    = mapcols - xmap
; samplesrc/rogue.map.pla: 0347:       xscr = 0
; samplesrc/rogue.map.pla: 0348:     fin
	!BYTE	$2A,$40			; CB	64
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$84			; SUB 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$00			; CN	0
	!BYTE	$74,$1B			; SLB	[27]
_B049 
; samplesrc/rogue.map.pla: 0349:     if xscr + l > scrnwidth
; samplesrc/rogue.map.pla: 0350:       l = scrnwidth - xscr
; samplesrc/rogue.map.pla: 0351:     fin
	!BYTE	$64,$1B			; LLB	[27]
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$2A,$28			; CB	40
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B050
	!WORD	_B050-*
	!BYTE	$2A,$28			; CB	40
	!BYTE	$64,$1B			; LLB	[27]
	!BYTE	$84			; SUB 
	!BYTE	$74,$0C			; SLB	[12]
_B050 
_B051 
; samplesrc/rogue.map.pla: 0352:     for yscr = 0 to scrnheight
	!BYTE	$2A,$16			; CB	22
	!BYTE	$00			; CN	0
_B053 
	!BYTE	$6C,$1A			; DLB	[26]
; samplesrc/rogue.map.pla: 0353:       ymap = yscr - ycentr + yorg
; samplesrc/rogue.map.pla: 0354:       if ymap >= 0 and ymap < maprows
; samplesrc/rogue.map.pla: 0355:         memcpy(screen[yscr] + xscr, viewmap + (ymap << rowshift) + xmap, l)
; samplesrc/rogue.map.pla: 0356:       fin
	!BYTE	$64,$1A			; LLB	[26]
	!BYTE	$3A,$0C			; SUBI	12
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$6E,$12			; DLW	[18]
	!BYTE	$00			; CN	0
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B055
	!WORD	_B055-*
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$2A,$40			; CB	64
	!BYTE	$46			; ISLT
_B055 
	!BYTE	$4C			; BRFLS	_B056
	!WORD	_B056-*
	!BYTE	$26			; LA	_D044+0
_F058 	!WORD	_D044+0		
	!BYTE	$B8,$1A			; IDXLB	[26]
	!BYTE	$62			; LW
	!BYTE	$B0,$1B			; ADDLB	[27]
	!BYTE	$6A			; LAW	_D041+0
_F059 	!WORD	_D041+0		
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$82			; ADD 
	!BYTE	$B2,$14			; ADDLW	[20]
	!BYTE	$64,$0C			; LLB	[12]
	!BYTE	$54			; CALL	_X018
_F060 	!WORD	0		
_B056 
_B057 
; samplesrc/rogue.map.pla: 0357:     next
_B054 
	!BYTE	$A4			; INCBRLE	_B053
	!WORD	_B053-*
_B052 
	!BYTE	$74,$1A			; SLB	[26]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0358:     darkness = 0
; samplesrc/rogue.map.pla: 0359:   fin
	!BYTE	$00			; CN	0
	!BYTE	$74,$11			; SLB	[17]
_B046 
_B047 
; samplesrc/rogue.map.pla: 0360:   //
; samplesrc/rogue.map.pla: 0361:   // Draw visible octants
; samplesrc/rogue.map.pla: 0362:   //
; samplesrc/rogue.map.pla: 0363:   for o = viewdir - viewfield - 1 to viewdir + viewfield
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$84			; SUB 
	!BYTE	$8E			; DECR
	!BYTE	$A0			; BRGT	_B058
	!WORD	_B058-*
_B059 
	!BYTE	$6E,$18			; DLW	[24]
; samplesrc/rogue.map.pla: 0364:     dist     = lightdist + 1
; samplesrc/rogue.map.pla: 0365:     occluded = 1
; samplesrc/rogue.map.pla: 0366:     when o & 7
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8C			; INCR
	!BYTE	$74,$0D			; SLB	[13]
	!BYTE	$02			; CN	1
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$66,$18			; LLW	[24]
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$52			; SEL
	!WORD	_B062-*
; samplesrc/rogue.map.pla: 0367:       is 0
_B063 
; samplesrc/rogue.map.pla: 0368:         //
; samplesrc/rogue.map.pla: 0369:         // Run through lit octant beam points
; samplesrc/rogue.map.pla: 0370:         //
; samplesrc/rogue.map.pla: 0371:         for l = 1 to dbeam[lightdist]
	!BYTE	$26			; LA	_D034+0
_F061 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B064
	!WORD	_B064-*
_B065 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0372:           //
; samplesrc/rogue.map.pla: 0373:           // Check parent visiblity
; samplesrc/rogue.map.pla: 0374:           //
; samplesrc/rogue.map.pla: 0375:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0376:             imap = ((yorg - ybeam[l]) << rowshift) + xorg + xbeam[l]
; samplesrc/rogue.map.pla: 0377:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0378:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0379:               //
; samplesrc/rogue.map.pla: 0380:               // The view stops here
; samplesrc/rogue.map.pla: 0381:               //
; samplesrc/rogue.map.pla: 0382:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0383:             else
	!BYTE	$26			; LA	_D038+0
_F062 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F063 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B067
	!WORD	_B067-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D036+0
_F064 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D035+0
_F065 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F066 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B069
	!WORD	_B069-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F067 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B070
	!WORD	_B070-*
_B069 
; samplesrc/rogue.map.pla: 0384:               //
; samplesrc/rogue.map.pla: 0385:               // This tile is transparent
; samplesrc/rogue.map.pla: 0386:               //
; samplesrc/rogue.map.pla: 0387:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0388:               //
; samplesrc/rogue.map.pla: 0389:               // Check adjacent tile for opaqueness - improves wall display
; samplesrc/rogue.map.pla: 0390:               //
; samplesrc/rogue.map.pla: 0391:               adjtile = ^(map + imap + 1) & INV_TILE
; samplesrc/rogue.map.pla: 0392:               if adjtile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0393:                 ^(viewmap + imap + 1) = adjtile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0394:                 screen.[ycentr-ybeam[l], xcentr+xbeam[l]+1] = adjtile
; samplesrc/rogue.map.pla: 0395:               fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F068 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D040+0
_F069 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$3C,$3F			; ANDI	63
	!BYTE	$6C,$0F			; DLB	[15]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B071
	!WORD	_B071-*
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F070 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$26			; LA	_D044+0
_F071 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D036+0
_F072 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D035+0
_F073 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B071 
_B072 
; samplesrc/rogue.map.pla: 0396:             fin
_B070 
; samplesrc/rogue.map.pla: 0397:             //
; samplesrc/rogue.map.pla: 0398:             // Update view
; samplesrc/rogue.map.pla: 0399:             //
; samplesrc/rogue.map.pla: 0400:             ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0401:             if tile <> PIT_TILE
; samplesrc/rogue.map.pla: 0402:               screen.[ycentr-ybeam[l], xcentr+xbeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0403:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F074 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B073
	!WORD	_B073-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F075 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F076 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D036+0
_F077 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D035+0
_F078 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B073 
_B074 
; samplesrc/rogue.map.pla: 0404:           else
	!BYTE	$50			; BRNCH	_B068
	!WORD	_B068-*
_B067 
; samplesrc/rogue.map.pla: 0405:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0406:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F079 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B068 
; samplesrc/rogue.map.pla: 0407:         next
_B066 
	!BYTE	$A4			; INCBRLE	_B065
	!WORD	_B065-*
_B064 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0408:         //
; samplesrc/rogue.map.pla: 0409:         // Run through visible octant beam points
; samplesrc/rogue.map.pla: 0410:         //
; samplesrc/rogue.map.pla: 0411:         for l = dbeam[lightdist]+1 to dbeam[viewdist]
	!BYTE	$26			; LA	_D034+0
_F080 	!WORD	_D034+0		
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D034+0
_F081 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$A0			; BRGT	_B075
	!WORD	_B075-*
_B076 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0412:           //
; samplesrc/rogue.map.pla: 0413:           // Check parent visiblity
; samplesrc/rogue.map.pla: 0414:           //
; samplesrc/rogue.map.pla: 0415:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0416:             imap = ((yorg - ybeam[l]) << rowshift) + xorg + xbeam[l]
; samplesrc/rogue.map.pla: 0417:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0418:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0419:               //
; samplesrc/rogue.map.pla: 0420:               // The view stops here
; samplesrc/rogue.map.pla: 0421:               //
; samplesrc/rogue.map.pla: 0422:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0423:             else
	!BYTE	$26			; LA	_D038+0
_F082 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F083 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B078
	!WORD	_B078-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D036+0
_F084 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D035+0
_F085 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F086 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B080
	!WORD	_B080-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F087 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B081
	!WORD	_B081-*
_B080 
; samplesrc/rogue.map.pla: 0424:               //
; samplesrc/rogue.map.pla: 0425:               // This tile is transparent
; samplesrc/rogue.map.pla: 0426:               //
; samplesrc/rogue.map.pla: 0427:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0428:               occluded  = 0
; samplesrc/rogue.map.pla: 0429:             fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F088 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$10			; SLB	[16]
_B081 
; samplesrc/rogue.map.pla: 0430:             //
; samplesrc/rogue.map.pla: 0431:             // If the tile is in light, update view
; samplesrc/rogue.map.pla: 0432:             //
; samplesrc/rogue.map.pla: 0433:             if tile & LIT_TILE
; samplesrc/rogue.map.pla: 0434:               ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0435:               screen.[ycentr-ybeam[l], xcentr+xbeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0436:               darkness = 0
; samplesrc/rogue.map.pla: 0437:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B082
	!WORD	_B082-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F089 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F090 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F091 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D036+0
_F092 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D035+0
_F093 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$11			; SLB	[17]
_B082 
_B083 
; samplesrc/rogue.map.pla: 0438:           else
	!BYTE	$50			; BRNCH	_B079
	!WORD	_B079-*
_B078 
; samplesrc/rogue.map.pla: 0439:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0440:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F094 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B079 
; samplesrc/rogue.map.pla: 0441:           //
; samplesrc/rogue.map.pla: 0442:           // Advance beam distance
; samplesrc/rogue.map.pla: 0443:           //
; samplesrc/rogue.map.pla: 0444:           if l == dbeam[dist]
; samplesrc/rogue.map.pla: 0445:             if occluded
; samplesrc/rogue.map.pla: 0446:               //
; samplesrc/rogue.map.pla: 0447:               // Beam fully occluded
; samplesrc/rogue.map.pla: 0448:               //
; samplesrc/rogue.map.pla: 0449:               break
	!BYTE	$64,$0C			; LLB	[12]
	!BYTE	$26			; LA	_D034+0
_F095 	!WORD	_D034+0		
	!BYTE	$B0,$0D			; ADDLB	[13]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B084
	!WORD	_B084-*
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$4C			; BRFLS	_B086
	!WORD	_B086-*
	!BYTE	$50			; BRNCH	_B075
	!WORD	_B075-*
; samplesrc/rogue.map.pla: 0450:             fin
_B086 
_B087 
; samplesrc/rogue.map.pla: 0451:             //
; samplesrc/rogue.map.pla: 0452:             // Update distance
; samplesrc/rogue.map.pla: 0453:             //
; samplesrc/rogue.map.pla: 0454:             occluded = 1
; samplesrc/rogue.map.pla: 0455:             dist++
	!BYTE	$02			; CN	1
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$8C			; INCR
; samplesrc/rogue.map.pla: 0456:           fin
	!BYTE	$74,$0D			; SLB	[13]
_B084 
_B085 
; samplesrc/rogue.map.pla: 0457:         next
_B077 
	!BYTE	$A4			; INCBRLE	_B076
	!WORD	_B076-*
_B075 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0458:         break
	!BYTE	$50			; BRNCH	_B061
	!WORD	_B061-*
; samplesrc/rogue.map.pla: 0459:       is 1
_B088 
; samplesrc/rogue.map.pla: 0460:         for l = 1 to dbeam[lightdist]
	!BYTE	$26			; LA	_D034+0
_F096 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B089
	!WORD	_B089-*
_B090 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0461:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0462:             imap = ((yorg - xbeam[l]) << rowshift) + xorg + ybeam[l]
; samplesrc/rogue.map.pla: 0463:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0464:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0465:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0466:             else
	!BYTE	$26			; LA	_D038+0
_F097 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F098 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B092
	!WORD	_B092-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D035+0
_F099 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D036+0
_F100 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F101 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B094
	!WORD	_B094-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F102 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B095
	!WORD	_B095-*
_B094 
; samplesrc/rogue.map.pla: 0467:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0468:               adjtile = ^(map + imap - mapcols) & INV_TILE
; samplesrc/rogue.map.pla: 0469:               if adjtile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0470:                 ^(viewmap + imap - mapcols) = adjtile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0471:                 screen.[ycentr-xbeam[l]-1, xcentr+ybeam[l]] = adjtile
; samplesrc/rogue.map.pla: 0472:               fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F103 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D040+0
_F104 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$3A,$40			; SUBI	64
	!BYTE	$60			; LB
	!BYTE	$3C,$3F			; ANDI	63
	!BYTE	$6C,$0F			; DLB	[15]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B096
	!WORD	_B096-*
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F105 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$3A,$40			; SUBI	64
	!BYTE	$70			; SB
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$26			; LA	_D044+0
_F106 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D035+0
_F107 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D036+0
_F108 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B096 
_B097 
; samplesrc/rogue.map.pla: 0473:             fin
_B095 
; samplesrc/rogue.map.pla: 0474:             ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0475:             if tile <> PIT_TILE
; samplesrc/rogue.map.pla: 0476:               screen.[ycentr-xbeam[l], xcentr+ybeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0477:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F109 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B098
	!WORD	_B098-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F110 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F111 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D035+0
_F112 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D036+0
_F113 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B098 
_B099 
; samplesrc/rogue.map.pla: 0478:           else
	!BYTE	$50			; BRNCH	_B093
	!WORD	_B093-*
_B092 
; samplesrc/rogue.map.pla: 0479:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0480:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F114 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B093 
; samplesrc/rogue.map.pla: 0481:         next
_B091 
	!BYTE	$A4			; INCBRLE	_B090
	!WORD	_B090-*
_B089 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0482:         for l = dbeam[lightdist]+1 to dbeam[viewdist]
	!BYTE	$26			; LA	_D034+0
_F115 	!WORD	_D034+0		
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D034+0
_F116 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$A0			; BRGT	_B100
	!WORD	_B100-*
_B101 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0483:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0484:             imap = ((yorg - xbeam[l]) << rowshift) + xorg + ybeam[l]
; samplesrc/rogue.map.pla: 0485:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0486:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0487:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0488:             else
	!BYTE	$26			; LA	_D038+0
_F117 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F118 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B103
	!WORD	_B103-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D035+0
_F119 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D036+0
_F120 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F121 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B105
	!WORD	_B105-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F122 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B106
	!WORD	_B106-*
_B105 
; samplesrc/rogue.map.pla: 0489:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0490:               occluded  = 0
; samplesrc/rogue.map.pla: 0491:             fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F123 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$10			; SLB	[16]
_B106 
; samplesrc/rogue.map.pla: 0492:             if tile & LIT_TILE
; samplesrc/rogue.map.pla: 0493:               ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0494:               screen.[ycentr-xbeam[l], xcentr+ybeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0495:               darkness = 0
; samplesrc/rogue.map.pla: 0496:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B107
	!WORD	_B107-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F124 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F125 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F126 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D035+0
_F127 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D036+0
_F128 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$11			; SLB	[17]
_B107 
_B108 
; samplesrc/rogue.map.pla: 0497:           else
	!BYTE	$50			; BRNCH	_B104
	!WORD	_B104-*
_B103 
; samplesrc/rogue.map.pla: 0498:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0499:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F129 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B104 
; samplesrc/rogue.map.pla: 0500:           if l == dbeam[dist]
; samplesrc/rogue.map.pla: 0501:             if occluded
; samplesrc/rogue.map.pla: 0502:               break
	!BYTE	$64,$0C			; LLB	[12]
	!BYTE	$26			; LA	_D034+0
_F130 	!WORD	_D034+0		
	!BYTE	$B0,$0D			; ADDLB	[13]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B109
	!WORD	_B109-*
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$4C			; BRFLS	_B111
	!WORD	_B111-*
	!BYTE	$50			; BRNCH	_B100
	!WORD	_B100-*
; samplesrc/rogue.map.pla: 0503:             fin
_B111 
_B112 
; samplesrc/rogue.map.pla: 0504:             occluded = 1
; samplesrc/rogue.map.pla: 0505:             dist++
	!BYTE	$02			; CN	1
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$8C			; INCR
; samplesrc/rogue.map.pla: 0506:           fin
	!BYTE	$74,$0D			; SLB	[13]
_B109 
_B110 
; samplesrc/rogue.map.pla: 0507:         next
_B102 
	!BYTE	$A4			; INCBRLE	_B101
	!WORD	_B101-*
_B100 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0508:         break
	!BYTE	$50			; BRNCH	_B061
	!WORD	_B061-*
; samplesrc/rogue.map.pla: 0509:       is 2
_B113 
; samplesrc/rogue.map.pla: 0510:         for l = 1 to dbeam[lightdist]
	!BYTE	$26			; LA	_D034+0
_F131 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B114
	!WORD	_B114-*
_B115 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0511:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0512:             imap = ((yorg + xbeam[l]) << rowshift) + xorg + ybeam[l]
; samplesrc/rogue.map.pla: 0513:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0514:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0515:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0516:             else
	!BYTE	$26			; LA	_D038+0
_F132 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F133 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B117
	!WORD	_B117-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D035+0
_F134 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D036+0
_F135 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F136 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B119
	!WORD	_B119-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F137 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B120
	!WORD	_B120-*
_B119 
; samplesrc/rogue.map.pla: 0517:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0518:               adjtile = ^(map + imap + mapcols) & INV_TILE
; samplesrc/rogue.map.pla: 0519:               if adjtile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0520:                 ^(viewmap + imap + mapcols) = adjtile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0521:                 screen.[ycentr+xbeam[l]+1, xcentr+ybeam[l]] = adjtile
; samplesrc/rogue.map.pla: 0522:               fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F138 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D040+0
_F139 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$38,$40			; ADDI	64
	!BYTE	$60			; LB
	!BYTE	$3C,$3F			; ANDI	63
	!BYTE	$6C,$0F			; DLB	[15]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B121
	!WORD	_B121-*
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F140 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$38,$40			; ADDI	64
	!BYTE	$70			; SB
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$26			; LA	_D044+0
_F141 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D035+0
_F142 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D036+0
_F143 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B121 
_B122 
; samplesrc/rogue.map.pla: 0523:             fin
_B120 
; samplesrc/rogue.map.pla: 0524:             ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0525:             if tile <> PIT_TILE
; samplesrc/rogue.map.pla: 0526:               screen.[ycentr+xbeam[l], xcentr+ybeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0527:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F144 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B123
	!WORD	_B123-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F145 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F146 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D035+0
_F147 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D036+0
_F148 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B123 
_B124 
; samplesrc/rogue.map.pla: 0528:           else
	!BYTE	$50			; BRNCH	_B118
	!WORD	_B118-*
_B117 
; samplesrc/rogue.map.pla: 0529:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0530:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F149 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B118 
; samplesrc/rogue.map.pla: 0531:         next
_B116 
	!BYTE	$A4			; INCBRLE	_B115
	!WORD	_B115-*
_B114 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0532:         for l = dbeam[lightdist]+1 to dbeam[viewdist]
	!BYTE	$26			; LA	_D034+0
_F150 	!WORD	_D034+0		
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D034+0
_F151 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$A0			; BRGT	_B125
	!WORD	_B125-*
_B126 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0533:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0534:             imap = ((yorg + xbeam[l]) << rowshift) + xorg + ybeam[l]
; samplesrc/rogue.map.pla: 0535:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0536:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0537:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0538:             else
	!BYTE	$26			; LA	_D038+0
_F152 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F153 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B128
	!WORD	_B128-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D035+0
_F154 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D036+0
_F155 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F156 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B130
	!WORD	_B130-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F157 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B131
	!WORD	_B131-*
_B130 
; samplesrc/rogue.map.pla: 0539:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0540:               occluded  = 0
; samplesrc/rogue.map.pla: 0541:             fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F158 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$10			; SLB	[16]
_B131 
; samplesrc/rogue.map.pla: 0542:             if tile & LIT_TILE
; samplesrc/rogue.map.pla: 0543:               ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0544:               screen.[ycentr+xbeam[l], xcentr+ybeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0545:               darkness = 0
; samplesrc/rogue.map.pla: 0546:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B132
	!WORD	_B132-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F159 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F160 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F161 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D035+0
_F162 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D036+0
_F163 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$11			; SLB	[17]
_B132 
_B133 
; samplesrc/rogue.map.pla: 0547:           else
	!BYTE	$50			; BRNCH	_B129
	!WORD	_B129-*
_B128 
; samplesrc/rogue.map.pla: 0548:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0549:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F164 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B129 
; samplesrc/rogue.map.pla: 0550:           if l == dbeam[dist]
; samplesrc/rogue.map.pla: 0551:             if occluded
; samplesrc/rogue.map.pla: 0552:               break
	!BYTE	$64,$0C			; LLB	[12]
	!BYTE	$26			; LA	_D034+0
_F165 	!WORD	_D034+0		
	!BYTE	$B0,$0D			; ADDLB	[13]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B134
	!WORD	_B134-*
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$4C			; BRFLS	_B136
	!WORD	_B136-*
	!BYTE	$50			; BRNCH	_B125
	!WORD	_B125-*
; samplesrc/rogue.map.pla: 0553:             fin
_B136 
_B137 
; samplesrc/rogue.map.pla: 0554:             occluded = 1
; samplesrc/rogue.map.pla: 0555:             dist++
	!BYTE	$02			; CN	1
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$8C			; INCR
; samplesrc/rogue.map.pla: 0556:           fin
	!BYTE	$74,$0D			; SLB	[13]
_B134 
_B135 
; samplesrc/rogue.map.pla: 0557:         next
_B127 
	!BYTE	$A4			; INCBRLE	_B126
	!WORD	_B126-*
_B125 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0558:         break
	!BYTE	$50			; BRNCH	_B061
	!WORD	_B061-*
; samplesrc/rogue.map.pla: 0559:       is 3
_B138 
; samplesrc/rogue.map.pla: 0560:         for l = 1 to dbeam[lightdist]
	!BYTE	$26			; LA	_D034+0
_F166 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B139
	!WORD	_B139-*
_B140 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0561:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0562:             imap = ((yorg + ybeam[l]) << rowshift) + xorg + xbeam[l]
; samplesrc/rogue.map.pla: 0563:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0564:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0565:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0566:             else
	!BYTE	$26			; LA	_D038+0
_F167 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F168 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B142
	!WORD	_B142-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D036+0
_F169 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D035+0
_F170 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F171 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B144
	!WORD	_B144-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F172 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B145
	!WORD	_B145-*
_B144 
; samplesrc/rogue.map.pla: 0567:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0568:               adjtile = ^(map + imap + 1) & INV_TILE
; samplesrc/rogue.map.pla: 0569:               if  adjtile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0570:                 ^(viewmap + imap + 1) = adjtile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0571:                 screen.[ycentr+ybeam[l], xcentr+xbeam[l]+1] = adjtile
; samplesrc/rogue.map.pla: 0572:               fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F173 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D040+0
_F174 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$3C,$3F			; ANDI	63
	!BYTE	$6C,$0F			; DLB	[15]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B146
	!WORD	_B146-*
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F175 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$26			; LA	_D044+0
_F176 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D036+0
_F177 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D035+0
_F178 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B146 
_B147 
; samplesrc/rogue.map.pla: 0573:             fin
_B145 
; samplesrc/rogue.map.pla: 0574:             ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0575:             if tile <> PIT_TILE
; samplesrc/rogue.map.pla: 0576:               screen.[ycentr+ybeam[l], xcentr+xbeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0577:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F179 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B148
	!WORD	_B148-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F180 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F181 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D036+0
_F182 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D035+0
_F183 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B148 
_B149 
; samplesrc/rogue.map.pla: 0578:           else
	!BYTE	$50			; BRNCH	_B143
	!WORD	_B143-*
_B142 
; samplesrc/rogue.map.pla: 0579:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0580:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F184 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B143 
; samplesrc/rogue.map.pla: 0581:         next
_B141 
	!BYTE	$A4			; INCBRLE	_B140
	!WORD	_B140-*
_B139 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0582:         for l = dbeam[lightdist]+1 to dbeam[viewdist]
	!BYTE	$26			; LA	_D034+0
_F185 	!WORD	_D034+0		
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D034+0
_F186 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$A0			; BRGT	_B150
	!WORD	_B150-*
_B151 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0583:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0584:             imap = ((yorg + ybeam[l]) << rowshift) + xorg + xbeam[l]
; samplesrc/rogue.map.pla: 0585:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0586:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0587:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0588:             else
	!BYTE	$26			; LA	_D038+0
_F187 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F188 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B153
	!WORD	_B153-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D036+0
_F189 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D035+0
_F190 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F191 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B155
	!WORD	_B155-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F192 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B156
	!WORD	_B156-*
_B155 
; samplesrc/rogue.map.pla: 0589:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0590:               occluded  = 0
; samplesrc/rogue.map.pla: 0591:             fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F193 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$10			; SLB	[16]
_B156 
; samplesrc/rogue.map.pla: 0592:             if tile & LIT_TILE
; samplesrc/rogue.map.pla: 0593:               ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0594:               screen.[ycentr+ybeam[l], xcentr+xbeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0595:               darkness = 0
; samplesrc/rogue.map.pla: 0596:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B157
	!WORD	_B157-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F194 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F195 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F196 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D036+0
_F197 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D035+0
_F198 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$11			; SLB	[17]
_B157 
_B158 
; samplesrc/rogue.map.pla: 0597:           else
	!BYTE	$50			; BRNCH	_B154
	!WORD	_B154-*
_B153 
; samplesrc/rogue.map.pla: 0598:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0599:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F199 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B154 
; samplesrc/rogue.map.pla: 0600:           if l == dbeam[dist]
; samplesrc/rogue.map.pla: 0601:             if occluded
; samplesrc/rogue.map.pla: 0602:               break
	!BYTE	$64,$0C			; LLB	[12]
	!BYTE	$26			; LA	_D034+0
_F200 	!WORD	_D034+0		
	!BYTE	$B0,$0D			; ADDLB	[13]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B159
	!WORD	_B159-*
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$4C			; BRFLS	_B161
	!WORD	_B161-*
	!BYTE	$50			; BRNCH	_B150
	!WORD	_B150-*
; samplesrc/rogue.map.pla: 0603:             fin
_B161 
_B162 
; samplesrc/rogue.map.pla: 0604:             occluded = 1
; samplesrc/rogue.map.pla: 0605:             dist++
	!BYTE	$02			; CN	1
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$8C			; INCR
; samplesrc/rogue.map.pla: 0606:           fin
	!BYTE	$74,$0D			; SLB	[13]
_B159 
_B160 
; samplesrc/rogue.map.pla: 0607:         next
_B152 
	!BYTE	$A4			; INCBRLE	_B151
	!WORD	_B151-*
_B150 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0608:         break
	!BYTE	$50			; BRNCH	_B061
	!WORD	_B061-*
; samplesrc/rogue.map.pla: 0609:       is 4
_B163 
; samplesrc/rogue.map.pla: 0610:         for l = 1 to dbeam[lightdist]
	!BYTE	$26			; LA	_D034+0
_F201 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B164
	!WORD	_B164-*
_B165 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0611:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0612:             imap = ((yorg + ybeam[l]) << rowshift) + xorg - xbeam[l]
; samplesrc/rogue.map.pla: 0613:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0614:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0615:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0616:             else
	!BYTE	$26			; LA	_D038+0
_F202 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F203 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B167
	!WORD	_B167-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D036+0
_F204 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D035+0
_F205 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F206 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B169
	!WORD	_B169-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F207 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B170
	!WORD	_B170-*
_B169 
; samplesrc/rogue.map.pla: 0617:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0618:               adjtile = ^(map + imap - 1) & INV_TILE
; samplesrc/rogue.map.pla: 0619:               if adjtile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0620:                 ^(viewmap + imap - 1) = adjtile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0621:                 screen.[ycentr+ybeam[l], xcentr-xbeam[l]-1] = adjtile
; samplesrc/rogue.map.pla: 0622:               fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F208 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D040+0
_F209 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$8E			; DECR
	!BYTE	$60			; LB
	!BYTE	$3C,$3F			; ANDI	63
	!BYTE	$6C,$0F			; DLB	[15]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B171
	!WORD	_B171-*
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F210 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$8E			; DECR
	!BYTE	$70			; SB
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$26			; LA	_D044+0
_F211 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D036+0
_F212 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D035+0
_F213 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$8E			; DECR
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B171 
_B172 
; samplesrc/rogue.map.pla: 0623:             fin
_B170 
; samplesrc/rogue.map.pla: 0624:             ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0625:             if tile <> PIT_TILE
; samplesrc/rogue.map.pla: 0626:               screen.[ycentr+ybeam[l], xcentr-xbeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0627:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F214 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B173
	!WORD	_B173-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F215 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F216 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D036+0
_F217 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D035+0
_F218 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B173 
_B174 
; samplesrc/rogue.map.pla: 0628:           else
	!BYTE	$50			; BRNCH	_B168
	!WORD	_B168-*
_B167 
; samplesrc/rogue.map.pla: 0629:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0630:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F219 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B168 
; samplesrc/rogue.map.pla: 0631:         next
_B166 
	!BYTE	$A4			; INCBRLE	_B165
	!WORD	_B165-*
_B164 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0632:         for l = dbeam[lightdist]+1 to dbeam[viewdist]
	!BYTE	$26			; LA	_D034+0
_F220 	!WORD	_D034+0		
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D034+0
_F221 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$A0			; BRGT	_B175
	!WORD	_B175-*
_B176 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0633:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0634:             imap = ((yorg + ybeam[l]) << rowshift) + xorg - xbeam[l]
; samplesrc/rogue.map.pla: 0635:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0636:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0637:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0638:             else
	!BYTE	$26			; LA	_D038+0
_F222 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F223 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B178
	!WORD	_B178-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D036+0
_F224 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D035+0
_F225 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F226 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B180
	!WORD	_B180-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F227 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B181
	!WORD	_B181-*
_B180 
; samplesrc/rogue.map.pla: 0639:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0640:               occluded  = 0
; samplesrc/rogue.map.pla: 0641:             fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F228 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$10			; SLB	[16]
_B181 
; samplesrc/rogue.map.pla: 0642:             if tile & LIT_TILE
; samplesrc/rogue.map.pla: 0643:               ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0644:               screen.[ycentr+ybeam[l], xcentr-xbeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0645:               darkness = 0
; samplesrc/rogue.map.pla: 0646:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B182
	!WORD	_B182-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F229 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F230 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F231 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D036+0
_F232 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D035+0
_F233 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$11			; SLB	[17]
_B182 
_B183 
; samplesrc/rogue.map.pla: 0647:           else
	!BYTE	$50			; BRNCH	_B179
	!WORD	_B179-*
_B178 
; samplesrc/rogue.map.pla: 0648:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0649:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F234 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B179 
; samplesrc/rogue.map.pla: 0650:           if l == dbeam[dist]
; samplesrc/rogue.map.pla: 0651:             if occluded
; samplesrc/rogue.map.pla: 0652:               break
	!BYTE	$64,$0C			; LLB	[12]
	!BYTE	$26			; LA	_D034+0
_F235 	!WORD	_D034+0		
	!BYTE	$B0,$0D			; ADDLB	[13]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B184
	!WORD	_B184-*
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$4C			; BRFLS	_B186
	!WORD	_B186-*
	!BYTE	$50			; BRNCH	_B175
	!WORD	_B175-*
; samplesrc/rogue.map.pla: 0653:             fin
_B186 
_B187 
; samplesrc/rogue.map.pla: 0654:             occluded = 1
; samplesrc/rogue.map.pla: 0655:             dist++
	!BYTE	$02			; CN	1
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$8C			; INCR
; samplesrc/rogue.map.pla: 0656:           fin
	!BYTE	$74,$0D			; SLB	[13]
_B184 
_B185 
; samplesrc/rogue.map.pla: 0657:         next
_B177 
	!BYTE	$A4			; INCBRLE	_B176
	!WORD	_B176-*
_B175 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0658:         break
	!BYTE	$50			; BRNCH	_B061
	!WORD	_B061-*
; samplesrc/rogue.map.pla: 0659:       is 5
_B188 
; samplesrc/rogue.map.pla: 0660:         for l = 1 to dbeam[lightdist]
	!BYTE	$26			; LA	_D034+0
_F236 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B189
	!WORD	_B189-*
_B190 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0661:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0662:             imap = ((yorg + xbeam[l]) << rowshift) + xorg - ybeam[l]
; samplesrc/rogue.map.pla: 0663:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0664:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0665:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0666:             else
	!BYTE	$26			; LA	_D038+0
_F237 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F238 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B192
	!WORD	_B192-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D035+0
_F239 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D036+0
_F240 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F241 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B194
	!WORD	_B194-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F242 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B195
	!WORD	_B195-*
_B194 
; samplesrc/rogue.map.pla: 0667:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0668:               adjtile = ^(map + imap + mapcols) & INV_TILE
; samplesrc/rogue.map.pla: 0669:               if adjtile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0670:                 ^(viewmap + imap + mapcols) = adjtile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0671:                 screen.[ycentr+xbeam[l]+1, xcentr-ybeam[l]] = adjtile
; samplesrc/rogue.map.pla: 0672:               fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F243 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D040+0
_F244 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$38,$40			; ADDI	64
	!BYTE	$60			; LB
	!BYTE	$3C,$3F			; ANDI	63
	!BYTE	$6C,$0F			; DLB	[15]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B196
	!WORD	_B196-*
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F245 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$38,$40			; ADDI	64
	!BYTE	$70			; SB
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$26			; LA	_D044+0
_F246 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D035+0
_F247 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D036+0
_F248 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B196 
_B197 
; samplesrc/rogue.map.pla: 0673:             fin
_B195 
; samplesrc/rogue.map.pla: 0674:             ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0675:             if tile <> PIT_TILE
; samplesrc/rogue.map.pla: 0676:               screen.[ycentr+xbeam[l], xcentr-ybeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0677:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F249 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B198
	!WORD	_B198-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F250 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F251 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D035+0
_F252 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D036+0
_F253 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B198 
_B199 
; samplesrc/rogue.map.pla: 0678:           else
	!BYTE	$50			; BRNCH	_B193
	!WORD	_B193-*
_B192 
; samplesrc/rogue.map.pla: 0679:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0680:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F254 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B193 
; samplesrc/rogue.map.pla: 0681:         next
_B191 
	!BYTE	$A4			; INCBRLE	_B190
	!WORD	_B190-*
_B189 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0682:         for l = dbeam[lightdist]+1 to dbeam[viewdist]
	!BYTE	$26			; LA	_D034+0
_F255 	!WORD	_D034+0		
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D034+0
_F256 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$A0			; BRGT	_B200
	!WORD	_B200-*
_B201 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0683:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0684:             imap = ((yorg + xbeam[l]) << rowshift) + xorg - ybeam[l]
; samplesrc/rogue.map.pla: 0685:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0686:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0687:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0688:             else
	!BYTE	$26			; LA	_D038+0
_F257 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F258 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B203
	!WORD	_B203-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D035+0
_F259 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D036+0
_F260 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F261 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B205
	!WORD	_B205-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F262 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B206
	!WORD	_B206-*
_B205 
; samplesrc/rogue.map.pla: 0689:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0690:               occluded  = 0
; samplesrc/rogue.map.pla: 0691:             fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F263 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$10			; SLB	[16]
_B206 
; samplesrc/rogue.map.pla: 0692:             if tile & LIT_TILE
; samplesrc/rogue.map.pla: 0693:               ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0694:               screen.[ycentr+xbeam[l], xcentr-ybeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0695:               darkness = 0
; samplesrc/rogue.map.pla: 0696:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B207
	!WORD	_B207-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F264 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F265 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F266 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D035+0
_F267 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D036+0
_F268 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$11			; SLB	[17]
_B207 
_B208 
; samplesrc/rogue.map.pla: 0697:           else
	!BYTE	$50			; BRNCH	_B204
	!WORD	_B204-*
_B203 
; samplesrc/rogue.map.pla: 0698:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0699:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F269 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B204 
; samplesrc/rogue.map.pla: 0700:           if l == dbeam[dist]
; samplesrc/rogue.map.pla: 0701:             if occluded
; samplesrc/rogue.map.pla: 0702:               break
	!BYTE	$64,$0C			; LLB	[12]
	!BYTE	$26			; LA	_D034+0
_F270 	!WORD	_D034+0		
	!BYTE	$B0,$0D			; ADDLB	[13]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B209
	!WORD	_B209-*
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$4C			; BRFLS	_B211
	!WORD	_B211-*
	!BYTE	$50			; BRNCH	_B200
	!WORD	_B200-*
; samplesrc/rogue.map.pla: 0703:             fin
_B211 
_B212 
; samplesrc/rogue.map.pla: 0704:             occluded = 1
; samplesrc/rogue.map.pla: 0705:             dist++
	!BYTE	$02			; CN	1
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$8C			; INCR
; samplesrc/rogue.map.pla: 0706:           fin
	!BYTE	$74,$0D			; SLB	[13]
_B209 
_B210 
; samplesrc/rogue.map.pla: 0707:         next
_B202 
	!BYTE	$A4			; INCBRLE	_B201
	!WORD	_B201-*
_B200 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0708:         break
	!BYTE	$50			; BRNCH	_B061
	!WORD	_B061-*
; samplesrc/rogue.map.pla: 0709:       is 6
_B213 
; samplesrc/rogue.map.pla: 0710:         for l = 1 to dbeam[lightdist]
	!BYTE	$26			; LA	_D034+0
_F271 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B214
	!WORD	_B214-*
_B215 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0711:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0712:             imap = ((yorg - xbeam[l]) << rowshift) + xorg - ybeam[l]
; samplesrc/rogue.map.pla: 0713:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0714:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0715:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0716:             else
	!BYTE	$26			; LA	_D038+0
_F272 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F273 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B217
	!WORD	_B217-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D035+0
_F274 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D036+0
_F275 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F276 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B219
	!WORD	_B219-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F277 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B220
	!WORD	_B220-*
_B219 
; samplesrc/rogue.map.pla: 0717:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0718:               adjtile = ^(map + imap - mapcols) & INV_TILE
; samplesrc/rogue.map.pla: 0719:               if adjtile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0720:                 ^(viewmap + imap - mapcols) = adjtile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0721:                 screen.[ycentr-xbeam[l]-1, xcentr-ybeam[l]] = adjtile
; samplesrc/rogue.map.pla: 0722:               fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F278 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D040+0
_F279 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$3A,$40			; SUBI	64
	!BYTE	$60			; LB
	!BYTE	$3C,$3F			; ANDI	63
	!BYTE	$6C,$0F			; DLB	[15]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B221
	!WORD	_B221-*
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F280 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$3A,$40			; SUBI	64
	!BYTE	$70			; SB
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$26			; LA	_D044+0
_F281 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D035+0
_F282 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D036+0
_F283 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B221 
_B222 
; samplesrc/rogue.map.pla: 0723:             fin
_B220 
; samplesrc/rogue.map.pla: 0724:             ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0725:             if tile <> PIT_TILE
; samplesrc/rogue.map.pla: 0726:               screen.[ycentr-xbeam[l], xcentr-ybeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0727:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F284 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B223
	!WORD	_B223-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F285 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F286 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D035+0
_F287 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D036+0
_F288 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B223 
_B224 
; samplesrc/rogue.map.pla: 0728:           else
	!BYTE	$50			; BRNCH	_B218
	!WORD	_B218-*
_B217 
; samplesrc/rogue.map.pla: 0729:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0730:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F289 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B218 
; samplesrc/rogue.map.pla: 0731:         next
_B216 
	!BYTE	$A4			; INCBRLE	_B215
	!WORD	_B215-*
_B214 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0732:         for l = dbeam[lightdist]+1 to dbeam[viewdist]
	!BYTE	$26			; LA	_D034+0
_F290 	!WORD	_D034+0		
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D034+0
_F291 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$A0			; BRGT	_B225
	!WORD	_B225-*
_B226 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0733:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0734:             imap = ((yorg - xbeam[l]) << rowshift) + xorg - ybeam[l]
; samplesrc/rogue.map.pla: 0735:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0736:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0737:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0738:             else
	!BYTE	$26			; LA	_D038+0
_F292 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F293 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B228
	!WORD	_B228-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D035+0
_F294 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D036+0
_F295 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F296 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B230
	!WORD	_B230-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F297 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B231
	!WORD	_B231-*
_B230 
; samplesrc/rogue.map.pla: 0739:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0740:               occluded  = 0
; samplesrc/rogue.map.pla: 0741:             fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F298 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$10			; SLB	[16]
_B231 
; samplesrc/rogue.map.pla: 0742:             if tile & LIT_TILE
; samplesrc/rogue.map.pla: 0743:               ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0744:               screen.[ycentr-xbeam[l], xcentr-ybeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0745:               darkness = 0
; samplesrc/rogue.map.pla: 0746:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B232
	!WORD	_B232-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F299 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F300 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F301 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D035+0
_F302 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D036+0
_F303 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$11			; SLB	[17]
_B232 
_B233 
; samplesrc/rogue.map.pla: 0747:           else
	!BYTE	$50			; BRNCH	_B229
	!WORD	_B229-*
_B228 
; samplesrc/rogue.map.pla: 0748:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0749:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F304 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B229 
; samplesrc/rogue.map.pla: 0750:           if l == dbeam[dist]
; samplesrc/rogue.map.pla: 0751:             if occluded
; samplesrc/rogue.map.pla: 0752:               break
	!BYTE	$64,$0C			; LLB	[12]
	!BYTE	$26			; LA	_D034+0
_F305 	!WORD	_D034+0		
	!BYTE	$B0,$0D			; ADDLB	[13]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B234
	!WORD	_B234-*
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$4C			; BRFLS	_B236
	!WORD	_B236-*
	!BYTE	$50			; BRNCH	_B225
	!WORD	_B225-*
; samplesrc/rogue.map.pla: 0753:             fin
_B236 
_B237 
; samplesrc/rogue.map.pla: 0754:             occluded = 1
; samplesrc/rogue.map.pla: 0755:             dist++
	!BYTE	$02			; CN	1
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$8C			; INCR
; samplesrc/rogue.map.pla: 0756:           fin
	!BYTE	$74,$0D			; SLB	[13]
_B234 
_B235 
; samplesrc/rogue.map.pla: 0757:         next
_B227 
	!BYTE	$A4			; INCBRLE	_B226
	!WORD	_B226-*
_B225 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0758:         break
	!BYTE	$50			; BRNCH	_B061
	!WORD	_B061-*
; samplesrc/rogue.map.pla: 0759:       is 7
_B238 
; samplesrc/rogue.map.pla: 0760:         for l = 1 to dbeam[lightdist]
	!BYTE	$26			; LA	_D034+0
_F306 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B239
	!WORD	_B239-*
_B240 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0761:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0762:             imap = ((yorg - ybeam[l]) << rowshift) + xorg - xbeam[l]
; samplesrc/rogue.map.pla: 0763:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0764:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0765:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0766:             else
	!BYTE	$26			; LA	_D038+0
_F307 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F308 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B242
	!WORD	_B242-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D036+0
_F309 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D035+0
_F310 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D040+0
_F311 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B244
	!WORD	_B244-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F312 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B245
	!WORD	_B245-*
_B244 
; samplesrc/rogue.map.pla: 0767:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0768:               adjtile = ^(map + imap - 1) & INV_TILE
; samplesrc/rogue.map.pla: 0769:               if adjtile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0770:                 ^(viewmap + imap - 1) = adjtile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0771:                 screen.[ycentr-ybeam[l], xcentr-xbeam[l]-1] = adjtile
; samplesrc/rogue.map.pla: 0772:               fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F313 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D040+0
_F314 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$8E			; DECR
	!BYTE	$60			; LB
	!BYTE	$3C,$3F			; ANDI	63
	!BYTE	$6C,$0F			; DLB	[15]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B246
	!WORD	_B246-*
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F315 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$8E			; DECR
	!BYTE	$70			; SB
	!BYTE	$64,$0F			; LLB	[15]
	!BYTE	$26			; LA	_D044+0
_F316 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D036+0
_F317 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D035+0
_F318 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$8E			; DECR
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B246 
_B247 
; samplesrc/rogue.map.pla: 0773:             fin
_B245 
; samplesrc/rogue.map.pla: 0774:             ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0775:             if tile <> PIT_TILE
; samplesrc/rogue.map.pla: 0776:               screen.[ycentr-ybeam[l], xcentr-xbeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0777:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F319 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B248
	!WORD	_B248-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F320 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F321 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D036+0
_F322 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D035+0
_F323 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B248 
_B249 
; samplesrc/rogue.map.pla: 0778:           else
	!BYTE	$50			; BRNCH	_B243
	!WORD	_B243-*
_B242 
; samplesrc/rogue.map.pla: 0779:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0780:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F324 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B243 
; samplesrc/rogue.map.pla: 0781:         next
_B241 
	!BYTE	$A4			; INCBRLE	_B240
	!WORD	_B240-*
_B239 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0782:         for l = dbeam[lightdist]+1 to dbeam[viewdist]
	!BYTE	$26			; LA	_D034+0
_F325 	!WORD	_D034+0		
	!BYTE	$B2,$0A			; ADDLW	[10]
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D034+0
_F326 	!WORD	_D034+0		
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$A0			; BRGT	_B250
	!WORD	_B250-*
_B251 
	!BYTE	$6C,$0C			; DLB	[12]
; samplesrc/rogue.map.pla: 0783:           imap = ((yorg - ybeam[l]) << rowshift) + xorg - xbeam[l]
; samplesrc/rogue.map.pla: 0784:           if vispix[vbeam[l]]
; samplesrc/rogue.map.pla: 0785:             tile = ^(map + imap)
; samplesrc/rogue.map.pla: 0786:             if tile & OPAQUE_TILE
; samplesrc/rogue.map.pla: 0787:               vispix[l] = 0
; samplesrc/rogue.map.pla: 0788:             else
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D036+0
_F327 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$0C			; CN	6
	!BYTE	$9A			; SHL
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$26			; LA	_D035+0
_F328 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$26			; LA	_D038+0
_F329 	!WORD	_D038+0		
	!BYTE	$26			; LA	_D037+0
_F330 	!WORD	_D037+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B253
	!WORD	_B253-*
	!BYTE	$6A			; LAW	_D040+0
_F331 	!WORD	_D040+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$60			; LB
	!BYTE	$6C,$0E			; DLB	[14]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B255
	!WORD	_B255-*
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F332 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B256
	!WORD	_B256-*
_B255 
; samplesrc/rogue.map.pla: 0789:               vispix[l] = 1
; samplesrc/rogue.map.pla: 0790:               occluded  = 0
; samplesrc/rogue.map.pla: 0791:             fin
	!BYTE	$02			; CN	1
	!BYTE	$26			; LA	_D038+0
_F333 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$10			; SLB	[16]
_B256 
; samplesrc/rogue.map.pla: 0792:             if tile & LIT_TILE
; samplesrc/rogue.map.pla: 0793:               ^(viewmap + imap) =  tile | VIEWED_TILE
; samplesrc/rogue.map.pla: 0794:               screen.[ycentr-ybeam[l], xcentr-xbeam[l]] = animate(tile)
; samplesrc/rogue.map.pla: 0795:               darkness = 0
; samplesrc/rogue.map.pla: 0796:             fin
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B257
	!WORD	_B257-*
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D041+0
_F334 	!WORD	_D041+0		
	!BYTE	$B2,$16			; ADDLW	[22]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$54			; CALL	_C005
_F335 	!WORD	_C005		
	!BYTE	$26			; LA	_D044+0
_F336 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$26			; LA	_D036+0
_F337 	!WORD	_D036+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$26			; LA	_D035+0
_F338 	!WORD	_D035+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$60			; LB
	!BYTE	$84			; SUB 
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$74,$11			; SLB	[17]
_B257 
_B258 
; samplesrc/rogue.map.pla: 0797:           else
	!BYTE	$50			; BRNCH	_B254
	!WORD	_B254-*
_B253 
; samplesrc/rogue.map.pla: 0798:             vispix[l] = 0
; samplesrc/rogue.map.pla: 0799:           fin
	!BYTE	$00			; CN	0
	!BYTE	$26			; LA	_D038+0
_F339 	!WORD	_D038+0		
	!BYTE	$B0,$0C			; ADDLB	[12]
	!BYTE	$70			; SB
_B254 
; samplesrc/rogue.map.pla: 0800:           if l == dbeam[dist]
; samplesrc/rogue.map.pla: 0801:             if occluded
; samplesrc/rogue.map.pla: 0802:               break
	!BYTE	$64,$0C			; LLB	[12]
	!BYTE	$26			; LA	_D034+0
_F340 	!WORD	_D034+0		
	!BYTE	$B0,$0D			; ADDLB	[13]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B259
	!WORD	_B259-*
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$4C			; BRFLS	_B261
	!WORD	_B261-*
	!BYTE	$50			; BRNCH	_B250
	!WORD	_B250-*
; samplesrc/rogue.map.pla: 0803:             fin
_B261 
_B262 
; samplesrc/rogue.map.pla: 0804:             occluded = 1
; samplesrc/rogue.map.pla: 0805:             dist++
	!BYTE	$02			; CN	1
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$64,$0D			; LLB	[13]
	!BYTE	$8C			; INCR
; samplesrc/rogue.map.pla: 0806:           fin
	!BYTE	$74,$0D			; SLB	[13]
_B259 
_B260 
; samplesrc/rogue.map.pla: 0807:         next
_B252 
	!BYTE	$A4			; INCBRLE	_B251
	!WORD	_B251-*
_B250 
	!BYTE	$74,$0C			; SLB	[12]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0808:         break
	!BYTE	$50			; BRNCH	_B061
	!WORD	_B061-*
; samplesrc/rogue.map.pla: 0809:     wend
	!BYTE	$50			; BRNCH	_B061
	!WORD	_B061-*
_B062 
	!BYTE	$08			; CASEBLOCK
	!WORD	$0000
	!WORD	_B063-*
	!WORD	$0001
	!WORD	_B088-*
	!WORD	$0002
	!WORD	_B113-*
	!WORD	$0003
	!WORD	_B138-*
	!WORD	$0004
	!WORD	_B163-*
	!WORD	$0005
	!WORD	_B188-*
	!WORD	$0006
	!WORD	_B213-*
	!WORD	$0007
	!WORD	_B238-*
_B061 
; samplesrc/rogue.map.pla: 0810:   next
_B060 
	!BYTE	$A4			; INCBRLE	_B059
	!WORD	_B059-*
_B058 
	!BYTE	$76,$18			; SLW	[24]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0811:   animseq = animseq ^ 1 // Update animation sequence
; samplesrc/rogue.map.pla: 0812:   return darkness
	!BYTE	$68			; LAB	_D033+0
_F341 	!WORD	_D033+0		
	!BYTE	$02			; CN	1
	!BYTE	$98			; XOR
	!BYTE	$78			; SAB	_D033+0
_F342 	!WORD	_D033+0		
	!BYTE	$64,$11			; LLB	[17]
	!BYTE	$5A,$1C			; LEAVE	28
; samplesrc/rogue.map.pla: 0813: end
; samplesrc/rogue.map.pla: 0814: 
; samplesrc/rogue.map.pla: 0815: //
; samplesrc/rogue.map.pla: 0816: // Draw other entities
; samplesrc/rogue.map.pla: 0817: //
; samplesrc/rogue.map.pla: 0818: 
; samplesrc/rogue.map.pla: 0819: export def drawvisentity(xofst, yofst, tile)#0
					; xofst -> [0]
					; yofst -> [2]
					; tile -> [4]
_C007 					; drawvisentity()
; samplesrc/rogue.map.pla: 0820:   if screen.[ycentr+yofst, xcentr+xofst] < $80
	!BYTE	$58,$06,$03		; ENTER	6,3
; samplesrc/rogue.map.pla: 0821:     screen.[ycentr+yofst, xcentr+xofst] = tile
; samplesrc/rogue.map.pla: 0822:   fin
	!BYTE	$26			; LA	_D044+0
_F343 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$2A,$80			; CB	128
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B263
	!WORD	_B263-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$26			; LA	_D044+0
_F344 	!WORD	_D044+0		
	!BYTE	$18			; CN	12
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$2A,$14			; CB	20
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
_B263 
_B264 
; samplesrc/rogue.map.pla: 0823: end
	!BYTE	$5A,$06			; LEAVE	6
; samplesrc/rogue.map.pla: 0824: 
; samplesrc/rogue.map.pla: 0825: export def drawplayer(tile)#0
					; tile -> [0]
_C008 					; drawplayer()
; samplesrc/rogue.map.pla: 0826:   screen.[ycentr, xcentr] = tile | $80
	!BYTE	$58,$02,$01		; ENTER	2,1
; samplesrc/rogue.map.pla: 0827: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$6A			; LAW	_D044+24
_F345 	!WORD	_D044+24		
	!BYTE	$38,$14			; ADDI	20
	!BYTE	$70			; SB
	!BYTE	$5A,$02			; LEAVE	2
; samplesrc/rogue.map.pla: 0828: 
; samplesrc/rogue.map.pla: 0829: //
; samplesrc/rogue.map.pla: 0830: // Update visible screen with screen buffer
; samplesrc/rogue.map.pla: 0831: //
; samplesrc/rogue.map.pla: 0832: 
; samplesrc/rogue.map.pla: 0833: export def updatescreen#0
_C009 					; updatescreen()
; samplesrc/rogue.map.pla: 0834:   byte row
					; row -> [0]
; samplesrc/rogue.map.pla: 0835: 
; samplesrc/rogue.map.pla: 0836:   for row = 0 to scrnheight - 2
	!BYTE	$58,$01,$00		; ENTER	1,0
	!BYTE	$2A,$14			; CB	20
	!BYTE	$00			; CN	0
_B266 
	!BYTE	$6C,$00			; DLB	[0]
; samplesrc/rogue.map.pla: 0837:     memcpy(viscreen[row], screen[row], 40)
; samplesrc/rogue.map.pla: 0838:   next
	!BYTE	$26			; LA	_D045+0
_F346 	!WORD	_D045+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$26			; LA	_D044+0
_F347 	!WORD	_D044+0		
	!BYTE	$B8,$00			; IDXLB	[0]
	!BYTE	$62			; LW
	!BYTE	$2A,$28			; CB	40
	!BYTE	$54			; CALL	_X018
_F348 	!WORD	0		
_B267 
	!BYTE	$A4			; INCBRLE	_B266
	!WORD	_B266-*
_B265 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0839: end
	!BYTE	$5A,$01			; LEAVE	1
; samplesrc/rogue.map.pla: 0840: 
; samplesrc/rogue.map.pla: 0841: //
; samplesrc/rogue.map.pla: 0842: // Print title page
; samplesrc/rogue.map.pla: 0843: //
; samplesrc/rogue.map.pla: 0844: 
; samplesrc/rogue.map.pla: 0845: conio:home()
_INIT 
; samplesrc/rogue.map.pla: 0846: while ^titlestr
	!BYTE	$6A			; LAW	_X028+6
_F349 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B270
	!WORD	_B270-*
_B268 
; samplesrc/rogue.map.pla: 0847:   puts(titlestr)
; samplesrc/rogue.map.pla: 0848:   titlestr = titlestr + ^titlestr + 1
; samplesrc/rogue.map.pla: 0849: loop
	!BYTE	$6A			; LAW	_D032+0
_F350 	!WORD	_D032+0		
	!BYTE	$54			; CALL	_X004
_F351 	!WORD	0		
	!BYTE	$6A			; LAW	_D032+0
_F352 	!WORD	_D032+0		
	!BYTE	$34			; DUP
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$8C			; INCR
	!BYTE	$7A			; SAW	_D032+0
_F353 	!WORD	_D032+0		
_B270 
	!BYTE	$6A			; LAW	_D032+0
_F354 	!WORD	_D032+0		
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B268
	!WORD	_B268-*
_B269 
; samplesrc/rogue.map.pla: 0850: for titlestr = 0 to scrnheight - 1
	!BYTE	$2A,$15			; CB	21
	!BYTE	$00			; CN	0
_B272 
	!BYTE	$7E			; DAW	_D032+0
_F355 	!WORD	_D032+0		
; samplesrc/rogue.map.pla: 0851:   screen[titlestr] = @screenbuffer + titlestr * scrnwidth
; samplesrc/rogue.map.pla: 0852: next
	!BYTE	$26			; LA	_D042+0
_F356 	!WORD	_D042+0		
	!BYTE	$6A			; LAW	_D032+0
_F357 	!WORD	_D032+0		
	!BYTE	$2A,$28			; CB	40
	!BYTE	$86			; MUL
	!BYTE	$82			; ADD 
	!BYTE	$26			; LA	_D044+0
_F358 	!WORD	_D044+0		
	!BYTE	$BE			; IDXAW	_D032+0
_F359 	!WORD	_D032+0		
	!BYTE	$72			; SW
_B273 
	!BYTE	$A4			; INCBRLE	_B272
	!WORD	_B272-*
_B271 
	!BYTE	$7A			; SAW	_D032+0
_F360 	!WORD	_D032+0		
	!BYTE	$30			; DROP 
; samplesrc/rogue.map.pla: 0853: done
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
_SYSFLAGS	=	0
_DEFCNT	=	11
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	29			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	29			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	29			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	29			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F133-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F134-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F135-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F136-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F137-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F138-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F139-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F140-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F141-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F142-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F143-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F144-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F145-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F146-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F147-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F148-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F149-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F150-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F151-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F152-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F153-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F154-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F155-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F156-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F157-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F158-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F159-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F160-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F161-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F162-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F163-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F164-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F165-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F166-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F167-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F168-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F169-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F170-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F171-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F172-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F173-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F174-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F175-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F176-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F177-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F178-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F179-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F180-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F181-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F182-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F183-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F184-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F185-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F186-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F187-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F188-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F189-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F190-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F191-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F192-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F193-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F194-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F195-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F196-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F197-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F198-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F199-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F200-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F201-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F202-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F203-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F204-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F205-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F206-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F207-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F208-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F209-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F210-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F211-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F212-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F213-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F214-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F215-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F216-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F217-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F218-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F219-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F220-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F221-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F222-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F223-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F224-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F225-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F226-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F227-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F228-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F229-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F230-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F231-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F232-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F233-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F234-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F235-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F236-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F237-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F238-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F239-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F240-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F241-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F242-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F243-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F244-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F245-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F246-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F247-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F248-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F249-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F250-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F251-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F252-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F253-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F254-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F255-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F256-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F257-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F258-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F259-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F260-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F261-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F262-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F263-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F264-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F265-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F266-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F267-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F268-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F269-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F270-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F271-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F272-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F273-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F274-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F275-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F276-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F277-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F278-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F279-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F280-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F281-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F282-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F283-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F284-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F285-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F286-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F287-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F288-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F289-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F290-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F291-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F292-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F293-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F294-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F295-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F296-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F297-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F298-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F299-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F300-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F301-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F302-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F303-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F304-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F305-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F306-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F307-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F308-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F309-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F310-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F311-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F312-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F313-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F314-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F315-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F316-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F317-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F318-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F319-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F320-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F321-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F322-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F323-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F324-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F325-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F326-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F327-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F328-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F329-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F330-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F331-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F332-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F333-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F334-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F335-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F336-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F337-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F338-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F339-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F340-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F341-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F342-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F343-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F344-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F345-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F346-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F347-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F348-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F349-_SEGBEGIN		
	!BYTE	28			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F350-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F351-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F352-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F353-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F354-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F355-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F356-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F357-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F358-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F359-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F360-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: PUTC
	!BYTE	$D0,$D5,$D4,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	2			; ESD INDEX
	; DCI STRING: PUTS
	!BYTE	$D0,$D5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	4			; ESD INDEX
	; DCI STRING: HEAPALLOC
	!BYTE	$C8,$C5,$C1,$D0,$C1,$CC,$CC,$CF,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	14			; ESD INDEX
	; DCI STRING: MEMSET
	!BYTE	$CD,$C5,$CD,$D3,$C5,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	17			; ESD INDEX
	; DCI STRING: MEMCPY
	!BYTE	$CD,$C5,$CD,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	18			; ESD INDEX
	; DCI STRING: CONIO
	!BYTE	$C3,$CF,$CE,$C9,$4F
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	28			; ESD INDEX
	; DCI STRING: FILEIO
	!BYTE	$C6,$C9,$CC,$C5,$C9,$4F
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	29			; ESD INDEX
	; DCI STRING: LOADMAP
	!BYTE	$CC,$CF,$C1,$C4,$CD,$C1,$50
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C000		
	; DCI STRING: GETMAPTILE
	!BYTE	$C7,$C5,$D4,$CD,$C1,$D0,$D4,$C9,$CC,$45
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C001		
	; DCI STRING: SETMAPTILE
	!BYTE	$D3,$C5,$D4,$CD,$C1,$D0,$D4,$C9,$CC,$45
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C002		
	; DCI STRING: UPDTMAPTILE
	!BYTE	$D5,$D0,$C4,$D4,$CD,$C1,$D0,$D4,$C9,$CC,$45
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C003		
	; DCI STRING: LIGHTTORCHES
	!BYTE	$CC,$C9,$C7,$C8,$D4,$D4,$CF,$D2,$C3,$C8,$C5,$53
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C004		
	; DCI STRING: ANIMATE
	!BYTE	$C1,$CE,$C9,$CD,$C1,$D4,$45
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C005		
	; DCI STRING: DRAWMAP
	!BYTE	$C4,$D2,$C1,$D7,$CD,$C1,$50
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C006		
	; DCI STRING: DRAWVISENTITY
	!BYTE	$C4,$D2,$C1,$D7,$D6,$C9,$D3,$C5,$CE,$D4,$C9,$D4,$59
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C007		
	; DCI STRING: DRAWPLAYER
	!BYTE	$C4,$D2,$C1,$D7,$D0,$CC,$C1,$D9,$C5,$52
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C008		
	; DCI STRING: UPDATESCREEN
	!BYTE	$D5,$D0,$C4,$C1,$D4,$C5,$D3,$C3,$D2,$C5,$C5,$4E
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_C009		
	!BYTE	$00			; END OF ESD
