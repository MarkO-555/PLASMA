include "inc/cmdsys.plh"

const TYPE_MASK = $70
const CONS_TYPE = $10
const NUM_TYPE  = $20
const SYM_TYPE  = $30
const SYM_LEN   = $0F

struc t_elem
  var  link
  byte type
end
struc t_cons
  res[t_elem]
  var car
  var cdr
end
struc t_num
  res[t_elem]
  var val
end
struc t_sym
  res[t_elem]
  char[0] name
end

var sym_list = NULL
var lit_list = NULL
var con_list = NULL

predef parse_expr(evalptr, level)#2
predef print(s_expr)

def new_cons
  var consptr

  consptr = heapalloc(t_cons)
  consptr->type = CONS_TYPE
  consptr=>car  = NULL
  consptr=>cdr  = NULL
  return consptr
end

def new_num(num)
  var numptr

  numptr = heapalloc(t_num)
  numptr->type = NUM_TYPE
  numptr=>val  = num
  puts("New number: "); puti(num); putln
  return numptr
end

def match_sym(sym, len)
  var symptr
  byte typelen, i

  typelen = SYM_TYPE | len
  len--
  symptr = sym_list
  while symptr
    if symptr->type == typelen
      for i = 0 to len
        if symptr->name[i] <> sym->[i]; break; fin
      next
      if i > len
        typelen = symptr->type
        symptr->type = len + 1
        puts("Match symbol: ")
        puts(symptr + type); putln
        symptr->type = typelen
        return symptr
      fin
    fin
    symptr = symptr=>link
  loop
  return NULL
end

def add_sym(sym, len)
  var symptr

  symptr = match_sym(sym, len)
  if symptr; return symptr; fin // Return already existing symbol
  symptr       = heapalloc(t_sym + len)
  symptr->type = len
  symptr=>link = sym_list
  sym_list     = symptr
  memcpy(symptr + name, sym, len)
  puts("New symbol: "); puts(symptr + type); putln
  symptr->type = SYM_TYPE | len
  return symptr
end

def is_num(c); return c >= '0' and c <= '9'; end
def is_alphasym(c); c=toupper(c); return c >= '*' and c <= 'Z' and c <> '.'; end

def parse_num(evalptr)#2 // return evalptr, numptr
  var num, sign

  num  = 0
  sign = 1
  if ^evalptr == '-'
    sign = -1
    evalptr++
  fin
  while ^evalptr >= '0' and ^evalptr <= '9'
    putc(^evalptr)
    num = num * 10 + ^evalptr - '0'
    evalptr++
  loop
  return evalptr, new_num(sign * num)
end

def parse_sym(evalptr)#2 // return evalptr, symptr
  var symptr
  symptr = evalptr
  while is_alphasym(^evalptr)
    putc(^evalptr)
    evalptr++
  loop
  return evalptr, add_sym(symptr, evalptr - symptr)
end

def parse_elem(evalptr, level)#2 // return evalptr, exprptr
  var elemptr

  if ^evalptr == '('
    evalptr++
    evalptr, elemptr = parse_expr(evalptr, level + 1)
  elsif (^evalptr == '-' and is_num(^(evalptr+1))) or is_num(^evalptr)
    evalptr, elemptr = parse_num(evalptr)
  elsif is_alphasym(^evalptr)
    evalptr, elemptr = parse_sym(evalptr)
  else
    putc('\\')
    putc(^evalptr)
    evalptr++
  fin
  return evalptr, elemptr
end

def parse_expr(evalptr, level)#2 // return evalptr, exprptr
  var exprptr, consptr, elemptr

  exprptr = NULL
  consptr = NULL
  while TRUE
    //
    // Parse textual S-expression
    //
    elemptr = NULL
    when ^evalptr
      is 0
        if level > 0
          // Refill input buffer
          evalptr = gets('>'|$80)
          ^(evalptr + ^evalptr + 1) = 0
          evalptr++
        else
          return evalptr, exprptr
        fin
        break
      is '!'
        return NULL, NULL
      is ' '
        evalptr++
        break
      is ')'
        putln
        return evalptr + 1, exprptr
      is '('
        evalptr++
        if level == 0
          level++
        else
          evalptr, elemptr = parse_expr(evalptr, level + 1)
        fin
        break
      is '.'
        evalptr++
        evalptr, elemptr = parse_expr(evalptr, 0)
        //
        // Add expression to CDR
        //
        if not (consptr and consptr=>car)
          puts("Invalid . operator\n")
          return evalptr, NULL
        fin
        consptr=>cdr = elemptr
        return evalptr, exprptr
      otherwise
        evalptr, elemptr = parse_elem(evalptr, level)
        if level == 0
          return evalptr, elemptr
        fin
    wend
    if elemptr
      //
      // Add element to S-expression
      //
      if not consptr
        consptr = new_cons
        exprptr = consptr
      else
        consptr=>cdr = new_cons
        consptr      = consptr=>cdr
      fin
      //
      // Add element to CAR
      //
      consptr=>car = elemptr
    fin
  loop
  return evalptr, exprptr
end

def read
  var readline, s_expr

  repeat
    readline = gets('?'|$80)
    ^(readline + ^readline + 1) = 0
    readline++
  until ^readline
  drop, s_expr = parse_expr(readline, 0)
  return s_expr
end

def eval(s_expr)
  return s_expr
end

def print_elem(s_expr)#0
  byte t

  if not s_expr
    puts("NIL")
  else
    when s_expr->type & TYPE_MASK
      is CONS_TYPE
        print(s_expr)
        break
      is NUM_TYPE
        puti(s_expr=>val)
        break
      is SYM_TYPE
        t = s_expr->type
        s_expr->type = t & SYM_LEN
        puts(s_expr + type)
        s_expr->type = t
        break;
    wend
  fin
end

def print(s_expr)
  if not s_expr; return FALSE; fin
  if s_expr->type == CONS_TYPE
    putc('(')
    print_elem(s_expr=>car)
    putc('.')
    print_elem(s_expr=>cdr)
    putc(')')
  else
    print_elem(s_expr)
  fin
  return TRUE
end

while print(eval(read)); putln; loop
done
