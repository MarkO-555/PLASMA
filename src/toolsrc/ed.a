; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; toolsrc/ed.pla: 0001: //=====================================
; toolsrc/ed.pla: 0002: //
; toolsrc/ed.pla: 0003: //              Text Editor
; toolsrc/ed.pla: 0004: //
; toolsrc/ed.pla: 0005: //=====================================
; toolsrc/ed.pla: 0006: 
; toolsrc/ed.pla: 0007: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0200 // Version built against
					; _SYSVER_ = 512
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $03
					; MACHID_MEM = 3
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     //
; inc/cmdsys.plh: 0038:     // Module don't free memory
; inc/cmdsys.plh: 0039:     //
; inc/cmdsys.plh: 0040:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0041:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0042:     //
; inc/cmdsys.plh: 0043:     // CMD exported interface table
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     struc t_cmdsys
; inc/cmdsys.plh: 0046:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0047:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0048:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0049:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0050:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0051:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0052:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0053:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0054:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0055:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0056:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0057:         byte refcons    // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0058:         byte devcons    // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0059:     end
					; t_cmdsys = 21
; inc/cmdsys.plh: 0060:     //
; inc/cmdsys.plh: 0061:     // CMD exported functions
; inc/cmdsys.plh: 0062:     //
; inc/cmdsys.plh: 0063:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0064:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0065:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0066:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0067:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0068:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0069: end
; toolsrc/ed.pla: 0007: 
; toolsrc/ed.pla: 0008: include "inc/args.plh"
; inc/args.plh: 0001: import args
	; DCI STRING: ARGS
	!BYTE	$C1,$D2,$C7,$53
					; ARGS -> X028
; inc/args.plh: 0002:     predef  argFirst, argNext(str)
					; ARGFIRST -> X029
					; ARGNEXT -> X030
; inc/args.plh: 0003: end
; toolsrc/ed.pla: 0008: 
; toolsrc/ed.pla: 0009: include "inc/fileio.plh"
; inc/fileio.plh: 0001: import fileio
	; DCI STRING: FILEIO
	!BYTE	$C6,$C9,$CC,$C5,$C9,$4F
					; FILEIO -> X031
; inc/fileio.plh: 0002:     //
; inc/fileio.plh: 0003:     // Useful ProDOS values
; inc/fileio.plh: 0004:     //
; inc/fileio.plh: 0005:     // MACHID is defined in cmdsys.plh
; inc/fileio.plh: 0006:     // Which slot has a ROM
; inc/fileio.plh: 0007:     const SLTBYT = $BF99
					; SLTBYT = 49049
; inc/fileio.plh: 0008:     // Prefix active
; inc/fileio.plh: 0009:     const PFIXPTR = $BF9A
					; PFIXPTR = 49050
; inc/fileio.plh: 0010:     // Memory alocate bitmap
; inc/fileio.plh: 0011:     const MEMTABL = $BF58
					; MEMTABL = 48984
; inc/fileio.plh: 0012:     //
; inc/fileio.plh: 0013:     // SOS/ProDOS error codes
; inc/fileio.plh: 0014:     //
; inc/fileio.plh: 0015:     const FILE_ERR_OK            = $00
					; FILE_ERR_OK = 0
; inc/fileio.plh: 0016:     const FILE_ERR_BAD_CALL_NUM  = $01
					; FILE_ERR_BAD_CALL_NUM = 1
; inc/fileio.plh: 0017:     const FILE_ERR_BAD_PARAM_CNT = $04
					; FILE_ERR_BAD_PARAM_CNT = 4
; inc/fileio.plh: 0018:     const FILE_ERR_INT_TBL_FULL  = $25
					; FILE_ERR_INT_TBL_FULL = 37
; inc/fileio.plh: 0019:     const FILE_ERR_IO            = $27
					; FILE_ERR_IO = 39
; inc/fileio.plh: 0020:     //
; inc/fileio.plh: 0021:     // File entry struc
; inc/fileio.plh: 0022:     //
; inc/fileio.plh: 0023:     struc t_fileentry
; inc/fileio.plh: 0024:         byte store_namelen
					; store_namelen = 0
; inc/fileio.plh: 0025:         byte entry_name[15]
					; entry_name = 1
; inc/fileio.plh: 0026:         byte entry_type
					; entry_type = 16
; inc/fileio.plh: 0027:         word entry_keyptr
					; entry_keyptr = 17
; inc/fileio.plh: 0028:         word entry_blocks
					; entry_blocks = 19
; inc/fileio.plh: 0029:         word entry_EOFL
					; entry_EOFL = 21
; inc/fileio.plh: 0030:         byte entry_EOFH
					; entry_EOFH = 23
; inc/fileio.plh: 0031:         word entry_create[2]
					; entry_create = 24
; inc/fileio.plh: 0032:         byte entry_version
					; entry_version = 28
; inc/fileio.plh: 0033:         byte entry_minver
					; entry_minver = 29
; inc/fileio.plh: 0034:         byte entry_access
					; entry_access = 30
; inc/fileio.plh: 0035:         word entry_aux
					; entry_aux = 31
; inc/fileio.plh: 0036:         word entry_mod[2]
					; entry_mod = 33
; inc/fileio.plh: 0037:         word entry_headptr
					; entry_headptr = 37
; inc/fileio.plh: 0038:     end
					; t_fileentry = 39
; inc/fileio.plh: 0039:     //
; inc/fileio.plh: 0040:     // File info struc
; inc/fileio.plh: 0041:     //
; inc/fileio.plh: 0042:     struc t_fileinfo
; inc/fileio.plh: 0043:         byte file_access
					; file_access = 0
; inc/fileio.plh: 0044:         byte file_type
					; file_type = 1
; inc/fileio.plh: 0045:         word aux_type
					; aux_type = 2
; inc/fileio.plh: 0046:         byte storage_type
					; storage_type = 4
; inc/fileio.plh: 0047:         word blocks_used
					; blocks_used = 5
; inc/fileio.plh: 0048:         word mod_date
					; mod_date = 7
; inc/fileio.plh: 0049:         word mod_time
					; mod_time = 9
; inc/fileio.plh: 0050:         word create_date
					; create_date = 11
; inc/fileio.plh: 0051:         word create_time
					; create_time = 13
; inc/fileio.plh: 0052:     end
					; t_fileinfo = 15
; inc/fileio.plh: 0053:     //
; inc/fileio.plh: 0054:     // File functions
; inc/fileio.plh: 0055:     //
; inc/fileio.plh: 0056:     struc t_fileio
; inc/fileio.plh: 0057:         word getpfx
					; getpfx = 0
; inc/fileio.plh: 0058:         word setpfx
					; setpfx = 2
; inc/fileio.plh: 0059:         word getfileinfo
					; getfileinfo = 4
; inc/fileio.plh: 0060:         word setfileinfo
					; setfileinfo = 6
; inc/fileio.plh: 0061:         word geteof
					; geteof = 8
; inc/fileio.plh: 0062:         word seteof
					; seteof = 10
; inc/fileio.plh: 0063:         word iobufalloc
					; iobufalloc = 12
; inc/fileio.plh: 0064:         word open
					; open = 14
; inc/fileio.plh: 0065:         word close
					; close = 16
; inc/fileio.plh: 0066:         word read
					; read = 18
; inc/fileio.plh: 0067:         word write
					; write = 20
; inc/fileio.plh: 0068:         word create
					; create = 22
; inc/fileio.plh: 0069:         word destroy
					; destroy = 24
; inc/fileio.plh: 0070:         word rename
					; rename = 26
; inc/fileio.plh: 0071:         word newline
					; newline = 28
; inc/fileio.plh: 0072:         word online
					; online = 30
; inc/fileio.plh: 0073:         word readblock
					; readblock = 32
; inc/fileio.plh: 0074:         word writeblock
					; writeblock = 34
; inc/fileio.plh: 0075:     end
					; t_fileio = 36
; inc/fileio.plh: 0076:     //
; inc/fileio.plh: 0077:     // Globally accessible error code
; inc/fileio.plh: 0078:     //
; inc/fileio.plh: 0079:     byte perr
					; PERR -> X032
; inc/fileio.plh: 0080: end
; toolsrc/ed.pla: 0009: 
; toolsrc/ed.pla: 0010: sysflags nojitc // Keep JITC from compiling and pausing while editing
	!BYTE	$00			; END OF MODULE DEPENDENCIES
_SYSFLAGS	=	$0100		; SYSTEM FLAGS
; toolsrc/ed.pla: 0011: //
; toolsrc/ed.pla: 0012: // Hardware constants
; toolsrc/ed.pla: 0013: //
; toolsrc/ed.pla: 0014: const csw           = $0036
					; csw = 54
; toolsrc/ed.pla: 0015: const pushbttn1     = $C061
					; pushbttn1 = 49249
; toolsrc/ed.pla: 0016: const pushbttn2     = $C062
					; pushbttn2 = 49250
; toolsrc/ed.pla: 0017: const pushbttn3     = $C063
					; pushbttn3 = 49251
; toolsrc/ed.pla: 0018: const keyboard      = $C000
					; keyboard = 49152
; toolsrc/ed.pla: 0019: const keystrobe     = $C010
					; keystrobe = 49168
; toolsrc/ed.pla: 0020: const inputln       = $01FF
					; inputln = 511
; toolsrc/ed.pla: 0021: //
; toolsrc/ed.pla: 0022: // ASCII key values
; toolsrc/ed.pla: 0023: //
; toolsrc/ed.pla: 0024: const keyenter      = $8D
					; keyenter = 141
; toolsrc/ed.pla: 0025: const keyspace      = $A0
					; keyspace = 160
; toolsrc/ed.pla: 0026: const keyarrowup    = $8B
					; keyarrowup = 139
; toolsrc/ed.pla: 0027: const keyarrowdown  = $8A
					; keyarrowdown = 138
; toolsrc/ed.pla: 0028: const keyarrowleft  = $88
					; keyarrowleft = 136
; toolsrc/ed.pla: 0029: const keyarrowright = $95
					; keyarrowright = 149
; toolsrc/ed.pla: 0030: const keyescape     = $9B
					; keyescape = 155
; toolsrc/ed.pla: 0031: const keyctrla      = $81
					; keyctrla = 129
; toolsrc/ed.pla: 0032: const keyctrlb      = $82
					; keyctrlb = 130
; toolsrc/ed.pla: 0033: const keyctrlc      = $83
					; keyctrlc = 131
; toolsrc/ed.pla: 0034: const keyctrld      = $84
					; keyctrld = 132
; toolsrc/ed.pla: 0035: const keyctrle      = $85
					; keyctrle = 133
; toolsrc/ed.pla: 0036: const keyctrlf      = $86
					; keyctrlf = 134
; toolsrc/ed.pla: 0037: const keyctrlg      = $87
					; keyctrlg = 135
; toolsrc/ed.pla: 0038: const keyctrli      = $89
					; keyctrli = 137
; toolsrc/ed.pla: 0039: const keyctrlk      = $8B
					; keyctrlk = 139
; toolsrc/ed.pla: 0040: const keyctrll      = $8C
					; keyctrll = 140
; toolsrc/ed.pla: 0041: const keyctrln      = $8E
					; keyctrln = 142
; toolsrc/ed.pla: 0042: const keyctrlo      = $8F
					; keyctrlo = 143
; toolsrc/ed.pla: 0043: const keyctrlp      = $90
					; keyctrlp = 144
; toolsrc/ed.pla: 0044: const keyctrlq      = $91
					; keyctrlq = 145
; toolsrc/ed.pla: 0045: const keyctrlr      = $92
					; keyctrlr = 146
; toolsrc/ed.pla: 0046: const keyctrls      = $93
					; keyctrls = 147
; toolsrc/ed.pla: 0047: const keyctrlt      = $94
					; keyctrlt = 148
; toolsrc/ed.pla: 0048: const keyctrlu      = $95
					; keyctrlu = 149
; toolsrc/ed.pla: 0049: const keyctrlv      = $96
					; keyctrlv = 150
; toolsrc/ed.pla: 0050: const keyctrlw      = $97
					; keyctrlw = 151
; toolsrc/ed.pla: 0051: const keyctrlx      = $98
					; keyctrlx = 152
; toolsrc/ed.pla: 0052: const keyctrly      = $99
					; keyctrly = 153
; toolsrc/ed.pla: 0053: const keyctrlz      = $9A
					; keyctrlz = 154
; toolsrc/ed.pla: 0054: const keytab        = keyctrli
					; keytab = 137
; toolsrc/ed.pla: 0055: const keydetab      = $9D
					; keydetab = 157
; toolsrc/ed.pla: 0056: const keydelete     = $FF
					; keydelete = 255
; toolsrc/ed.pla: 0057: //
; toolsrc/ed.pla: 0058: // Data and text buffer constants
; toolsrc/ed.pla: 0059: //
; toolsrc/ed.pla: 0060: const MAXLINES      = 999
					; MAXLINES = 999
; toolsrc/ed.pla: 0061: const MAXLINESSIZE  = MAXLINES+24
					; MAXLINESSIZE = 1023
; toolsrc/ed.pla: 0062: const MAXCLIPLINES  = 256
					; MAXCLIPLINES = 256
; toolsrc/ed.pla: 0063: const MAXLNLEN      = 79
					; MAXLNLEN = 79
; toolsrc/ed.pla: 0064: const MAXSTRPLSIZE  = $8000
					; MAXSTRPLSIZE = 32768
; toolsrc/ed.pla: 0065: //const STRPLMAPSIZE  = 224 // $E0 = 28K is memory@16 bytes per bit map, 128 bytes per 8 bit map, 1K bytes per 8 byte map
; toolsrc/ed.pla: 0066: const pgjmp         = 16
					; pgjmp = 16
; toolsrc/ed.pla: 0067: const changed       = 1
					; changed = 1
; toolsrc/ed.pla: 0068: const insmode       = 2
					; insmode = 2
; toolsrc/ed.pla: 0069: const gutter        = 4
					; gutter = 4
; toolsrc/ed.pla: 0070: const uppercase     = 8
					; uppercase = 8
; toolsrc/ed.pla: 0071: const selection     = 16
					; selection = 16
; toolsrc/ed.pla: 0072: const showcurs      = 32
					; showcurs = 32
; toolsrc/ed.pla: 0073: const shiftlock     = 128
					; shiftlock = 128
; toolsrc/ed.pla: 0074: //
; toolsrc/ed.pla: 0075: // Text screen row address array
; toolsrc/ed.pla: 0076: //
; toolsrc/ed.pla: 0077: const scrnheight  = 24
					; scrnheight = 24
; toolsrc/ed.pla: 0078: const scrnbottom  = 23
					; scrnbottom = 23
; toolsrc/ed.pla: 0079: word scrnwidth    = 36
_D033 					; scrnwidth    = 36
	!WORD	$0024
; toolsrc/ed.pla: 0080: word scrnright    = 35
_D034 					; scrnright    = 35
	!WORD	$0023
; toolsrc/ed.pla: 0081: word txtscrn      = $0400,$0480,$0500,$0580,$0600,$0680,$0700,$0780
_D035 					; txtscrn      = $0400,$0480,$0500,$0580,$0600,$0680,$0700,$0780
	!WORD	$0400
	!WORD	$0480
	!WORD	$0500
	!WORD	$0580
	!WORD	$0600
	!WORD	$0680
	!WORD	$0700
	!WORD	$0780
; toolsrc/ed.pla: 0082: word              = $0428,$04A8,$0528,$05A8,$0628,$06A8,$0728,$07A8
	!WORD	$0428
	!WORD	$04A8
	!WORD	$0528
	!WORD	$05A8
	!WORD	$0628
	!WORD	$06A8
	!WORD	$0728
	!WORD	$07A8
; toolsrc/ed.pla: 0083: word              = $0450,$04D0,$0550,$05D0,$0650,$06D0,$0750,$07D0
	!WORD	$0450
	!WORD	$04D0
	!WORD	$0550
	!WORD	$05D0
	!WORD	$0650
	!WORD	$06D0
	!WORD	$0750
	!WORD	$07D0
; toolsrc/ed.pla: 0084: //
; toolsrc/ed.pla: 0085: // Editor variables
; toolsrc/ed.pla: 0086: //
; toolsrc/ed.pla: 0087: byte nullstr       = ""
_D036 					; nullstr       = ""
	!BYTE	$00
; toolsrc/ed.pla: 0088: byte[80] findstr   = ""
_D037 					; findstr   = ""
	!BYTE	$00
	!FILL	$4F
; toolsrc/ed.pla: 0089: byte[64] filename  = "UNTITLED"
_D038 					; filename  = "UNTITLED"
	!BYTE	$08
	!BYTE	$55,$4E,$54,$49,$54,$4C,$45,$44
	!FILL	$37
; toolsrc/ed.pla: 0090: byte exit          = FALSE
_D039 					; exit          = FALSE
	!BYTE	$00
; toolsrc/ed.pla: 0091: byte flags         = 0
_D040 					; flags         = 0
	!BYTE	$00
; toolsrc/ed.pla: 0092: byte flash         = 0
_D041 					; flash         = 0
	!BYTE	$00
; toolsrc/ed.pla: 0093: word numlines      = 0
_D042 					; numlines      = 0
	!WORD	$0000
; toolsrc/ed.pla: 0094: word numcliplines  = 0
_D043 					; numcliplines  = 0
	!WORD	$0000
; toolsrc/ed.pla: 0095: word arg
_D044 	!FILL	2			; arg
; toolsrc/ed.pla: 0096: word strplsize     = MAXSTRPLSIZE
_D045 					; strplsize     = MAXSTRPLSIZE
	!WORD	$8000
; toolsrc/ed.pla: 0097: word strpool, strplmapsize, txtlinbuf, cliplinbuf, strpoolmap
_D046 	!FILL	2			; strpool, strplmapsize, txtlinbuf, cliplinbuf, strpoolmap
_D047 	!FILL	2			; strplmapsize, txtlinbuf, cliplinbuf, strpoolmap
_D048 	!FILL	2			; txtlinbuf, cliplinbuf, strpoolmap
_D049 	!FILL	2			; cliplinbuf, strpoolmap
_D050 	!FILL	2			; strpoolmap
; toolsrc/ed.pla: 0098: word cursx, cursy, scrnleft, curscol
_D051 	!FILL	2			; cursx, cursy, scrnleft, curscol
_D052 	!FILL	2			; cursy, scrnleft, curscol
_D053 	!FILL	2			; scrnleft, curscol
_D054 	!FILL	2			; curscol
; toolsrc/ed.pla: 0099: byte underchr, curschr
_D055 	!FILL	1			; underchr, curschr
_D056 	!FILL	1			; curschr
; toolsrc/ed.pla: 0100: word keyin, cursrow, selrow, scrntop, cursptr
_D057 	!FILL	2			; keyin, cursrow, selrow, scrntop, cursptr
_D058 	!FILL	2			; cursrow, selrow, scrntop, cursptr
_D059 	!FILL	2			; selrow, scrntop, cursptr
_D060 	!FILL	2			; scrntop, cursptr
_D061 	!FILL	2			; cursptr
; toolsrc/ed.pla: 0101: byte a3echo         = $80
_D062 					; a3echo         = $80
	!BYTE	$80
; toolsrc/ed.pla: 0102: byte a3noecho       = $00
_D063 					; a3noecho       = $00
	!BYTE	$00
; toolsrc/ed.pla: 0103: //
; toolsrc/ed.pla: 0104: // Predeclared functions
; toolsrc/ed.pla: 0105: //
; toolsrc/ed.pla: 0106: predef cmdmode#0
; toolsrc/ed.pla: 0107: //
; toolsrc/ed.pla: 0108: // Utility functions
; toolsrc/ed.pla: 0109: //
; toolsrc/ed.pla: 0110: // Defines for ASM routines
; toolsrc/ed.pla: 0111: //
; toolsrc/ed.pla: 0112: asm equates
_A000 					; equates()
; toolsrc/ed.pla: 0113:     !SOURCE "vmsrc/plvmzp.inc"
    !SOURCE "vmsrc/plvmzp.inc"
; toolsrc/ed.pla: 0114: end
; toolsrc/ed.pla: 0115: asm sethibit(strptr)#0
_A001 					; sethibit()
; toolsrc/ed.pla: 0116:         LDA     ESTKL,X
        LDA     ESTKL,X
; toolsrc/ed.pla: 0117:         STA     SRCL
        STA     SRCL
; toolsrc/ed.pla: 0118:         LDA     ESTKH,X
        LDA     ESTKH,X
; toolsrc/ed.pla: 0119:         STA     SRCH
        STA     SRCH
; toolsrc/ed.pla: 0120:         INX
        INX
; toolsrc/ed.pla: 0121:         LDY     #$00
        LDY     #$00
; toolsrc/ed.pla: 0122:         LDA     (SRC),Y
        LDA     (SRC),Y
; toolsrc/ed.pla: 0123:         BEQ     +
        BEQ     +
; toolsrc/ed.pla: 0124:         TAY
        TAY
; toolsrc/ed.pla: 0125: STHILP  LDA     (SRC),Y
STHILP  LDA     (SRC),Y
; toolsrc/ed.pla: 0126:         ORA     #$80
        ORA     #$80
; toolsrc/ed.pla: 0127:         STA     (SRC),Y
        STA     (SRC),Y
; toolsrc/ed.pla: 0128:         DEY
        DEY
; toolsrc/ed.pla: 0129:         BNE     STHILP
        BNE     STHILP
; toolsrc/ed.pla: 0130: +       RTS
+       RTS
; toolsrc/ed.pla: 0131: end
; toolsrc/ed.pla: 0132: asm lncpy(dststr, srcstr)#0
_A002 					; lncpy()
; toolsrc/ed.pla: 0133:         LDA     ESTKL,X
        LDA     ESTKL,X
; toolsrc/ed.pla: 0134:         STA     SRCL
        STA     SRCL
; toolsrc/ed.pla: 0135:         LDA     ESTKH,X
        LDA     ESTKH,X
; toolsrc/ed.pla: 0136:         STA     SRCH
        STA     SRCH
; toolsrc/ed.pla: 0137:         INX
        INX
; toolsrc/ed.pla: 0138:         LDA     ESTKL,X
        LDA     ESTKL,X
; toolsrc/ed.pla: 0139:         STA     DSTL
        STA     DSTL
; toolsrc/ed.pla: 0140:         LDA     ESTKH,X
        LDA     ESTKH,X
; toolsrc/ed.pla: 0141:         STA     DSTH
        STA     DSTH
; toolsrc/ed.pla: 0142:         INX
        INX
; toolsrc/ed.pla: 0143:         LDY     #$00
        LDY     #$00
; toolsrc/ed.pla: 0144:         LDA     (SRC),Y
        LDA     (SRC),Y
; toolsrc/ed.pla: 0145:         CMP     #80
        CMP     #80
; toolsrc/ed.pla: 0146:         BCC     +
        BCC     +
; toolsrc/ed.pla: 0147:         LDA     #79
        LDA     #79
; toolsrc/ed.pla: 0148:         CLC
        CLC
; toolsrc/ed.pla: 0149: +       ADC     #$01    ; APPEND CR TO END OF STRING
+       ADC     #$01    ; APPEND CR TO END OF STRING
; toolsrc/ed.pla: 0150:         STA     (DST),Y
        STA     (DST),Y
; toolsrc/ed.pla: 0151:         TAY
        TAY
; toolsrc/ed.pla: 0152:         LDA     #$0D
        LDA     #$0D
; toolsrc/ed.pla: 0153:         STA     (DST),Y
        STA     (DST),Y
; toolsrc/ed.pla: 0154:         DEY
        DEY
; toolsrc/ed.pla: 0155:         BEQ     ++
        BEQ     ++
; toolsrc/ed.pla: 0156: CPLNLP  LDA     (SRC),Y
CPLNLP  LDA     (SRC),Y
; toolsrc/ed.pla: 0157:         CMP     #$20
        CMP     #$20
; toolsrc/ed.pla: 0158:         BCS     +
        BCS     +
; toolsrc/ed.pla: 0159:         ADC     #$60
        ADC     #$60
; toolsrc/ed.pla: 0160: +       AND     #$7F
+       AND     #$7F
; toolsrc/ed.pla: 0161:         STA     (DST),Y
        STA     (DST),Y
; toolsrc/ed.pla: 0162:         DEY
        DEY
; toolsrc/ed.pla: 0163:         BNE     CPLNLP
        BNE     CPLNLP
; toolsrc/ed.pla: 0164: ++      RTS
++      RTS
; toolsrc/ed.pla: 0165: end
; toolsrc/ed.pla: 0166: asm lnupcpy(dststr, srcstr)#0
_A003 					; lnupcpy()
; toolsrc/ed.pla: 0167:         LDA     ESTKL,X
        LDA     ESTKL,X
; toolsrc/ed.pla: 0168:         STA     SRCL
        STA     SRCL
; toolsrc/ed.pla: 0169:         LDA     ESTKH,X
        LDA     ESTKH,X
; toolsrc/ed.pla: 0170:         STA     SRCH
        STA     SRCH
; toolsrc/ed.pla: 0171:         INX
        INX
; toolsrc/ed.pla: 0172:         LDA     ESTKL,X
        LDA     ESTKL,X
; toolsrc/ed.pla: 0173:         STA     DSTL
        STA     DSTL
; toolsrc/ed.pla: 0174:         LDA     ESTKH,X
        LDA     ESTKH,X
; toolsrc/ed.pla: 0175:         STA     DSTH
        STA     DSTH
; toolsrc/ed.pla: 0176:         INX
        INX
; toolsrc/ed.pla: 0177:         LDY     #$00
        LDY     #$00
; toolsrc/ed.pla: 0178:         LDA     (SRC),Y
        LDA     (SRC),Y
; toolsrc/ed.pla: 0179:         CMP     #80
        CMP     #80
; toolsrc/ed.pla: 0180:         BCC     +
        BCC     +
; toolsrc/ed.pla: 0181:         LDA     #79
        LDA     #79
; toolsrc/ed.pla: 0182: +       STA     (DST),Y
+       STA     (DST),Y
; toolsrc/ed.pla: 0183:         TAY
        TAY
; toolsrc/ed.pla: 0184:         BEQ     +++
        BEQ     +++
; toolsrc/ed.pla: 0185: CPUPLP  LDA     (SRC),Y
CPUPLP  LDA     (SRC),Y
; toolsrc/ed.pla: 0186:         CMP     #$20
        CMP     #$20
; toolsrc/ed.pla: 0187:         BCS     +
        BCS     +
; toolsrc/ed.pla: 0188:         ADC     #$60
        ADC     #$60
; toolsrc/ed.pla: 0189: +       AND     #$7F
+       AND     #$7F
; toolsrc/ed.pla: 0190:         CMP     #$7B
        CMP     #$7B
; toolsrc/ed.pla: 0191:         BCS     ++
        BCS     ++
; toolsrc/ed.pla: 0192:         CMP     #$61
        CMP     #$61
; toolsrc/ed.pla: 0193:         BCC     ++
        BCC     ++
; toolsrc/ed.pla: 0194:         SEC
        SEC
; toolsrc/ed.pla: 0195:         SBC     #$20
        SBC     #$20
; toolsrc/ed.pla: 0196: ++      STA     (DST),Y
++      STA     (DST),Y
; toolsrc/ed.pla: 0197:         DEY
        DEY
; toolsrc/ed.pla: 0198:         BNE     CPUPLP
        BNE     CPUPLP
; toolsrc/ed.pla: 0199: +++     RTS
+++     RTS
; toolsrc/ed.pla: 0200: end
; toolsrc/ed.pla: 0201: def bell#0
	!BYTE	$00			; PAD BYTE
_SUBSEG 				; BYTECODE STARTS
_C000 					; bell()
; toolsrc/ed.pla: 0202:     putc($07)
; toolsrc/ed.pla: 0203: end
	!BYTE	$0E			; CN	7
	!BYTE	$54			; CALL	_X002
_F000 	!WORD	0		
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0204: //
; toolsrc/ed.pla: 0205: // Memory management routines
; toolsrc/ed.pla: 0206: //
; toolsrc/ed.pla: 0207: def sizemask(size)
					; size -> [0]
_C001 					; sizemask()
; toolsrc/ed.pla: 0208:     if size <= 16
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/ed.pla: 0209:         return $01
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$10			; CB	16
	!BYTE	$4A			; ISLE
	!BYTE	$4C			; BRFLS	_B001
	!WORD	_B001-*
	!BYTE	$02			; CN	1
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0210:     elsif size <= 32
	!BYTE	$50			; BRNCH	_B002
	!WORD	_B002-*
_B001 
; toolsrc/ed.pla: 0211:         return $03
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$4A			; ISLE
	!BYTE	$4C			; BRFLS	_B003
	!WORD	_B003-*
	!BYTE	$06			; CN	3
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0212:     elsif size <= 48
	!BYTE	$50			; BRNCH	_B002
	!WORD	_B002-*
_B003 
; toolsrc/ed.pla: 0213:         return $07
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$4A			; ISLE
	!BYTE	$4C			; BRFLS	_B004
	!WORD	_B004-*
	!BYTE	$0E			; CN	7
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0214:     elsif size <= 64
	!BYTE	$50			; BRNCH	_B002
	!WORD	_B002-*
_B004 
; toolsrc/ed.pla: 0215:         return $0F
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$40			; CB	64
	!BYTE	$4A			; ISLE
	!BYTE	$4C			; BRFLS	_B005
	!WORD	_B005-*
	!BYTE	$1E			; CN	15
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0216:     elsif size <= 80
	!BYTE	$50			; BRNCH	_B002
	!WORD	_B002-*
_B005 
; toolsrc/ed.pla: 0217:         return $1F
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$50			; CB	80
	!BYTE	$4A			; ISLE
	!BYTE	$4C			; BRFLS	_B006
	!WORD	_B006-*
	!BYTE	$2A,$1F			; CB	31
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0218:     fin
_B006 
_B002 
; toolsrc/ed.pla: 0219:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0220: end
; toolsrc/ed.pla: 0221: def strpoolalloc(size)
					; size -> [0]
_C002 					; strpoolalloc()
; toolsrc/ed.pla: 0222:     byte szmask
					; szmask -> [2]
; toolsrc/ed.pla: 0223:     word mapmask, addr, i
					; mapmask -> [3]
					; addr -> [5]
					; i -> [7]
; toolsrc/ed.pla: 0224: 
; toolsrc/ed.pla: 0225:     szmask = sizemask(size)
	!BYTE	$58,$09,$01		; ENTER	9,1
; toolsrc/ed.pla: 0226:     for i = strplmapsize - 1 downto 0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C001
_F001 	!WORD	_C001		
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D047+0
_F002 	!WORD	_D047+0		
	!BYTE	$8E			; DECR
	!BYTE	$A2			; BRLT	_B007
	!WORD	_B007-*
_B008 
	!BYTE	$6E,$07			; DLW	[7]
; toolsrc/ed.pla: 0227:         if ^(strpoolmap + i) <> $FF
; toolsrc/ed.pla: 0228:             mapmask = szmask
; toolsrc/ed.pla: 0229:             repeat
	!BYTE	$6A			; LAW	_D050+0
_F003 	!WORD	_D050+0		
	!BYTE	$B2,$07			; ADDLW	[7]
	!BYTE	$60			; LB
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$22			; BREQ	_B010
	!WORD	_B010-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$76,$03			; SLW	[3]
_B013 
; toolsrc/ed.pla: 0230:                 if ^(strpoolmap + i) & mapmask
; toolsrc/ed.pla: 0231:                     mapmask = mapmask << 1
; toolsrc/ed.pla: 0232:                 else
	!BYTE	$6A			; LAW	_D050+0
_F004 	!WORD	_D050+0		
	!BYTE	$B2,$07			; ADDLW	[7]
	!BYTE	$60			; LB
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B015
	!WORD	_B015-*
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$76,$03			; SLW	[3]
	!BYTE	$50			; BRNCH	_B016
	!WORD	_B016-*
_B015 
; toolsrc/ed.pla: 0233:                     ^(strpoolmap + i) = ^(strpoolmap + i) | mapmask
; toolsrc/ed.pla: 0234:                     addr = (i << 7) + strpool
; toolsrc/ed.pla: 0235:                     while !(mapmask & 1)
	!BYTE	$6A			; LAW	_D050+0
_F005 	!WORD	_D050+0		
	!BYTE	$B2,$07			; ADDLW	[7]
	!BYTE	$60			; LB
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$96			; OR 
	!BYTE	$6A			; LAW	_D050+0
_F006 	!WORD	_D050+0		
	!BYTE	$B2,$07			; ADDLW	[7]
	!BYTE	$70			; SB
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$0E			; CN	7
	!BYTE	$9A			; SHL
	!BYTE	$B6			; ADDAW	_D046+0
_F007 	!WORD	_D046+0		
	!BYTE	$76,$05			; SLW	[5]
	!BYTE	$50			; BRNCH	_B019
	!WORD	_B019-*
_B017 
; toolsrc/ed.pla: 0236:                         addr = addr + 16
; toolsrc/ed.pla: 0237:                         mapmask = mapmask >> 1
; toolsrc/ed.pla: 0238:                     loop
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$76,$05			; SLW	[5]
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$02			; CN	1
	!BYTE	$9C			; SHR
	!BYTE	$76,$03			; SLW	[3]
_B019 
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B017
	!WORD	_B017-*
_B018 
; toolsrc/ed.pla: 0239:                     return addr
	!BYTE	$32			; DROP2
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$5A,$09			; LEAVE	9
; toolsrc/ed.pla: 0240:                 fin
_B016 
; toolsrc/ed.pla: 0241:             until mapmask & $100
_B014 
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$2C,$00,$01		; CW	256
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B013
	!WORD	_B013-*
_B012 
; toolsrc/ed.pla: 0242:         fin
_B010 
_B011 
; toolsrc/ed.pla: 0243:     next
_B009 
	!BYTE	$A8			; DECBRGE	_B008
	!WORD	_B008-*
_B007 
	!BYTE	$76,$07			; SLW	[7]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0244:     bell()
; toolsrc/ed.pla: 0245:     puts("OUT OF MEMORY!")
	!BYTE	$54			; CALL	_C000
_F008 	!WORD	_C000		
	!BYTE	$2E			; CS
	!BYTE	$0E
	!BYTE	$4F,$55,$54,$20,$4F,$46,$20,$4D
	!BYTE	$45,$4D,$4F,$52,$59,$21
	!BYTE	$54			; CALL	_X004
_F009 	!WORD	0		
; toolsrc/ed.pla: 0246:     return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$09			; LEAVE	9
; toolsrc/ed.pla: 0247: end
; toolsrc/ed.pla: 0248: def striplead(strptr, chr)#0
					; strptr -> [0]
					; chr -> [2]
_C003 					; striplead()
; toolsrc/ed.pla: 0249:     byte striplen
					; striplen -> [4]
; toolsrc/ed.pla: 0250: 
; toolsrc/ed.pla: 0251:     for striplen = 1 to ^strptr
	!BYTE	$58,$05,$02		; ENTER	5,2
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B020
	!WORD	_B020-*
_B021 
	!BYTE	$6C,$04			; DLB	[4]
; toolsrc/ed.pla: 0252:         if ^(strptr + striplen) <> chr
; toolsrc/ed.pla: 0253:             break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$60			; LB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$22			; BREQ	_B023
	!WORD	_B023-*
	!BYTE	$50			; BRNCH	_B020
	!WORD	_B020-*
; toolsrc/ed.pla: 0254:         fin
_B023 
_B024 
; toolsrc/ed.pla: 0255:     next
_B022 
	!BYTE	$A4			; INCBRLE	_B021
	!WORD	_B021-*
_B020 
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0256:     if striplen > 1
; toolsrc/ed.pla: 0257:         ^strptr = ^strptr - (striplen - 1)
; toolsrc/ed.pla: 0258:         memcpy(strptr + 1, strptr + striplen, ^strptr)
; toolsrc/ed.pla: 0259:     fin
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B025
	!WORD	_B025-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8E			; DECR
	!BYTE	$84			; SUB 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F010 	!WORD	0		
_B025 
_B026 
; toolsrc/ed.pla: 0260: end
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 0261: def striptail(strptr, chr)#0
					; strptr -> [0]
					; chr -> [2]
_C004 					; striptail()
; toolsrc/ed.pla: 0262:     byte strlen
					; strlen -> [4]
; toolsrc/ed.pla: 0263: 
; toolsrc/ed.pla: 0264:     for strlen = ^strptr downto 1
	!BYTE	$58,$05,$02		; ENTER	5,2
	!BYTE	$02			; CN	1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$A2			; BRLT	_B027
	!WORD	_B027-*
_B028 
	!BYTE	$6C,$04			; DLB	[4]
; toolsrc/ed.pla: 0265:         if ^(strptr + strlen) <> $8D and ^(strptr + strlen) <> chr
; toolsrc/ed.pla: 0266:             break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$60			; LB
	!BYTE	$2A,$8D			; CB	141
	!BYTE	$42			; ISNE
	!BYTE	$AC			; BRAND	_B030
	!WORD	_B030-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$60			; LB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$42			; ISNE
_B030 
	!BYTE	$4C			; BRFLS	_B031
	!WORD	_B031-*
	!BYTE	$50			; BRNCH	_B027
	!WORD	_B027-*
; toolsrc/ed.pla: 0267:         fin
_B031 
_B032 
; toolsrc/ed.pla: 0268:     next
_B029 
	!BYTE	$A8			; DECBRGE	_B028
	!WORD	_B028-*
_B027 
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0269:     ^strptr = strlen
; toolsrc/ed.pla: 0270: end
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$70			; SB
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 0271: def strstripcpy(dststr, srcstr)#0
					; dststr -> [0]
					; srcstr -> [2]
_C005 					; strstripcpy()
; toolsrc/ed.pla: 0272:     memcpy(dststr, srcstr, ^srcstr + 1)
	!BYTE	$58,$04,$02		; ENTER	4,2
; toolsrc/ed.pla: 0273:     striptail(dststr, keyspace)
; toolsrc/ed.pla: 0274: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$34			; DUP
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_X018
_F011 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$54			; CALL	_C004
_F012 	!WORD	_C004		
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 0275: def delstr(strptr)#0
					; strptr -> [0]
_C006 					; delstr()
; toolsrc/ed.pla: 0276:     byte mask, ofst
					; mask -> [2]
					; ofst -> [3]
; toolsrc/ed.pla: 0277: 
; toolsrc/ed.pla: 0278:     if strptr and strptr <> @nullstr
	!BYTE	$58,$04,$01		; ENTER	4,1
; toolsrc/ed.pla: 0279:         mask = sizemask(^strptr + 1)
; toolsrc/ed.pla: 0280:         ofst = (strptr - strpool) >> 4
; toolsrc/ed.pla: 0281:         mask = mask << (ofst & $07)
; toolsrc/ed.pla: 0282:         ofst = ofst >> 3
; toolsrc/ed.pla: 0283:         ^(strpoolmap + ofst) = ^(strpoolmap + ofst) & ~mask
; toolsrc/ed.pla: 0284:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$AC			; BRAND	_B033
	!WORD	_B033-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D036+0
_F013 	!WORD	_D036+0		
	!BYTE	$42			; ISNE
_B033 
	!BYTE	$4C			; BRFLS	_B034
	!WORD	_B034-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_C001
_F014 	!WORD	_C001		
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D046+0
_F015 	!WORD	_D046+0		
	!BYTE	$84			; SUB 
	!BYTE	$08			; CN	4
	!BYTE	$9C			; SHR
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$9A			; SHL
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$06			; CN	3
	!BYTE	$9C			; SHR
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$6A			; LAW	_D050+0
_F016 	!WORD	_D050+0		
	!BYTE	$B0,$03			; ADDLB	[3]
	!BYTE	$60			; LB
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$92			; COMP
	!BYTE	$94			; AND 
	!BYTE	$6A			; LAW	_D050+0
_F017 	!WORD	_D050+0		
	!BYTE	$B0,$03			; ADDLB	[3]
	!BYTE	$70			; SB
_B034 
_B035 
; toolsrc/ed.pla: 0285: end
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 0286: def newstr(strptr)
					; strptr -> [0]
_C007 					; newstr()
; toolsrc/ed.pla: 0287:     byte strlen
					; strlen -> [2]
; toolsrc/ed.pla: 0288:     word newptr
					; newptr -> [3]
; toolsrc/ed.pla: 0289: 
; toolsrc/ed.pla: 0290:     strlen = ^strptr
	!BYTE	$58,$05,$01		; ENTER	5,1
; toolsrc/ed.pla: 0291:     while ^(strptr + strlen) == keyenter or ^(strptr + strlen) == keyspace
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$50			; BRNCH	_B038
	!WORD	_B038-*
_B036 
; toolsrc/ed.pla: 0292:         strlen--
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0293:     loop
	!BYTE	$74,$02			; SLB	[2]
_B038 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$60			; LB
	!BYTE	$2A,$8D			; CB	141
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B039
	!WORD	_B039-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$60			; LB
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$40			; ISEQ
_B039 
	!BYTE	$4E			; BRTRU	_B036
	!WORD	_B036-*
_B037 
; toolsrc/ed.pla: 0294:     if strlen == 0
; toolsrc/ed.pla: 0295:         return @nullstr
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$4E			; BRTRU	_B040
	!WORD	_B040-*
	!BYTE	$26			; LA	_D036+0
_F018 	!WORD	_D036+0		
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 0296:     fin
_B040 
_B041 
; toolsrc/ed.pla: 0297:     newptr = strpoolalloc(strlen + 1)
; toolsrc/ed.pla: 0298:     if newptr
; toolsrc/ed.pla: 0299:         memcpy(newptr, strptr, strlen + 1)
; toolsrc/ed.pla: 0300:         ^newptr = strlen
; toolsrc/ed.pla: 0301:         return newptr
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_C002
_F019 	!WORD	_C002		
	!BYTE	$6E,$03			; DLW	[3]
	!BYTE	$4C			; BRFLS	_B042
	!WORD	_B042-*
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_X018
_F020 	!WORD	0		
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$70			; SB
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 0302:     fin
_B042 
_B043 
; toolsrc/ed.pla: 0303:     return @nullstr
	!BYTE	$26			; LA	_D036+0
_F021 	!WORD	_D036+0		
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 0304: end
; toolsrc/ed.pla: 0305: def inittxtbuf#0
_C008 					; inittxtbuf()
; toolsrc/ed.pla: 0306:     word i
					; i -> [0]
; toolsrc/ed.pla: 0307: 
; toolsrc/ed.pla: 0308:     if not strpool
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/ed.pla: 0309:         txtlinbuf  = heapalloc(MAXLINESSIZE*2)
; toolsrc/ed.pla: 0310:         cliplinbuf = heapalloc(MAXCLIPLINES*2)
; toolsrc/ed.pla: 0311:         while isult(heapavail, strplsize)
	!BYTE	$6A			; LAW	_D046+0
_F022 	!WORD	_D046+0		
	!BYTE	$4E			; BRTRU	_B044
	!WORD	_B044-*
	!BYTE	$2C,$FE,$07		; CW	2046
	!BYTE	$54			; CALL	_X014
_F023 	!WORD	0		
	!BYTE	$7A			; SAW	_D048+0
_F024 	!WORD	_D048+0		
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$54			; CALL	_X014
_F025 	!WORD	0		
	!BYTE	$7A			; SAW	_D049+0
_F026 	!WORD	_D049+0		
	!BYTE	$50			; BRNCH	_B048
	!WORD	_B048-*
_B046 
; toolsrc/ed.pla: 0312:             strplsize = strplsize - 4096
; toolsrc/ed.pla: 0313:         loop
	!BYTE	$6A			; LAW	_D045+0
_F027 	!WORD	_D045+0		
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$84			; SUB 
	!BYTE	$7A			; SAW	_D045+0
_F028 	!WORD	_D045+0		
_B048 
	!BYTE	$54			; CALL	_X016
_F029 	!WORD	0		
	!BYTE	$6A			; LAW	_D045+0
_F030 	!WORD	_D045+0		
	!BYTE	$54			; CALL	_X026
_F031 	!WORD	0		
	!BYTE	$4E			; BRTRU	_B046
	!WORD	_B046-*
_B047 
; toolsrc/ed.pla: 0314:         if isult(heapavail - strplsize, 4096) // Keep at least 4096 free
; toolsrc/ed.pla: 0315:             strplsize = strplsize - 4096
; toolsrc/ed.pla: 0316:         fin
	!BYTE	$54			; CALL	_X016
_F032 	!WORD	0		
	!BYTE	$6A			; LAW	_D045+0
_F033 	!WORD	_D045+0		
	!BYTE	$84			; SUB 
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$54			; CALL	_X026
_F034 	!WORD	0		
	!BYTE	$4C			; BRFLS	_B049
	!WORD	_B049-*
	!BYTE	$6A			; LAW	_D045+0
_F035 	!WORD	_D045+0		
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$84			; SUB 
	!BYTE	$7A			; SAW	_D045+0
_F036 	!WORD	_D045+0		
_B049 
_B050 
; toolsrc/ed.pla: 0317:         strplmapsize = strplsize / 128
; toolsrc/ed.pla: 0318:         strpoolmap   = heapalloc(strplmapsize)
; toolsrc/ed.pla: 0319:         strpool      = heapalloc(strplsize)
; toolsrc/ed.pla: 0320:         memset(txtlinbuf,  @nullstr, MAXLINESSIZE*2)
; toolsrc/ed.pla: 0321:         memset(cliplinbuf, @nullstr, MAXCLIPLINES*2)
; toolsrc/ed.pla: 0322:         memset(strpoolmap, 0, strplmapsize)
; toolsrc/ed.pla: 0323:     else
	!BYTE	$6A			; LAW	_D045+0
_F037 	!WORD	_D045+0		
	!BYTE	$0E			; CN	7
	!BYTE	$9C			; SHR
	!BYTE	$7E			; DAW	_D047+0
_F038 	!WORD	_D047+0		
	!BYTE	$54			; CALL	_X014
_F039 	!WORD	0		
	!BYTE	$7A			; SAW	_D050+0
_F040 	!WORD	_D050+0		
	!BYTE	$6A			; LAW	_D045+0
_F041 	!WORD	_D045+0		
	!BYTE	$54			; CALL	_X014
_F042 	!WORD	0		
	!BYTE	$7A			; SAW	_D046+0
_F043 	!WORD	_D046+0		
	!BYTE	$6A			; LAW	_D048+0
_F044 	!WORD	_D048+0		
	!BYTE	$26			; LA	_D036+0
_F045 	!WORD	_D036+0		
	!BYTE	$2C,$FE,$07		; CW	2046
	!BYTE	$54			; CALL	_X017
_F046 	!WORD	0		
	!BYTE	$6A			; LAW	_D049+0
_F047 	!WORD	_D049+0		
	!BYTE	$26			; LA	_D036+0
_F048 	!WORD	_D036+0		
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$54			; CALL	_X017
_F049 	!WORD	0		
	!BYTE	$6A			; LAW	_D050+0
_F050 	!WORD	_D050+0		
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D047+0
_F051 	!WORD	_D047+0		
	!BYTE	$54			; CALL	_X017
_F052 	!WORD	0		
	!BYTE	$50			; BRNCH	_B045
	!WORD	_B045-*
_B044 
; toolsrc/ed.pla: 0324:         for i = 0 to MAXLINESSIZE-1
	!BYTE	$2C,$FE,$03		; CW	1022
	!BYTE	$00			; CN	0
_B052 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0325:             if txtlinbuf=>[i] <> @nullstr
; toolsrc/ed.pla: 0326:                 delstr(txtlinbuf=>[i])
; toolsrc/ed.pla: 0327:                 txtlinbuf=>[i] = @nullstr
; toolsrc/ed.pla: 0328:             fin
	!BYTE	$6A			; LAW	_D048+0
_F053 	!WORD	_D048+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$26			; LA	_D036+0
_F054 	!WORD	_D036+0		
	!BYTE	$22			; BREQ	_B054
	!WORD	_B054-*
	!BYTE	$6A			; LAW	_D048+0
_F055 	!WORD	_D048+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C006
_F056 	!WORD	_C006		
	!BYTE	$26			; LA	_D036+0
_F057 	!WORD	_D036+0		
	!BYTE	$6A			; LAW	_D048+0
_F058 	!WORD	_D048+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$72			; SW
_B054 
_B055 
; toolsrc/ed.pla: 0329:         next
_B053 
	!BYTE	$A4			; INCBRLE	_B052
	!WORD	_B052-*
_B051 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0330:     fin
_B045 
; toolsrc/ed.pla: 0331:     numlines   = 1
; toolsrc/ed.pla: 0332:     cursrow    = 0
; toolsrc/ed.pla: 0333:     curscol    = 0
; toolsrc/ed.pla: 0334:     cursx      = 0
; toolsrc/ed.pla: 0335:     cursy      = 0
; toolsrc/ed.pla: 0336:     scrnleft   = 0
; toolsrc/ed.pla: 0337:     scrntop    = 0
; toolsrc/ed.pla: 0338:     flags      = flags & ~selection
; toolsrc/ed.pla: 0339: end
	!BYTE	$02			; CN	1
	!BYTE	$7A			; SAW	_D042+0
_F059 	!WORD	_D042+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D058+0
_F060 	!WORD	_D058+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D054+0
_F061 	!WORD	_D054+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D051+0
_F062 	!WORD	_D051+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D052+0
_F063 	!WORD	_D052+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D053+0
_F064 	!WORD	_D053+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D060+0
_F065 	!WORD	_D060+0		
	!BYTE	$68			; LAB	_D040+0
_F066 	!WORD	_D040+0		
	!BYTE	$5E,$EF			; CFFB	-17
	!BYTE	$94			; AND 
	!BYTE	$78			; SAB	_D040+0
_F067 	!WORD	_D040+0		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0340: //
; toolsrc/ed.pla: 0341: // Case conversion/printing routines
; toolsrc/ed.pla: 0342: //
; toolsrc/ed.pla: 0343: def caseconv(chr)
					; chr -> [0]
_C009 					; caseconv()
; toolsrc/ed.pla: 0344:     if flags & uppercase
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/ed.pla: 0345:         if chr & $E0 == $E0
; toolsrc/ed.pla: 0346:             chr = chr - $E0
; toolsrc/ed.pla: 0347:         fin
	!BYTE	$68			; LAB	_D040+0
_F068 	!WORD	_D040+0		
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B056
	!WORD	_B056-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$E0			; ANDI	224
	!BYTE	$2A,$E0			; CB	224
	!BYTE	$24			; BRNE	_B058
	!WORD	_B058-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3A,$E0			; SUBI	224
	!BYTE	$76,$00			; SLW	[0]
_B058 
_B059 
; toolsrc/ed.pla: 0348:     fin
_B056 
_B057 
; toolsrc/ed.pla: 0349:     return chr
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0350: end
; toolsrc/ed.pla: 0351: def strupper(strptr)#0
					; strptr -> [0]
_C010 					; strupper()
; toolsrc/ed.pla: 0352:     byte i, chr
					; i -> [2]
					; chr -> [3]
; toolsrc/ed.pla: 0353: 
; toolsrc/ed.pla: 0354:     if ^strptr
	!BYTE	$58,$04,$01		; ENTER	4,1
; toolsrc/ed.pla: 0355:         for i = ^strptr downto 1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B060
	!WORD	_B060-*
	!BYTE	$02			; CN	1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$A2			; BRLT	_B062
	!WORD	_B062-*
_B063 
	!BYTE	$6C,$02			; DLB	[2]
; toolsrc/ed.pla: 0356:             chr = (strptr).[i]
; toolsrc/ed.pla: 0357:             if chr & $E0 == $E0
; toolsrc/ed.pla: 0358:                 (strptr).[i] = chr - $E0
; toolsrc/ed.pla: 0359:             fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$60			; LB
	!BYTE	$6C,$03			; DLB	[3]
	!BYTE	$3C,$E0			; ANDI	224
	!BYTE	$2A,$E0			; CB	224
	!BYTE	$24			; BRNE	_B065
	!WORD	_B065-*
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$3A,$E0			; SUBI	224
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$70			; SB
_B065 
_B066 
; toolsrc/ed.pla: 0360:         next
_B064 
	!BYTE	$A8			; DECBRGE	_B063
	!WORD	_B063-*
_B062 
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0361:     fin
_B060 
_B061 
; toolsrc/ed.pla: 0362: end
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 0363: def strlower(strptr)#0
					; strptr -> [0]
_C011 					; strlower()
; toolsrc/ed.pla: 0364:     byte i, chr
					; i -> [2]
					; chr -> [3]
; toolsrc/ed.pla: 0365: 
; toolsrc/ed.pla: 0366:     if ^strptr
	!BYTE	$58,$04,$01		; ENTER	4,1
; toolsrc/ed.pla: 0367:         for i = ^strptr downto 1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B067
	!WORD	_B067-*
	!BYTE	$02			; CN	1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$A2			; BRLT	_B069
	!WORD	_B069-*
_B070 
	!BYTE	$6C,$02			; DLB	[2]
; toolsrc/ed.pla: 0368:             chr = (strptr).[i]
; toolsrc/ed.pla: 0369:             if chr & $E0 == $00
; toolsrc/ed.pla: 0370:                 (strptr).[i] = chr + $E0
; toolsrc/ed.pla: 0371:             fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$60			; LB
	!BYTE	$6C,$03			; DLB	[3]
	!BYTE	$3C,$E0			; ANDI	224
	!BYTE	$4E			; BRTRU	_B072
	!WORD	_B072-*
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$38,$E0			; ADDI	224
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$70			; SB
_B072 
_B073 
; toolsrc/ed.pla: 0372:         next
_B071 
	!BYTE	$A8			; DECBRGE	_B070
	!WORD	_B070-*
_B069 
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0373:     fin
_B067 
_B068 
; toolsrc/ed.pla: 0374: end
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 0375: def txtupper#0
_C012 					; txtupper()
; toolsrc/ed.pla: 0376:     word i, strptr
					; i -> [0]
					; strptr -> [2]
; toolsrc/ed.pla: 0377: 
; toolsrc/ed.pla: 0378:     flags = flags | uppercase
	!BYTE	$58,$04,$00		; ENTER	4,0
; toolsrc/ed.pla: 0379:     for i = numlines - 1 downto 0
	!BYTE	$68			; LAB	_D040+0
_F069 	!WORD	_D040+0		
	!BYTE	$3E,$08			; ORI	8
	!BYTE	$78			; SAB	_D040+0
_F070 	!WORD	_D040+0		
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D042+0
_F071 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$A2			; BRLT	_B074
	!WORD	_B074-*
_B075 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0380:         strupper(txtlinbuf=>[i])
; toolsrc/ed.pla: 0381:     next
	!BYTE	$6A			; LAW	_D048+0
_F072 	!WORD	_D048+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C010
_F073 	!WORD	_C010		
_B076 
	!BYTE	$A8			; DECBRGE	_B075
	!WORD	_B075-*
_B074 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0382: end
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 0383: def txtlower#0
_C013 					; txtlower()
; toolsrc/ed.pla: 0384:     word i, strptr
					; i -> [0]
					; strptr -> [2]
; toolsrc/ed.pla: 0385: 
; toolsrc/ed.pla: 0386:     flags = flags & ~uppercase
	!BYTE	$58,$04,$00		; ENTER	4,0
; toolsrc/ed.pla: 0387:     for i = numlines - 1 downto 0
	!BYTE	$68			; LAB	_D040+0
_F074 	!WORD	_D040+0		
	!BYTE	$5E,$F7			; CFFB	-9
	!BYTE	$94			; AND 
	!BYTE	$78			; SAB	_D040+0
_F075 	!WORD	_D040+0		
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D042+0
_F076 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$A2			; BRLT	_B077
	!WORD	_B077-*
_B078 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0388:         strlower(txtlinbuf=>[i])
; toolsrc/ed.pla: 0389:     next
	!BYTE	$6A			; LAW	_D048+0
_F077 	!WORD	_D048+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C011
_F078 	!WORD	_C011		
_B079 
	!BYTE	$A8			; DECBRGE	_B078
	!WORD	_B078-*
_B077 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0390: end
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 0391: def strtonum(strptr)
					; strptr -> [0]
_C014 					; strtonum()
; toolsrc/ed.pla: 0392:     word num, i
					; num -> [2]
					; i -> [4]
; toolsrc/ed.pla: 0393:     byte c
					; c -> [6]
; toolsrc/ed.pla: 0394: 
; toolsrc/ed.pla: 0395:     num = 0
	!BYTE	$58,$07,$01		; ENTER	7,1
; toolsrc/ed.pla: 0396:     for i = 1 to ^strptr
	!BYTE	$00			; CN	0
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B080
	!WORD	_B080-*
_B081 
	!BYTE	$6E,$04			; DLW	[4]
; toolsrc/ed.pla: 0397:         c = ^(strptr + i) & $7F
; toolsrc/ed.pla: 0398:         if c < '0' and c > '9'
; toolsrc/ed.pla: 0399:             break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$60			; LB
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$6C,$06			; DLB	[6]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$46			; ISLT
	!BYTE	$AC			; BRAND	_B083
	!WORD	_B083-*
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$2A,$39			; CB	57
	!BYTE	$44			; ISGT
_B083 
	!BYTE	$4C			; BRFLS	_B084
	!WORD	_B084-*
	!BYTE	$50			; BRNCH	_B080
	!WORD	_B080-*
; toolsrc/ed.pla: 0400:         fin
_B084 
_B085 
; toolsrc/ed.pla: 0401:         num = num * 10 + c - '0'
; toolsrc/ed.pla: 0402:     next
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$14			; CN	10
	!BYTE	$86			; MUL
	!BYTE	$B0,$06			; ADDLB	[6]
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$76,$02			; SLW	[2]
_B082 
	!BYTE	$A4			; INCBRLE	_B081
	!WORD	_B081-*
_B080 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0403:     return num
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$07			; LEAVE	7
; toolsrc/ed.pla: 0404: end
; toolsrc/ed.pla: 0405: def nametostr(namestr, len, strptr)#0
					; namestr -> [0]
					; len -> [2]
					; strptr -> [4]
_C015 					; nametostr()
; toolsrc/ed.pla: 0406:     ^strptr = len
	!BYTE	$58,$06,$03		; ENTER	6,3
; toolsrc/ed.pla: 0407:     memcpy(strptr + 1, namestr, len)
; toolsrc/ed.pla: 0408: end
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_X018
_F079 	!WORD	0		
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/ed.pla: 0409: //
; toolsrc/ed.pla: 0410: // File routines
; toolsrc/ed.pla: 0411: //
; toolsrc/ed.pla: 0412: def readtxt(filename, startline)#0
					; filename -> [0]
					; startline -> [2]
_C016 					; readtxt()
; toolsrc/ed.pla: 0413:     byte refnum, i, j, txtbuf[MAXLNLEN+2]
					; refnum -> [4]
					; i -> [5]
					; j -> [6]
					; txtbuf -> [7]
; toolsrc/ed.pla: 0414: 
; toolsrc/ed.pla: 0415:     refnum = fileio:open(filename)
	!BYTE	$58,$58,$02		; ENTER	88,2
; toolsrc/ed.pla: 0416:     if refnum
; toolsrc/ed.pla: 0417:         fileio:newline(refnum, $7F, $0D)
; toolsrc/ed.pla: 0418:         numlines = startline
; toolsrc/ed.pla: 0419:         repeat
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X031+14
_F080 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$4C			; BRFLS	_B086
	!WORD	_B086-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$1A			; CN	13
	!BYTE	$6A			; LAW	_X031+28
_F081 	!WORD	0+28		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$7A			; SAW	_D042+0
_F082 	!WORD	_D042+0		
_B089 
; toolsrc/ed.pla: 0420:             txtbuf = fileio:read(refnum, @txtbuf + 1, MAXLNLEN)
; toolsrc/ed.pla: 0421:             if txtbuf
; toolsrc/ed.pla: 0422:                 sethibit(@txtbuf)
; toolsrc/ed.pla: 0423:                 if flags & uppercase; strupper(@txtbuf); fin
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$2A,$4F			; CB	79
	!BYTE	$6A			; LAW	_X031+18
_F083 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$6C,$07			; DLB	[7]
	!BYTE	$4C			; BRFLS	_B091
	!WORD	_B091-*
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$54			; CALL	_A001
_F084 	!WORD	_A001		
	!BYTE	$68			; LAB	_D040+0
_F085 	!WORD	_D040+0		
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B093
	!WORD	_B093-*
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$54			; CALL	_C010
_F086 	!WORD	_C010		
_B093 
_B094 
; toolsrc/ed.pla: 0424:                 txtlinbuf=>[numlines] = newstr(@txtbuf)
; toolsrc/ed.pla: 0425:                 numlines++
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$54			; CALL	_C007
_F087 	!WORD	_C007		
	!BYTE	$6A			; LAW	_D048+0
_F088 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D042+0
_F089 	!WORD	_D042+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D042+0
_F090 	!WORD	_D042+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0426:             fin
	!BYTE	$7A			; SAW	_D042+0
_F091 	!WORD	_D042+0		
_B091 
_B092 
; toolsrc/ed.pla: 0427:             if !(numlines & $0F); putc('.'); fin
	!BYTE	$6A			; LAW	_D042+0
_F092 	!WORD	_D042+0		
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$4E			; BRTRU	_B095
	!WORD	_B095-*
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X002
_F093 	!WORD	0		
_B095 
_B096 
; toolsrc/ed.pla: 0428:         until txtbuf == 0 or numlines == MAXLINES
_B090 
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$80			; NOT
	!BYTE	$AE			; BROR	_B097
	!WORD	_B097-*
	!BYTE	$6A			; LAW	_D042+0
_F094 	!WORD	_D042+0		
	!BYTE	$2C,$E7,$03		; CW	999
	!BYTE	$40			; ISEQ
_B097 
	!BYTE	$4C			; BRFLS	_B089
	!WORD	_B089-*
_B088 
; toolsrc/ed.pla: 0429:         fileio:close(refnum)
; toolsrc/ed.pla: 0430:         //
; toolsrc/ed.pla: 0431:         // Make sure there is a blank line at the end of the buffer
; toolsrc/ed.pla: 0432:         //
; toolsrc/ed.pla: 0433:         if numlines < MAXLINES and txtlinbuf=>[numlines - 1] <> @nullstr
; toolsrc/ed.pla: 0434:             txtlinbuf=>[numlines] = @nullstr
; toolsrc/ed.pla: 0435:             numlines++
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$6A			; LAW	_X031+16
_F095 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D042+0
_F096 	!WORD	_D042+0		
	!BYTE	$2C,$E7,$03		; CW	999
	!BYTE	$46			; ISLT
	!BYTE	$AC			; BRAND	_B098
	!WORD	_B098-*
	!BYTE	$6A			; LAW	_D048+0
_F097 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D042+0
_F098 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$26			; LA	_D036+0
_F099 	!WORD	_D036+0		
	!BYTE	$42			; ISNE
_B098 
	!BYTE	$4C			; BRFLS	_B099
	!WORD	_B099-*
	!BYTE	$26			; LA	_D036+0
_F100 	!WORD	_D036+0		
	!BYTE	$6A			; LAW	_D048+0
_F101 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D042+0
_F102 	!WORD	_D042+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D042+0
_F103 	!WORD	_D042+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0436:         fin
	!BYTE	$7A			; SAW	_D042+0
_F104 	!WORD	_D042+0		
_B099 
_B100 
; toolsrc/ed.pla: 0437:     fin
_B086 
_B087 
; toolsrc/ed.pla: 0438:     putln
; toolsrc/ed.pla: 0439: end
	!BYTE	$54			; CALL	_X003
_F105 	!WORD	0		
	!BYTE	$5A,$58			; LEAVE	88
; toolsrc/ed.pla: 0440: def writetxt(filename)#0
					; filename -> [0]
_C017 					; writetxt()
; toolsrc/ed.pla: 0441:     word i
					; i -> [2]
; toolsrc/ed.pla: 0442:     byte refnum, txtbuf[MAXLNLEN+2]
					; refnum -> [4]
					; txtbuf -> [5]
; toolsrc/ed.pla: 0443: 
; toolsrc/ed.pla: 0444:     //
; toolsrc/ed.pla: 0445:     // Remove blank lines at end of text.
; toolsrc/ed.pla: 0446:     //
; toolsrc/ed.pla: 0447:     while numlines > 1 and txtlinbuf=>[numlines - 1] == @nullstr; numlines--; loop
	!BYTE	$58,$56,$01		; ENTER	86,1
	!BYTE	$50			; BRNCH	_B103
	!WORD	_B103-*
_B101 
	!BYTE	$6A			; LAW	_D042+0
_F106 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$7A			; SAW	_D042+0
_F107 	!WORD	_D042+0		
_B103 
	!BYTE	$6A			; LAW	_D042+0
_F108 	!WORD	_D042+0		
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$AC			; BRAND	_B104
	!WORD	_B104-*
	!BYTE	$6A			; LAW	_D048+0
_F109 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D042+0
_F110 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$26			; LA	_D036+0
_F111 	!WORD	_D036+0		
	!BYTE	$40			; ISEQ
_B104 
	!BYTE	$4E			; BRTRU	_B101
	!WORD	_B101-*
_B102 
; toolsrc/ed.pla: 0448:     //
; toolsrc/ed.pla: 0449:     // Delete old file and re-create
; toolsrc/ed.pla: 0450:     //
; toolsrc/ed.pla: 0451:     fileio:destroy(filename)
; toolsrc/ed.pla: 0452:     fileio:create(filename, $04, $00) // full access, TXT file
; toolsrc/ed.pla: 0453:     refnum = fileio:open(filename)
; toolsrc/ed.pla: 0454:     if refnum == 0
; toolsrc/ed.pla: 0455:         puts("\nError $"); puth(perr); puts(" opening: "); puts(filename); putln
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X031+24
_F112 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$08			; CN	4
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_X031+22
_F113 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_X031+14
_F114 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$4E			; BRTRU	_B105
	!WORD	_B105-*
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$0D,$45,$72,$72,$6F,$72,$20,$24
	!BYTE	$54			; CALL	_X004
_F115 	!WORD	0		
	!BYTE	$68			; LAB	_X032+0
_F116 	!WORD	0+0		
	!BYTE	$54			; CALL	_X009
_F117 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$0A
	!BYTE	$20,$6F,$70,$65,$6E,$69,$6E,$67
	!BYTE	$3A,$20
	!BYTE	$54			; CALL	_X004
_F118 	!WORD	0		
; toolsrc/ed.pla: 0456:         return
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X004
_F119 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F120 	!WORD	0		
	!BYTE	$5A,$56			; LEAVE	86
; toolsrc/ed.pla: 0457:     fin
_B105 
_B106 
; toolsrc/ed.pla: 0458:     //
; toolsrc/ed.pla: 0459:     // Write all the text lines to the file.
; toolsrc/ed.pla: 0460:     //
; toolsrc/ed.pla: 0461:     for i = 0 to numlines - 1
	!BYTE	$6A			; LAW	_D042+0
_F121 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B107
	!WORD	_B107-*
_B108 
	!BYTE	$6E,$02			; DLW	[2]
; toolsrc/ed.pla: 0462:         lncpy(@txtbuf, txtlinbuf=>[i])
; toolsrc/ed.pla: 0463:         if fileio:write(refnum, @txtbuf + 1, txtbuf) <> txtbuf
; toolsrc/ed.pla: 0464:             puts("\nError $"); puth(perr); puts(" writing: "); puts(filename); putln
	!BYTE	$28,$05			; LLA	[5]
	!BYTE	$6A			; LAW	_D048+0
_F122 	!WORD	_D048+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_A002
_F123 	!WORD	_A002		
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$6A			; LAW	_X031+20
_F124 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$22			; BREQ	_B110
	!WORD	_B110-*
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$0D,$45,$72,$72,$6F,$72,$20,$24
	!BYTE	$54			; CALL	_X004
_F125 	!WORD	0		
	!BYTE	$68			; LAB	_X032+0
_F126 	!WORD	0+0		
	!BYTE	$54			; CALL	_X009
_F127 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$0A
	!BYTE	$20,$77,$72,$69,$74,$69,$6E,$67
	!BYTE	$3A,$20
	!BYTE	$54			; CALL	_X004
_F128 	!WORD	0		
; toolsrc/ed.pla: 0465:             fileio:close(refnum)
; toolsrc/ed.pla: 0466:             return
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X004
_F129 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F130 	!WORD	0		
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$6A			; LAW	_X031+16
_F131 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$32			; DROP2
	!BYTE	$5A,$56			; LEAVE	86
; toolsrc/ed.pla: 0467:         fin
_B110 
_B111 
; toolsrc/ed.pla: 0468:         if !(i & $0F); putc('.'); fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$4E			; BRTRU	_B112
	!WORD	_B112-*
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X002
_F132 	!WORD	0		
_B112 
_B113 
; toolsrc/ed.pla: 0469:     next
_B109 
	!BYTE	$A4			; INCBRLE	_B108
	!WORD	_B108-*
_B107 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0470:     if fileio:close(refnum) <> FILE_ERR_OK
; toolsrc/ed.pla: 0471:         puts("\nError $"); puth(perr); puts(" closing: "); puts(filename)
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$6A			; LAW	_X031+16
_F133 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$4C			; BRFLS	_B114
	!WORD	_B114-*
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$0D,$45,$72,$72,$6F,$72,$20,$24
	!BYTE	$54			; CALL	_X004
_F134 	!WORD	0		
	!BYTE	$68			; LAB	_X032+0
_F135 	!WORD	0+0		
	!BYTE	$54			; CALL	_X009
_F136 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$0A
	!BYTE	$20,$63,$6C,$6F,$73,$69,$6E,$67
	!BYTE	$3A,$20
	!BYTE	$54			; CALL	_X004
_F137 	!WORD	0		
; toolsrc/ed.pla: 0472:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X004
_F138 	!WORD	0		
_B114 
_B115 
; toolsrc/ed.pla: 0473:     putln
; toolsrc/ed.pla: 0474: end
	!BYTE	$54			; CALL	_X003
_F139 	!WORD	0		
	!BYTE	$5A,$56			; LEAVE	86
; toolsrc/ed.pla: 0475: //
; toolsrc/ed.pla: 0476: // Screen routines
; toolsrc/ed.pla: 0477: //
; toolsrc/ed.pla: 0478: def clrscrn#0
_C018 					; clrscrn()
; toolsrc/ed.pla: 0479:     if MACHID == $F2 // Apple 3
; toolsrc/ed.pla: 0480:         putc(28)
; toolsrc/ed.pla: 0481:     else
	!BYTE	$68			; LAB	_X001+0
_F140 	!WORD	0+0		
	!BYTE	$2A,$F2			; CB	242
	!BYTE	$24			; BRNE	_B116
	!WORD	_B116-*
	!BYTE	$2A,$1C			; CB	28
	!BYTE	$54			; CALL	_X002
_F141 	!WORD	0		
	!BYTE	$50			; BRNCH	_B117
	!WORD	_B117-*
_B116 
; toolsrc/ed.pla: 0482:         call($FC58, 0, 0, 0, 0)
; toolsrc/ed.pla: 0483:     fin
	!BYTE	$2C,$58,$FC		; CW	64600
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_X010
_F142 	!WORD	0		
	!BYTE	$30			; DROP 
_B117 
; toolsrc/ed.pla: 0484: end
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0485: def drawrow(row, ofst, strptr)#0
					; row -> [0]
					; ofst -> [2]
					; strptr -> [4]
_C019 					; drawrow()
; toolsrc/ed.pla: 0486:     byte numchars
					; numchars -> [6]
; toolsrc/ed.pla: 0487:     word scrnptr
					; scrnptr -> [7]
; toolsrc/ed.pla: 0488: 
; toolsrc/ed.pla: 0489:     scrnptr = txtscrn[row] + (flags & gutter)
	!BYTE	$58,$09,$03		; ENTER	9,3
; toolsrc/ed.pla: 0490:     if ofst >= ^strptr
; toolsrc/ed.pla: 0491:         numchars = 0
; toolsrc/ed.pla: 0492:     else
	!BYTE	$26			; LA	_D035+0
_F143 	!WORD	_D035+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$68			; LAB	_D040+0
_F144 	!WORD	_D040+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$82			; ADD 
	!BYTE	$76,$07			; SLW	[7]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B118
	!WORD	_B118-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$50			; BRNCH	_B119
	!WORD	_B119-*
_B118 
; toolsrc/ed.pla: 0493:         numchars = ^strptr - ofst
; toolsrc/ed.pla: 0494:     fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$84			; SUB 
	!BYTE	$74,$06			; SLB	[6]
_B119 
; toolsrc/ed.pla: 0495:     if numchars >= scrnwidth
; toolsrc/ed.pla: 0496:         numchars = scrnwidth
; toolsrc/ed.pla: 0497:     else
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$6A			; LAW	_D033+0
_F145 	!WORD	_D033+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B120
	!WORD	_B120-*
	!BYTE	$6A			; LAW	_D033+0
_F146 	!WORD	_D033+0		
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$50			; BRNCH	_B121
	!WORD	_B121-*
_B120 
; toolsrc/ed.pla: 0498:         memset(scrnptr + numchars, $A0A0, scrnwidth - numchars)
; toolsrc/ed.pla: 0499:     fin
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$B0,$06			; ADDLB	[6]
	!BYTE	$2C,$A0,$A0		; CW	41120
	!BYTE	$6A			; LAW	_D033+0
_F147 	!WORD	_D033+0		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X017
_F148 	!WORD	0		
_B121 
; toolsrc/ed.pla: 0500:     memcpy(scrnptr, strptr + ofst + 1, numchars)
; toolsrc/ed.pla: 0501: end
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$54			; CALL	_X018
_F149 	!WORD	0		
	!BYTE	$5A,$09			; LEAVE	9
; toolsrc/ed.pla: 0502: def drawgutter(scrnrow, ofst)#0
					; scrnrow -> [0]
					; ofst -> [2]
_C020 					; drawgutter()
; toolsrc/ed.pla: 0503:     byte row, hilite, ofstch, huns, tens, ones
					; row -> [4]
					; hilite -> [5]
					; ofstch -> [6]
					; huns -> [7]
					; tens -> [8]
					; ones -> [9]
; toolsrc/ed.pla: 0504:     word scrnptr, scrnrow
					; scrnptr -> [10]
					; scrnrow -> [12]
; toolsrc/ed.pla: 0505: 
; toolsrc/ed.pla: 0506:     //
; toolsrc/ed.pla: 0507:     // Draw line numbers and gutter hilites
; toolsrc/ed.pla: 0508:     //
; toolsrc/ed.pla: 0509:     //ofstch = ofst ?? $80 | '<' :: keyspace
; toolsrc/ed.pla: 0510:     ofstch = ofst ?? '<' :: ' '
	!BYTE	$58,$0E,$02		; ENTER	14,2
; toolsrc/ed.pla: 0511:     huns, tens = divmod(scrnrow + 1, 100)
; toolsrc/ed.pla: 0512:     tens, ones = divmod(tens, 10)
; toolsrc/ed.pla: 0513:     for row = 0 to 23
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B122
	!WORD	_B122-*
	!BYTE	$2A,$3C			; CB	60
	!BYTE	$50			; BRNCH	_B123
	!WORD	_B123-*
_B122 
	!BYTE	$2A,$20			; CB	32
_B123 
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$2A,$64			; CB	100
	!BYTE	$54			; CALL	_X023
_F150 	!WORD	0		
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$74,$07			; SLB	[7]
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$14			; CN	10
	!BYTE	$54			; CALL	_X023
_F151 	!WORD	0		
	!BYTE	$74,$09			; SLB	[9]
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$2A,$17			; CB	23
	!BYTE	$00			; CN	0
_B125 
	!BYTE	$6C,$04			; DLB	[4]
; toolsrc/ed.pla: 0514:         scrnptr = txtscrn[row]
; toolsrc/ed.pla: 0515:         if scrnrow < numlines
; toolsrc/ed.pla: 0516:             if flags & selection and (scrnrow >= selrow and scrnrow <= cursrow) or (scrnrow >= cursrow and scrnrow <= selrow)
; toolsrc/ed.pla: 0517:                 hilite = $00
; toolsrc/ed.pla: 0518:             elsif scrnrow == cursrow
	!BYTE	$26			; LA	_D035+0
_F152 	!WORD	_D035+0		
	!BYTE	$B8,$04			; IDXLB	[4]
	!BYTE	$62			; LW
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D042+0
_F153 	!WORD	_D042+0		
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B127
	!WORD	_B127-*
	!BYTE	$68			; LAB	_D040+0
_F154 	!WORD	_D040+0		
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$AC			; BRAND	_B129
	!WORD	_B129-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D059+0
_F155 	!WORD	_D059+0		
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B130
	!WORD	_B130-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D058+0
_F156 	!WORD	_D058+0		
	!BYTE	$4A			; ISLE
_B130 
	!BYTE	$AE			; BROR	_B131
	!WORD	_B131-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D058+0
_F157 	!WORD	_D058+0		
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B132
	!WORD	_B132-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D059+0
_F158 	!WORD	_D059+0		
	!BYTE	$4A			; ISLE
_B132 
_B131 
_B129 
	!BYTE	$4C			; BRFLS	_B133
	!WORD	_B133-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B134
	!WORD	_B134-*
_B133 
; toolsrc/ed.pla: 0519:                 hilite = $00
; toolsrc/ed.pla: 0520:             else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D058+0
_F159 	!WORD	_D058+0		
	!BYTE	$24			; BRNE	_B135
	!WORD	_B135-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B134
	!WORD	_B134-*
_B135 
; toolsrc/ed.pla: 0521:                 hilite = $80
; toolsrc/ed.pla: 0522:             fin
	!BYTE	$2A,$80			; CB	128
	!BYTE	$74,$05			; SLB	[5]
_B134 
; toolsrc/ed.pla: 0523:             if huns
; toolsrc/ed.pla: 0524:                 ^scrnptr     = hilite + '0' + huns
; toolsrc/ed.pla: 0525:                 ^(scrnptr+1) = hilite + '0' + tens
; toolsrc/ed.pla: 0526:                 ^(scrnptr+2) = hilite + '0' + ones
; toolsrc/ed.pla: 0527:                 ones++
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$4C			; BRFLS	_B136
	!WORD	_B136-*
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$38,$30			; ADDI	48
	!BYTE	$B0,$07			; ADDLB	[7]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$38,$30			; ADDI	48
	!BYTE	$B0,$08			; ADDLB	[8]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$38,$30			; ADDI	48
	!BYTE	$B0,$09			; ADDLB	[9]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$64,$09			; LLB	[9]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0528:                 if ones > 9
; toolsrc/ed.pla: 0529:                     ones = 0
; toolsrc/ed.pla: 0530:                     tens++
	!BYTE	$6C,$09			; DLB	[9]
	!BYTE	$12			; CN	9
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B138
	!WORD	_B138-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$09			; SLB	[9]
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0531:                     if tens > 9
; toolsrc/ed.pla: 0532:                         tens = 0
; toolsrc/ed.pla: 0533:                         huns++
	!BYTE	$6C,$08			; DLB	[8]
	!BYTE	$12			; CN	9
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B140
	!WORD	_B140-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0534:                     fin
	!BYTE	$74,$07			; SLB	[7]
_B140 
_B141 
; toolsrc/ed.pla: 0535:                 fin
_B138 
_B139 
; toolsrc/ed.pla: 0536:             elsif tens
	!BYTE	$50			; BRNCH	_B137
	!WORD	_B137-*
_B136 
; toolsrc/ed.pla: 0537:                 ^scrnptr     = hilite + ' '
; toolsrc/ed.pla: 0538:                 ^(scrnptr+1) = hilite + '0' + tens
; toolsrc/ed.pla: 0539:                 ^(scrnptr+2) = hilite + '0' + ones
; toolsrc/ed.pla: 0540:                 ones++
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$4C			; BRFLS	_B142
	!WORD	_B142-*
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$38,$20			; ADDI	32
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$38,$30			; ADDI	48
	!BYTE	$B0,$08			; ADDLB	[8]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$38,$30			; ADDI	48
	!BYTE	$B0,$09			; ADDLB	[9]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$64,$09			; LLB	[9]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0541:                 if ones > 9
; toolsrc/ed.pla: 0542:                     ones = 0
; toolsrc/ed.pla: 0543:                     tens++
	!BYTE	$6C,$09			; DLB	[9]
	!BYTE	$12			; CN	9
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B143
	!WORD	_B143-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$09			; SLB	[9]
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0544:                     if tens > 9
; toolsrc/ed.pla: 0545:                         tens = 0
; toolsrc/ed.pla: 0546:                         huns = 1
; toolsrc/ed.pla: 0547:                     fin
	!BYTE	$6C,$08			; DLB	[8]
	!BYTE	$12			; CN	9
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B145
	!WORD	_B145-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$02			; CN	1
	!BYTE	$74,$07			; SLB	[7]
_B145 
_B146 
; toolsrc/ed.pla: 0548:                 fin
_B143 
_B144 
; toolsrc/ed.pla: 0549:             elsif ones
	!BYTE	$50			; BRNCH	_B137
	!WORD	_B137-*
_B142 
; toolsrc/ed.pla: 0550:                 ^scrnptr     = hilite + ' '
; toolsrc/ed.pla: 0551:                 ^(scrnptr+1) = hilite + ' '
; toolsrc/ed.pla: 0552:                 ^(scrnptr+2) = hilite + '0' + ones
; toolsrc/ed.pla: 0553:                 ones++
	!BYTE	$64,$09			; LLB	[9]
	!BYTE	$4C			; BRFLS	_B147
	!WORD	_B147-*
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$38,$20			; ADDI	32
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$70			; SB
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$38,$20			; ADDI	32
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$38,$30			; ADDI	48
	!BYTE	$B0,$09			; ADDLB	[9]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
	!BYTE	$64,$09			; LLB	[9]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0554:                 if ones > 9
; toolsrc/ed.pla: 0555:                     ones = 0
; toolsrc/ed.pla: 0556:                     tens = 1
; toolsrc/ed.pla: 0557:                 fin
	!BYTE	$6C,$09			; DLB	[9]
	!BYTE	$12			; CN	9
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B148
	!WORD	_B148-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$09			; SLB	[9]
	!BYTE	$02			; CN	1
	!BYTE	$74,$08			; SLB	[8]
_B148 
_B149 
; toolsrc/ed.pla: 0558:             fin
_B147 
_B137 
; toolsrc/ed.pla: 0559:             ^(scrnptr+3) = ofstch
; toolsrc/ed.pla: 0560:         else
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B128
	!WORD	_B128-*
_B127 
; toolsrc/ed.pla: 0561:             *scrnptr     = $A0A0
; toolsrc/ed.pla: 0562:             *(scrnptr+2) = $A0A0
; toolsrc/ed.pla: 0563:         fin
	!BYTE	$2C,$A0,$A0		; CW	41120
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$72			; SW
	!BYTE	$2C,$A0,$A0		; CW	41120
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
_B128 
; toolsrc/ed.pla: 0564:         scrnrow++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0565:     next
	!BYTE	$76,$00			; SLW	[0]
_B126 
	!BYTE	$A4			; INCBRLE	_B125
	!WORD	_B125-*
_B124 
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0566: end
	!BYTE	$5A,$0E			; LEAVE	14
; toolsrc/ed.pla: 0567: def drawscrn(toprow, ofst)#0
					; toprow -> [0]
					; ofst -> [2]
_C021 					; drawscrn()
; toolsrc/ed.pla: 0568:     byte row, numchars, lofst
					; row -> [4]
					; numchars -> [5]
					; lofst -> [6]
; toolsrc/ed.pla: 0569:     word strptr, scrnptr
					; strptr -> [7]
					; scrnptr -> [9]
; toolsrc/ed.pla: 0570: 
; toolsrc/ed.pla: 0571:     lofst = flags & gutter
	!BYTE	$58,$0B,$02		; ENTER	11,2
; toolsrc/ed.pla: 0572:     if lofst
; toolsrc/ed.pla: 0573:         drawgutter(toprow, ofst)
; toolsrc/ed.pla: 0574:     fin
	!BYTE	$68			; LAB	_D040+0
_F160 	!WORD	_D040+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$6C,$06			; DLB	[6]
	!BYTE	$4C			; BRFLS	_B150
	!WORD	_B150-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C020
_F161 	!WORD	_C020		
_B150 
_B151 
; toolsrc/ed.pla: 0575:     //
; toolsrc/ed.pla: 0576:     // Draw text
; toolsrc/ed.pla: 0577:     //
; toolsrc/ed.pla: 0578:     if ofst
; toolsrc/ed.pla: 0579:         for row = 0 to 23
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B152
	!WORD	_B152-*
	!BYTE	$2A,$17			; CB	23
	!BYTE	$00			; CN	0
_B155 
	!BYTE	$6C,$04			; DLB	[4]
; toolsrc/ed.pla: 0580:             strptr   = txtlinbuf=>[toprow + row]
; toolsrc/ed.pla: 0581:             scrnptr  = txtscrn[row] + lofst
; toolsrc/ed.pla: 0582:             if ofst >= ^strptr
; toolsrc/ed.pla: 0583:                 numchars = 0
; toolsrc/ed.pla: 0584:             else
	!BYTE	$6A			; LAW	_D048+0
_F162 	!WORD	_D048+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$07			; SLW	[7]
	!BYTE	$26			; LA	_D035+0
_F163 	!WORD	_D035+0		
	!BYTE	$B8,$04			; IDXLB	[4]
	!BYTE	$62			; LW
	!BYTE	$B0,$06			; ADDLB	[6]
	!BYTE	$76,$09			; SLW	[9]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$60			; LB
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B157
	!WORD	_B157-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B158
	!WORD	_B158-*
_B157 
; toolsrc/ed.pla: 0585:                 numchars = ^strptr - ofst
; toolsrc/ed.pla: 0586:             fin
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$60			; LB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$84			; SUB 
	!BYTE	$74,$05			; SLB	[5]
_B158 
; toolsrc/ed.pla: 0587:             if numchars >= scrnwidth
; toolsrc/ed.pla: 0588:                 numchars = scrnwidth
; toolsrc/ed.pla: 0589:             else
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$6A			; LAW	_D033+0
_F164 	!WORD	_D033+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B159
	!WORD	_B159-*
	!BYTE	$6A			; LAW	_D033+0
_F165 	!WORD	_D033+0		
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B160
	!WORD	_B160-*
_B159 
; toolsrc/ed.pla: 0590:                 memset(scrnptr + numchars, $A0A0, scrnwidth - numchars)
; toolsrc/ed.pla: 0591:             fin
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$B0,$05			; ADDLB	[5]
	!BYTE	$2C,$A0,$A0		; CW	41120
	!BYTE	$6A			; LAW	_D033+0
_F166 	!WORD	_D033+0		
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X017
_F167 	!WORD	0		
_B160 
; toolsrc/ed.pla: 0592:             memcpy(scrnptr, strptr + ofst + 1, numchars)
; toolsrc/ed.pla: 0593:         next
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$54			; CALL	_X018
_F168 	!WORD	0		
_B156 
	!BYTE	$A4			; INCBRLE	_B155
	!WORD	_B155-*
_B154 
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0594:     else
	!BYTE	$50			; BRNCH	_B153
	!WORD	_B153-*
_B152 
; toolsrc/ed.pla: 0595:         for row = 0 to 23
	!BYTE	$2A,$17			; CB	23
	!BYTE	$00			; CN	0
_B162 
	!BYTE	$6C,$04			; DLB	[4]
; toolsrc/ed.pla: 0596:             strptr   = txtlinbuf=>[toprow + row]
; toolsrc/ed.pla: 0597:             scrnptr  = txtscrn[row] + lofst
; toolsrc/ed.pla: 0598:             numchars = ^strptr
; toolsrc/ed.pla: 0599:             if numchars >= scrnwidth
; toolsrc/ed.pla: 0600:                 numchars = scrnwidth
; toolsrc/ed.pla: 0601:             else
	!BYTE	$6A			; LAW	_D048+0
_F169 	!WORD	_D048+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$76,$07			; SLW	[7]
	!BYTE	$26			; LA	_D035+0
_F170 	!WORD	_D035+0		
	!BYTE	$B8,$04			; IDXLB	[4]
	!BYTE	$62			; LW
	!BYTE	$B0,$06			; ADDLB	[6]
	!BYTE	$76,$09			; SLW	[9]
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$60			; LB
	!BYTE	$6C,$05			; DLB	[5]
	!BYTE	$6A			; LAW	_D033+0
_F171 	!WORD	_D033+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B164
	!WORD	_B164-*
	!BYTE	$6A			; LAW	_D033+0
_F172 	!WORD	_D033+0		
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B165
	!WORD	_B165-*
_B164 
; toolsrc/ed.pla: 0602:                 memset(scrnptr + numchars, $A0A0, scrnwidth - numchars)
; toolsrc/ed.pla: 0603:             fin
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$B0,$05			; ADDLB	[5]
	!BYTE	$2C,$A0,$A0		; CW	41120
	!BYTE	$6A			; LAW	_D033+0
_F173 	!WORD	_D033+0		
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X017
_F174 	!WORD	0		
_B165 
; toolsrc/ed.pla: 0604:             memcpy(scrnptr, strptr + 1, numchars)
; toolsrc/ed.pla: 0605:         next
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$8C			; INCR
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$54			; CALL	_X018
_F175 	!WORD	0		
_B163 
	!BYTE	$A4			; INCBRLE	_B162
	!WORD	_B162-*
_B161 
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0606:     fin
_B153 
; toolsrc/ed.pla: 0607: end
	!BYTE	$5A,$0B			; LEAVE	11
; toolsrc/ed.pla: 0608: def cursoff#0
_C022 					; cursoff()
; toolsrc/ed.pla: 0609:     word scrnptr
					; scrnptr -> [0]
; toolsrc/ed.pla: 0610: 
; toolsrc/ed.pla: 0611:     if flags & showcurs
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/ed.pla: 0612:         ^cursptr     = underchr
; toolsrc/ed.pla: 0613:         if flags & gutter
; toolsrc/ed.pla: 0614:             scrnptr      = txtscrn[cursy]
; toolsrc/ed.pla: 0615:             *scrnptr     = *scrnptr     | $8080
; toolsrc/ed.pla: 0616:             ^(scrnptr+2) = ^(scrnptr+2) | $80
; toolsrc/ed.pla: 0617:         fin
	!BYTE	$68			; LAB	_D040+0
_F176 	!WORD	_D040+0		
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$4C			; BRFLS	_B166
	!WORD	_B166-*
	!BYTE	$68			; LAB	_D055+0
_F177 	!WORD	_D055+0		
	!BYTE	$6A			; LAW	_D061+0
_F178 	!WORD	_D061+0		
	!BYTE	$70			; SB
	!BYTE	$68			; LAB	_D040+0
_F179 	!WORD	_D040+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B168
	!WORD	_B168-*
	!BYTE	$26			; LA	_D035+0
_F180 	!WORD	_D035+0		
	!BYTE	$BE			; IDXAW	_D052+0
_F181 	!WORD	_D052+0		
	!BYTE	$62			; LW
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$62			; LW
	!BYTE	$2C,$80,$80		; CW	32896
	!BYTE	$96			; OR 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
_B168 
_B169 
; toolsrc/ed.pla: 0618:         flags = flags & ~showcurs
; toolsrc/ed.pla: 0619: 
; toolsrc/ed.pla: 0620:     fin
	!BYTE	$68			; LAB	_D040+0
_F182 	!WORD	_D040+0		
	!BYTE	$5E,$DF			; CFFB	-33
	!BYTE	$94			; AND 
	!BYTE	$78			; SAB	_D040+0
_F183 	!WORD	_D040+0		
_B166 
_B167 
; toolsrc/ed.pla: 0621: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0622: def curson#0
_C023 					; curson()
; toolsrc/ed.pla: 0623:     byte lofst
					; lofst -> [0]
; toolsrc/ed.pla: 0624:     word scrnptr
					; scrnptr -> [1]
; toolsrc/ed.pla: 0625: 
; toolsrc/ed.pla: 0626:     if !(flags & showcurs)
	!BYTE	$58,$03,$00		; ENTER	3,0
; toolsrc/ed.pla: 0627:         lofst = flags & gutter
; toolsrc/ed.pla: 0628:         if lofst
; toolsrc/ed.pla: 0629:             scrnptr = txtscrn[cursy]
; toolsrc/ed.pla: 0630:             *scrnptr     = *scrnptr     & $7F7F
; toolsrc/ed.pla: 0631:             ^(scrnptr+2) = ^(scrnptr+2) & $7F
; toolsrc/ed.pla: 0632:         fin
	!BYTE	$68			; LAB	_D040+0
_F184 	!WORD	_D040+0		
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$4E			; BRTRU	_B170
	!WORD	_B170-*
	!BYTE	$68			; LAB	_D040+0
_F185 	!WORD	_D040+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$6C,$00			; DLB	[0]
	!BYTE	$4C			; BRFLS	_B172
	!WORD	_B172-*
	!BYTE	$26			; LA	_D035+0
_F186 	!WORD	_D035+0		
	!BYTE	$BE			; IDXAW	_D052+0
_F187 	!WORD	_D052+0		
	!BYTE	$62			; LW
	!BYTE	$6E,$01			; DLW	[1]
	!BYTE	$62			; LW
	!BYTE	$2C,$7F,$7F		; CW	32639
	!BYTE	$94			; AND 
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$72			; SW
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$70			; SB
_B172 
_B173 
; toolsrc/ed.pla: 0633:         cursptr  = txtscrn[cursy] + lofst + cursx
; toolsrc/ed.pla: 0634:         underchr = ^cursptr
; toolsrc/ed.pla: 0635:         ^cursptr = curschr
; toolsrc/ed.pla: 0636:         flags = flags | showcurs
; toolsrc/ed.pla: 0637:     fin
	!BYTE	$26			; LA	_D035+0
_F188 	!WORD	_D035+0		
	!BYTE	$BE			; IDXAW	_D052+0
_F189 	!WORD	_D052+0		
	!BYTE	$62			; LW
	!BYTE	$B0,$00			; ADDLB	[0]
	!BYTE	$B6			; ADDAW	_D051+0
_F190 	!WORD	_D051+0		
	!BYTE	$7A			; SAW	_D061+0
_F191 	!WORD	_D061+0		
	!BYTE	$6A			; LAW	_D061+0
_F192 	!WORD	_D061+0		
	!BYTE	$60			; LB
	!BYTE	$78			; SAB	_D055+0
_F193 	!WORD	_D055+0		
	!BYTE	$68			; LAB	_D056+0
_F194 	!WORD	_D056+0		
	!BYTE	$6A			; LAW	_D061+0
_F195 	!WORD	_D061+0		
	!BYTE	$70			; SB
	!BYTE	$68			; LAB	_D040+0
_F196 	!WORD	_D040+0		
	!BYTE	$3E,$20			; ORI	32
	!BYTE	$78			; SAB	_D040+0
_F197 	!WORD	_D040+0		
_B170 
_B171 
; toolsrc/ed.pla: 0638: end
	!BYTE	$5A,$03			; LEAVE	3
; toolsrc/ed.pla: 0639: def cursflash#0
_C024 					; cursflash()
; toolsrc/ed.pla: 0640:     if flags & showcurs
; toolsrc/ed.pla: 0641:         if flash == 0
; toolsrc/ed.pla: 0642:             ^cursptr = curschr
; toolsrc/ed.pla: 0643:         elsif flash == 128
	!BYTE	$68			; LAB	_D040+0
_F198 	!WORD	_D040+0		
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$4C			; BRFLS	_B174
	!WORD	_B174-*
	!BYTE	$68			; LAB	_D041+0
_F199 	!WORD	_D041+0		
	!BYTE	$4E			; BRTRU	_B176
	!WORD	_B176-*
	!BYTE	$68			; LAB	_D056+0
_F200 	!WORD	_D056+0		
	!BYTE	$6A			; LAW	_D061+0
_F201 	!WORD	_D061+0		
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B177
	!WORD	_B177-*
_B176 
; toolsrc/ed.pla: 0644:             ^cursptr = underchr
; toolsrc/ed.pla: 0645:         fin
	!BYTE	$68			; LAB	_D041+0
_F202 	!WORD	_D041+0		
	!BYTE	$2A,$80			; CB	128
	!BYTE	$24			; BRNE	_B178
	!WORD	_B178-*
	!BYTE	$68			; LAB	_D055+0
_F203 	!WORD	_D055+0		
	!BYTE	$6A			; LAW	_D061+0
_F204 	!WORD	_D061+0		
	!BYTE	$70			; SB
_B178 
_B177 
; toolsrc/ed.pla: 0646:         flash++
	!BYTE	$68			; LAB	_D041+0
_F205 	!WORD	_D041+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0647:     fin
	!BYTE	$78			; SAB	_D041+0
_F206 	!WORD	_D041+0		
_B174 
_B175 
; toolsrc/ed.pla: 0648: end
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0649: def redraw#0
_C025 					; redraw()
; toolsrc/ed.pla: 0650:     cursoff
; toolsrc/ed.pla: 0651:     drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 0652:     curson
; toolsrc/ed.pla: 0653: end
	!BYTE	$54			; CALL	_C022
_F207 	!WORD	_C022		
	!BYTE	$6A			; LAW	_D060+0
_F208 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F209 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F210 	!WORD	_C021		
	!BYTE	$54			; CALL	_C023
_F211 	!WORD	_C023		
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0654: def curshpos(hpos)#1
					; hpos -> [0]
_C026 					; curshpos()
; toolsrc/ed.pla: 0655:     byte needredraw
					; needredraw -> [2]
; toolsrc/ed.pla: 0656: 
; toolsrc/ed.pla: 0657:     needredraw = TRUE
	!BYTE	$58,$03,$01		; ENTER	3,1
; toolsrc/ed.pla: 0658:     if hpos < 0; hpos = 0; fin
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B179
	!WORD	_B179-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$00			; SLW	[0]
_B179 
_B180 
; toolsrc/ed.pla: 0659:     if hpos > MAXLNLEN; hpos = MAXLNLEN; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$4F			; CB	79
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B181
	!WORD	_B181-*
	!BYTE	$2A,$4F			; CB	79
	!BYTE	$76,$00			; SLW	[0]
_B181 
_B182 
; toolsrc/ed.pla: 0660:     curscol = hpos
; toolsrc/ed.pla: 0661:     cursx   = curscol - scrnleft
; toolsrc/ed.pla: 0662:     if cursx > scrnright
; toolsrc/ed.pla: 0663:         cursx      = scrnright
; toolsrc/ed.pla: 0664:         scrnleft   = curscol - scrnright
; toolsrc/ed.pla: 0665:     elsif cursx < 0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7E			; DAW	_D054+0
_F212 	!WORD	_D054+0		
	!BYTE	$6A			; LAW	_D053+0
_F213 	!WORD	_D053+0		
	!BYTE	$84			; SUB 
	!BYTE	$7E			; DAW	_D051+0
_F214 	!WORD	_D051+0		
	!BYTE	$6A			; LAW	_D034+0
_F215 	!WORD	_D034+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B183
	!WORD	_B183-*
	!BYTE	$6A			; LAW	_D034+0
_F216 	!WORD	_D034+0		
	!BYTE	$7A			; SAW	_D051+0
_F217 	!WORD	_D051+0		
	!BYTE	$6A			; LAW	_D054+0
_F218 	!WORD	_D054+0		
	!BYTE	$6A			; LAW	_D034+0
_F219 	!WORD	_D034+0		
	!BYTE	$84			; SUB 
	!BYTE	$7A			; SAW	_D053+0
_F220 	!WORD	_D053+0		
	!BYTE	$50			; BRNCH	_B184
	!WORD	_B184-*
_B183 
; toolsrc/ed.pla: 0666:         cursx      = 0
; toolsrc/ed.pla: 0667:         scrnleft   = curscol
; toolsrc/ed.pla: 0668:     else
	!BYTE	$6A			; LAW	_D051+0
_F221 	!WORD	_D051+0		
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B185
	!WORD	_B185-*
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D051+0
_F222 	!WORD	_D051+0		
	!BYTE	$6A			; LAW	_D054+0
_F223 	!WORD	_D054+0		
	!BYTE	$7A			; SAW	_D053+0
_F224 	!WORD	_D053+0		
	!BYTE	$50			; BRNCH	_B184
	!WORD	_B184-*
_B185 
; toolsrc/ed.pla: 0669:         needredraw = FALSE
; toolsrc/ed.pla: 0670:     fin
	!BYTE	$00			; CN	0
	!BYTE	$74,$02			; SLB	[2]
_B184 
; toolsrc/ed.pla: 0671:     return needredraw
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$03			; LEAVE	3
; toolsrc/ed.pla: 0672: end
; toolsrc/ed.pla: 0673: def cursvpos(vpos)#1
					; vpos -> [0]
_C027 					; cursvpos()
; toolsrc/ed.pla: 0674:     byte needredraw
					; needredraw -> [2]
; toolsrc/ed.pla: 0675: 
; toolsrc/ed.pla: 0676:     needredraw = TRUE
	!BYTE	$58,$03,$01		; ENTER	3,1
; toolsrc/ed.pla: 0677:     if vpos < 0; vpos = 0; fin
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B186
	!WORD	_B186-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$00			; SLW	[0]
_B186 
_B187 
; toolsrc/ed.pla: 0678:     if vpos > numlines - 1; vpos = numlines - 1; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D042+0
_F225 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B188
	!WORD	_B188-*
	!BYTE	$6A			; LAW	_D042+0
_F226 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$76,$00			; SLW	[0]
_B188 
_B189 
; toolsrc/ed.pla: 0679:     cursrow = vpos
; toolsrc/ed.pla: 0680:     cursy   = cursrow - scrntop
; toolsrc/ed.pla: 0681:     if cursy > scrnbottom
; toolsrc/ed.pla: 0682:         cursy = scrnbottom
; toolsrc/ed.pla: 0683:         scrntop = cursrow - scrnbottom
; toolsrc/ed.pla: 0684:     elsif cursy < 0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7E			; DAW	_D058+0
_F227 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D060+0
_F228 	!WORD	_D060+0		
	!BYTE	$84			; SUB 
	!BYTE	$7E			; DAW	_D052+0
_F229 	!WORD	_D052+0		
	!BYTE	$2A,$17			; CB	23
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B190
	!WORD	_B190-*
	!BYTE	$2A,$17			; CB	23
	!BYTE	$7A			; SAW	_D052+0
_F230 	!WORD	_D052+0		
	!BYTE	$6A			; LAW	_D058+0
_F231 	!WORD	_D058+0		
	!BYTE	$3A,$17			; SUBI	23
	!BYTE	$7A			; SAW	_D060+0
_F232 	!WORD	_D060+0		
	!BYTE	$50			; BRNCH	_B191
	!WORD	_B191-*
_B190 
; toolsrc/ed.pla: 0685:         cursy    = 0
; toolsrc/ed.pla: 0686:         scrntop  = cursrow
; toolsrc/ed.pla: 0687:     else
	!BYTE	$6A			; LAW	_D052+0
_F233 	!WORD	_D052+0		
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B192
	!WORD	_B192-*
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D052+0
_F234 	!WORD	_D052+0		
	!BYTE	$6A			; LAW	_D058+0
_F235 	!WORD	_D058+0		
	!BYTE	$7A			; SAW	_D060+0
_F236 	!WORD	_D060+0		
	!BYTE	$50			; BRNCH	_B191
	!WORD	_B191-*
_B192 
; toolsrc/ed.pla: 0688:         needredraw = FALSE
; toolsrc/ed.pla: 0689:     fin
	!BYTE	$00			; CN	0
	!BYTE	$74,$02			; SLB	[2]
_B191 
; toolsrc/ed.pla: 0690:     return needredraw
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$03			; LEAVE	3
; toolsrc/ed.pla: 0691: end
; toolsrc/ed.pla: 0692: def curshome#0
_C028 					; curshome()
; toolsrc/ed.pla: 0693:     cursoff
; toolsrc/ed.pla: 0694:     cursrow  = 0
; toolsrc/ed.pla: 0695:     curscol  = 0
; toolsrc/ed.pla: 0696:     cursx    = 0
; toolsrc/ed.pla: 0697:     cursy    = 0
; toolsrc/ed.pla: 0698:     scrnleft = 0
; toolsrc/ed.pla: 0699:     scrntop  = 0
; toolsrc/ed.pla: 0700:     drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 0701:     curson
; toolsrc/ed.pla: 0702: end
	!BYTE	$54			; CALL	_C022
_F237 	!WORD	_C022		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D058+0
_F238 	!WORD	_D058+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D054+0
_F239 	!WORD	_D054+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D051+0
_F240 	!WORD	_D051+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D052+0
_F241 	!WORD	_D052+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D053+0
_F242 	!WORD	_D053+0		
	!BYTE	$00			; CN	0
	!BYTE	$7E			; DAW	_D060+0
_F243 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F244 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F245 	!WORD	_C021		
	!BYTE	$54			; CALL	_C023
_F246 	!WORD	_C023		
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0703: def cursend#0
_C029 					; cursend()
; toolsrc/ed.pla: 0704:     cursoff
; toolsrc/ed.pla: 0705:     if numlines > 23
; toolsrc/ed.pla: 0706:         cursrow  = numlines - 1
; toolsrc/ed.pla: 0707:         cursy    = 23
; toolsrc/ed.pla: 0708:         scrntop  = cursrow - 23
; toolsrc/ed.pla: 0709:     else
	!BYTE	$54			; CALL	_C022
_F247 	!WORD	_C022		
	!BYTE	$6A			; LAW	_D042+0
_F248 	!WORD	_D042+0		
	!BYTE	$2A,$17			; CB	23
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B193
	!WORD	_B193-*
	!BYTE	$6A			; LAW	_D042+0
_F249 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$7A			; SAW	_D058+0
_F250 	!WORD	_D058+0		
	!BYTE	$2A,$17			; CB	23
	!BYTE	$7A			; SAW	_D052+0
_F251 	!WORD	_D052+0		
	!BYTE	$6A			; LAW	_D058+0
_F252 	!WORD	_D058+0		
	!BYTE	$3A,$17			; SUBI	23
	!BYTE	$7A			; SAW	_D060+0
_F253 	!WORD	_D060+0		
	!BYTE	$50			; BRNCH	_B194
	!WORD	_B194-*
_B193 
; toolsrc/ed.pla: 0710:         cursrow  = numlines - 1
; toolsrc/ed.pla: 0711:         cursy    = numlines - 1
; toolsrc/ed.pla: 0712:         scrntop  = 0
; toolsrc/ed.pla: 0713:     fin
	!BYTE	$6A			; LAW	_D042+0
_F254 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$7A			; SAW	_D058+0
_F255 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D042+0
_F256 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$7A			; SAW	_D052+0
_F257 	!WORD	_D052+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D060+0
_F258 	!WORD	_D060+0		
_B194 
; toolsrc/ed.pla: 0714:     curscol  = 0
; toolsrc/ed.pla: 0715:     cursx    = 0
; toolsrc/ed.pla: 0716:     scrnleft = 0
; toolsrc/ed.pla: 0717:     drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 0718:     curson
; toolsrc/ed.pla: 0719: end
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D054+0
_F259 	!WORD	_D054+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D051+0
_F260 	!WORD	_D051+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D053+0
_F261 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D060+0
_F262 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F263 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F264 	!WORD	_C021		
	!BYTE	$54			; CALL	_C023
_F265 	!WORD	_C023		
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0720: def cursup#0
_C030 					; cursup()
; toolsrc/ed.pla: 0721:     if cursrow > 0
; toolsrc/ed.pla: 0722:         cursoff
; toolsrc/ed.pla: 0723:         cursrow--
	!BYTE	$6A			; LAW	_D058+0
_F266 	!WORD	_D058+0		
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B195
	!WORD	_B195-*
	!BYTE	$54			; CALL	_C022
_F267 	!WORD	_C022		
	!BYTE	$6A			; LAW	_D058+0
_F268 	!WORD	_D058+0		
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0724:         if cursy > 0
; toolsrc/ed.pla: 0725:             cursy--
	!BYTE	$7A			; SAW	_D058+0
_F269 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D052+0
_F270 	!WORD	_D052+0		
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B197
	!WORD	_B197-*
	!BYTE	$6A			; LAW	_D052+0
_F271 	!WORD	_D052+0		
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0726:             if flags & selection
; toolsrc/ed.pla: 0727:                 drawgutter(scrntop, scrnleft)
; toolsrc/ed.pla: 0728:             fin
	!BYTE	$7A			; SAW	_D052+0
_F272 	!WORD	_D052+0		
	!BYTE	$68			; LAB	_D040+0
_F273 	!WORD	_D040+0		
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B199
	!WORD	_B199-*
	!BYTE	$6A			; LAW	_D060+0
_F274 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F275 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C020
_F276 	!WORD	_C020		
_B199 
_B200 
; toolsrc/ed.pla: 0729:         else
	!BYTE	$50			; BRNCH	_B198
	!WORD	_B198-*
_B197 
; toolsrc/ed.pla: 0730:             scrntop = cursrow
; toolsrc/ed.pla: 0731:             drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 0732:         fin
	!BYTE	$6A			; LAW	_D058+0
_F277 	!WORD	_D058+0		
	!BYTE	$7E			; DAW	_D060+0
_F278 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F279 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F280 	!WORD	_C021		
_B198 
; toolsrc/ed.pla: 0733:         curson
; toolsrc/ed.pla: 0734:     fin
	!BYTE	$54			; CALL	_C023
_F281 	!WORD	_C023		
_B195 
_B196 
; toolsrc/ed.pla: 0735: end
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0736: def pgup#0
_C031 					; pgup()
; toolsrc/ed.pla: 0737:     cursoff
; toolsrc/ed.pla: 0738:     if cursvpos(cursrow - pgjmp)
; toolsrc/ed.pla: 0739:         drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 0740:     else
	!BYTE	$54			; CALL	_C022
_F282 	!WORD	_C022		
	!BYTE	$6A			; LAW	_D058+0
_F283 	!WORD	_D058+0		
	!BYTE	$3A,$10			; SUBI	16
	!BYTE	$54			; CALL	_C027
_F284 	!WORD	_C027		
	!BYTE	$4C			; BRFLS	_B201
	!WORD	_B201-*
	!BYTE	$6A			; LAW	_D060+0
_F285 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F286 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F287 	!WORD	_C021		
	!BYTE	$50			; BRNCH	_B202
	!WORD	_B202-*
_B201 
; toolsrc/ed.pla: 0741:         if flags & selection
; toolsrc/ed.pla: 0742:             drawgutter(scrntop, scrnleft)
; toolsrc/ed.pla: 0743:         fin
	!BYTE	$68			; LAB	_D040+0
_F288 	!WORD	_D040+0		
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B203
	!WORD	_B203-*
	!BYTE	$6A			; LAW	_D060+0
_F289 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F290 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C020
_F291 	!WORD	_C020		
_B203 
_B204 
; toolsrc/ed.pla: 0744:     fin
_B202 
; toolsrc/ed.pla: 0745:     curson
; toolsrc/ed.pla: 0746: end
	!BYTE	$54			; CALL	_C023
_F292 	!WORD	_C023		
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0747: def cursdown#0
_C032 					; cursdown()
; toolsrc/ed.pla: 0748:     if cursrow < numlines - 1
; toolsrc/ed.pla: 0749:         cursoff
; toolsrc/ed.pla: 0750:         cursrow++
	!BYTE	$6A			; LAW	_D058+0
_F293 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D042+0
_F294 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B205
	!WORD	_B205-*
	!BYTE	$54			; CALL	_C022
_F295 	!WORD	_C022		
	!BYTE	$6A			; LAW	_D058+0
_F296 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0751:         if cursy < 23
; toolsrc/ed.pla: 0752:             cursy++
	!BYTE	$7A			; SAW	_D058+0
_F297 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D052+0
_F298 	!WORD	_D052+0		
	!BYTE	$2A,$17			; CB	23
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B207
	!WORD	_B207-*
	!BYTE	$6A			; LAW	_D052+0
_F299 	!WORD	_D052+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0753:             if flags & selection
; toolsrc/ed.pla: 0754:                 drawgutter(scrntop, scrnleft)
; toolsrc/ed.pla: 0755:             fin
	!BYTE	$7A			; SAW	_D052+0
_F300 	!WORD	_D052+0		
	!BYTE	$68			; LAB	_D040+0
_F301 	!WORD	_D040+0		
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B209
	!WORD	_B209-*
	!BYTE	$6A			; LAW	_D060+0
_F302 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F303 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C020
_F304 	!WORD	_C020		
_B209 
_B210 
; toolsrc/ed.pla: 0756:         else
	!BYTE	$50			; BRNCH	_B208
	!WORD	_B208-*
_B207 
; toolsrc/ed.pla: 0757:             scrntop = cursrow - 23
; toolsrc/ed.pla: 0758:             drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 0759:         fin
	!BYTE	$6A			; LAW	_D058+0
_F305 	!WORD	_D058+0		
	!BYTE	$3A,$17			; SUBI	23
	!BYTE	$7E			; DAW	_D060+0
_F306 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F307 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F308 	!WORD	_C021		
_B208 
; toolsrc/ed.pla: 0760:         curson
; toolsrc/ed.pla: 0761:     fin
	!BYTE	$54			; CALL	_C023
_F309 	!WORD	_C023		
_B205 
_B206 
; toolsrc/ed.pla: 0762: end
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0763: def pgdown#0
_C033 					; pgdown()
; toolsrc/ed.pla: 0764:     cursoff
; toolsrc/ed.pla: 0765:     if cursvpos(cursrow + pgjmp)
; toolsrc/ed.pla: 0766:         drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 0767:     else
	!BYTE	$54			; CALL	_C022
_F310 	!WORD	_C022		
	!BYTE	$6A			; LAW	_D058+0
_F311 	!WORD	_D058+0		
	!BYTE	$38,$10			; ADDI	16
	!BYTE	$54			; CALL	_C027
_F312 	!WORD	_C027		
	!BYTE	$4C			; BRFLS	_B211
	!WORD	_B211-*
	!BYTE	$6A			; LAW	_D060+0
_F313 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F314 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F315 	!WORD	_C021		
	!BYTE	$50			; BRNCH	_B212
	!WORD	_B212-*
_B211 
; toolsrc/ed.pla: 0768:         if flags & selection
; toolsrc/ed.pla: 0769:             drawgutter(scrntop, scrnleft)
; toolsrc/ed.pla: 0770:         fin
	!BYTE	$68			; LAB	_D040+0
_F316 	!WORD	_D040+0		
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B213
	!WORD	_B213-*
	!BYTE	$6A			; LAW	_D060+0
_F317 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F318 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C020
_F319 	!WORD	_C020		
_B213 
_B214 
; toolsrc/ed.pla: 0771:     fin
_B212 
; toolsrc/ed.pla: 0772:     curson
; toolsrc/ed.pla: 0773: end
	!BYTE	$54			; CALL	_C023
_F320 	!WORD	_C023		
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0774: def cursleft#0
_C034 					; cursleft()
; toolsrc/ed.pla: 0775:     if curscol > 0
; toolsrc/ed.pla: 0776:         cursoff
; toolsrc/ed.pla: 0777:         curscol--
	!BYTE	$6A			; LAW	_D054+0
_F321 	!WORD	_D054+0		
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B215
	!WORD	_B215-*
	!BYTE	$54			; CALL	_C022
_F322 	!WORD	_C022		
	!BYTE	$6A			; LAW	_D054+0
_F323 	!WORD	_D054+0		
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0778:         if cursx > 0
; toolsrc/ed.pla: 0779:             cursx--
	!BYTE	$7A			; SAW	_D054+0
_F324 	!WORD	_D054+0		
	!BYTE	$6A			; LAW	_D051+0
_F325 	!WORD	_D051+0		
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B217
	!WORD	_B217-*
	!BYTE	$6A			; LAW	_D051+0
_F326 	!WORD	_D051+0		
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0780:         else
	!BYTE	$7A			; SAW	_D051+0
_F327 	!WORD	_D051+0		
	!BYTE	$50			; BRNCH	_B218
	!WORD	_B218-*
_B217 
; toolsrc/ed.pla: 0781:             scrnleft = curscol
; toolsrc/ed.pla: 0782:             drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 0783:         fin
	!BYTE	$6A			; LAW	_D054+0
_F328 	!WORD	_D054+0		
	!BYTE	$7A			; SAW	_D053+0
_F329 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D060+0
_F330 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F331 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F332 	!WORD	_C021		
_B218 
; toolsrc/ed.pla: 0784:         curson
; toolsrc/ed.pla: 0785:     fin
	!BYTE	$54			; CALL	_C023
_F333 	!WORD	_C023		
_B215 
_B216 
; toolsrc/ed.pla: 0786: end
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0787: def pgleft#0
_C035 					; pgleft()
; toolsrc/ed.pla: 0788:     word i, strptr
					; i -> [0]
					; strptr -> [2]
; toolsrc/ed.pla: 0789: 
; toolsrc/ed.pla: 0790:     strptr = txtlinbuf=>[cursrow]
	!BYTE	$58,$04,$00		; ENTER	4,0
; toolsrc/ed.pla: 0791:     if curscol > ^strptr
; toolsrc/ed.pla: 0792:         i = ^strptr
; toolsrc/ed.pla: 0793:     else
	!BYTE	$6A			; LAW	_D048+0
_F334 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F335 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$6A			; LAW	_D054+0
_F336 	!WORD	_D054+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B219
	!WORD	_B219-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B220
	!WORD	_B220-*
_B219 
; toolsrc/ed.pla: 0794:         for i = 1 to ^strptr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B221
	!WORD	_B221-*
_B222 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0795:             if ^(strptr + i) <> keyspace
; toolsrc/ed.pla: 0796:                 break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$22			; BREQ	_B224
	!WORD	_B224-*
	!BYTE	$50			; BRNCH	_B221
	!WORD	_B221-*
; toolsrc/ed.pla: 0797:             fin
_B224 
_B225 
; toolsrc/ed.pla: 0798:         next
_B223 
	!BYTE	$A4			; INCBRLE	_B222
	!WORD	_B222-*
_B221 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0799:         i--
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0800:         if i >= curscol
; toolsrc/ed.pla: 0801:             i = 0
; toolsrc/ed.pla: 0802:         fin
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$6A			; LAW	_D054+0
_F337 	!WORD	_D054+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B226
	!WORD	_B226-*
	!BYTE	$00			; CN	0
	!BYTE	$76,$00			; SLW	[0]
_B226 
_B227 
; toolsrc/ed.pla: 0803:     fin
_B220 
; toolsrc/ed.pla: 0804:     cursoff
; toolsrc/ed.pla: 0805:     if curshpos(i)
; toolsrc/ed.pla: 0806:     //if curshpos(curscol - 8)
; toolsrc/ed.pla: 0807:         drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 0808:     else
	!BYTE	$54			; CALL	_C022
_F338 	!WORD	_C022		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C026
_F339 	!WORD	_C026		
	!BYTE	$4C			; BRFLS	_B228
	!WORD	_B228-*
	!BYTE	$6A			; LAW	_D060+0
_F340 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F341 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F342 	!WORD	_C021		
	!BYTE	$50			; BRNCH	_B229
	!WORD	_B229-*
_B228 
; toolsrc/ed.pla: 0809:         if flags & selection
; toolsrc/ed.pla: 0810:             drawgutter(scrntop, scrnleft)
; toolsrc/ed.pla: 0811:         fin
	!BYTE	$68			; LAB	_D040+0
_F343 	!WORD	_D040+0		
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B230
	!WORD	_B230-*
	!BYTE	$6A			; LAW	_D060+0
_F344 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F345 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C020
_F346 	!WORD	_C020		
_B230 
_B231 
; toolsrc/ed.pla: 0812:     fin
_B229 
; toolsrc/ed.pla: 0813:     curson
; toolsrc/ed.pla: 0814: end
	!BYTE	$54			; CALL	_C023
_F347 	!WORD	_C023		
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 0815: def cursright#0
_C036 					; cursright()
; toolsrc/ed.pla: 0816:     if curscol < MAXLNLEN
; toolsrc/ed.pla: 0817:         cursoff
; toolsrc/ed.pla: 0818:         curscol++
	!BYTE	$6A			; LAW	_D054+0
_F348 	!WORD	_D054+0		
	!BYTE	$2A,$4F			; CB	79
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B232
	!WORD	_B232-*
	!BYTE	$54			; CALL	_C022
_F349 	!WORD	_C022		
	!BYTE	$6A			; LAW	_D054+0
_F350 	!WORD	_D054+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0819:         if cursx < scrnright
; toolsrc/ed.pla: 0820:             cursx++
	!BYTE	$7A			; SAW	_D054+0
_F351 	!WORD	_D054+0		
	!BYTE	$6A			; LAW	_D051+0
_F352 	!WORD	_D051+0		
	!BYTE	$6A			; LAW	_D034+0
_F353 	!WORD	_D034+0		
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B234
	!WORD	_B234-*
	!BYTE	$6A			; LAW	_D051+0
_F354 	!WORD	_D051+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 0821:         else
	!BYTE	$7A			; SAW	_D051+0
_F355 	!WORD	_D051+0		
	!BYTE	$50			; BRNCH	_B235
	!WORD	_B235-*
_B234 
; toolsrc/ed.pla: 0822:             scrnleft = curscol - scrnright
; toolsrc/ed.pla: 0823:             drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 0824:         fin
	!BYTE	$6A			; LAW	_D054+0
_F356 	!WORD	_D054+0		
	!BYTE	$6A			; LAW	_D034+0
_F357 	!WORD	_D034+0		
	!BYTE	$84			; SUB 
	!BYTE	$7A			; SAW	_D053+0
_F358 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D060+0
_F359 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F360 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F361 	!WORD	_C021		
_B235 
; toolsrc/ed.pla: 0825:         curson
; toolsrc/ed.pla: 0826:     fin
	!BYTE	$54			; CALL	_C023
_F362 	!WORD	_C023		
_B232 
_B233 
; toolsrc/ed.pla: 0827: end
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 0828: def pgright#0
_C037 					; pgright()
; toolsrc/ed.pla: 0829:     word i, strptr
					; i -> [0]
					; strptr -> [2]
; toolsrc/ed.pla: 0830: 
; toolsrc/ed.pla: 0831:     strptr = txtlinbuf=>[cursrow]
	!BYTE	$58,$04,$00		; ENTER	4,0
; toolsrc/ed.pla: 0832:     if curscol >= ^strptr
; toolsrc/ed.pla: 0833:         i = curscol + 8
; toolsrc/ed.pla: 0834:     else
	!BYTE	$6A			; LAW	_D048+0
_F363 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F364 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$6A			; LAW	_D054+0
_F365 	!WORD	_D054+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B236
	!WORD	_B236-*
	!BYTE	$6A			; LAW	_D054+0
_F366 	!WORD	_D054+0		
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B237
	!WORD	_B237-*
_B236 
; toolsrc/ed.pla: 0835:         for i = 1 to ^strptr
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B238
	!WORD	_B238-*
_B239 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0836:             if ^(strptr + i) <> keyspace
; toolsrc/ed.pla: 0837:                 break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$22			; BREQ	_B241
	!WORD	_B241-*
	!BYTE	$50			; BRNCH	_B238
	!WORD	_B238-*
; toolsrc/ed.pla: 0838:             fin
_B241 
_B242 
; toolsrc/ed.pla: 0839:         next
_B240 
	!BYTE	$A4			; INCBRLE	_B239
	!WORD	_B239-*
_B238 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0840:         i--
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 0841:         if curscol >= i
; toolsrc/ed.pla: 0842:             i = ^strptr
; toolsrc/ed.pla: 0843:         fin
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$6A			; LAW	_D054+0
_F367 	!WORD	_D054+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B243
	!WORD	_B243-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$76,$00			; SLW	[0]
_B243 
_B244 
; toolsrc/ed.pla: 0844:     fin
_B237 
; toolsrc/ed.pla: 0845:     cursoff
; toolsrc/ed.pla: 0846:     if curshpos(i)
; toolsrc/ed.pla: 0847:     //if curshpos(curscol + 8)
; toolsrc/ed.pla: 0848:         drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 0849:     else
	!BYTE	$54			; CALL	_C022
_F368 	!WORD	_C022		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C026
_F369 	!WORD	_C026		
	!BYTE	$4C			; BRFLS	_B245
	!WORD	_B245-*
	!BYTE	$6A			; LAW	_D060+0
_F370 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F371 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F372 	!WORD	_C021		
	!BYTE	$50			; BRNCH	_B246
	!WORD	_B246-*
_B245 
; toolsrc/ed.pla: 0850:         if flags & selection
; toolsrc/ed.pla: 0851:             drawgutter(scrntop, scrnleft)
; toolsrc/ed.pla: 0852:         fin
	!BYTE	$68			; LAB	_D040+0
_F373 	!WORD	_D040+0		
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B247
	!WORD	_B247-*
	!BYTE	$6A			; LAW	_D060+0
_F374 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F375 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C020
_F376 	!WORD	_C020		
_B247 
_B248 
; toolsrc/ed.pla: 0853:     fin
_B246 
; toolsrc/ed.pla: 0854:     curson
; toolsrc/ed.pla: 0855: end
	!BYTE	$54			; CALL	_C023
_F377 	!WORD	_C023		
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 0856: //
; toolsrc/ed.pla: 0857: // Find string in text
; toolsrc/ed.pla: 0858: //
; toolsrc/ed.pla: 0859: def findline(strptr, start)#1
					; strptr -> [0]
					; start -> [2]
_C038 					; findline()
; toolsrc/ed.pla: 0860:     byte scan, i, upstr[MAXLNLEN+1]
					; scan -> [4]
					; i -> [5]
					; upstr -> [6]
; toolsrc/ed.pla: 0861: 
; toolsrc/ed.pla: 0862:     if ^strptr >= findstr
	!BYTE	$58,$56,$02		; ENTER	86,2
; toolsrc/ed.pla: 0863:         lnupcpy(@upstr, strptr)
; toolsrc/ed.pla: 0864:         for scan = start to upstr - findstr + 1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$68			; LAB	_D037+0
_F378 	!WORD	_D037+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B249
	!WORD	_B249-*
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_A003
_F379 	!WORD	_A003		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$68			; LAB	_D037+0
_F380 	!WORD	_D037+0		
	!BYTE	$84			; SUB 
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$A0			; BRGT	_B251
	!WORD	_B251-*
_B252 
	!BYTE	$6C,$04			; DLB	[4]
; toolsrc/ed.pla: 0865:             if upstr[scan] == findstr[1]
; toolsrc/ed.pla: 0866:                 for i = 2 to findstr
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$60			; LB
	!BYTE	$68			; LAB	_D037+1
_F381 	!WORD	_D037+1		
	!BYTE	$24			; BRNE	_B254
	!WORD	_B254-*
	!BYTE	$68			; LAB	_D037+0
_F382 	!WORD	_D037+0		
	!BYTE	$04			; CN	2
	!BYTE	$A0			; BRGT	_B256
	!WORD	_B256-*
_B257 
	!BYTE	$6C,$05			; DLB	[5]
; toolsrc/ed.pla: 0867:                     if upstr[scan + i - 1] <> findstr[i]
; toolsrc/ed.pla: 0868:                         break
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$B0,$05			; ADDLB	[5]
	!BYTE	$8E			; DECR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D037+0
_F383 	!WORD	_D037+0		
	!BYTE	$B0,$05			; ADDLB	[5]
	!BYTE	$60			; LB
	!BYTE	$22			; BREQ	_B259
	!WORD	_B259-*
	!BYTE	$50			; BRNCH	_B256
	!WORD	_B256-*
; toolsrc/ed.pla: 0869:                     fin
_B259 
_B260 
; toolsrc/ed.pla: 0870:                 next
_B258 
	!BYTE	$A4			; INCBRLE	_B257
	!WORD	_B257-*
_B256 
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0871:                 if i > findstr
; toolsrc/ed.pla: 0872:                     curshpos(scan - 1)
; toolsrc/ed.pla: 0873:                     return TRUE
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$68			; LAB	_D037+0
_F384 	!WORD	_D037+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B261
	!WORD	_B261-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C026
_F385 	!WORD	_C026		
	!BYTE	$30			; DROP 
	!BYTE	$32			; DROP2
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$56			; LEAVE	86
; toolsrc/ed.pla: 0874:                 fin
_B261 
_B262 
; toolsrc/ed.pla: 0875:             fin
_B254 
_B255 
; toolsrc/ed.pla: 0876:         next
_B253 
	!BYTE	$A4			; INCBRLE	_B252
	!WORD	_B252-*
_B251 
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0877:     fin
_B249 
_B250 
; toolsrc/ed.pla: 0878:     return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$56			; LEAVE	86
; toolsrc/ed.pla: 0879: end
; toolsrc/ed.pla: 0880: def findtxt#0
_C039 					; findtxt()
; toolsrc/ed.pla: 0881:     word f
					; f -> [0]
; toolsrc/ed.pla: 0882: 
; toolsrc/ed.pla: 0883:     //
; toolsrc/ed.pla: 0884:     // Search from current pos to end
; toolsrc/ed.pla: 0885:     //
; toolsrc/ed.pla: 0886:     if findline(txtlinbuf=>[cursrow], curscol + 2)
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/ed.pla: 0887:         return
	!BYTE	$6A			; LAW	_D048+0
_F386 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F387 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D054+0
_F388 	!WORD	_D054+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$54			; CALL	_C038
_F389 	!WORD	_C038		
	!BYTE	$4C			; BRFLS	_B263
	!WORD	_B263-*
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0888:     fin
_B263 
_B264 
; toolsrc/ed.pla: 0889:     for f = cursrow + 1 to numlines - 1
	!BYTE	$6A			; LAW	_D042+0
_F390 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$6A			; LAW	_D058+0
_F391 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$A0			; BRGT	_B265
	!WORD	_B265-*
_B266 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0890:         if findline(txtlinbuf=>[f], 1)
; toolsrc/ed.pla: 0891:             cursvpos(f)
; toolsrc/ed.pla: 0892:             return
	!BYTE	$6A			; LAW	_D048+0
_F392 	!WORD	_D048+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C038
_F393 	!WORD	_C038		
	!BYTE	$4C			; BRFLS	_B268
	!WORD	_B268-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C027
_F394 	!WORD	_C027		
	!BYTE	$30			; DROP 
	!BYTE	$32			; DROP2
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0893:         fin
_B268 
_B269 
; toolsrc/ed.pla: 0894:     next
_B267 
	!BYTE	$A4			; INCBRLE	_B266
	!WORD	_B266-*
_B265 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0895:     //
; toolsrc/ed.pla: 0896:     // Search from beginning to current pos
; toolsrc/ed.pla: 0897:     //
; toolsrc/ed.pla: 0898:     for f = 0 to cursrow
	!BYTE	$6A			; LAW	_D058+0
_F395 	!WORD	_D058+0		
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B270
	!WORD	_B270-*
_B271 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 0899:         if findline(txtlinbuf=>[f], 1)
; toolsrc/ed.pla: 0900:             cursvpos(f)
; toolsrc/ed.pla: 0901:             return
	!BYTE	$6A			; LAW	_D048+0
_F396 	!WORD	_D048+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C038
_F397 	!WORD	_C038		
	!BYTE	$4C			; BRFLS	_B273
	!WORD	_B273-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C027
_F398 	!WORD	_C027		
	!BYTE	$30			; DROP 
	!BYTE	$32			; DROP2
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0902:         fin
_B273 
_B274 
; toolsrc/ed.pla: 0903:     next
_B272 
	!BYTE	$A4			; INCBRLE	_B271
	!WORD	_B271-*
_B270 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 0904:     bell
; toolsrc/ed.pla: 0905: end
	!BYTE	$54			; CALL	_C000
_F399 	!WORD	_C000		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 0906: //
; toolsrc/ed.pla: 0907: // Keyboard routines
; toolsrc/ed.pla: 0908: //
; toolsrc/ed.pla: 0909: def dev_control(devnum, code, list)#1
					; devnum -> [0]
					; code -> [2]
					; list -> [4]
_C040 					; dev_control()
; toolsrc/ed.pla: 0910:     byte params[5]
					; params -> [6]
; toolsrc/ed.pla: 0911: 
; toolsrc/ed.pla: 0912:     params.0 = 3
	!BYTE	$58,$0B,$03		; ENTER	11,3
; toolsrc/ed.pla: 0913:     params.1 = devnum
; toolsrc/ed.pla: 0914:     params.2 = code
; toolsrc/ed.pla: 0915:     params:3 = list
; toolsrc/ed.pla: 0916:     perr     = syscall($83, @params)
; toolsrc/ed.pla: 0917:     return perr
	!BYTE	$06			; CN	3
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$74,$07			; SLB	[7]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$76,$09			; SLW	[9]
	!BYTE	$2A,$83			; CB	131
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_X011
_F400 	!WORD	0		
	!BYTE	$7C			; DAB	_X032+0
_F401 	!WORD	0+0		
	!BYTE	$5A,$0B			; LEAVE	11
; toolsrc/ed.pla: 0918: end
; toolsrc/ed.pla: 0919: def cons_keyavail
_C041 					; cons_keyavail()
; toolsrc/ed.pla: 0920:     byte params[5]
					; params -> [0]
; toolsrc/ed.pla: 0921:     byte count
					; count -> [5]
; toolsrc/ed.pla: 0922: 
; toolsrc/ed.pla: 0923:     params.0 = 3
	!BYTE	$58,$06,$00		; ENTER	6,0
; toolsrc/ed.pla: 0924:     params.1 = cmdsys.devcons
; toolsrc/ed.pla: 0925:     params.2 = 5
; toolsrc/ed.pla: 0926:     params:3 = @count
; toolsrc/ed.pla: 0927:     return syscall($82, @params) ?? 0 :: count
	!BYTE	$06			; CN	3
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$68			; LAB	_X000+20
_F402 	!WORD	0+20		
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$0A			; CN	5
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$28,$05			; LLA	[5]
	!BYTE	$76,$03			; SLW	[3]
	!BYTE	$2A,$82			; CB	130
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$54			; CALL	_X011
_F403 	!WORD	0		
	!BYTE	$4C			; BRFLS	_B275
	!WORD	_B275-*
	!BYTE	$00			; CN	0
	!BYTE	$50			; BRNCH	_B276
	!WORD	_B276-*
_B275 
	!BYTE	$64,$05			; LLB	[5]
_B276 
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/ed.pla: 0928: end
; toolsrc/ed.pla: 0929: def cons_keyread
_C042 					; cons_keyread()
; toolsrc/ed.pla: 0930:     byte params[8]
					; params -> [0]
; toolsrc/ed.pla: 0931:     byte key
					; key -> [8]
; toolsrc/ed.pla: 0932: 
; toolsrc/ed.pla: 0933:     params.0 = 4
	!BYTE	$58,$09,$00		; ENTER	9,0
; toolsrc/ed.pla: 0934:     params.1 = cmdsys.refcons
; toolsrc/ed.pla: 0935:     params:2 = @key
; toolsrc/ed.pla: 0936:     params:4 = 1
; toolsrc/ed.pla: 0937:     params:6 = 0
; toolsrc/ed.pla: 0938:     syscall($CA, @params)
; toolsrc/ed.pla: 0939:     return params:6 ?? key :: 0
	!BYTE	$08			; CN	4
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$68			; LAB	_X000+19
_F404 	!WORD	0+19		
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$28,$08			; LLA	[8]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$02			; CN	1
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$00			; CN	0
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$2A,$CA			; CB	202
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$54			; CALL	_X011
_F405 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$4C			; BRFLS	_B277
	!WORD	_B277-*
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$50			; BRNCH	_B278
	!WORD	_B278-*
_B277 
	!BYTE	$00			; CN	0
_B278 
	!BYTE	$5A,$09			; LEAVE	9
; toolsrc/ed.pla: 0940: end
; toolsrc/ed.pla: 0941: def keyin3
_C043 					; keyin3()
; toolsrc/ed.pla: 0942:     byte key
					; key -> [0]
; toolsrc/ed.pla: 0943: 
; toolsrc/ed.pla: 0944:     repeat
	!BYTE	$58,$01,$00		; ENTER	1,0
_B280 
; toolsrc/ed.pla: 0945:         cursflash
; toolsrc/ed.pla: 0946:     until cons_keyavail
	!BYTE	$54			; CALL	_C024
_F406 	!WORD	_C024		
_B281 
	!BYTE	$54			; CALL	_C041
_F407 	!WORD	_C041		
	!BYTE	$4C			; BRFLS	_B280
	!WORD	_B280-*
_B279 
; toolsrc/ed.pla: 0947:     key = cons_keyread
; toolsrc/ed.pla: 0948:     if key & $80 // Open Apple modifier
; toolsrc/ed.pla: 0949:         when key
	!BYTE	$54			; CALL	_C042
_F408 	!WORD	_C042		
	!BYTE	$6C,$00			; DLB	[0]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B282
	!WORD	_B282-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$52			; SEL
	!WORD	_B285-*
; toolsrc/ed.pla: 0950:             is keyarrowleft
_B286 
; toolsrc/ed.pla: 0951:                 key = keyctrla; break
	!BYTE	$2A,$81			; CB	129
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0952:             is keyarrowright
_B287 
; toolsrc/ed.pla: 0953:                 key = keyctrls; break
	!BYTE	$2A,$93			; CB	147
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0954:             is keyarrowup
_B288 
; toolsrc/ed.pla: 0955:                 key = keyctrlw; break
	!BYTE	$2A,$97			; CB	151
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0956:             is keyarrowdown
_B289 
; toolsrc/ed.pla: 0957:                 key = keyctrlz; break
	!BYTE	$2A,$9A			; CB	154
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0958:             is keyenter
_B290 
; toolsrc/ed.pla: 0959:                 key = keyctrlf; break
	!BYTE	$2A,$86			; CB	134
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0960:              is keytab
_B291 
; toolsrc/ed.pla: 0961:                 key = keydetab; break
	!BYTE	$2A,$9D			; CB	157
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0962:            is $80 | '\\'
_B292 
; toolsrc/ed.pla: 0963:                 key = keydelete; break // Delete
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0964:             //
; toolsrc/ed.pla: 0965:             // Map OA+keypad
; toolsrc/ed.pla: 0966:             //
; toolsrc/ed.pla: 0967:             is $80 | '4'
_B293 
; toolsrc/ed.pla: 0968:                 key = keyarrowleft; break
	!BYTE	$2A,$88			; CB	136
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0969:             is $80 | '6'
_B294 
; toolsrc/ed.pla: 0970:                 key = keyarrowright; break
	!BYTE	$2A,$95			; CB	149
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0971:             is $80 | '8'
_B295 
; toolsrc/ed.pla: 0972:                 key = keyarrowup; break
	!BYTE	$2A,$8B			; CB	139
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0973:             is $80 | '2'
_B296 
; toolsrc/ed.pla: 0974:                 key = keyarrowdown; break
	!BYTE	$2A,$8A			; CB	138
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0975:             is $80 | '7'
_B297 
; toolsrc/ed.pla: 0976:                 key = keyctrlq; break // Top
	!BYTE	$2A,$91			; CB	145
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0977:             is $80 | '1'
_B298 
; toolsrc/ed.pla: 0978:                 key = keyctrle; break // Bottom
	!BYTE	$2A,$85			; CB	133
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0979:             is $80 | '9'
_B299 
; toolsrc/ed.pla: 0980:                 key = keyctrlw; break // Pg Up
	!BYTE	$2A,$97			; CB	151
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0981:             is $80 | '3'
_B300 
; toolsrc/ed.pla: 0982:                 key = keyctrlz; break // Pg Dn
	!BYTE	$2A,$9A			; CB	154
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0983:             is $80 | '5'
_B301 
; toolsrc/ed.pla: 0984:                 key = keyctrld; break // Del
	!BYTE	$2A,$84			; CB	132
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0985:             is $80 | '.'
_B302 
; toolsrc/ed.pla: 0986:                 key = keyctrlc; break // Copy
	!BYTE	$2A,$83			; CB	131
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0987:             is $80 | '0'
_B303 
; toolsrc/ed.pla: 0988:                 key = keyctrlv; break // Paste
	!BYTE	$2A,$96			; CB	150
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0989:             is $80 | '-'
_B304 
; toolsrc/ed.pla: 0990:                 key = keyctrlx; break // Cut
	!BYTE	$2A,$98			; CB	152
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
; toolsrc/ed.pla: 0991:         wend
	!BYTE	$50			; BRNCH	_B284
	!WORD	_B284-*
_B285 
	!BYTE	$13			; CASEBLOCK
	!WORD	$0088
	!WORD	_B286-*
	!WORD	$0089
	!WORD	_B291-*
	!WORD	$008A
	!WORD	_B289-*
	!WORD	$008B
	!WORD	_B288-*
	!WORD	$008D
	!WORD	_B290-*
	!WORD	$0095
	!WORD	_B287-*
	!WORD	$00AD
	!WORD	_B304-*
	!WORD	$00AE
	!WORD	_B302-*
	!WORD	$00B0
	!WORD	_B303-*
	!WORD	$00B1
	!WORD	_B298-*
	!WORD	$00B2
	!WORD	_B296-*
	!WORD	$00B3
	!WORD	_B300-*
	!WORD	$00B4
	!WORD	_B293-*
	!WORD	$00B5
	!WORD	_B301-*
	!WORD	$00B6
	!WORD	_B294-*
	!WORD	$00B7
	!WORD	_B297-*
	!WORD	$00B8
	!WORD	_B295-*
	!WORD	$00B9
	!WORD	_B299-*
	!WORD	$00DC
	!WORD	_B292-*
_B284 
; toolsrc/ed.pla: 0992:     fin
_B282 
_B283 
; toolsrc/ed.pla: 0993:     return key | $80
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$5A,$01			; LEAVE	1
; toolsrc/ed.pla: 0994: end
; toolsrc/ed.pla: 0995: def keyin2e
_C044 					; keyin2e()
; toolsrc/ed.pla: 0996:     byte key, vbl
					; key -> [0]
					; vbl -> [1]
; toolsrc/ed.pla: 0997:     ^$C079 = 0 // IOU enable and clear VBL int on //c
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/ed.pla: 0998:     ^$C05B = 0 // Enable VBL Ints on //c
; toolsrc/ed.pla: 0999:     vbl    = ^$C019
; toolsrc/ed.pla: 1000:     repeat
	!BYTE	$00			; CN	0
	!BYTE	$78,$79,$C0		; SAB	49273
	!BYTE	$00			; CN	0
	!BYTE	$78,$5B,$C0		; SAB	49243
	!BYTE	$68,$19,$C0		; LAB	49177
	!BYTE	$74,$01			; SLB	[1]
_B306 
; toolsrc/ed.pla: 1001:         if flags & showcurs
; toolsrc/ed.pla: 1002:             if flash == 0
; toolsrc/ed.pla: 1003:                 ^cursptr = curschr
; toolsrc/ed.pla: 1004:             elsif flash == 128
	!BYTE	$68			; LAB	_D040+0
_F409 	!WORD	_D040+0		
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$4C			; BRFLS	_B308
	!WORD	_B308-*
	!BYTE	$68			; LAB	_D041+0
_F410 	!WORD	_D041+0		
	!BYTE	$4E			; BRTRU	_B310
	!WORD	_B310-*
	!BYTE	$68			; LAB	_D056+0
_F411 	!WORD	_D056+0		
	!BYTE	$6A			; LAW	_D061+0
_F412 	!WORD	_D061+0		
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B311
	!WORD	_B311-*
_B310 
; toolsrc/ed.pla: 1005:                 ^cursptr = underchr
; toolsrc/ed.pla: 1006:             fin
	!BYTE	$68			; LAB	_D041+0
_F413 	!WORD	_D041+0		
	!BYTE	$2A,$80			; CB	128
	!BYTE	$24			; BRNE	_B312
	!WORD	_B312-*
	!BYTE	$68			; LAB	_D055+0
_F414 	!WORD	_D055+0		
	!BYTE	$6A			; LAW	_D061+0
_F415 	!WORD	_D061+0		
	!BYTE	$70			; SB
_B312 
_B311 
; toolsrc/ed.pla: 1007:             if vbl ^ ^$C019
; toolsrc/ed.pla: 1008:                 flash = flash + 8
; toolsrc/ed.pla: 1009:                 vbl = ^$C019
; toolsrc/ed.pla: 1010:                 ^$C079 = 0 // Clear VBL int on //c
; toolsrc/ed.pla: 1011:             fin
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$68,$19,$C0		; LAB	49177
	!BYTE	$98			; XOR
	!BYTE	$4C			; BRFLS	_B313
	!WORD	_B313-*
	!BYTE	$68			; LAB	_D041+0
_F416 	!WORD	_D041+0		
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$78			; SAB	_D041+0
_F417 	!WORD	_D041+0		
	!BYTE	$68,$19,$C0		; LAB	49177
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$00			; CN	0
	!BYTE	$78,$79,$C0		; SAB	49273
_B313 
_B314 
; toolsrc/ed.pla: 1012:         fin
_B308 
_B309 
; toolsrc/ed.pla: 1013:         key = ^keyboard
; toolsrc/ed.pla: 1014:     until key >= 128
	!BYTE	$68,$00,$C0		; LAB	49152
	!BYTE	$74,$00			; SLB	[0]
_B307 
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$2A,$80			; CB	128
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B306
	!WORD	_B306-*
_B305 
; toolsrc/ed.pla: 1015:     ^$C05A = 0 // Disable VBL Ints on //c
; toolsrc/ed.pla: 1016:     ^$C078 = 0 // IOU disable on //c
; toolsrc/ed.pla: 1017:     ^keystrobe
; toolsrc/ed.pla: 1018:     if ^pushbttn2 & 128 // Closed Apple pressed
; toolsrc/ed.pla: 1019:         when key
	!BYTE	$00			; CN	0
	!BYTE	$78,$5A,$C0		; SAB	49242
	!BYTE	$00			; CN	0
	!BYTE	$78,$78,$C0		; SAB	49272
	!BYTE	$68,$10,$C0		; LAB	49168
	!BYTE	$30			; DROP 
	!BYTE	$68,$62,$C0		; LAB	49250
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B315
	!WORD	_B315-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$52			; SEL
	!WORD	_B318-*
; toolsrc/ed.pla: 1020:             is keyarrowleft
_B319 
; toolsrc/ed.pla: 1021:                 key = keyctrla; break
	!BYTE	$2A,$81			; CB	129
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B317
	!WORD	_B317-*
; toolsrc/ed.pla: 1022:             is keyarrowright
_B320 
; toolsrc/ed.pla: 1023:                 key = keyctrls; break
	!BYTE	$2A,$93			; CB	147
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B317
	!WORD	_B317-*
; toolsrc/ed.pla: 1024:             is keyarrowup
_B321 
; toolsrc/ed.pla: 1025:                 key = keyctrlw; break
	!BYTE	$2A,$97			; CB	151
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B317
	!WORD	_B317-*
; toolsrc/ed.pla: 1026:             is keyarrowdown
_B322 
; toolsrc/ed.pla: 1027:                 key = keyctrlz; break
	!BYTE	$2A,$9A			; CB	154
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B317
	!WORD	_B317-*
; toolsrc/ed.pla: 1028:             is keyenter
_B323 
; toolsrc/ed.pla: 1029:                 key = keyctrlf; break
	!BYTE	$2A,$86			; CB	134
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B317
	!WORD	_B317-*
; toolsrc/ed.pla: 1030:             is keytab
_B324 
; toolsrc/ed.pla: 1031:                 key = keydetab; break
	!BYTE	$2A,$9D			; CB	157
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B317
	!WORD	_B317-*
; toolsrc/ed.pla: 1032:         wend
	!BYTE	$50			; BRNCH	_B317
	!WORD	_B317-*
_B318 
	!BYTE	$06			; CASEBLOCK
	!WORD	$0088
	!WORD	_B319-*
	!WORD	$0089
	!WORD	_B324-*
	!WORD	$008A
	!WORD	_B322-*
	!WORD	$008B
	!WORD	_B321-*
	!WORD	$008D
	!WORD	_B323-*
	!WORD	$0095
	!WORD	_B320-*
_B317 
; toolsrc/ed.pla: 1033:     fin
_B315 
_B316 
; toolsrc/ed.pla: 1034:     return key
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 1035: end
; toolsrc/ed.pla: 1036: def keyin2
_C045 					; keyin2()
; toolsrc/ed.pla: 1037:     byte key
					; key -> [0]
; toolsrc/ed.pla: 1038: 
; toolsrc/ed.pla: 1039:     repeat
	!BYTE	$58,$01,$00		; ENTER	1,0
_B326 
; toolsrc/ed.pla: 1040:         cursflash
; toolsrc/ed.pla: 1041:         key = ^keyboard
; toolsrc/ed.pla: 1042:         if key == keyctrll
; toolsrc/ed.pla: 1043:             ^keystrobe
; toolsrc/ed.pla: 1044:             flags = flags ^ shiftlock
; toolsrc/ed.pla: 1045:             key   = 0
; toolsrc/ed.pla: 1046:         fin
	!BYTE	$54			; CALL	_C024
_F418 	!WORD	_C024		
	!BYTE	$68,$00,$C0		; LAB	49152
	!BYTE	$6C,$00			; DLB	[0]
	!BYTE	$2A,$8C			; CB	140
	!BYTE	$24			; BRNE	_B328
	!WORD	_B328-*
	!BYTE	$68,$10,$C0		; LAB	49168
	!BYTE	$30			; DROP 
	!BYTE	$68			; LAB	_D040+0
_F419 	!WORD	_D040+0		
	!BYTE	$2A,$80			; CB	128
	!BYTE	$98			; XOR
	!BYTE	$78			; SAB	_D040+0
_F420 	!WORD	_D040+0		
	!BYTE	$00			; CN	0
	!BYTE	$74,$00			; SLB	[0]
_B328 
_B329 
; toolsrc/ed.pla: 1047:     until key >= 128
_B327 
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$2A,$80			; CB	128
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B326
	!WORD	_B326-*
_B325 
; toolsrc/ed.pla: 1048:     ^keystrobe
; toolsrc/ed.pla: 1049:     when key
	!BYTE	$68,$10,$C0		; LAB	49168
	!BYTE	$30			; DROP 
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$52			; SEL
	!WORD	_B331-*
; toolsrc/ed.pla: 1050:         is keyctrln
_B332 
; toolsrc/ed.pla: 1051:             key = $DB // '['
; toolsrc/ed.pla: 1052:             break
	!BYTE	$2A,$DB			; CB	219
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B330
	!WORD	_B330-*
; toolsrc/ed.pla: 1053:         is $9E // SHIFT+CTRL+N
_B333 
; toolsrc/ed.pla: 1054:             key = $FE // '~'
; toolsrc/ed.pla: 1055:             break
	!BYTE	$2A,$FE			; CB	254
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B330
	!WORD	_B330-*
; toolsrc/ed.pla: 1056:         is keyctrlp
_B334 
; toolsrc/ed.pla: 1057:             key = $DC // '\'
; toolsrc/ed.pla: 1058:             break
	!BYTE	$2A,$DC			; CB	220
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B330
	!WORD	_B330-*
; toolsrc/ed.pla: 1059:         is $80 // SHIFT+CTRL+P -> CTRL+@
_B335 
; toolsrc/ed.pla: 1060:             key = $FC // '|'
; toolsrc/ed.pla: 1061:             break
	!BYTE	$2A,$FC			; CB	252
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B330
	!WORD	_B330-*
; toolsrc/ed.pla: 1062:         is keyctrlg
_B336 
; toolsrc/ed.pla: 1063:             key = $DF // '_'
; toolsrc/ed.pla: 1064:             break
	!BYTE	$2A,$DF			; CB	223
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B330
	!WORD	_B330-*
; toolsrc/ed.pla: 1065:         is keyarrowleft
_B337 
; toolsrc/ed.pla: 1066:             if ^pushbttn3 < 128
; toolsrc/ed.pla: 1067:                 key = keydelete
; toolsrc/ed.pla: 1068:             fin
	!BYTE	$68,$63,$C0		; LAB	49251
	!BYTE	$2A,$80			; CB	128
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B338
	!WORD	_B338-*
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$74,$00			; SLB	[0]
_B338 
_B339 
; toolsrc/ed.pla: 1069:             break
	!BYTE	$50			; BRNCH	_B330
	!WORD	_B330-*
; toolsrc/ed.pla: 1070:         is keyarrowright
_B340 
; toolsrc/ed.pla: 1071:             if ^pushbttn3 < 128
; toolsrc/ed.pla: 1072:                 key = keytab
; toolsrc/ed.pla: 1073:             fin
	!BYTE	$68,$63,$C0		; LAB	49251
	!BYTE	$2A,$80			; CB	128
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B341
	!WORD	_B341-*
	!BYTE	$2A,$89			; CB	137
	!BYTE	$74,$00			; SLB	[0]
_B341 
_B342 
; toolsrc/ed.pla: 1074:             break
	!BYTE	$50			; BRNCH	_B330
	!WORD	_B330-*
; toolsrc/ed.pla: 1075:         otherwise
_B331 
	!BYTE	$07			; CASEBLOCK
	!WORD	$0080
	!WORD	_B335-*
	!WORD	$0087
	!WORD	_B336-*
	!WORD	$0088
	!WORD	_B337-*
	!WORD	$008E
	!WORD	_B332-*
	!WORD	$0090
	!WORD	_B334-*
	!WORD	$0095
	!WORD	_B340-*
	!WORD	$009E
	!WORD	_B333-*
; toolsrc/ed.pla: 1076:             if key >= $C0 and flags < shiftlock
; toolsrc/ed.pla: 1077:                 if ^pushbttn3 < 128
; toolsrc/ed.pla: 1078:                     when key
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$2A,$C0			; CB	192
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B343
	!WORD	_B343-*
	!BYTE	$68			; LAB	_D040+0
_F421 	!WORD	_D040+0		
	!BYTE	$2A,$80			; CB	128
	!BYTE	$46			; ISLT
_B343 
	!BYTE	$4C			; BRFLS	_B344
	!WORD	_B344-*
	!BYTE	$68,$63,$C0		; LAB	49251
	!BYTE	$2A,$80			; CB	128
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B346
	!WORD	_B346-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$52			; SEL
	!WORD	_B349-*
; toolsrc/ed.pla: 1079:                         is $C0
_B350 
; toolsrc/ed.pla: 1080:                             key = $D0 // P
; toolsrc/ed.pla: 1081:                             break
	!BYTE	$2A,$D0			; CB	208
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B348
	!WORD	_B348-*
; toolsrc/ed.pla: 1082:                         is $DD
_B351 
; toolsrc/ed.pla: 1083:                             key = $CD // M
; toolsrc/ed.pla: 1084:                             break
	!BYTE	$2A,$CD			; CB	205
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B348
	!WORD	_B348-*
; toolsrc/ed.pla: 1085:                         is $DE
_B352 
; toolsrc/ed.pla: 1086:                             key = $CE // N
; toolsrc/ed.pla: 1087:                     wend
	!BYTE	$2A,$CE			; CB	206
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B348
	!WORD	_B348-*
_B349 
	!BYTE	$03			; CASEBLOCK
	!WORD	$00C0
	!WORD	_B350-*
	!WORD	$00DD
	!WORD	_B351-*
	!WORD	$00DE
	!WORD	_B352-*
_B348 
; toolsrc/ed.pla: 1088:                 else
	!BYTE	$50			; BRNCH	_B347
	!WORD	_B347-*
_B346 
; toolsrc/ed.pla: 1089:                    key = key | $E0
; toolsrc/ed.pla: 1090:                 fin
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3E,$E0			; ORI	224
	!BYTE	$74,$00			; SLB	[0]
_B347 
; toolsrc/ed.pla: 1091:             fin
_B344 
_B345 
; toolsrc/ed.pla: 1092:     wend
_B330 
; toolsrc/ed.pla: 1093:     return key
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$5A,$01			; LEAVE	1
; toolsrc/ed.pla: 1094: end
; toolsrc/ed.pla: 1095: def setkeyin#0
_C046 					; setkeyin()
; toolsrc/ed.pla: 1096:     when MACHID & MACHID_MODEL
	!BYTE	$68			; LAB	_X001+0
_F422 	!WORD	0+0		
	!BYTE	$3C,$C8			; ANDI	200
	!BYTE	$52			; SEL
	!WORD	_B354-*
; toolsrc/ed.pla: 1097:         is MACHID_IIE
_B355 
; toolsrc/ed.pla: 1098:         is MACHID_IIC
_B356 
; toolsrc/ed.pla: 1099:             keyin = @keyin2e
; toolsrc/ed.pla: 1100:             break
	!BYTE	$26			; LA	_C044+0
_F423 	!WORD	_C044+0		
	!BYTE	$7A			; SAW	_D057+0
_F424 	!WORD	_D057+0		
	!BYTE	$50			; BRNCH	_B353
	!WORD	_B353-*
; toolsrc/ed.pla: 1101:         is MACHID_III
_B357 
; toolsrc/ed.pla: 1102:             keyin = @keyin3
; toolsrc/ed.pla: 1103:             break
	!BYTE	$26			; LA	_C043+0
_F425 	!WORD	_C043+0		
	!BYTE	$7A			; SAW	_D057+0
_F426 	!WORD	_D057+0		
	!BYTE	$50			; BRNCH	_B353
	!WORD	_B353-*
; toolsrc/ed.pla: 1104:         otherwise // ][ or ][+
_B354 
	!BYTE	$03			; CASEBLOCK
	!WORD	$0080
	!WORD	_B355-*
	!WORD	$0088
	!WORD	_B356-*
	!WORD	$00C0
	!WORD	_B357-*
; toolsrc/ed.pla: 1105:             keyin = @keyin2
; toolsrc/ed.pla: 1106:     wend
	!BYTE	$26			; LA	_C045+0
_F427 	!WORD	_C045+0		
	!BYTE	$7A			; SAW	_D057+0
_F428 	!WORD	_D057+0		
_B353 
; toolsrc/ed.pla: 1107: end
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 1108: //
; toolsrc/ed.pla: 1109: // Printer routines
; toolsrc/ed.pla: 1110: //
; toolsrc/ed.pla: 1111: def printtxt(slot)#0
					; slot -> [0]
_C047 					; printtxt()
; toolsrc/ed.pla: 1112:     byte txtbuf[MAXLNLEN+1]
					; txtbuf -> [2]
; toolsrc/ed.pla: 1113:     word i, scrncsw
					; i -> [82]
					; scrncsw -> [84]
; toolsrc/ed.pla: 1114: 
; toolsrc/ed.pla: 1115:     scrncsw = *csw
	!BYTE	$58,$56,$01		; ENTER	86,1
; toolsrc/ed.pla: 1116:     *csw  = $C000 | (slot << 8)
; toolsrc/ed.pla: 1117:     for i = 0 to numlines - 1
	!BYTE	$6A,$36,$00		; LAW	54
	!BYTE	$76,$54			; SLW	[84]
	!BYTE	$2C,$00,$C0		; CW	49152
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$10			; CN	8
	!BYTE	$9A			; SHL
	!BYTE	$96			; OR 
	!BYTE	$7A,$36,$00		; SAW	54
	!BYTE	$6A			; LAW	_D042+0
_F429 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B358
	!WORD	_B358-*
_B359 
	!BYTE	$6E,$52			; DLW	[82]
; toolsrc/ed.pla: 1118:         lncpy(@txtbuf, txtlinbuf=>[i])
; toolsrc/ed.pla: 1119:         puts(@txtbuf)
; toolsrc/ed.pla: 1120:         putln
; toolsrc/ed.pla: 1121:     next
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$6A			; LAW	_D048+0
_F430 	!WORD	_D048+0		
	!BYTE	$BA,$52			; IDXLW	[82]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_A002
_F431 	!WORD	_A002		
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$54			; CALL	_X004
_F432 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F433 	!WORD	0		
_B360 
	!BYTE	$A4			; INCBRLE	_B359
	!WORD	_B359-*
_B358 
	!BYTE	$76,$52			; SLW	[82]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1122:     *csw = scrncsw
; toolsrc/ed.pla: 1123: end
	!BYTE	$66,$54			; LLW	[84]
	!BYTE	$7A,$36,$00		; SAW	54
	!BYTE	$5A,$56			; LEAVE	86
; toolsrc/ed.pla: 1124: def freesel#0
_C048 					; freesel()
; toolsrc/ed.pla: 1125:     word i
					; i -> [0]
; toolsrc/ed.pla: 1126: 
; toolsrc/ed.pla: 1127:     for i = 0 to numcliplines - 1
	!BYTE	$58,$02,$00		; ENTER	2,0
	!BYTE	$6A			; LAW	_D043+0
_F434 	!WORD	_D043+0		
	!BYTE	$8E			; DECR
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B361
	!WORD	_B361-*
_B362 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 1128:         if cliplinbuf=>[i] <> @nullstr
; toolsrc/ed.pla: 1129:             delstr(cliplinbuf=>[i])
; toolsrc/ed.pla: 1130:             cliplinbuf=>[i] = @nullstr
; toolsrc/ed.pla: 1131:         fin
	!BYTE	$6A			; LAW	_D049+0
_F435 	!WORD	_D049+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$26			; LA	_D036+0
_F436 	!WORD	_D036+0		
	!BYTE	$22			; BREQ	_B364
	!WORD	_B364-*
	!BYTE	$6A			; LAW	_D049+0
_F437 	!WORD	_D049+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C006
_F438 	!WORD	_C006		
	!BYTE	$26			; LA	_D036+0
_F439 	!WORD	_D036+0		
	!BYTE	$6A			; LAW	_D049+0
_F440 	!WORD	_D049+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$72			; SW
_B364 
_B365 
; toolsrc/ed.pla: 1132:     next
_B363 
	!BYTE	$A4			; INCBRLE	_B362
	!WORD	_B362-*
_B361 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1133:     numcliplines = 0
; toolsrc/ed.pla: 1134: end
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D043+0
_F441 	!WORD	_D043+0		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 1135: def selrange#2
_C049 					; selrange()
; toolsrc/ed.pla: 1136:     word first, last
					; first -> [0]
					; last -> [2]
; toolsrc/ed.pla: 1137: 
; toolsrc/ed.pla: 1138:     if flags & selection
	!BYTE	$58,$04,$00		; ENTER	4,0
; toolsrc/ed.pla: 1139:         if cursrow > selrow
; toolsrc/ed.pla: 1140:             first, last = selrow, cursrow
; toolsrc/ed.pla: 1141:         else
	!BYTE	$68			; LAB	_D040+0
_F442 	!WORD	_D040+0		
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B366
	!WORD	_B366-*
	!BYTE	$6A			; LAW	_D058+0
_F443 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D059+0
_F444 	!WORD	_D059+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B368
	!WORD	_B368-*
	!BYTE	$6A			; LAW	_D059+0
_F445 	!WORD	_D059+0		
	!BYTE	$6A			; LAW	_D058+0
_F446 	!WORD	_D058+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B369
	!WORD	_B369-*
_B368 
; toolsrc/ed.pla: 1142:             first, last = cursrow, selrow
; toolsrc/ed.pla: 1143:         fin
	!BYTE	$6A			; LAW	_D058+0
_F447 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D059+0
_F448 	!WORD	_D059+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$76,$00			; SLW	[0]
_B369 
; toolsrc/ed.pla: 1144:     else
	!BYTE	$50			; BRNCH	_B367
	!WORD	_B367-*
_B366 
; toolsrc/ed.pla: 1145:         first = cursrow
; toolsrc/ed.pla: 1146:         last = first
; toolsrc/ed.pla: 1147:     fin
	!BYTE	$6A			; LAW	_D058+0
_F449 	!WORD	_D058+0		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$76,$02			; SLW	[2]
_B367 
; toolsrc/ed.pla: 1148:     return first, last
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 1149: end
; toolsrc/ed.pla: 1150: def beginsel#0
_C050 					; beginsel()
; toolsrc/ed.pla: 1151:     flags  = flags ^ selection
; toolsrc/ed.pla: 1152:     selrow = cursrow
; toolsrc/ed.pla: 1153:     drawgutter(scrntop, scrnleft)
; toolsrc/ed.pla: 1154: end
	!BYTE	$68			; LAB	_D040+0
_F450 	!WORD	_D040+0		
	!BYTE	$2A,$10			; CB	16
	!BYTE	$98			; XOR
	!BYTE	$78			; SAB	_D040+0
_F451 	!WORD	_D040+0		
	!BYTE	$6A			; LAW	_D058+0
_F452 	!WORD	_D058+0		
	!BYTE	$7A			; SAW	_D059+0
_F453 	!WORD	_D059+0		
	!BYTE	$6A			; LAW	_D060+0
_F454 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F455 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C020
_F456 	!WORD	_C020		
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 1155: def copysel#0
_C051 					; copysel()
; toolsrc/ed.pla: 1156:     word firstsel, lastsel
					; firstsel -> [0]
					; lastsel -> [2]
; toolsrc/ed.pla: 1157: 
; toolsrc/ed.pla: 1158:     freesel
	!BYTE	$58,$04,$00		; ENTER	4,0
; toolsrc/ed.pla: 1159:     firstsel, lastsel = selrange
; toolsrc/ed.pla: 1160:     for numcliplines = 0 to lastsel - firstsel
	!BYTE	$54			; CALL	_C048
_F457 	!WORD	_C048		
	!BYTE	$54			; CALL	_C049
_F458 	!WORD	_C049		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B370
	!WORD	_B370-*
_B371 
	!BYTE	$7E			; DAW	_D043+0
_F459 	!WORD	_D043+0		
; toolsrc/ed.pla: 1161:         cliplinbuf=>[numcliplines] = newstr(txtlinbuf=>[firstsel + numcliplines])
; toolsrc/ed.pla: 1162:     next
	!BYTE	$6A			; LAW	_D048+0
_F460 	!WORD	_D048+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B6			; ADDAW	_D043+0
_F461 	!WORD	_D043+0		
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C007
_F462 	!WORD	_C007		
	!BYTE	$6A			; LAW	_D049+0
_F463 	!WORD	_D049+0		
	!BYTE	$BE			; IDXAW	_D043+0
_F464 	!WORD	_D043+0		
	!BYTE	$72			; SW
_B372 
	!BYTE	$A4			; INCBRLE	_B371
	!WORD	_B371-*
_B370 
	!BYTE	$7A			; SAW	_D043+0
_F465 	!WORD	_D043+0		
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1163:     flags = flags & ~selection
; toolsrc/ed.pla: 1164:     drawgutter(scrntop, scrnleft)
; toolsrc/ed.pla: 1165: end
	!BYTE	$68			; LAB	_D040+0
_F466 	!WORD	_D040+0		
	!BYTE	$5E,$EF			; CFFB	-17
	!BYTE	$94			; AND 
	!BYTE	$78			; SAB	_D040+0
_F467 	!WORD	_D040+0		
	!BYTE	$6A			; LAW	_D060+0
_F468 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F469 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C020
_F470 	!WORD	_C020		
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 1166: def cutsel#0
_C052 					; cutsel()
; toolsrc/ed.pla: 1167:     word firstsel, lastsel
					; firstsel -> [0]
					; lastsel -> [2]
; toolsrc/ed.pla: 1168: 
; toolsrc/ed.pla: 1169:     freesel
	!BYTE	$58,$04,$00		; ENTER	4,0
; toolsrc/ed.pla: 1170:     firstsel, lastsel = selrange
; toolsrc/ed.pla: 1171:     if lastsel - firstsel < MAXCLIPLINES
; toolsrc/ed.pla: 1172:         for numcliplines = 0 to lastsel - firstsel
	!BYTE	$54			; CALL	_C048
_F471 	!WORD	_C048		
	!BYTE	$54			; CALL	_C049
_F472 	!WORD	_C049		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$2C,$00,$01		; CW	256
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B373
	!WORD	_B373-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B375
	!WORD	_B375-*
_B376 
	!BYTE	$7E			; DAW	_D043+0
_F473 	!WORD	_D043+0		
; toolsrc/ed.pla: 1173:             cliplinbuf=>[numcliplines] = txtlinbuf=>[firstsel + numcliplines]
; toolsrc/ed.pla: 1174:         next
	!BYTE	$6A			; LAW	_D048+0
_F474 	!WORD	_D048+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B6			; ADDAW	_D043+0
_F475 	!WORD	_D043+0		
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D049+0
_F476 	!WORD	_D049+0		
	!BYTE	$BE			; IDXAW	_D043+0
_F477 	!WORD	_D043+0		
	!BYTE	$72			; SW
_B377 
	!BYTE	$A4			; INCBRLE	_B376
	!WORD	_B376-*
_B375 
	!BYTE	$7A			; SAW	_D043+0
_F478 	!WORD	_D043+0		
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1175:         memcpy(@txtlinbuf=>[firstsel], @txtlinbuf=>[lastsel + 1], (numlines - lastsel + 1) * 2)
; toolsrc/ed.pla: 1176:         numlines = numlines - numcliplines
; toolsrc/ed.pla: 1177:         for lastsel = numlines to numlines + numcliplines
	!BYTE	$6A			; LAW	_D048+0
_F479 	!WORD	_D048+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$6A			; LAW	_D048+0
_F480 	!WORD	_D048+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$6A			; LAW	_D042+0
_F481 	!WORD	_D042+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$84			; SUB 
	!BYTE	$8C			; INCR
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X018
_F482 	!WORD	0		
	!BYTE	$6A			; LAW	_D042+0
_F483 	!WORD	_D042+0		
	!BYTE	$6A			; LAW	_D043+0
_F484 	!WORD	_D043+0		
	!BYTE	$84			; SUB 
	!BYTE	$7E			; DAW	_D042+0
_F485 	!WORD	_D042+0		
	!BYTE	$B6			; ADDAW	_D043+0
_F486 	!WORD	_D043+0		
	!BYTE	$6A			; LAW	_D042+0
_F487 	!WORD	_D042+0		
	!BYTE	$A0			; BRGT	_B378
	!WORD	_B378-*
_B379 
	!BYTE	$6E,$02			; DLW	[2]
; toolsrc/ed.pla: 1178:             txtlinbuf=>[lastsel] = @nullstr
; toolsrc/ed.pla: 1179:         next
	!BYTE	$26			; LA	_D036+0
_F488 	!WORD	_D036+0		
	!BYTE	$6A			; LAW	_D048+0
_F489 	!WORD	_D048+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$72			; SW
_B380 
	!BYTE	$A4			; INCBRLE	_B379
	!WORD	_B379-*
_B378 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1180:         cursrow  = firstsel
; toolsrc/ed.pla: 1181:         if cursrow >= numlines
; toolsrc/ed.pla: 1182:             cursrow = numlines - 1
; toolsrc/ed.pla: 1183:         fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7E			; DAW	_D058+0
_F490 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D042+0
_F491 	!WORD	_D042+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B381
	!WORD	_B381-*
	!BYTE	$6A			; LAW	_D042+0
_F492 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$7A			; SAW	_D058+0
_F493 	!WORD	_D058+0		
_B381 
_B382 
; toolsrc/ed.pla: 1184:         if cursrow < scrntop
; toolsrc/ed.pla: 1185:             scrntop = cursrow
; toolsrc/ed.pla: 1186:         fin
	!BYTE	$6A			; LAW	_D058+0
_F494 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D060+0
_F495 	!WORD	_D060+0		
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B383
	!WORD	_B383-*
	!BYTE	$6A			; LAW	_D058+0
_F496 	!WORD	_D058+0		
	!BYTE	$7A			; SAW	_D060+0
_F497 	!WORD	_D060+0		
_B383 
_B384 
; toolsrc/ed.pla: 1187:         cursy = cursrow - scrntop
; toolsrc/ed.pla: 1188:         flags = flags | changed
; toolsrc/ed.pla: 1189:         flags = flags & ~selection
; toolsrc/ed.pla: 1190:         redraw
; toolsrc/ed.pla: 1191:     else
	!BYTE	$6A			; LAW	_D058+0
_F498 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D060+0
_F499 	!WORD	_D060+0		
	!BYTE	$84			; SUB 
	!BYTE	$7A			; SAW	_D052+0
_F500 	!WORD	_D052+0		
	!BYTE	$68			; LAB	_D040+0
_F501 	!WORD	_D040+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$7C			; DAB	_D040+0
_F502 	!WORD	_D040+0		
	!BYTE	$5E,$EF			; CFFB	-17
	!BYTE	$94			; AND 
	!BYTE	$78			; SAB	_D040+0
_F503 	!WORD	_D040+0		
	!BYTE	$54			; CALL	_C025
_F504 	!WORD	_C025		
	!BYTE	$50			; BRNCH	_B374
	!WORD	_B374-*
_B373 
; toolsrc/ed.pla: 1192:         bell
; toolsrc/ed.pla: 1193:     fin
	!BYTE	$54			; CALL	_C000
_F505 	!WORD	_C000		
_B374 
; toolsrc/ed.pla: 1194: end
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/ed.pla: 1195: def pastesel#0
_C053 					; pastesel()
; toolsrc/ed.pla: 1196:     word p
					; p -> [0]
; toolsrc/ed.pla: 1197: 
; toolsrc/ed.pla: 1198:     if numcliplines and numcliplines + numlines < MAXLINES
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/ed.pla: 1199:         memcpy(@txtlinbuf=>[cursrow + numcliplines], @txtlinbuf=>[cursrow], (numlines - cursrow) * 2)
; toolsrc/ed.pla: 1200:         for p = 0 to numcliplines - 1
	!BYTE	$6A			; LAW	_D043+0
_F506 	!WORD	_D043+0		
	!BYTE	$AC			; BRAND	_B385
	!WORD	_B385-*
	!BYTE	$6A			; LAW	_D043+0
_F507 	!WORD	_D043+0		
	!BYTE	$B6			; ADDAW	_D042+0
_F508 	!WORD	_D042+0		
	!BYTE	$2C,$E7,$03		; CW	999
	!BYTE	$46			; ISLT
_B385 
	!BYTE	$4C			; BRFLS	_B386
	!WORD	_B386-*
	!BYTE	$6A			; LAW	_D048+0
_F509 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D058+0
_F510 	!WORD	_D058+0		
	!BYTE	$B6			; ADDAW	_D043+0
_F511 	!WORD	_D043+0		
	!BYTE	$9E			; IDXW
	!BYTE	$6A			; LAW	_D048+0
_F512 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F513 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D042+0
_F514 	!WORD	_D042+0		
	!BYTE	$6A			; LAW	_D058+0
_F515 	!WORD	_D058+0		
	!BYTE	$84			; SUB 
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X018
_F516 	!WORD	0		
	!BYTE	$6A			; LAW	_D043+0
_F517 	!WORD	_D043+0		
	!BYTE	$8E			; DECR
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B388
	!WORD	_B388-*
_B389 
	!BYTE	$6E,$00			; DLW	[0]
; toolsrc/ed.pla: 1201:             txtlinbuf=>[cursrow + p] = newstr(cliplinbuf=>[p])
; toolsrc/ed.pla: 1202:         next
	!BYTE	$6A			; LAW	_D049+0
_F518 	!WORD	_D049+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C007
_F519 	!WORD	_C007		
	!BYTE	$6A			; LAW	_D048+0
_F520 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D058+0
_F521 	!WORD	_D058+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
_B390 
	!BYTE	$A4			; INCBRLE	_B389
	!WORD	_B389-*
_B388 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1203:         numlines = numlines + numcliplines
; toolsrc/ed.pla: 1204:         flags = flags | changed
; toolsrc/ed.pla: 1205:         redraw
; toolsrc/ed.pla: 1206:     else
	!BYTE	$6A			; LAW	_D042+0
_F522 	!WORD	_D042+0		
	!BYTE	$B6			; ADDAW	_D043+0
_F523 	!WORD	_D043+0		
	!BYTE	$7A			; SAW	_D042+0
_F524 	!WORD	_D042+0		
	!BYTE	$68			; LAB	_D040+0
_F525 	!WORD	_D040+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D040+0
_F526 	!WORD	_D040+0		
	!BYTE	$54			; CALL	_C025
_F527 	!WORD	_C025		
	!BYTE	$50			; BRNCH	_B387
	!WORD	_B387-*
_B386 
; toolsrc/ed.pla: 1207:         bell
; toolsrc/ed.pla: 1208:     fin
	!BYTE	$54			; CALL	_C000
_F528 	!WORD	_C000		
_B387 
; toolsrc/ed.pla: 1209: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 1210: def indentsel#0
_C054 					; indentsel()
; toolsrc/ed.pla: 1211:     byte indentstr[MAXLNLEN+1], j, l
					; indentstr -> [0]
					; j -> [80]
					; l -> [81]
; toolsrc/ed.pla: 1212:     word firstsel, lastsel, i
					; firstsel -> [82]
					; lastsel -> [84]
					; i -> [86]
; toolsrc/ed.pla: 1213: 
; toolsrc/ed.pla: 1214:     freesel
	!BYTE	$58,$58,$00		; ENTER	88,0
; toolsrc/ed.pla: 1215:     firstsel, lastsel = selrange
; toolsrc/ed.pla: 1216:     for i = firstsel to lastsel
	!BYTE	$54			; CALL	_C048
_F529 	!WORD	_C048		
	!BYTE	$54			; CALL	_C049
_F530 	!WORD	_C049		
	!BYTE	$76,$54			; SLW	[84]
	!BYTE	$76,$52			; SLW	[82]
	!BYTE	$66,$54			; LLW	[84]
	!BYTE	$66,$52			; LLW	[82]
	!BYTE	$A0			; BRGT	_B391
	!WORD	_B391-*
_B392 
	!BYTE	$6E,$56			; DLW	[86]
; toolsrc/ed.pla: 1217:         l = ^(txtlinbuf=>[i])
; toolsrc/ed.pla: 1218:         if l and l < MAXLNLEN - 2
; toolsrc/ed.pla: 1219:             memcpy(@indentstr + 3, txtlinbuf=>[i] + 1, l)
; toolsrc/ed.pla: 1220:             indentstr[0] = l + 2
; toolsrc/ed.pla: 1221:             indentstr[1] = keyspace
; toolsrc/ed.pla: 1222:             indentstr[2] = keyspace
; toolsrc/ed.pla: 1223:             //
; toolsrc/ed.pla: 1224:             // Align indent
; toolsrc/ed.pla: 1225:             //
; toolsrc/ed.pla: 1226:             for j = 3 to indentstr[0]
	!BYTE	$6A			; LAW	_D048+0
_F531 	!WORD	_D048+0		
	!BYTE	$BA,$56			; IDXLW	[86]
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$6C,$51			; DLB	[81]
	!BYTE	$AC			; BRAND	_B394
	!WORD	_B394-*
	!BYTE	$64,$51			; LLB	[81]
	!BYTE	$2A,$4D			; CB	77
	!BYTE	$46			; ISLT
_B394 
	!BYTE	$4C			; BRFLS	_B395
	!WORD	_B395-*
	!BYTE	$28,$03			; LLA	[3]
	!BYTE	$6A			; LAW	_D048+0
_F532 	!WORD	_D048+0		
	!BYTE	$BA,$56			; IDXLW	[86]
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$64,$51			; LLB	[81]
	!BYTE	$54			; CALL	_X018
_F533 	!WORD	0		
	!BYTE	$64,$51			; LLB	[81]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$06			; CN	3
	!BYTE	$A0			; BRGT	_B397
	!WORD	_B397-*
_B398 
	!BYTE	$6C,$50			; DLB	[80]
; toolsrc/ed.pla: 1227:                 if indentstr[j] <> keyspace
; toolsrc/ed.pla: 1228:                     if j & 1 == 0
; toolsrc/ed.pla: 1229:                         indentstr[0]--
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$B0,$50			; ADDLB	[80]
	!BYTE	$60			; LB
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$22			; BREQ	_B400
	!WORD	_B400-*
	!BYTE	$64,$50			; LLB	[80]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4E			; BRTRU	_B402
	!WORD	_B402-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 1230:                         memcpy(@indentstr + 1, @indentstr + 2, indentstr[0])
; toolsrc/ed.pla: 1231:                     fin
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_X018
_F534 	!WORD	0		
_B402 
_B403 
; toolsrc/ed.pla: 1232:                     break
	!BYTE	$50			; BRNCH	_B397
	!WORD	_B397-*
; toolsrc/ed.pla: 1233:                 fin
_B400 
_B401 
; toolsrc/ed.pla: 1234:             next
_B399 
	!BYTE	$A4			; INCBRLE	_B398
	!WORD	_B398-*
_B397 
	!BYTE	$74,$50			; SLB	[80]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1235:             delstr(txtlinbuf=>[i])
; toolsrc/ed.pla: 1236:             txtlinbuf=>[i] = newstr(@indentstr)
; toolsrc/ed.pla: 1237:             flags = flags | changed
; toolsrc/ed.pla: 1238:         fin
	!BYTE	$6A			; LAW	_D048+0
_F535 	!WORD	_D048+0		
	!BYTE	$BA,$56			; IDXLW	[86]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C006
_F536 	!WORD	_C006		
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$54			; CALL	_C007
_F537 	!WORD	_C007		
	!BYTE	$6A			; LAW	_D048+0
_F538 	!WORD	_D048+0		
	!BYTE	$BA,$56			; IDXLW	[86]
	!BYTE	$72			; SW
	!BYTE	$68			; LAB	_D040+0
_F539 	!WORD	_D040+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D040+0
_F540 	!WORD	_D040+0		
_B395 
_B396 
; toolsrc/ed.pla: 1239:     next
_B393 
	!BYTE	$A4			; INCBRLE	_B392
	!WORD	_B392-*
_B391 
	!BYTE	$76,$56			; SLW	[86]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1240:     redraw
; toolsrc/ed.pla: 1241: end
	!BYTE	$54			; CALL	_C025
_F541 	!WORD	_C025		
	!BYTE	$5A,$58			; LEAVE	88
; toolsrc/ed.pla: 1242: def undentsel#0
_C055 					; undentsel()
; toolsrc/ed.pla: 1243:     byte undentstr[MAXLNLEN+1], l
					; undentstr -> [0]
					; l -> [80]
; toolsrc/ed.pla: 1244:     word firstsel, lastsel, i
					; firstsel -> [81]
					; lastsel -> [83]
					; i -> [85]
; toolsrc/ed.pla: 1245: 
; toolsrc/ed.pla: 1246:     freesel
	!BYTE	$58,$57,$00		; ENTER	87,0
; toolsrc/ed.pla: 1247:     firstsel, lastsel = selrange
; toolsrc/ed.pla: 1248:     for i = firstsel to lastsel
	!BYTE	$54			; CALL	_C048
_F542 	!WORD	_C048		
	!BYTE	$54			; CALL	_C049
_F543 	!WORD	_C049		
	!BYTE	$76,$53			; SLW	[83]
	!BYTE	$76,$51			; SLW	[81]
	!BYTE	$66,$53			; LLW	[83]
	!BYTE	$66,$51			; LLW	[81]
	!BYTE	$A0			; BRGT	_B404
	!WORD	_B404-*
_B405 
	!BYTE	$6E,$55			; DLW	[85]
; toolsrc/ed.pla: 1249:         l = ^(txtlinbuf=>[i])
; toolsrc/ed.pla: 1250:         if l
; toolsrc/ed.pla: 1251:             memcpy(@undentstr + 1, txtlinbuf=>[i] + 1, l)
; toolsrc/ed.pla: 1252:             if undentstr[1] == keyspace
; toolsrc/ed.pla: 1253:                 memcpy(@undentstr + 1, @undentstr + 2, l - 1)
; toolsrc/ed.pla: 1254:                 l--
	!BYTE	$6A			; LAW	_D048+0
_F544 	!WORD	_D048+0		
	!BYTE	$BA,$55			; IDXLW	[85]
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$6C,$50			; DLB	[80]
	!BYTE	$4C			; BRFLS	_B407
	!WORD	_B407-*
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$6A			; LAW	_D048+0
_F545 	!WORD	_D048+0		
	!BYTE	$BA,$55			; IDXLW	[85]
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$64,$50			; LLB	[80]
	!BYTE	$54			; CALL	_X018
_F546 	!WORD	0		
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$24			; BRNE	_B409
	!WORD	_B409-*
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$64,$50			; LLB	[80]
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_X018
_F547 	!WORD	0		
	!BYTE	$64,$50			; LLB	[80]
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 1255:                 if l and undentstr[1] == keyspace
; toolsrc/ed.pla: 1256:                     memcpy(@undentstr + 1, @undentstr + 2, l - 1)
; toolsrc/ed.pla: 1257:                     l--
	!BYTE	$6C,$50			; DLB	[80]
	!BYTE	$AC			; BRAND	_B411
	!WORD	_B411-*
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$40			; ISEQ
_B411 
	!BYTE	$4C			; BRFLS	_B412
	!WORD	_B412-*
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$64,$50			; LLB	[80]
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_X018
_F548 	!WORD	0		
	!BYTE	$64,$50			; LLB	[80]
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 1258:                 fin
	!BYTE	$74,$50			; SLB	[80]
_B412 
_B413 
; toolsrc/ed.pla: 1259:                 undentstr[0] = l
; toolsrc/ed.pla: 1260:                 delstr(txtlinbuf=>[i])
; toolsrc/ed.pla: 1261:                 txtlinbuf=>[i] = newstr(@undentstr)
; toolsrc/ed.pla: 1262:                 flags = flags | changed
; toolsrc/ed.pla: 1263:             fin
	!BYTE	$64,$50			; LLB	[80]
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$6A			; LAW	_D048+0
_F549 	!WORD	_D048+0		
	!BYTE	$BA,$55			; IDXLW	[85]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C006
_F550 	!WORD	_C006		
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$54			; CALL	_C007
_F551 	!WORD	_C007		
	!BYTE	$6A			; LAW	_D048+0
_F552 	!WORD	_D048+0		
	!BYTE	$BA,$55			; IDXLW	[85]
	!BYTE	$72			; SW
	!BYTE	$68			; LAB	_D040+0
_F553 	!WORD	_D040+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D040+0
_F554 	!WORD	_D040+0		
_B409 
_B410 
; toolsrc/ed.pla: 1264:         fin
_B407 
_B408 
; toolsrc/ed.pla: 1265:     next
_B406 
	!BYTE	$A4			; INCBRLE	_B405
	!WORD	_B405-*
_B404 
	!BYTE	$76,$55			; SLW	[85]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1266:     redraw
; toolsrc/ed.pla: 1267: end
	!BYTE	$54			; CALL	_C025
_F555 	!WORD	_C025		
	!BYTE	$5A,$57			; LEAVE	87
; toolsrc/ed.pla: 1268: def autoindent(strptr)#0
					; strptr -> [0]
_C056 					; autoindent()
; toolsrc/ed.pla: 1269:     byte i
					; i -> [2]
; toolsrc/ed.pla: 1270: 
; toolsrc/ed.pla: 1271:     for i = 1 to ^strptr
	!BYTE	$58,$03,$01		; ENTER	3,1
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B414
	!WORD	_B414-*
_B415 
	!BYTE	$6C,$02			; DLB	[2]
; toolsrc/ed.pla: 1272:         if ^(strptr + i) <> keyspace
; toolsrc/ed.pla: 1273:             break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$60			; LB
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$22			; BREQ	_B417
	!WORD	_B417-*
	!BYTE	$50			; BRNCH	_B414
	!WORD	_B414-*
; toolsrc/ed.pla: 1274:         fin
_B417 
_B418 
; toolsrc/ed.pla: 1275:     next
_B416 
	!BYTE	$A4			; INCBRLE	_B415
	!WORD	_B415-*
_B414 
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1276:     curshpos(i - 1)
; toolsrc/ed.pla: 1277: end
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C026
_F556 	!WORD	_C026		
	!BYTE	$30			; DROP 
	!BYTE	$5A,$03			; LEAVE	3
; toolsrc/ed.pla: 1278: def openline(row)
					; row -> [0]
_C057 					; openline()
; toolsrc/ed.pla: 1279:     if numlines < MAXLINES
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/ed.pla: 1280:         memcpy(@txtlinbuf=>[row + 1], @txtlinbuf=>[row], (numlines - row) * 2)
; toolsrc/ed.pla: 1281:         txtlinbuf=>[row] = @nullstr
; toolsrc/ed.pla: 1282:         numlines++
	!BYTE	$6A			; LAW	_D042+0
_F557 	!WORD	_D042+0		
	!BYTE	$2C,$E7,$03		; CW	999
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B419
	!WORD	_B419-*
	!BYTE	$6A			; LAW	_D048+0
_F558 	!WORD	_D048+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$6A			; LAW	_D048+0
_F559 	!WORD	_D048+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$6A			; LAW	_D042+0
_F560 	!WORD	_D042+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$84			; SUB 
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X018
_F561 	!WORD	0		
	!BYTE	$26			; LA	_D036+0
_F562 	!WORD	_D036+0		
	!BYTE	$6A			; LAW	_D048+0
_F563 	!WORD	_D048+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D042+0
_F564 	!WORD	_D042+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1283:         flags = flags | changed
; toolsrc/ed.pla: 1284:         return TRUE
	!BYTE	$7A			; SAW	_D042+0
_F565 	!WORD	_D042+0		
	!BYTE	$68			; LAB	_D040+0
_F566 	!WORD	_D040+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D040+0
_F567 	!WORD	_D040+0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 1285:     fin
_B419 
_B420 
; toolsrc/ed.pla: 1286:     bell
; toolsrc/ed.pla: 1287:     return FALSE
	!BYTE	$54			; CALL	_C000
_F568 	!WORD	_C000		
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 1288: end
; toolsrc/ed.pla: 1289: def joinline#0
_C058 					; joinline()
; toolsrc/ed.pla: 1290:     byte joinstr[MAXLNLEN+1], joinlen, stripjoin[MAXLNLEN+1]
					; joinstr -> [0]
					; joinlen -> [80]
					; stripjoin -> [81]
; toolsrc/ed.pla: 1291: 
; toolsrc/ed.pla: 1292:     if cursrow < numlines - 1
	!BYTE	$58,$A1,$00		; ENTER	161,0
; toolsrc/ed.pla: 1293:         strstripcpy(@joinstr, txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1294:         memcpy(@stripjoin, txtlinbuf=>[cursrow + 1], ^(txtlinbuf=>[cursrow + 1]) + 1)
; toolsrc/ed.pla: 1295:         striplead(@stripjoin, keyspace);
; toolsrc/ed.pla: 1296:         joinlen = joinstr + stripjoin
; toolsrc/ed.pla: 1297:         if joinlen <= MAXLNLEN
; toolsrc/ed.pla: 1298:             curshpos(joinstr)
; toolsrc/ed.pla: 1299:             memcpy(@joinstr + joinstr + 1, @stripjoin + 1, stripjoin)
; toolsrc/ed.pla: 1300:             joinstr = joinlen
; toolsrc/ed.pla: 1301:             delstr(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1302:             txtlinbuf=>[cursrow] = newstr(@joinstr)
; toolsrc/ed.pla: 1303:             delstr(txtlinbuf=>[cursrow + 1])
; toolsrc/ed.pla: 1304:             numlines--
	!BYTE	$6A			; LAW	_D058+0
_F569 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D042+0
_F570 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B421
	!WORD	_B421-*
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$6A			; LAW	_D048+0
_F571 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F572 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C005
_F573 	!WORD	_C005		
	!BYTE	$28,$51			; LLA	[81]
	!BYTE	$6A			; LAW	_D048+0
_F574 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D058+0
_F575 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D048+0
_F576 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D058+0
_F577 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_X018
_F578 	!WORD	0		
	!BYTE	$28,$51			; LLA	[81]
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$54			; CALL	_C003
_F579 	!WORD	_C003		
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$B0,$51			; ADDLB	[81]
	!BYTE	$6C,$50			; DLB	[80]
	!BYTE	$2A,$4F			; CB	79
	!BYTE	$4A			; ISLE
	!BYTE	$4C			; BRFLS	_B423
	!WORD	_B423-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_C026
_F580 	!WORD	_C026		
	!BYTE	$30			; DROP 
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$B0,$00			; ADDLB	[0]
	!BYTE	$8C			; INCR
	!BYTE	$28,$52			; LLA	[82]
	!BYTE	$64,$51			; LLB	[81]
	!BYTE	$54			; CALL	_X018
_F581 	!WORD	0		
	!BYTE	$64,$50			; LLB	[80]
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$6A			; LAW	_D048+0
_F582 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F583 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C006
_F584 	!WORD	_C006		
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$54			; CALL	_C007
_F585 	!WORD	_C007		
	!BYTE	$6A			; LAW	_D048+0
_F586 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F587 	!WORD	_D058+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D048+0
_F588 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D058+0
_F589 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C006
_F590 	!WORD	_C006		
	!BYTE	$6A			; LAW	_D042+0
_F591 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 1305:             memcpy(@txtlinbuf=>[cursrow + 1], @txtlinbuf=>[cursrow + 2], (numlines - cursrow) * 2)
; toolsrc/ed.pla: 1306:             flags = flags | changed
; toolsrc/ed.pla: 1307:             return
	!BYTE	$7A			; SAW	_D042+0
_F592 	!WORD	_D042+0		
	!BYTE	$6A			; LAW	_D048+0
_F593 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D058+0
_F594 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$6A			; LAW	_D048+0
_F595 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D058+0
_F596 	!WORD	_D058+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$9E			; IDXW
	!BYTE	$6A			; LAW	_D042+0
_F597 	!WORD	_D042+0		
	!BYTE	$6A			; LAW	_D058+0
_F598 	!WORD	_D058+0		
	!BYTE	$84			; SUB 
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X018
_F599 	!WORD	0		
	!BYTE	$68			; LAB	_D040+0
_F600 	!WORD	_D040+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D040+0
_F601 	!WORD	_D040+0		
	!BYTE	$5A,$A1			; LEAVE	161
; toolsrc/ed.pla: 1308:         fin
_B423 
_B424 
; toolsrc/ed.pla: 1309:     fin
_B421 
_B422 
; toolsrc/ed.pla: 1310:     bell
; toolsrc/ed.pla: 1311: end
	!BYTE	$54			; CALL	_C000
_F602 	!WORD	_C000		
	!BYTE	$5A,$A1			; LEAVE	161
; toolsrc/ed.pla: 1312: def splitline#0
_C059 					; splitline()
; toolsrc/ed.pla: 1313:     byte splitstr[MAXLNLEN+1], splitlen, i
					; splitstr -> [0]
					; splitlen -> [80]
					; i -> [81]
; toolsrc/ed.pla: 1314: 
; toolsrc/ed.pla: 1315:     if openline(cursrow + 1)
	!BYTE	$58,$52,$00		; ENTER	82,0
; toolsrc/ed.pla: 1316:         if curscol
; toolsrc/ed.pla: 1317:             splitlen = ^(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1318:             if curscol < splitlen - 1
; toolsrc/ed.pla: 1319:                 splitstr = splitlen - curscol
; toolsrc/ed.pla: 1320:                 memcpy(@splitstr + 1, txtlinbuf=>[cursrow] + curscol + 1, splitstr)
; toolsrc/ed.pla: 1321:                 striplead(@splitstr, keyspace)
; toolsrc/ed.pla: 1322:                 for i = 1 to curscol
	!BYTE	$6A			; LAW	_D058+0
_F603 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_C057
_F604 	!WORD	_C057		
	!BYTE	$4C			; BRFLS	_B425
	!WORD	_B425-*
	!BYTE	$6A			; LAW	_D054+0
_F605 	!WORD	_D054+0		
	!BYTE	$4C			; BRFLS	_B427
	!WORD	_B427-*
	!BYTE	$6A			; LAW	_D048+0
_F606 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F607 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$74,$50			; SLB	[80]
	!BYTE	$6A			; LAW	_D054+0
_F608 	!WORD	_D054+0		
	!BYTE	$64,$50			; LLB	[80]
	!BYTE	$8E			; DECR
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B429
	!WORD	_B429-*
	!BYTE	$64,$50			; LLB	[80]
	!BYTE	$6A			; LAW	_D054+0
_F609 	!WORD	_D054+0		
	!BYTE	$84			; SUB 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$6A			; LAW	_D048+0
_F610 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F611 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$B6			; ADDAW	_D054+0
_F612 	!WORD	_D054+0		
	!BYTE	$8C			; INCR
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_X018
_F613 	!WORD	0		
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$54			; CALL	_C003
_F614 	!WORD	_C003		
	!BYTE	$6A			; LAW	_D054+0
_F615 	!WORD	_D054+0		
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B431
	!WORD	_B431-*
_B432 
	!BYTE	$6C,$51			; DLB	[81]
; toolsrc/ed.pla: 1323:                     if ^(txtlinbuf=>[cursrow] + i) <> keyspace
; toolsrc/ed.pla: 1324:                         break
	!BYTE	$6A			; LAW	_D048+0
_F616 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F617 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$B0,$51			; ADDLB	[81]
	!BYTE	$60			; LB
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$22			; BREQ	_B434
	!WORD	_B434-*
	!BYTE	$50			; BRNCH	_B431
	!WORD	_B431-*
; toolsrc/ed.pla: 1325:                     fin
_B434 
_B435 
; toolsrc/ed.pla: 1326:                     memcpy(@splitstr + 2, @splitstr + 1, splitstr)
; toolsrc/ed.pla: 1327:                     splitstr[1] = keyspace
; toolsrc/ed.pla: 1328:                     splitstr++
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_X018
_F618 	!WORD	0		
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1329:                 next
	!BYTE	$74,$00			; SLB	[0]
_B433 
	!BYTE	$A4			; INCBRLE	_B432
	!WORD	_B432-*
_B431 
	!BYTE	$74,$51			; SLB	[81]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1330:                 txtlinbuf=>[cursrow + 1] = newstr(@splitstr)
; toolsrc/ed.pla: 1331:                 splitstr = curscol
; toolsrc/ed.pla: 1332:                 memcpy(@splitstr + 1, txtlinbuf=>[cursrow] + 1, splitstr)
; toolsrc/ed.pla: 1333:                 delstr(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1334:                 txtlinbuf=>[cursrow] = newstr(@splitstr)
; toolsrc/ed.pla: 1335:                 curshpos(i - 1)
; toolsrc/ed.pla: 1336:             else
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$54			; CALL	_C007
_F619 	!WORD	_C007		
	!BYTE	$6A			; LAW	_D048+0
_F620 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D058+0
_F621 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D054+0
_F622 	!WORD	_D054+0		
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$28,$01			; LLA	[1]
	!BYTE	$6A			; LAW	_D048+0
_F623 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F624 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$8C			; INCR
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_X018
_F625 	!WORD	0		
	!BYTE	$6A			; LAW	_D048+0
_F626 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F627 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C006
_F628 	!WORD	_C006		
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$54			; CALL	_C007
_F629 	!WORD	_C007		
	!BYTE	$6A			; LAW	_D048+0
_F630 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F631 	!WORD	_D058+0		
	!BYTE	$72			; SW
	!BYTE	$64,$51			; LLB	[81]
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C026
_F632 	!WORD	_C026		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B430
	!WORD	_B430-*
_B429 
; toolsrc/ed.pla: 1337:                 if splitlen > 0
; toolsrc/ed.pla: 1338:                     for curscol = 1 to splitlen - 1
	!BYTE	$64,$50			; LLB	[80]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B436
	!WORD	_B436-*
	!BYTE	$64,$50			; LLB	[80]
	!BYTE	$8E			; DECR
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B438
	!WORD	_B438-*
_B439 
	!BYTE	$7E			; DAW	_D054+0
_F633 	!WORD	_D054+0		
; toolsrc/ed.pla: 1339:                         if ^(txtlinbuf=>[cursrow] + curscol) <> keyspace
; toolsrc/ed.pla: 1340:                             break
	!BYTE	$6A			; LAW	_D048+0
_F634 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F635 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$B6			; ADDAW	_D054+0
_F636 	!WORD	_D054+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$22			; BREQ	_B441
	!WORD	_B441-*
	!BYTE	$50			; BRNCH	_B438
	!WORD	_B438-*
; toolsrc/ed.pla: 1341:                         fin
_B441 
_B442 
; toolsrc/ed.pla: 1342:                     next
_B440 
	!BYTE	$A4			; INCBRLE	_B439
	!WORD	_B439-*
_B438 
	!BYTE	$7A			; SAW	_D054+0
_F637 	!WORD	_D054+0		
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1343:                     curshpos(curscol - 1)
; toolsrc/ed.pla: 1344:                 fin
	!BYTE	$6A			; LAW	_D054+0
_F638 	!WORD	_D054+0		
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C026
_F639 	!WORD	_C026		
	!BYTE	$30			; DROP 
_B436 
_B437 
; toolsrc/ed.pla: 1345:             fin
_B430 
; toolsrc/ed.pla: 1346:          else
	!BYTE	$50			; BRNCH	_B428
	!WORD	_B428-*
_B427 
; toolsrc/ed.pla: 1347:             txtlinbuf=>[cursrow + 1] = txtlinbuf=>[cursrow]
; toolsrc/ed.pla: 1348:             txtlinbuf=>[cursrow]     = @nullstr
; toolsrc/ed.pla: 1349:         fin
	!BYTE	$6A			; LAW	_D048+0
_F640 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F641 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D048+0
_F642 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D058+0
_F643 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$9E			; IDXW
	!BYTE	$72			; SW
	!BYTE	$26			; LA	_D036+0
_F644 	!WORD	_D036+0		
	!BYTE	$6A			; LAW	_D048+0
_F645 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F646 	!WORD	_D058+0		
	!BYTE	$72			; SW
_B428 
; toolsrc/ed.pla: 1350:     fin
_B425 
_B426 
; toolsrc/ed.pla: 1351: end
	!BYTE	$5A,$52			; LEAVE	82
; toolsrc/ed.pla: 1352: def editkey(key)
					; key -> [0]
_C060 					; editkey()
; toolsrc/ed.pla: 1353:     if key >= keyspace or key == keydelete or key == keyctrld or key == keyctrlr
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/ed.pla: 1354:         return TRUE
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$48			; ISGE
	!BYTE	$AE			; BROR	_B443
	!WORD	_B443-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B444
	!WORD	_B444-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$84			; CB	132
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B445
	!WORD	_B445-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$92			; CB	146
	!BYTE	$40			; ISEQ
_B445 
_B444 
_B443 
	!BYTE	$4C			; BRFLS	_B446
	!WORD	_B446-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 1355:     fin
_B446 
_B447 
; toolsrc/ed.pla: 1356:     return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/ed.pla: 1357: end
; toolsrc/ed.pla: 1358: def editline(key)
					; key -> [0]
_C061 					; editline()
; toolsrc/ed.pla: 1359:     word undoline
					; undoline -> [2]
; toolsrc/ed.pla: 1360:     byte undopos, localchange, editstr[], editlen, editchars[MAXLNLEN+1]
					; undopos -> [4]
					; localchange -> [5]
					; editstr -> [6]
					; editlen -> [6]
					; editchars -> [7]
; toolsrc/ed.pla: 1361: 
; toolsrc/ed.pla: 1362:     if (editkey(key))
	!BYTE	$58,$57,$01		; ENTER	87,1
; toolsrc/ed.pla: 1363:         undopos  = curscol
; toolsrc/ed.pla: 1364:         undoline = txtlinbuf=>[cursrow]
; toolsrc/ed.pla: 1365:         editlen = MAXLNLEN
; toolsrc/ed.pla: 1366:         memset(@editchars, $A0A0, MAXLNLEN)
; toolsrc/ed.pla: 1367:         memcpy(@editchars, undoline + 1, ^undoline)
; toolsrc/ed.pla: 1368:         txtlinbuf=>[cursrow] = @editstr
; toolsrc/ed.pla: 1369:         localchange = FALSE
; toolsrc/ed.pla: 1370:         repeat
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C060
_F647 	!WORD	_C060		
	!BYTE	$4C			; BRFLS	_B448
	!WORD	_B448-*
	!BYTE	$6A			; LAW	_D054+0
_F648 	!WORD	_D054+0		
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$6A			; LAW	_D048+0
_F649 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F650 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$2A,$4F			; CB	79
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$2C,$A0,$A0		; CW	41120
	!BYTE	$2A,$4F			; CB	79
	!BYTE	$54			; CALL	_X017
_F651 	!WORD	0		
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F652 	!WORD	0		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$6A			; LAW	_D048+0
_F653 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F654 	!WORD	_D058+0		
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$74,$05			; SLB	[5]
_B451 
; toolsrc/ed.pla: 1371:             when key
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$52			; SEL
	!WORD	_B454-*
; toolsrc/ed.pla: 1372:                 is keyctrld
_B455 
; toolsrc/ed.pla: 1373:                     memcpy(@editchars[curscol], @editchars[curscol + 1], MAXLNLEN - 1 - curscol)
; toolsrc/ed.pla: 1374:                     editchars[MAXLNLEN - 1] = keyspace
; toolsrc/ed.pla: 1375:                     cursoff
; toolsrc/ed.pla: 1376:                     drawrow(cursy, scrnleft, @editstr)
; toolsrc/ed.pla: 1377:                     curson
; toolsrc/ed.pla: 1378:                     localchange = TRUE
; toolsrc/ed.pla: 1379:                     break
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$B6			; ADDAW	_D054+0
_F655 	!WORD	_D054+0		
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$6A			; LAW	_D054+0
_F656 	!WORD	_D054+0		
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$2A,$4E			; CB	78
	!BYTE	$6A			; LAW	_D054+0
_F657 	!WORD	_D054+0		
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X018
_F658 	!WORD	0		
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$74,$55			; SLB	[85]
	!BYTE	$54			; CALL	_C022
_F659 	!WORD	_C022		
	!BYTE	$6A			; LAW	_D052+0
_F660 	!WORD	_D052+0		
	!BYTE	$6A			; LAW	_D053+0
_F661 	!WORD	_D053+0		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_C019
_F662 	!WORD	_C019		
	!BYTE	$54			; CALL	_C023
_F663 	!WORD	_C023		
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B453
	!WORD	_B453-*
; toolsrc/ed.pla: 1380:                 is keyctrlr
_B456 
; toolsrc/ed.pla: 1381:                     memset(@editchars, $A0A0, MAXLNLEN)
; toolsrc/ed.pla: 1382:                     memcpy(@editchars, undoline + 1, ^undoline)
; toolsrc/ed.pla: 1383:                     cursoff
; toolsrc/ed.pla: 1384:                     if curshpos(undopos)
; toolsrc/ed.pla: 1385:                         drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 1386:                     else
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$2C,$A0,$A0		; CW	41120
	!BYTE	$2A,$4F			; CB	79
	!BYTE	$54			; CALL	_X017
_F664 	!WORD	0		
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8C			; INCR
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F665 	!WORD	0		
	!BYTE	$54			; CALL	_C022
_F666 	!WORD	_C022		
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$54			; CALL	_C026
_F667 	!WORD	_C026		
	!BYTE	$4C			; BRFLS	_B457
	!WORD	_B457-*
	!BYTE	$6A			; LAW	_D060+0
_F668 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F669 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F670 	!WORD	_C021		
	!BYTE	$50			; BRNCH	_B458
	!WORD	_B458-*
_B457 
; toolsrc/ed.pla: 1387:                         drawrow(cursy, scrnleft, @editstr)
; toolsrc/ed.pla: 1388:                     fin
	!BYTE	$6A			; LAW	_D052+0
_F671 	!WORD	_D052+0		
	!BYTE	$6A			; LAW	_D053+0
_F672 	!WORD	_D053+0		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_C019
_F673 	!WORD	_C019		
_B458 
; toolsrc/ed.pla: 1389:                     curson
; toolsrc/ed.pla: 1390:                     localchange = FALSE
; toolsrc/ed.pla: 1391:                     break
	!BYTE	$54			; CALL	_C023
_F674 	!WORD	_C023		
	!BYTE	$00			; CN	0
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B453
	!WORD	_B453-*
; toolsrc/ed.pla: 1392:                 is keydelete
_B459 
; toolsrc/ed.pla: 1393:                     if curscol > 0
; toolsrc/ed.pla: 1394:                         memcpy(@editchars[curscol - 1], @editchars[curscol], MAXLNLEN - curscol)
; toolsrc/ed.pla: 1395:                         editchars[MAXLNLEN - 1] = keyspace
; toolsrc/ed.pla: 1396:                         cursoff
; toolsrc/ed.pla: 1397:                         if curshpos(curscol - 1)
; toolsrc/ed.pla: 1398:                             drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 1399:                         else
	!BYTE	$6A			; LAW	_D054+0
_F675 	!WORD	_D054+0		
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B460
	!WORD	_B460-*
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$6A			; LAW	_D054+0
_F676 	!WORD	_D054+0		
	!BYTE	$8E			; DECR
	!BYTE	$82			; ADD 
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$B6			; ADDAW	_D054+0
_F677 	!WORD	_D054+0		
	!BYTE	$2A,$4F			; CB	79
	!BYTE	$6A			; LAW	_D054+0
_F678 	!WORD	_D054+0		
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X018
_F679 	!WORD	0		
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$74,$55			; SLB	[85]
	!BYTE	$54			; CALL	_C022
_F680 	!WORD	_C022		
	!BYTE	$6A			; LAW	_D054+0
_F681 	!WORD	_D054+0		
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C026
_F682 	!WORD	_C026		
	!BYTE	$4C			; BRFLS	_B462
	!WORD	_B462-*
	!BYTE	$6A			; LAW	_D060+0
_F683 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F684 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F685 	!WORD	_C021		
	!BYTE	$50			; BRNCH	_B463
	!WORD	_B463-*
_B462 
; toolsrc/ed.pla: 1400:                             drawrow(cursy, scrnleft, @editstr)
; toolsrc/ed.pla: 1401:                         fin
	!BYTE	$6A			; LAW	_D052+0
_F686 	!WORD	_D052+0		
	!BYTE	$6A			; LAW	_D053+0
_F687 	!WORD	_D053+0		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_C019
_F688 	!WORD	_C019		
_B463 
; toolsrc/ed.pla: 1402:                         curson
; toolsrc/ed.pla: 1403:                         localchange = TRUE
; toolsrc/ed.pla: 1404:                     fin
	!BYTE	$54			; CALL	_C023
_F689 	!WORD	_C023		
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$05			; SLB	[5]
_B460 
_B461 
; toolsrc/ed.pla: 1405:                     break
	!BYTE	$50			; BRNCH	_B453
	!WORD	_B453-*
; toolsrc/ed.pla: 1406:                 otherwise
_B454 
	!BYTE	$03			; CASEBLOCK
	!WORD	$0084
	!WORD	_B455-*
	!WORD	$0092
	!WORD	_B456-*
	!WORD	$00FF
	!WORD	_B459-*
; toolsrc/ed.pla: 1407:                     if flags & insmode
; toolsrc/ed.pla: 1408:                         if editchars[MAXLNLEN - 1] == keyspace
; toolsrc/ed.pla: 1409:                             memcpy(@editchars[curscol+1], @editchars[curscol], MAXLNLEN - 1 - curscol)
; toolsrc/ed.pla: 1410:                         else
	!BYTE	$68			; LAB	_D040+0
_F690 	!WORD	_D040+0		
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B464
	!WORD	_B464-*
	!BYTE	$64,$55			; LLB	[85]
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$24			; BRNE	_B466
	!WORD	_B466-*
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$6A			; LAW	_D054+0
_F691 	!WORD	_D054+0		
	!BYTE	$8C			; INCR
	!BYTE	$82			; ADD 
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$B6			; ADDAW	_D054+0
_F692 	!WORD	_D054+0		
	!BYTE	$2A,$4E			; CB	78
	!BYTE	$6A			; LAW	_D054+0
_F693 	!WORD	_D054+0		
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X018
_F694 	!WORD	0		
	!BYTE	$50			; BRNCH	_B467
	!WORD	_B467-*
_B466 
; toolsrc/ed.pla: 1411:                             bell
; toolsrc/ed.pla: 1412:                             break
	!BYTE	$54			; CALL	_C000
_F695 	!WORD	_C000		
	!BYTE	$50			; BRNCH	_B453
	!WORD	_B453-*
; toolsrc/ed.pla: 1413:                         fin
_B467 
; toolsrc/ed.pla: 1414:                     fin
_B464 
_B465 
; toolsrc/ed.pla: 1415:                     editchars[curscol] = caseconv(key)
; toolsrc/ed.pla: 1416:                     cursoff
; toolsrc/ed.pla: 1417:                     if curshpos(curscol + 1)
; toolsrc/ed.pla: 1418:                         drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 1419:                     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C009
_F696 	!WORD	_C009		
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$B6			; ADDAW	_D054+0
_F697 	!WORD	_D054+0		
	!BYTE	$70			; SB
	!BYTE	$54			; CALL	_C022
_F698 	!WORD	_C022		
	!BYTE	$6A			; LAW	_D054+0
_F699 	!WORD	_D054+0		
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_C026
_F700 	!WORD	_C026		
	!BYTE	$4C			; BRFLS	_B468
	!WORD	_B468-*
	!BYTE	$6A			; LAW	_D060+0
_F701 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F702 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F703 	!WORD	_C021		
	!BYTE	$50			; BRNCH	_B469
	!WORD	_B469-*
_B468 
; toolsrc/ed.pla: 1420:                         drawrow(cursy, scrnleft, @editstr)
; toolsrc/ed.pla: 1421:                     fin
	!BYTE	$6A			; LAW	_D052+0
_F704 	!WORD	_D052+0		
	!BYTE	$6A			; LAW	_D053+0
_F705 	!WORD	_D053+0		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_C019
_F706 	!WORD	_C019		
_B469 
; toolsrc/ed.pla: 1422:                     curson
; toolsrc/ed.pla: 1423:                     localchange = TRUE
; toolsrc/ed.pla: 1424:                     break
	!BYTE	$54			; CALL	_C023
_F707 	!WORD	_C023		
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B453
	!WORD	_B453-*
; toolsrc/ed.pla: 1425:             wend
_B453 
; toolsrc/ed.pla: 1426:             key = keyin()
; toolsrc/ed.pla: 1427:         until not editkey(key)
	!BYTE	$6A			; LAW	_D057+0
_F708 	!WORD	_D057+0		
	!BYTE	$56			; ICAL
	!BYTE	$76,$00			; SLW	[0]
_B452 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C060
_F709 	!WORD	_C060		
	!BYTE	$4E			; BRTRU	_B451
	!WORD	_B451-*
_B450 
; toolsrc/ed.pla: 1428:         if localchange
; toolsrc/ed.pla: 1429:             flags = flags | changed
; toolsrc/ed.pla: 1430:             delstr(undoline)
; toolsrc/ed.pla: 1431:             txtlinbuf=>[cursrow] = newstr(@editstr)
; toolsrc/ed.pla: 1432:         else
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$4C			; BRFLS	_B470
	!WORD	_B470-*
	!BYTE	$68			; LAB	_D040+0
_F710 	!WORD	_D040+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D040+0
_F711 	!WORD	_D040+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C006
_F712 	!WORD	_C006		
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_C007
_F713 	!WORD	_C007		
	!BYTE	$6A			; LAW	_D048+0
_F714 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F715 	!WORD	_D058+0		
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B471
	!WORD	_B471-*
_B470 
; toolsrc/ed.pla: 1433:             txtlinbuf=>[cursrow] = undoline
; toolsrc/ed.pla: 1434:         fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D048+0
_F716 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F717 	!WORD	_D058+0		
	!BYTE	$72			; SW
_B471 
; toolsrc/ed.pla: 1435:     fin
_B448 
_B449 
; toolsrc/ed.pla: 1436:     return key
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$57			; LEAVE	87
; toolsrc/ed.pla: 1437: end
; toolsrc/ed.pla: 1438: def editmode#0
_C062 					; editmode()
; toolsrc/ed.pla: 1439:     if MACHID == $F2 // Apple 3
; toolsrc/ed.pla: 1440:         dev_control(cmdsys.devcons, 11, @a3noecho)
; toolsrc/ed.pla: 1441:     fin
	!BYTE	$68			; LAB	_X001+0
_F718 	!WORD	0+0		
	!BYTE	$2A,$F2			; CB	242
	!BYTE	$24			; BRNE	_B472
	!WORD	_B472-*
	!BYTE	$68			; LAB	_X000+20
_F719 	!WORD	0+20		
	!BYTE	$16			; CN	11
	!BYTE	$26			; LA	_D063+0
_F720 	!WORD	_D063+0		
	!BYTE	$54			; CALL	_C040
_F721 	!WORD	_C040		
	!BYTE	$30			; DROP 
_B472 
_B473 
; toolsrc/ed.pla: 1442:     repeat
_B475 
; toolsrc/ed.pla: 1443:         when editline(keyin())
	!BYTE	$6A			; LAW	_D057+0
_F722 	!WORD	_D057+0		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_C061
_F723 	!WORD	_C061		
	!BYTE	$52			; SEL
	!WORD	_B478-*
; toolsrc/ed.pla: 1444:             is keyarrowup
_B479 
; toolsrc/ed.pla: 1445:                 cursup; break
	!BYTE	$54			; CALL	_C030
_F724 	!WORD	_C030		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1446:             is keyarrowdown
_B480 
; toolsrc/ed.pla: 1447:                 cursdown; break
	!BYTE	$54			; CALL	_C032
_F725 	!WORD	_C032		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1448:             is keyarrowleft
_B481 
; toolsrc/ed.pla: 1449:                 cursleft; break
	!BYTE	$54			; CALL	_C034
_F726 	!WORD	_C034		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1450:             is keyarrowright
_B482 
; toolsrc/ed.pla: 1451:                 cursright; break
	!BYTE	$54			; CALL	_C036
_F727 	!WORD	_C036		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1452:             is keyctrlw
_B483 
; toolsrc/ed.pla: 1453:                 pgup; break
	!BYTE	$54			; CALL	_C031
_F728 	!WORD	_C031		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1454:             is keyctrlz
_B484 
; toolsrc/ed.pla: 1455:                 pgdown; break
	!BYTE	$54			; CALL	_C033
_F729 	!WORD	_C033		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1456:             is keyctrla
_B485 
; toolsrc/ed.pla: 1457:                 pgleft; break
	!BYTE	$54			; CALL	_C035
_F730 	!WORD	_C035		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1458:             is keyctrls
_B486 
; toolsrc/ed.pla: 1459:                 pgright; break
	!BYTE	$54			; CALL	_C037
_F731 	!WORD	_C037		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1460:             is keyctrlq
_B487 
; toolsrc/ed.pla: 1461:                 curshome; break
	!BYTE	$54			; CALL	_C028
_F732 	!WORD	_C028		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1462:             is keyctrle
_B488 
; toolsrc/ed.pla: 1463:                 cursend; break
	!BYTE	$54			; CALL	_C029
_F733 	!WORD	_C029		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1464:             is keyctrlb
_B489 
; toolsrc/ed.pla: 1465:                 beginsel; break
	!BYTE	$54			; CALL	_C050
_F734 	!WORD	_C050		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1466:             is keyctrlc
_B490 
; toolsrc/ed.pla: 1467:                 copysel; break
	!BYTE	$54			; CALL	_C051
_F735 	!WORD	_C051		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1468:             is keyctrlx
_B491 
; toolsrc/ed.pla: 1469:                 cutsel; break
	!BYTE	$54			; CALL	_C052
_F736 	!WORD	_C052		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1470:             is keyctrlv
_B492 
; toolsrc/ed.pla: 1471:                 pastesel; break
	!BYTE	$54			; CALL	_C053
_F737 	!WORD	_C053		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1472:             is keyctrlf
_B493 
; toolsrc/ed.pla: 1473:                 if cursrow == (numlines - 1)
; toolsrc/ed.pla: 1474:                     if numlines < MAXLINES
; toolsrc/ed.pla: 1475:                         numlines++
	!BYTE	$6A			; LAW	_D058+0
_F738 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D042+0
_F739 	!WORD	_D042+0		
	!BYTE	$8E			; DECR
	!BYTE	$24			; BRNE	_B494
	!WORD	_B494-*
	!BYTE	$6A			; LAW	_D042+0
_F740 	!WORD	_D042+0		
	!BYTE	$2C,$E7,$03		; CW	999
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B496
	!WORD	_B496-*
	!BYTE	$6A			; LAW	_D042+0
_F741 	!WORD	_D042+0		
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1476:                         cursdown
; toolsrc/ed.pla: 1477:                         flags = flags | changed
; toolsrc/ed.pla: 1478:                         drawgutter(scrntop, scrnleft)
; toolsrc/ed.pla: 1479:                     else
	!BYTE	$7A			; SAW	_D042+0
_F742 	!WORD	_D042+0		
	!BYTE	$54			; CALL	_C032
_F743 	!WORD	_C032		
	!BYTE	$68			; LAB	_D040+0
_F744 	!WORD	_D040+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D040+0
_F745 	!WORD	_D040+0		
	!BYTE	$6A			; LAW	_D060+0
_F746 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F747 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C020
_F748 	!WORD	_C020		
	!BYTE	$50			; BRNCH	_B497
	!WORD	_B497-*
_B496 
; toolsrc/ed.pla: 1480:                         bell
; toolsrc/ed.pla: 1481:                     fin
	!BYTE	$54			; CALL	_C000
_F749 	!WORD	_C000		
_B497 
; toolsrc/ed.pla: 1482:                     break
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1483:                 fin
_B494 
_B495 
; toolsrc/ed.pla: 1484:                 cursdown
; toolsrc/ed.pla: 1485:             is keyctrlo
	!BYTE	$54			; CALL	_C032
_F750 	!WORD	_C032		
_B498 
; toolsrc/ed.pla: 1486:                 openline(cursrow)
; toolsrc/ed.pla: 1487:                 if cursrow
; toolsrc/ed.pla: 1488:                     autoindent(txtlinbuf=>[cursrow - 1])
; toolsrc/ed.pla: 1489:                 else
	!BYTE	$6A			; LAW	_D058+0
_F751 	!WORD	_D058+0		
	!BYTE	$54			; CALL	_C057
_F752 	!WORD	_C057		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D058+0
_F753 	!WORD	_D058+0		
	!BYTE	$4C			; BRFLS	_B499
	!WORD	_B499-*
	!BYTE	$6A			; LAW	_D048+0
_F754 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D058+0
_F755 	!WORD	_D058+0		
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C056
_F756 	!WORD	_C056		
	!BYTE	$50			; BRNCH	_B500
	!WORD	_B500-*
_B499 
; toolsrc/ed.pla: 1490:                     curshpos(0)
; toolsrc/ed.pla: 1491:                 fin
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C026
_F757 	!WORD	_C026		
	!BYTE	$30			; DROP 
_B500 
; toolsrc/ed.pla: 1492:                 redraw
; toolsrc/ed.pla: 1493:                 break
	!BYTE	$54			; CALL	_C025
_F758 	!WORD	_C025		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1494:             is keyenter
_B501 
; toolsrc/ed.pla: 1495:                 if flags & insmode
; toolsrc/ed.pla: 1496:                     splitline
; toolsrc/ed.pla: 1497:                 else
	!BYTE	$68			; LAB	_D040+0
_F759 	!WORD	_D040+0		
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B502
	!WORD	_B502-*
	!BYTE	$54			; CALL	_C059
_F760 	!WORD	_C059		
	!BYTE	$50			; BRNCH	_B503
	!WORD	_B503-*
_B502 
; toolsrc/ed.pla: 1498:                     openline(cursrow + 1)
; toolsrc/ed.pla: 1499:                 fin
	!BYTE	$6A			; LAW	_D058+0
_F761 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_C057
_F762 	!WORD	_C057		
	!BYTE	$30			; DROP 
_B503 
; toolsrc/ed.pla: 1500:                 autoindent(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1501:                 cursvpos(cursrow + 1)
; toolsrc/ed.pla: 1502:                 redraw
; toolsrc/ed.pla: 1503:                 break
	!BYTE	$6A			; LAW	_D048+0
_F763 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F764 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C056
_F765 	!WORD	_C056		
	!BYTE	$6A			; LAW	_D058+0
_F766 	!WORD	_D058+0		
	!BYTE	$8C			; INCR
	!BYTE	$54			; CALL	_C027
_F767 	!WORD	_C027		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C025
_F768 	!WORD	_C025		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1504:             is keyctrlt
_B504 
; toolsrc/ed.pla: 1505:                 joinline
; toolsrc/ed.pla: 1506:                 redraw
; toolsrc/ed.pla: 1507:                 break
	!BYTE	$54			; CALL	_C058
_F769 	!WORD	_C058		
	!BYTE	$54			; CALL	_C025
_F770 	!WORD	_C025		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1508:             is keytab
_B505 
; toolsrc/ed.pla: 1509:                 if flags & insmode
; toolsrc/ed.pla: 1510:                     indentsel
; toolsrc/ed.pla: 1511:                     cursoff
; toolsrc/ed.pla: 1512:                     if not ^(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1513:                         curshpos((curscol + 2) & $FE)
; toolsrc/ed.pla: 1514:                     else
	!BYTE	$68			; LAB	_D040+0
_F771 	!WORD	_D040+0		
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B506
	!WORD	_B506-*
	!BYTE	$54			; CALL	_C054
_F772 	!WORD	_C054		
	!BYTE	$54			; CALL	_C022
_F773 	!WORD	_C022		
	!BYTE	$6A			; LAW	_D048+0
_F774 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F775 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B508
	!WORD	_B508-*
	!BYTE	$6A			; LAW	_D054+0
_F776 	!WORD	_D054+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$3C,$FE			; ANDI	254
	!BYTE	$54			; CALL	_C026
_F777 	!WORD	_C026		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B509
	!WORD	_B509-*
_B508 
; toolsrc/ed.pla: 1515:                         autoindent(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1516:                     fin
	!BYTE	$6A			; LAW	_D048+0
_F778 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F779 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C056
_F780 	!WORD	_C056		
_B509 
; toolsrc/ed.pla: 1517:                     curson
; toolsrc/ed.pla: 1518:                     break
	!BYTE	$54			; CALL	_C023
_F781 	!WORD	_C023		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1519:                 fin
_B506 
_B507 
; toolsrc/ed.pla: 1520:            is keydetab
_B510 
; toolsrc/ed.pla: 1521:                 undentsel
; toolsrc/ed.pla: 1522:                 cursoff
; toolsrc/ed.pla: 1523:                 if not ^(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1524:                     curshpos((curscol - 2) & $FFFE)
; toolsrc/ed.pla: 1525:                 else
	!BYTE	$54			; CALL	_C055
_F782 	!WORD	_C055		
	!BYTE	$54			; CALL	_C022
_F783 	!WORD	_C022		
	!BYTE	$6A			; LAW	_D048+0
_F784 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F785 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B511
	!WORD	_B511-*
	!BYTE	$6A			; LAW	_D054+0
_F786 	!WORD	_D054+0		
	!BYTE	$3A,$02			; SUBI	2
	!BYTE	$5E,$FE			; CFFB	65534
	!BYTE	$94			; AND 
	!BYTE	$54			; CALL	_C026
_F787 	!WORD	_C026		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B512
	!WORD	_B512-*
_B511 
; toolsrc/ed.pla: 1526:                     autoindent(txtlinbuf=>[cursrow])
; toolsrc/ed.pla: 1527:                 fin
	!BYTE	$6A			; LAW	_D048+0
_F788 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D058+0
_F789 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C056
_F790 	!WORD	_C056		
_B512 
; toolsrc/ed.pla: 1528:                 curson
; toolsrc/ed.pla: 1529:                 break
	!BYTE	$54			; CALL	_C023
_F791 	!WORD	_C023		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1530:             is keyctrly
_B513 
; toolsrc/ed.pla: 1531:                 flags   = flags ^ insmode
; toolsrc/ed.pla: 1532:                 curschr = flags & insmode ?? '+' :: ' '
; toolsrc/ed.pla: 1533:                 break
	!BYTE	$68			; LAB	_D040+0
_F792 	!WORD	_D040+0		
	!BYTE	$04			; CN	2
	!BYTE	$98			; XOR
	!BYTE	$7C			; DAB	_D040+0
_F793 	!WORD	_D040+0		
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B514
	!WORD	_B514-*
	!BYTE	$2A,$2B			; CB	43
	!BYTE	$50			; BRNCH	_B515
	!WORD	_B515-*
_B514 
	!BYTE	$2A,$20			; CB	32
_B515 
	!BYTE	$78			; SAB	_D056+0
_F794 	!WORD	_D056+0		
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
; toolsrc/ed.pla: 1534:             is keyescape
_B516 
; toolsrc/ed.pla: 1535:                 if MACHID == $F2 // Apple 3
; toolsrc/ed.pla: 1536:                     dev_control(cmdsys.devcons, 11, @a3echo)
; toolsrc/ed.pla: 1537:                 fin
	!BYTE	$68			; LAB	_X001+0
_F795 	!WORD	0+0		
	!BYTE	$2A,$F2			; CB	242
	!BYTE	$24			; BRNE	_B517
	!WORD	_B517-*
	!BYTE	$68			; LAB	_X000+20
_F796 	!WORD	0+20		
	!BYTE	$16			; CN	11
	!BYTE	$26			; LA	_D062+0
_F797 	!WORD	_D062+0		
	!BYTE	$54			; CALL	_C040
_F798 	!WORD	_C040		
	!BYTE	$30			; DROP 
_B517 
_B518 
; toolsrc/ed.pla: 1538:                 cursoff
; toolsrc/ed.pla: 1539:                 cmdmode
; toolsrc/ed.pla: 1540:                 if not exit
; toolsrc/ed.pla: 1541:                     if MACHID == $F2 // Apple 3
; toolsrc/ed.pla: 1542:                         dev_control(cmdsys.devcons, 11, @a3noecho)
; toolsrc/ed.pla: 1543:                     fin
	!BYTE	$54			; CALL	_C022
_F799 	!WORD	_C022		
	!BYTE	$54			; CALL	_P000
_F800 	!WORD	_P000		
	!BYTE	$68			; LAB	_D039+0
_F801 	!WORD	_D039+0		
	!BYTE	$4E			; BRTRU	_B519
	!WORD	_B519-*
	!BYTE	$68			; LAB	_X001+0
_F802 	!WORD	0+0		
	!BYTE	$2A,$F2			; CB	242
	!BYTE	$24			; BRNE	_B521
	!WORD	_B521-*
	!BYTE	$68			; LAB	_X000+20
_F803 	!WORD	0+20		
	!BYTE	$16			; CN	11
	!BYTE	$26			; LA	_D063+0
_F804 	!WORD	_D063+0		
	!BYTE	$54			; CALL	_C040
_F805 	!WORD	_C040		
	!BYTE	$30			; DROP 
_B521 
_B522 
; toolsrc/ed.pla: 1544:                     redraw
; toolsrc/ed.pla: 1545:                 fin
	!BYTE	$54			; CALL	_C025
_F806 	!WORD	_C025		
_B519 
_B520 
; toolsrc/ed.pla: 1546:         wend
	!BYTE	$50			; BRNCH	_B477
	!WORD	_B477-*
_B478 
	!BYTE	$16			; CASEBLOCK
	!WORD	$0081
	!WORD	_B485-*
	!WORD	$0082
	!WORD	_B489-*
	!WORD	$0083
	!WORD	_B490-*
	!WORD	$0085
	!WORD	_B488-*
	!WORD	$0086
	!WORD	_B493-*
	!WORD	$0088
	!WORD	_B481-*
	!WORD	$0089
	!WORD	_B505-*
	!WORD	$008A
	!WORD	_B480-*
	!WORD	$008B
	!WORD	_B479-*
	!WORD	$008D
	!WORD	_B501-*
	!WORD	$008F
	!WORD	_B498-*
	!WORD	$0091
	!WORD	_B487-*
	!WORD	$0093
	!WORD	_B486-*
	!WORD	$0094
	!WORD	_B504-*
	!WORD	$0095
	!WORD	_B482-*
	!WORD	$0096
	!WORD	_B492-*
	!WORD	$0097
	!WORD	_B483-*
	!WORD	$0098
	!WORD	_B491-*
	!WORD	$0099
	!WORD	_B513-*
	!WORD	$009A
	!WORD	_B484-*
	!WORD	$009B
	!WORD	_B516-*
	!WORD	$009D
	!WORD	_B510-*
_B477 
; toolsrc/ed.pla: 1547:     until exit
_B476 
	!BYTE	$68			; LAB	_D039+0
_F807 	!WORD	_D039+0		
	!BYTE	$4C			; BRFLS	_B475
	!WORD	_B475-*
_B474 
; toolsrc/ed.pla: 1548: end
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 1549: //
; toolsrc/ed.pla: 1550: // Command mode
; toolsrc/ed.pla: 1551: //
; toolsrc/ed.pla: 1552: def prfiles(optpath)
					; optpath -> [0]
_C063 					; prfiles()
; toolsrc/ed.pla: 1553:     byte path[64]
					; path -> [2]
; toolsrc/ed.pla: 1554:     byte refnum
					; refnum -> [66]
; toolsrc/ed.pla: 1555:     byte firstblk
					; firstblk -> [67]
; toolsrc/ed.pla: 1556:     byte entrylen, entriesblk
					; entrylen -> [68]
					; entriesblk -> [69]
; toolsrc/ed.pla: 1557:     byte i, type, len
					; i -> [70]
					; type -> [71]
					; len -> [72]
; toolsrc/ed.pla: 1558:     word databuff, entry
					; databuff -> [73]
					; entry -> [75]
; toolsrc/ed.pla: 1559: 
; toolsrc/ed.pla: 1560:     if ^optpath
	!BYTE	$58,$4D,$01		; ENTER	77,1
; toolsrc/ed.pla: 1561:         strstripcpy(@path, optpath)
; toolsrc/ed.pla: 1562:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B523
	!WORD	_B523-*
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C005
_F808 	!WORD	_C005		
	!BYTE	$50			; BRNCH	_B524
	!WORD	_B524-*
_B523 
; toolsrc/ed.pla: 1563:         fileio:getpfx(@path)
; toolsrc/ed.pla: 1564:         puts(@path)
; toolsrc/ed.pla: 1565:         putln
; toolsrc/ed.pla: 1566:     fin
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$6A			; LAW	_X031+0
_F809 	!WORD	0+0		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$54			; CALL	_X004
_F810 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F811 	!WORD	0		
_B524 
; toolsrc/ed.pla: 1567:     databuff = heapalloc(512)
; toolsrc/ed.pla: 1568:     refnum = fileio:open(@path)
; toolsrc/ed.pla: 1569:     if perr
; toolsrc/ed.pla: 1570:         return perr
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$54			; CALL	_X014
_F812 	!WORD	0		
	!BYTE	$76,$49			; SLW	[73]
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$6A			; LAW	_X031+14
_F813 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$74,$42			; SLB	[66]
	!BYTE	$68			; LAB	_X032+0
_F814 	!WORD	0+0		
	!BYTE	$4C			; BRFLS	_B525
	!WORD	_B525-*
	!BYTE	$68			; LAB	_X032+0
_F815 	!WORD	0+0		
	!BYTE	$5A,$4D			; LEAVE	77
; toolsrc/ed.pla: 1571:     fin
_B525 
_B526 
; toolsrc/ed.pla: 1572:     firstblk = 1
; toolsrc/ed.pla: 1573:     while fileio:read(refnum, databuff, 512) == 512
	!BYTE	$02			; CN	1
	!BYTE	$74,$43			; SLB	[67]
	!BYTE	$50			; BRNCH	_B529
	!WORD	_B529-*
_B527 
; toolsrc/ed.pla: 1574:         entry = databuff + 4
; toolsrc/ed.pla: 1575:         if firstblk
; toolsrc/ed.pla: 1576:             entrylen   = databuff->$23
; toolsrc/ed.pla: 1577:             entriesblk = databuff->$24
; toolsrc/ed.pla: 1578:             entry      = entry + entrylen
; toolsrc/ed.pla: 1579:         fin
	!BYTE	$66,$49			; LLW	[73]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$76,$4B			; SLW	[75]
	!BYTE	$64,$43			; LLB	[67]
	!BYTE	$4C			; BRFLS	_B530
	!WORD	_B530-*
	!BYTE	$66,$49			; LLW	[73]
	!BYTE	$38,$23			; ADDI	35
	!BYTE	$60			; LB
	!BYTE	$74,$44			; SLB	[68]
	!BYTE	$66,$49			; LLW	[73]
	!BYTE	$38,$24			; ADDI	36
	!BYTE	$60			; LB
	!BYTE	$74,$45			; SLB	[69]
	!BYTE	$66,$4B			; LLW	[75]
	!BYTE	$B0,$44			; ADDLB	[68]
	!BYTE	$76,$4B			; SLW	[75]
_B530 
_B531 
; toolsrc/ed.pla: 1580:         for i = firstblk to entriesblk
	!BYTE	$64,$45			; LLB	[69]
	!BYTE	$64,$43			; LLB	[67]
	!BYTE	$A0			; BRGT	_B532
	!WORD	_B532-*
_B533 
	!BYTE	$6C,$46			; DLB	[70]
; toolsrc/ed.pla: 1581:             type = ^entry
; toolsrc/ed.pla: 1582:             if type <> 0
; toolsrc/ed.pla: 1583:                 len = type & $0F
; toolsrc/ed.pla: 1584:                 ^entry = len
; toolsrc/ed.pla: 1585:                 puts(entry)
; toolsrc/ed.pla: 1586:                 if type & $F0 == $D0 // Is it a directory?
; toolsrc/ed.pla: 1587:                     putc('/')
; toolsrc/ed.pla: 1588:                     len++
	!BYTE	$66,$4B			; LLW	[75]
	!BYTE	$60			; LB
	!BYTE	$6C,$47			; DLB	[71]
	!BYTE	$4C			; BRFLS	_B535
	!WORD	_B535-*
	!BYTE	$64,$47			; LLB	[71]
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$6C,$48			; DLB	[72]
	!BYTE	$66,$4B			; LLW	[75]
	!BYTE	$70			; SB
	!BYTE	$66,$4B			; LLW	[75]
	!BYTE	$54			; CALL	_X004
_F816 	!WORD	0		
	!BYTE	$64,$47			; LLB	[71]
	!BYTE	$3C,$F0			; ANDI	240
	!BYTE	$2A,$D0			; CB	208
	!BYTE	$24			; BRNE	_B537
	!WORD	_B537-*
	!BYTE	$2A,$2F			; CB	47
	!BYTE	$54			; CALL	_X002
_F817 	!WORD	0		
	!BYTE	$64,$48			; LLB	[72]
	!BYTE	$8C			; INCR
; toolsrc/ed.pla: 1589:                 fin
	!BYTE	$74,$48			; SLB	[72]
_B537 
_B538 
; toolsrc/ed.pla: 1590:                 for len = 20 - len downto 1
	!BYTE	$02			; CN	1
	!BYTE	$2A,$14			; CB	20
	!BYTE	$64,$48			; LLB	[72]
	!BYTE	$84			; SUB 
	!BYTE	$A2			; BRLT	_B539
	!WORD	_B539-*
_B540 
	!BYTE	$6C,$48			; DLB	[72]
; toolsrc/ed.pla: 1591:                     putc(' ')
; toolsrc/ed.pla: 1592:                 next
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_X002
_F818 	!WORD	0		
_B541 
	!BYTE	$A8			; DECBRGE	_B540
	!WORD	_B540-*
_B539 
	!BYTE	$74,$48			; SLB	[72]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1593:             fin
_B535 
_B536 
; toolsrc/ed.pla: 1594:             entry = entry + entrylen
; toolsrc/ed.pla: 1595:         next
	!BYTE	$66,$4B			; LLW	[75]
	!BYTE	$B0,$44			; ADDLB	[68]
	!BYTE	$76,$4B			; SLW	[75]
_B534 
	!BYTE	$A4			; INCBRLE	_B533
	!WORD	_B533-*
_B532 
	!BYTE	$74,$46			; SLB	[70]
	!BYTE	$30			; DROP 
; toolsrc/ed.pla: 1596:         firstblk = 0
; toolsrc/ed.pla: 1597:     loop
	!BYTE	$00			; CN	0
	!BYTE	$74,$43			; SLB	[67]
_B529 
	!BYTE	$64,$42			; LLB	[66]
	!BYTE	$66,$49			; LLW	[73]
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$6A			; LAW	_X031+18
_F819 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$22			; BREQ	_B527
	!WORD	_B527-*
_B528 
; toolsrc/ed.pla: 1598:     fileio:close(refnum)
; toolsrc/ed.pla: 1599:     heaprelease(databuff)
; toolsrc/ed.pla: 1600:     putln
; toolsrc/ed.pla: 1601:     return 0
	!BYTE	$64,$42			; LLB	[66]
	!BYTE	$6A			; LAW	_X031+16
_F820 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$49			; LLW	[73]
	!BYTE	$54			; CALL	_X015
_F821 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_X003
_F822 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$5A,$4D			; LEAVE	77
; toolsrc/ed.pla: 1602: end
; toolsrc/ed.pla: 1603: def parsecmd(strptr)
					; strptr -> [0]
_C064 					; parsecmd()
; toolsrc/ed.pla: 1604:     byte cmd
					; cmd -> [2]
; toolsrc/ed.pla: 1605: 
; toolsrc/ed.pla: 1606:     cmd = 0
	!BYTE	$58,$03,$01		; ENTER	3,1
; toolsrc/ed.pla: 1607:     striplead(strptr, ' ')
; toolsrc/ed.pla: 1608:     if ^strptr
; toolsrc/ed.pla: 1609:         cmd = ^(strptr + 1)
; toolsrc/ed.pla: 1610:         memcpy(strptr + 1, strptr + 2, ^strptr)
; toolsrc/ed.pla: 1611:         ^strptr--
	!BYTE	$00			; CN	0
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C003
_F823 	!WORD	_C003		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B542
	!WORD	_B542-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X018
_F824 	!WORD	0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$8E			; DECR
; toolsrc/ed.pla: 1612:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$70			; SB
_B542 
_B543 
; toolsrc/ed.pla: 1613:     if ^strptr
; toolsrc/ed.pla: 1614:         striplead(strptr, ' ')
; toolsrc/ed.pla: 1615:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B544
	!WORD	_B544-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C003
_F825 	!WORD	_C003		
_B544 
_B545 
; toolsrc/ed.pla: 1616:     return cmd
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$03			; LEAVE	3
; toolsrc/ed.pla: 1617: end
; toolsrc/ed.pla: 1618: def chkchng
_C065 					; chkchng()
; toolsrc/ed.pla: 1619:     if flags & changed
; toolsrc/ed.pla: 1620:         puts("LOSE CHANGES TO FILE (Y/N)?")
	!BYTE	$68			; LAB	_D040+0
_F826 	!WORD	_D040+0		
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B546
	!WORD	_B546-*
	!BYTE	$2E			; CS
	!BYTE	$1B
	!BYTE	$4C,$4F,$53,$45,$20,$43,$48,$41
	!BYTE	$4E,$47,$45,$53,$20,$54,$4F,$20
	!BYTE	$46,$49,$4C,$45,$20,$28,$59,$2F
	!BYTE	$4E,$29,$3F
	!BYTE	$54			; CALL	_X004
_F827 	!WORD	0		
; toolsrc/ed.pla: 1621:         if toupper(keyin()) == 'N'
; toolsrc/ed.pla: 1622:             putln
; toolsrc/ed.pla: 1623:             return FALSE
	!BYTE	$6A			; LAW	_D057+0
_F828 	!WORD	_D057+0		
	!BYTE	$56			; ICAL
	!BYTE	$54			; CALL	_X021
_F829 	!WORD	0		
	!BYTE	$2A,$4E			; CB	78
	!BYTE	$24			; BRNE	_B548
	!WORD	_B548-*
	!BYTE	$54			; CALL	_X003
_F830 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 1624:         fin
_B548 
_B549 
; toolsrc/ed.pla: 1625:         putln
; toolsrc/ed.pla: 1626:     fin
	!BYTE	$54			; CALL	_X003
_F831 	!WORD	0		
_B546 
_B547 
; toolsrc/ed.pla: 1627:     return TRUE
	!BYTE	$20			; MINUS ONE
	!BYTE	$5C			; RET
; toolsrc/ed.pla: 1628: end
; toolsrc/ed.pla: 1629: def cmdmode#0
_P000 					; cmdmode#0()
_C066 					; cmdmode()
; toolsrc/ed.pla: 1630:     byte slot
					; slot -> [0]
; toolsrc/ed.pla: 1631:     word cmdptr, line
					; cmdptr -> [1]
					; line -> [3]
; toolsrc/ed.pla: 1632: 
; toolsrc/ed.pla: 1633:     clrscrn
	!BYTE	$58,$05,$00		; ENTER	5,0
; toolsrc/ed.pla: 1634:     puts("PLASMA Editor, Version 2.0\n")
	!BYTE	$54			; CALL	_C018
_F832 	!WORD	_C018		
	!BYTE	$2E			; CS
	!BYTE	$1B
	!BYTE	$50,$4C,$41,$53,$4D,$41,$20,$45
	!BYTE	$64,$69,$74,$6F,$72,$2C,$20,$56
	!BYTE	$65,$72,$73,$69,$6F,$6E,$20,$32
	!BYTE	$2E,$30,$0D
	!BYTE	$54			; CALL	_X004
_F833 	!WORD	0		
; toolsrc/ed.pla: 1635:     while not exit
	!BYTE	$50			; BRNCH	_B552
	!WORD	_B552-*
_B550 
; toolsrc/ed.pla: 1636:         puts(@filename)
; toolsrc/ed.pla: 1637:         cmdptr = gets($BA)
; toolsrc/ed.pla: 1638:         when toupper(parsecmd(cmdptr))
	!BYTE	$26			; LA	_D038+0
_F834 	!WORD	_D038+0		
	!BYTE	$54			; CALL	_X004
_F835 	!WORD	0		
	!BYTE	$2A,$BA			; CB	186
	!BYTE	$54			; CALL	_X007
_F836 	!WORD	0		
	!BYTE	$6E,$01			; DLW	[1]
	!BYTE	$54			; CALL	_C064
_F837 	!WORD	_C064		
	!BYTE	$54			; CALL	_X021
_F838 	!WORD	0		
	!BYTE	$52			; SEL
	!WORD	_B554-*
; toolsrc/ed.pla: 1639:             is 'F' // Find string
_B555 
; toolsrc/ed.pla: 1640:                 if ^cmdptr
; toolsrc/ed.pla: 1641:                     lnupcpy(@findstr, cmdptr)
; toolsrc/ed.pla: 1642:                 fin
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B556
	!WORD	_B556-*
	!BYTE	$26			; LA	_D037+0
_F839 	!WORD	_D037+0		
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$54			; CALL	_A003
_F840 	!WORD	_A003		
_B556 
_B557 
; toolsrc/ed.pla: 1643:                 findtxt
; toolsrc/ed.pla: 1644:                 return
	!BYTE	$54			; CALL	_C039
_F841 	!WORD	_C039		
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 1645:             is 'T' // Toggle upper/lower case display
_B558 
; toolsrc/ed.pla: 1646:                 if ^cmdptr
; toolsrc/ed.pla: 1647:                     when toupper(^(cmdptr + 1))
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B559
	!WORD	_B559-*
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F842 	!WORD	0		
	!BYTE	$52			; SEL
	!WORD	_B562-*
; toolsrc/ed.pla: 1648:                         is 'G' // Gutter view
_B563 
; toolsrc/ed.pla: 1649:                             flags = flags ^ gutter
; toolsrc/ed.pla: 1650:                             if flags & gutter
; toolsrc/ed.pla: 1651:                                 scrnwidth    = 36
; toolsrc/ed.pla: 1652:                                 scrnright    = 35
; toolsrc/ed.pla: 1653:                             else
	!BYTE	$68			; LAB	_D040+0
_F843 	!WORD	_D040+0		
	!BYTE	$08			; CN	4
	!BYTE	$98			; XOR
	!BYTE	$7C			; DAB	_D040+0
_F844 	!WORD	_D040+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B564
	!WORD	_B564-*
	!BYTE	$2A,$24			; CB	36
	!BYTE	$7A			; SAW	_D033+0
_F845 	!WORD	_D033+0		
	!BYTE	$2A,$23			; CB	35
	!BYTE	$7A			; SAW	_D034+0
_F846 	!WORD	_D034+0		
	!BYTE	$50			; BRNCH	_B565
	!WORD	_B565-*
_B564 
; toolsrc/ed.pla: 1654:                                 scrnwidth    = 40
; toolsrc/ed.pla: 1655:                                 scrnright    = 39
; toolsrc/ed.pla: 1656:                             fin
	!BYTE	$2A,$28			; CB	40
	!BYTE	$7A			; SAW	_D033+0
_F847 	!WORD	_D033+0		
	!BYTE	$2A,$27			; CB	39
	!BYTE	$7A			; SAW	_D034+0
_F848 	!WORD	_D034+0		
_B565 
; toolsrc/ed.pla: 1657:                             break
	!BYTE	$50			; BRNCH	_B561
	!WORD	_B561-*
; toolsrc/ed.pla: 1658:                         is 'C' // Lower case chip (Apple ][/][+ only)
_B566 
; toolsrc/ed.pla: 1659:                             if flags & uppercase
; toolsrc/ed.pla: 1660:                                 txtlower
; toolsrc/ed.pla: 1661:                             else
	!BYTE	$68			; LAB	_D040+0
_F849 	!WORD	_D040+0		
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B567
	!WORD	_B567-*
	!BYTE	$54			; CALL	_C013
_F850 	!WORD	_C013		
	!BYTE	$50			; BRNCH	_B568
	!WORD	_B568-*
_B567 
; toolsrc/ed.pla: 1662:                                 txtupper
; toolsrc/ed.pla: 1663:                             fin
	!BYTE	$54			; CALL	_C012
_F851 	!WORD	_C012		
_B568 
; toolsrc/ed.pla: 1664:                             break
	!BYTE	$50			; BRNCH	_B561
	!WORD	_B561-*
; toolsrc/ed.pla: 1665:                     wend
	!BYTE	$50			; BRNCH	_B561
	!WORD	_B561-*
_B562 
	!BYTE	$02			; CASEBLOCK
	!WORD	$0043
	!WORD	_B566-*
	!WORD	$0047
	!WORD	_B563-*
_B561 
; toolsrc/ed.pla: 1666:                 fin
_B559 
_B560 
; toolsrc/ed.pla: 1667:                 return
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 1668:             is 'G' // Goto line #
_B569 
; toolsrc/ed.pla: 1669:                 line = strtonum(cmdptr)
; toolsrc/ed.pla: 1670:                 if line
; toolsrc/ed.pla: 1671:                     curshpos(0)
; toolsrc/ed.pla: 1672:                     cursvpos(line - 1)
; toolsrc/ed.pla: 1673:                fin
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$54			; CALL	_C014
_F852 	!WORD	_C014		
	!BYTE	$6E,$03			; DLW	[3]
	!BYTE	$4C			; BRFLS	_B570
	!WORD	_B570-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C026
_F853 	!WORD	_C026		
	!BYTE	$30			; DROP 
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C027
_F854 	!WORD	_C027		
	!BYTE	$30			; DROP 
_B570 
_B571 
; toolsrc/ed.pla: 1674:             is 'E' // Edit mode
_B572 
; toolsrc/ed.pla: 1675:             is 0
_B573 
; toolsrc/ed.pla: 1676:                 return
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 1677:             is 'A' // Append file
_B574 
; toolsrc/ed.pla: 1678:                 readtxt(cmdptr, numlines)
; toolsrc/ed.pla: 1679:                 flags = flags | changed
; toolsrc/ed.pla: 1680:                 break
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$6A			; LAW	_D042+0
_F855 	!WORD	_D042+0		
	!BYTE	$54			; CALL	_C016
_F856 	!WORD	_C016		
	!BYTE	$68			; LAB	_D040+0
_F857 	!WORD	_D040+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D040+0
_F858 	!WORD	_D040+0		
	!BYTE	$50			; BRNCH	_B553
	!WORD	_B553-*
; toolsrc/ed.pla: 1681:             is 'R' // Read file
_B575 
; toolsrc/ed.pla: 1682:                 if chkchng
; toolsrc/ed.pla: 1683:                     inittxtbuf
; toolsrc/ed.pla: 1684:                     strstripcpy(@filename, cmdptr)
; toolsrc/ed.pla: 1685:                     readtxt(@filename, 0)
; toolsrc/ed.pla: 1686:                     flags = flags & ~changed
; toolsrc/ed.pla: 1687:                 fin
	!BYTE	$54			; CALL	_C065
_F859 	!WORD	_C065		
	!BYTE	$4C			; BRFLS	_B576
	!WORD	_B576-*
	!BYTE	$54			; CALL	_C008
_F860 	!WORD	_C008		
	!BYTE	$26			; LA	_D038+0
_F861 	!WORD	_D038+0		
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$54			; CALL	_C005
_F862 	!WORD	_C005		
	!BYTE	$26			; LA	_D038+0
_F863 	!WORD	_D038+0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C016
_F864 	!WORD	_C016		
	!BYTE	$68			; LAB	_D040+0
_F865 	!WORD	_D040+0		
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$94			; AND 
	!BYTE	$78			; SAB	_D040+0
_F866 	!WORD	_D040+0		
_B576 
_B577 
; toolsrc/ed.pla: 1688:                 break
	!BYTE	$50			; BRNCH	_B553
	!WORD	_B553-*
; toolsrc/ed.pla: 1689:             is 'W' // Write file
_B578 
; toolsrc/ed.pla: 1690:                 if ^cmdptr
; toolsrc/ed.pla: 1691:                     strstripcpy(@filename, cmdptr)
; toolsrc/ed.pla: 1692:                 fin
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B579
	!WORD	_B579-*
	!BYTE	$26			; LA	_D038+0
_F867 	!WORD	_D038+0		
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$54			; CALL	_C005
_F868 	!WORD	_C005		
_B579 
_B580 
; toolsrc/ed.pla: 1693:                 writetxt(@filename)
; toolsrc/ed.pla: 1694:                 //if flags & changed; fin
; toolsrc/ed.pla: 1695:                 flags = flags & ~changed
; toolsrc/ed.pla: 1696:                 break
	!BYTE	$26			; LA	_D038+0
_F869 	!WORD	_D038+0		
	!BYTE	$54			; CALL	_C017
_F870 	!WORD	_C017		
	!BYTE	$68			; LAB	_D040+0
_F871 	!WORD	_D040+0		
	!BYTE	$5E,$FE			; CFFB	-2
	!BYTE	$94			; AND 
	!BYTE	$78			; SAB	_D040+0
_F872 	!WORD	_D040+0		
	!BYTE	$50			; BRNCH	_B553
	!WORD	_B553-*
; toolsrc/ed.pla: 1697:             is 'C' // Catalog
_B581 
; toolsrc/ed.pla: 1698:                 prfiles(cmdptr); break
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$54			; CALL	_C063
_F873 	!WORD	_C063		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B553
	!WORD	_B553-*
; toolsrc/ed.pla: 1699:             is 'P' // Prefix
_B582 
; toolsrc/ed.pla: 1700:                 fileio:setpfx(cmdptr); break
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$6A			; LAW	_X031+2
_F874 	!WORD	0+2		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B553
	!WORD	_B553-*
; toolsrc/ed.pla: 1701:             is 'H' // Hardcopy
_B583 
; toolsrc/ed.pla: 1702:                 if ^cmdptr
; toolsrc/ed.pla: 1703:                     slot = cmdptr.1 - '0'
; toolsrc/ed.pla: 1704:                 else
	!BYTE	$66,$01			; LLW	[1]
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B584
	!WORD	_B584-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B585
	!WORD	_B585-*
_B584 
; toolsrc/ed.pla: 1705:                     slot = 1
; toolsrc/ed.pla: 1706:                 fin
	!BYTE	$02			; CN	1
	!BYTE	$74,$00			; SLB	[0]
_B585 
; toolsrc/ed.pla: 1707:                 printtxt(slot)
; toolsrc/ed.pla: 1708:                 break
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_C047
_F875 	!WORD	_C047		
	!BYTE	$50			; BRNCH	_B553
	!WORD	_B553-*
; toolsrc/ed.pla: 1709:             is 'Q' // Quit
_B586 
; toolsrc/ed.pla: 1710:                 exit = chkchng
; toolsrc/ed.pla: 1711:                 if not exit
; toolsrc/ed.pla: 1712:                     return
	!BYTE	$54			; CALL	_C065
_F876 	!WORD	_C065		
	!BYTE	$7C			; DAB	_D039+0
_F877 	!WORD	_D039+0		
	!BYTE	$4E			; BRTRU	_B587
	!WORD	_B587-*
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 1713:                 fin
_B587 
_B588 
; toolsrc/ed.pla: 1714:                 break
	!BYTE	$50			; BRNCH	_B553
	!WORD	_B553-*
; toolsrc/ed.pla: 1715:            is 'N'
_B589 
; toolsrc/ed.pla: 1716:                 if chkchng
; toolsrc/ed.pla: 1717:                     inittxtbuf
; toolsrc/ed.pla: 1718:                     strstripcpy(@filename, "UNTITLED")
	!BYTE	$54			; CALL	_C065
_F878 	!WORD	_C065		
	!BYTE	$4C			; BRFLS	_B590
	!WORD	_B590-*
	!BYTE	$54			; CALL	_C008
_F879 	!WORD	_C008		
	!BYTE	$26			; LA	_D038+0
_F880 	!WORD	_D038+0		
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$55,$4E,$54,$49,$54,$4C,$45,$44
	!BYTE	$54			; CALL	_C005
_F881 	!WORD	_C005		
; toolsrc/ed.pla: 1719:                 fin
_B590 
_B591 
; toolsrc/ed.pla: 1720:                 break
	!BYTE	$50			; BRNCH	_B553
	!WORD	_B553-*
; toolsrc/ed.pla: 1721:             otherwise
_B554 
	!BYTE	$0D			; CASEBLOCK
	!WORD	$0000
	!WORD	_B573-*
	!WORD	$0041
	!WORD	_B574-*
	!WORD	$0043
	!WORD	_B581-*
	!WORD	$0045
	!WORD	_B572-*
	!WORD	$0046
	!WORD	_B555-*
	!WORD	$0047
	!WORD	_B569-*
	!WORD	$0048
	!WORD	_B583-*
	!WORD	$004E
	!WORD	_B589-*
	!WORD	$0050
	!WORD	_B582-*
	!WORD	$0051
	!WORD	_B586-*
	!WORD	$0052
	!WORD	_B575-*
	!WORD	$0054
	!WORD	_B558-*
	!WORD	$0057
	!WORD	_B578-*
; toolsrc/ed.pla: 1722:                 bell
; toolsrc/ed.pla: 1723:                 putc('?')
; toolsrc/ed.pla: 1724:                 putln
; toolsrc/ed.pla: 1725:         wend
	!BYTE	$54			; CALL	_C000
_F882 	!WORD	_C000		
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$54			; CALL	_X002
_F883 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F884 	!WORD	0		
_B553 
; toolsrc/ed.pla: 1726:         if perr
; toolsrc/ed.pla: 1727:             puts("ERROR: $")
	!BYTE	$68			; LAB	_X032+0
_F885 	!WORD	0+0		
	!BYTE	$4C			; BRFLS	_B592
	!WORD	_B592-*
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$45,$52,$52,$4F,$52,$3A,$20,$24
	!BYTE	$54			; CALL	_X004
_F886 	!WORD	0		
; toolsrc/ed.pla: 1728:             putb(perr)
; toolsrc/ed.pla: 1729:         putln
; toolsrc/ed.pla: 1730:         fin
	!BYTE	$68			; LAB	_X032+0
_F887 	!WORD	0+0		
	!BYTE	$54			; CALL	_X008
_F888 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F889 	!WORD	0		
_B592 
_B593 
; toolsrc/ed.pla: 1731:     loop
_B552 
	!BYTE	$68			; LAB	_D039+0
_F890 	!WORD	_D039+0		
	!BYTE	$4C			; BRFLS	_B550
	!WORD	_B550-*
_B551 
; toolsrc/ed.pla: 1732: end
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/ed.pla: 1733: //
; toolsrc/ed.pla: 1734: // Init editor
; toolsrc/ed.pla: 1735: //
; toolsrc/ed.pla: 1736: setkeyin
_INIT 
; toolsrc/ed.pla: 1737: if not (MACHID & $80) // ][ or ][+
; toolsrc/ed.pla: 1738:     flags = uppercase | shiftlock
; toolsrc/ed.pla: 1739: fin
	!BYTE	$54			; CALL	_C046
_F891 	!WORD	_C046		
	!BYTE	$68			; LAB	_X001+0
_F892 	!WORD	0+0		
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4E			; BRTRU	_B594
	!WORD	_B594-*
	!BYTE	$2A,$88			; CB	136
	!BYTE	$78			; SAB	_D040+0
_F893 	!WORD	_D040+0		
_B594 
_B595 
; toolsrc/ed.pla: 1740: inittxtbuf
; toolsrc/ed.pla: 1741: arg = argNext(argFirst)
; toolsrc/ed.pla: 1742: if ^arg
; toolsrc/ed.pla: 1743:     strcpy(@filename, arg)
; toolsrc/ed.pla: 1744:     puts(@filename)
; toolsrc/ed.pla: 1745:     readtxt(@filename, 0)
; toolsrc/ed.pla: 1746:     arg = argNext(arg)
; toolsrc/ed.pla: 1747:     if ^arg
; toolsrc/ed.pla: 1748:         cursrow = strtonum(arg)
; toolsrc/ed.pla: 1749:         if cursrow
; toolsrc/ed.pla: 1750:             curshpos(0)
; toolsrc/ed.pla: 1751:             cursvpos(cursrow - 1)
; toolsrc/ed.pla: 1752:         fin
	!BYTE	$54			; CALL	_C008
_F894 	!WORD	_C008		
	!BYTE	$54			; CALL	_X029
_F895 	!WORD	0		
	!BYTE	$54			; CALL	_X030
_F896 	!WORD	0		
	!BYTE	$7A			; SAW	_D044+0
_F897 	!WORD	_D044+0		
	!BYTE	$6A			; LAW	_D044+0
_F898 	!WORD	_D044+0		
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B596
	!WORD	_B596-*
	!BYTE	$26			; LA	_D038+0
_F899 	!WORD	_D038+0		
	!BYTE	$6A			; LAW	_D044+0
_F900 	!WORD	_D044+0		
	!BYTE	$54			; CALL	_X019
_F901 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D038+0
_F902 	!WORD	_D038+0		
	!BYTE	$54			; CALL	_X004
_F903 	!WORD	0		
	!BYTE	$26			; LA	_D038+0
_F904 	!WORD	_D038+0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C016
_F905 	!WORD	_C016		
	!BYTE	$6A			; LAW	_D044+0
_F906 	!WORD	_D044+0		
	!BYTE	$54			; CALL	_X030
_F907 	!WORD	0		
	!BYTE	$7A			; SAW	_D044+0
_F908 	!WORD	_D044+0		
	!BYTE	$6A			; LAW	_D044+0
_F909 	!WORD	_D044+0		
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B598
	!WORD	_B598-*
	!BYTE	$6A			; LAW	_D044+0
_F910 	!WORD	_D044+0		
	!BYTE	$54			; CALL	_C014
_F911 	!WORD	_C014		
	!BYTE	$7E			; DAW	_D058+0
_F912 	!WORD	_D058+0		
	!BYTE	$4C			; BRFLS	_B600
	!WORD	_B600-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C026
_F913 	!WORD	_C026		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D058+0
_F914 	!WORD	_D058+0		
	!BYTE	$8E			; DECR
	!BYTE	$54			; CALL	_C027
_F915 	!WORD	_C027		
	!BYTE	$30			; DROP 
_B600 
_B601 
; toolsrc/ed.pla: 1753:     fin
_B598 
_B599 
; toolsrc/ed.pla: 1754: fin
_B596 
_B597 
; toolsrc/ed.pla: 1755: curschr  = '+'
; toolsrc/ed.pla: 1756: flags    = flags | insmode | gutter
; toolsrc/ed.pla: 1757: drawscrn(scrntop, scrnleft)
; toolsrc/ed.pla: 1758: curson
; toolsrc/ed.pla: 1759: editmode
; toolsrc/ed.pla: 1760: done
	!BYTE	$2A,$2B			; CB	43
	!BYTE	$78			; SAB	_D056+0
_F916 	!WORD	_D056+0		
	!BYTE	$68			; LAB	_D040+0
_F917 	!WORD	_D040+0		
	!BYTE	$3E,$02			; ORI	2
	!BYTE	$3E,$04			; ORI	4
	!BYTE	$78			; SAB	_D040+0
_F918 	!WORD	_D040+0		
	!BYTE	$6A			; LAW	_D060+0
_F919 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D053+0
_F920 	!WORD	_D053+0		
	!BYTE	$54			; CALL	_C021
_F921 	!WORD	_C021		
	!BYTE	$54			; CALL	_C023
_F922 	!WORD	_C023		
	!BYTE	$54			; CALL	_C062
_F923 	!WORD	_C062		
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
_DEFCNT	=	68
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C010		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C011		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C012		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C013		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C014		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C015		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C016		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C017		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C018		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C019		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C020		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C021		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C022		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C023		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C024		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C025		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C026		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C027		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C028		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C029		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C030		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C031		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C032		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C033		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C034		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C035		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C036		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C037		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C038		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C039		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C040		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C041		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C042		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C043		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C044		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C045		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C046		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C047		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C048		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C049		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C050		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C051		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C052		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C053		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C054		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C055		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C056		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C057		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C058		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C059		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C060		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C061		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C062		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C063		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C064		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C065		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C066		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	16			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	26			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	16			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	26			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	9			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	9			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F133-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F134-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F135-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F136-_SEGBEGIN		
	!BYTE	9			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F137-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F138-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F139-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F140-_SEGBEGIN		
	!BYTE	1			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F141-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F142-_SEGBEGIN		
	!BYTE	10			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F143-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F144-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F145-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F146-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F147-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F148-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F149-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F150-_SEGBEGIN		
	!BYTE	23			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F151-_SEGBEGIN		
	!BYTE	23			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F152-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F153-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F154-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F155-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F156-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F157-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F158-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F159-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F160-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F161-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F162-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F163-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F164-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F165-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F166-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F167-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F168-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F169-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F170-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F171-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F172-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F173-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F174-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F175-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F176-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F177-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F178-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F179-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F180-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F181-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F182-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F183-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F184-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F185-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F186-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F187-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F188-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F189-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F190-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F191-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F192-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F193-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F194-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F195-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F196-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F197-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F198-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F199-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F200-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F201-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F202-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F203-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F204-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F205-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F206-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F207-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F208-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F209-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F210-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F211-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F212-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F213-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F214-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F215-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F216-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F217-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F218-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F219-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F220-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F221-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F222-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F223-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F224-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F225-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F226-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F227-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F228-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F229-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F230-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F231-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F232-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F233-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F234-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F235-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F236-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F237-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F238-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F239-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F240-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F241-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F242-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F243-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F244-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F245-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F246-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F247-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F248-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F249-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F250-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F251-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F252-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F253-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F254-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F255-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F256-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F257-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F258-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F259-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F260-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F261-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F262-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F263-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F264-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F265-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F266-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F267-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F268-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F269-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F270-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F271-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F272-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F273-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F274-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F275-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F276-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F277-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F278-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F279-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F280-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F281-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F282-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F283-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F284-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F285-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F286-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F287-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F288-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F289-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F290-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F291-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F292-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F293-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F294-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F295-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F296-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F297-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F298-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F299-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F300-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F301-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F302-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F303-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F304-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F305-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F306-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F307-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F308-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F309-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F310-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F311-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F312-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F313-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F314-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F315-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F316-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F317-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F318-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F319-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F320-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F321-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F322-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F323-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F324-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F325-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F326-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F327-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F328-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F329-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F330-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F331-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F332-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F333-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F334-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F335-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F336-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F337-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F338-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F339-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F340-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F341-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F342-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F343-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F344-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F345-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F346-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F347-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F348-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F349-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F350-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F351-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F352-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F353-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F354-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F355-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F356-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F357-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F358-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F359-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F360-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F361-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F362-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F363-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F364-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F365-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F366-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F367-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F368-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F369-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F370-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F371-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F372-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F373-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F374-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F375-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F376-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F377-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F378-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F379-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F380-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F381-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F382-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F383-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F384-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F385-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F386-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F387-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F388-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F389-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F390-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F391-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F392-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F393-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F394-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F395-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F396-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F397-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F398-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F399-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F400-_SEGBEGIN		
	!BYTE	11			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F401-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F402-_SEGBEGIN		
	!BYTE	0			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F403-_SEGBEGIN		
	!BYTE	11			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F404-_SEGBEGIN		
	!BYTE	0			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F405-_SEGBEGIN		
	!BYTE	11			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F406-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F407-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F408-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F409-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F410-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F411-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F412-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F413-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F414-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F415-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F416-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F417-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F418-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F419-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F420-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F421-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F422-_SEGBEGIN		
	!BYTE	1			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F423-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F424-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F425-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F426-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F427-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F428-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F429-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F430-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F431-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F432-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F433-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F434-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F435-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F436-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F437-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F438-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F439-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F440-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F441-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F442-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F443-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F444-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F445-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F446-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F447-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F448-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F449-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F450-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F451-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F452-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F453-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F454-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F455-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F456-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F457-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F458-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F459-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F460-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F461-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F462-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F463-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F464-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F465-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F466-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F467-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F468-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F469-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F470-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F471-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F472-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F473-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F474-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F475-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F476-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F477-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F478-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F479-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F480-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F481-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F482-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F483-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F484-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F485-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F486-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F487-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F488-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F489-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F490-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F491-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F492-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F493-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F494-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F495-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F496-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F497-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F498-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F499-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F500-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F501-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F502-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F503-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F504-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F505-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F506-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F507-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F508-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F509-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F510-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F511-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F512-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F513-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F514-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F515-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F516-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F517-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F518-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F519-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F520-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F521-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F522-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F523-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F524-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F525-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F526-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F527-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F528-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F529-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F530-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F531-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F532-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F533-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F534-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F535-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F536-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F537-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F538-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F539-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F540-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F541-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F542-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F543-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F544-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F545-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F546-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F547-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F548-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F549-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F550-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F551-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F552-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F553-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F554-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F555-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F556-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F557-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F558-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F559-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F560-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F561-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F562-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F563-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F564-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F565-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F566-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F567-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F568-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F569-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F570-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F571-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F572-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F573-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F574-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F575-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F576-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F577-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F578-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F579-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F580-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F581-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F582-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F583-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F584-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F585-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F586-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F587-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F588-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F589-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F590-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F591-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F592-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F593-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F594-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F595-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F596-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F597-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F598-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F599-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F600-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F601-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F602-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F603-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F604-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F605-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F606-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F607-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F608-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F609-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F610-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F611-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F612-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F613-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F614-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F615-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F616-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F617-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F618-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F619-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F620-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F621-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F622-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F623-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F624-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F625-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F626-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F627-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F628-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F629-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F630-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F631-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F632-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F633-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F634-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F635-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F636-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F637-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F638-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F639-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F640-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F641-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F642-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F643-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F644-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F645-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F646-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F647-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F648-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F649-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F650-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F651-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F652-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F653-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F654-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F655-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F656-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F657-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F658-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F659-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F660-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F661-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F662-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F663-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F664-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F665-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F666-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F667-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F668-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F669-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F670-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F671-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F672-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F673-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F674-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F675-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F676-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F677-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F678-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F679-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F680-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F681-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F682-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F683-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F684-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F685-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F686-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F687-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F688-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F689-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F690-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F691-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F692-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F693-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F694-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F695-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F696-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F697-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F698-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F699-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F700-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F701-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F702-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F703-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F704-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F705-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F706-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F707-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F708-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F709-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F710-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F711-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F712-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F713-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F714-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F715-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F716-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F717-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F718-_SEGBEGIN		
	!BYTE	1			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F719-_SEGBEGIN		
	!BYTE	0			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F720-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F721-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F722-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F723-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F724-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F725-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F726-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F727-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F728-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F729-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F730-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F731-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F732-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F733-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F734-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F735-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F736-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F737-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F738-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F739-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F740-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F741-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F742-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F743-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F744-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F745-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F746-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F747-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F748-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F749-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F750-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F751-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F752-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F753-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F754-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F755-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F756-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F757-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F758-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F759-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F760-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F761-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F762-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F763-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F764-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F765-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F766-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F767-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F768-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F769-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F770-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F771-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F772-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F773-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F774-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F775-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F776-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F777-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F778-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F779-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F780-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F781-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F782-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F783-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F784-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F785-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F786-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F787-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F788-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F789-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F790-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F791-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F792-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F793-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F794-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F795-_SEGBEGIN		
	!BYTE	1			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F796-_SEGBEGIN		
	!BYTE	0			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F797-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F798-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F799-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F800-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F801-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F802-_SEGBEGIN		
	!BYTE	1			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F803-_SEGBEGIN		
	!BYTE	0			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F804-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F805-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F806-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F807-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F808-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F809-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F810-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F811-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F812-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F813-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F814-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F815-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F816-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F817-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F818-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F819-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F820-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F821-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F822-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F823-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F824-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F825-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F826-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F827-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F828-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F829-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F830-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F831-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F832-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F833-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F834-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F835-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F836-_SEGBEGIN		
	!BYTE	7			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F837-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F838-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F839-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F840-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F841-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F842-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F843-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F844-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F845-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F846-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F847-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F848-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F849-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F850-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F851-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F852-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F853-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F854-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F855-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F856-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F857-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F858-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F859-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F860-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F861-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F862-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F863-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F864-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F865-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F866-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F867-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F868-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F869-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F870-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F871-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F872-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F873-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F874-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F875-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F876-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F877-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F878-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F879-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F880-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F881-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F882-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F883-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F884-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F885-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F886-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F887-_SEGBEGIN		
	!BYTE	32			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F888-_SEGBEGIN		
	!BYTE	8			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F889-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F890-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F891-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F892-_SEGBEGIN		
	!BYTE	1			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F893-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F894-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F895-_SEGBEGIN		
	!BYTE	29			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F896-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F897-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F898-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F899-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F900-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F901-_SEGBEGIN		
	!BYTE	19			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F902-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F903-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F904-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F905-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F906-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F907-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F908-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F909-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F910-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F911-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F912-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F913-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F914-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F915-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F916-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F917-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F918-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F919-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F920-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F921-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F922-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F923-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	0			; ESD INDEX
	; DCI STRING: MACHID
	!BYTE	$CD,$C1,$C3,$C8,$C9,$44
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	1			; ESD INDEX
	; DCI STRING: PUTC
	!BYTE	$D0,$D5,$D4,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	2			; ESD INDEX
	; DCI STRING: PUTLN
	!BYTE	$D0,$D5,$D4,$CC,$4E
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	3			; ESD INDEX
	; DCI STRING: PUTS
	!BYTE	$D0,$D5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	4			; ESD INDEX
	; DCI STRING: GETS
	!BYTE	$C7,$C5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	7			; ESD INDEX
	; DCI STRING: PUTB
	!BYTE	$D0,$D5,$D4,$42
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	8			; ESD INDEX
	; DCI STRING: PUTH
	!BYTE	$D0,$D5,$D4,$48
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	9			; ESD INDEX
	; DCI STRING: CALL
	!BYTE	$C3,$C1,$CC,$4C
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	10			; ESD INDEX
	; DCI STRING: SYSCALL
	!BYTE	$D3,$D9,$D3,$C3,$C1,$CC,$4C
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	11			; ESD INDEX
	; DCI STRING: HEAPALLOC
	!BYTE	$C8,$C5,$C1,$D0,$C1,$CC,$CC,$CF,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	14			; ESD INDEX
	; DCI STRING: HEAPRELEASE
	!BYTE	$C8,$C5,$C1,$D0,$D2,$C5,$CC,$C5,$C1,$D3,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	15			; ESD INDEX
	; DCI STRING: HEAPAVAIL
	!BYTE	$C8,$C5,$C1,$D0,$C1,$D6,$C1,$C9,$4C
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	16			; ESD INDEX
	; DCI STRING: MEMSET
	!BYTE	$CD,$C5,$CD,$D3,$C5,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	17			; ESD INDEX
	; DCI STRING: MEMCPY
	!BYTE	$CD,$C5,$CD,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	18			; ESD INDEX
	; DCI STRING: STRCPY
	!BYTE	$D3,$D4,$D2,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	19			; ESD INDEX
	; DCI STRING: TOUPPER
	!BYTE	$D4,$CF,$D5,$D0,$D0,$C5,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	21			; ESD INDEX
	; DCI STRING: DIVMOD
	!BYTE	$C4,$C9,$D6,$CD,$CF,$44
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	23			; ESD INDEX
	; DCI STRING: ISULT
	!BYTE	$C9,$D3,$D5,$CC,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	26			; ESD INDEX
	; DCI STRING: ARGFIRST
	!BYTE	$C1,$D2,$C7,$C6,$C9,$D2,$D3,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	29			; ESD INDEX
	; DCI STRING: ARGNEXT
	!BYTE	$C1,$D2,$C7,$CE,$C5,$D8,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	30			; ESD INDEX
	; DCI STRING: FILEIO
	!BYTE	$C6,$C9,$CC,$C5,$C9,$4F
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	31			; ESD INDEX
	; DCI STRING: PERR
	!BYTE	$D0,$C5,$D2,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	32			; ESD INDEX
	!BYTE	$00			; END OF ESD
