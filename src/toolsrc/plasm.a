; ACME COMPATIBLE OUTPUT
	!WORD	_SEGEND-_SEGBEGIN	; LENGTH OF HEADER + CODE/DATA + BYTECODE SEGMENT
_SEGBEGIN 
	!WORD	$6502			; MAGIC #
	!WORD	_SYSFLAGS			; SYSTEM FLAGS
	!WORD	_SUBSEG			; BYTECODE SUB-SEGMENT
	!WORD	_DEFCNT			; BYTECODE DEF COUNT
	!WORD	_INIT			; MODULE INITIALIZATION ROUTINE
; toolsrc/plasm.pla: 0001: include "inc/cmdsys.plh"
; inc/cmdsys.plh: 0001: import cmdsys
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
					; CMDSYS -> X000
; inc/cmdsys.plh: 0002:     //
; inc/cmdsys.plh: 0003:     // Useful values for everyone
; inc/cmdsys.plh: 0004:     //
; inc/cmdsys.plh: 0005:     const _SYSVER_ = $0200 // Version built against
					; _SYSVER_ = 512
; inc/cmdsys.plh: 0006:     const FALSE    = 0
					; FALSE = 0
; inc/cmdsys.plh: 0007:     const TRUE     = not FALSE
					; TRUE = -1
; inc/cmdsys.plh: 0008:     const NULL     = 0
					; NULL = 0
; inc/cmdsys.plh: 0009:     //
; inc/cmdsys.plh: 0010:     // Machine ID values
; inc/cmdsys.plh: 0011:     //
; inc/cmdsys.plh: 0012:     const MACHID_CLOCK = $01
					; MACHID_CLOCK = 1
; inc/cmdsys.plh: 0013:     const MACHID_80COL = $02
					; MACHID_80COL = 2
; inc/cmdsys.plh: 0014:     const MACHID_MEM   = $03
					; MACHID_MEM = 3
; inc/cmdsys.plh: 0015:     const MACHID_64K   = $20
					; MACHID_64K = 32
; inc/cmdsys.plh: 0016:     const MACHID_128K  = $30
					; MACHID_128K = 48
; inc/cmdsys.plh: 0017:     const MACHID_MODEL = $C8
					; MACHID_MODEL = 200
; inc/cmdsys.plh: 0018:     const MACHID_II    = $00
					; MACHID_II = 0
; inc/cmdsys.plh: 0019:     const MACHID_IIPLUS= $40
					; MACHID_IIPLUS = 64
; inc/cmdsys.plh: 0020:     const MACHID_IIE   = $80
					; MACHID_IIE = 128
; inc/cmdsys.plh: 0021:     const MACHID_III   = $C0
					; MACHID_III = 192
; inc/cmdsys.plh: 0022:     const MACHID_IIC   = $88
					; MACHID_IIC = 136
; inc/cmdsys.plh: 0023:     const MACHID_I     = $08
					; MACHID_I = 8
; inc/cmdsys.plh: 0024:     byte MACHID
					; MACHID -> X001
; inc/cmdsys.plh: 0025:     //
; inc/cmdsys.plh: 0026:     // System flags: memory allocator screen holes.
; inc/cmdsys.plh: 0027:     //
; inc/cmdsys.plh: 0028:     const restxt1     = $0001
					; restxt1 = 1
; inc/cmdsys.plh: 0029:     const restxt2     = $0002
					; restxt2 = 2
; inc/cmdsys.plh: 0030:     const resxtxt1    = $0004
					; resxtxt1 = 4
; inc/cmdsys.plh: 0031:     const resxtxt2    = $0008
					; resxtxt2 = 8
; inc/cmdsys.plh: 0032:     const reshgr1     = $0010
					; reshgr1 = 16
; inc/cmdsys.plh: 0033:     const reshgr2     = $0020
					; reshgr2 = 32
; inc/cmdsys.plh: 0034:     const resxhgr1    = $0040
					; resxhgr1 = 64
; inc/cmdsys.plh: 0035:     const resxhgr2    = $0080
					; resxhgr2 = 128
; inc/cmdsys.plh: 0036:     const nojitc      = $0100
					; nojitc = 256
; inc/cmdsys.plh: 0037:     //
; inc/cmdsys.plh: 0038:     // Module don't free memory
; inc/cmdsys.plh: 0039:     //
; inc/cmdsys.plh: 0040:     const modkeep     = $2000
					; modkeep = 8192
; inc/cmdsys.plh: 0041:     const modinitkeep = $4000
					; modinitkeep = 16384
; inc/cmdsys.plh: 0042:     //
; inc/cmdsys.plh: 0043:     // CMD exported interface table
; inc/cmdsys.plh: 0044:     //
; inc/cmdsys.plh: 0045:     struc t_cmdsys
; inc/cmdsys.plh: 0046:         word sysver
					; sysver = 0
; inc/cmdsys.plh: 0047:         word syspath
					; syspath = 2
; inc/cmdsys.plh: 0048:         word cmdline
					; cmdline = 4
; inc/cmdsys.plh: 0049:         word modexec
					; modexec = 6
; inc/cmdsys.plh: 0050:         word sysopen
					; sysopen = 8
; inc/cmdsys.plh: 0051:         word sysclose
					; sysclose = 10
; inc/cmdsys.plh: 0052:         word sysread
					; sysread = 12
; inc/cmdsys.plh: 0053:         word syswrite
					; syswrite = 14
; inc/cmdsys.plh: 0054:         byte syserr
					; syserr = 16
; inc/cmdsys.plh: 0055:         byte jitcount
					; jitcount = 17
; inc/cmdsys.plh: 0056:         byte jitsize
					; jitsize = 18
; inc/cmdsys.plh: 0057:         byte refcons    // Apple /// specific
					; refcons = 19
; inc/cmdsys.plh: 0058:         byte devcons    // Apple /// specific
					; devcons = 20
; inc/cmdsys.plh: 0059:     end
					; t_cmdsys = 21
; inc/cmdsys.plh: 0060:     //
; inc/cmdsys.plh: 0061:     // CMD exported functions
; inc/cmdsys.plh: 0062:     //
; inc/cmdsys.plh: 0063:     predef putc(c)#0, putln()#0, puts(s)#0, puti(i)#0, getc()#1, gets(p)#1, putb(b)#0, puth(h)#0
					; PUTC -> X002
					; PUTLN -> X003
					; PUTS -> X004
					; PUTI -> X005
					; GETC -> X006
					; GETS -> X007
					; PUTB -> X008
					; PUTH -> X009
; inc/cmdsys.plh: 0064:     predef call(addr,areg,xreg,yreg,status)#1, syscall(cmd,params)#1
					; CALL -> X010
					; SYSCALL -> X011
; inc/cmdsys.plh: 0065:     predef heapmark()#1, heapallocalign(size, pow2, freeaddr)#1
					; HEAPMARK -> X012
					; HEAPALLOCALIGN -> X013
; inc/cmdsys.plh: 0066:     predef heapalloc(size)#1, heaprelease(newheap)#1, heapavail()#1
					; HEAPALLOC -> X014
					; HEAPRELEASE -> X015
					; HEAPAVAIL -> X016
; inc/cmdsys.plh: 0067:     predef memset(addr,value,size)#0, memcpy(dst,src,size)#0, strcpy(dst,src)#1, strcat(dst,src)#1
					; MEMSET -> X017
					; MEMCPY -> X018
					; STRCPY -> X019
					; STRCAT -> X020
; inc/cmdsys.plh: 0068:     predef toupper(c)#1, sext(a)#1, divmod(a,b)#2, isugt(a,b)#1, isuge(a,b)#1, isult(a,b)#1, isule(a,b)#1
					; TOUPPER -> X021
					; SEXT -> X022
					; DIVMOD -> X023
					; ISUGT -> X024
					; ISUGE -> X025
					; ISULT -> X026
					; ISULE -> X027
; inc/cmdsys.plh: 0069: end
; toolsrc/plasm.pla: 0001: 
; toolsrc/plasm.pla: 0002: include "inc/args.plh"
; inc/args.plh: 0001: import args
	; DCI STRING: ARGS
	!BYTE	$C1,$D2,$C7,$53
					; ARGS -> X028
; inc/args.plh: 0002:     predef  argFirst, argNext(str)
					; ARGFIRST -> X029
					; ARGNEXT -> X030
; inc/args.plh: 0003: end
; toolsrc/plasm.pla: 0002: 
; toolsrc/plasm.pla: 0003: include "inc/fileio.plh"
; inc/fileio.plh: 0001: import fileio
	; DCI STRING: FILEIO
	!BYTE	$C6,$C9,$CC,$C5,$C9,$4F
					; FILEIO -> X031
; inc/fileio.plh: 0002:     //
; inc/fileio.plh: 0003:     // Useful ProDOS values
; inc/fileio.plh: 0004:     //
; inc/fileio.plh: 0005:     // MACHID is defined in cmdsys.plh
; inc/fileio.plh: 0006:     // Which slot has a ROM
; inc/fileio.plh: 0007:     const SLTBYT = $BF99
					; SLTBYT = 49049
; inc/fileio.plh: 0008:     // Prefix active
; inc/fileio.plh: 0009:     const PFIXPTR = $BF9A
					; PFIXPTR = 49050
; inc/fileio.plh: 0010:     // Memory alocate bitmap
; inc/fileio.plh: 0011:     const MEMTABL = $BF58
					; MEMTABL = 48984
; inc/fileio.plh: 0012:     //
; inc/fileio.plh: 0013:     // SOS/ProDOS error codes
; inc/fileio.plh: 0014:     //
; inc/fileio.plh: 0015:     const FILE_ERR_OK            = $00
					; FILE_ERR_OK = 0
; inc/fileio.plh: 0016:     const FILE_ERR_BAD_CALL_NUM  = $01
					; FILE_ERR_BAD_CALL_NUM = 1
; inc/fileio.plh: 0017:     const FILE_ERR_BAD_PARAM_CNT = $04
					; FILE_ERR_BAD_PARAM_CNT = 4
; inc/fileio.plh: 0018:     const FILE_ERR_INT_TBL_FULL  = $25
					; FILE_ERR_INT_TBL_FULL = 37
; inc/fileio.plh: 0019:     const FILE_ERR_IO            = $27
					; FILE_ERR_IO = 39
; inc/fileio.plh: 0020:     //
; inc/fileio.plh: 0021:     // File entry struc
; inc/fileio.plh: 0022:     //
; inc/fileio.plh: 0023:     struc t_fileentry
; inc/fileio.plh: 0024:         byte store_namelen
					; store_namelen = 0
; inc/fileio.plh: 0025:         byte entry_name[15]
					; entry_name = 1
; inc/fileio.plh: 0026:         byte entry_type
					; entry_type = 16
; inc/fileio.plh: 0027:         word entry_keyptr
					; entry_keyptr = 17
; inc/fileio.plh: 0028:         word entry_blocks
					; entry_blocks = 19
; inc/fileio.plh: 0029:         word entry_EOFL
					; entry_EOFL = 21
; inc/fileio.plh: 0030:         byte entry_EOFH
					; entry_EOFH = 23
; inc/fileio.plh: 0031:         word entry_create[2]
					; entry_create = 24
; inc/fileio.plh: 0032:         byte entry_version
					; entry_version = 28
; inc/fileio.plh: 0033:         byte entry_minver
					; entry_minver = 29
; inc/fileio.plh: 0034:         byte entry_access
					; entry_access = 30
; inc/fileio.plh: 0035:         word entry_aux
					; entry_aux = 31
; inc/fileio.plh: 0036:         word entry_mod[2]
					; entry_mod = 33
; inc/fileio.plh: 0037:         word entry_headptr
					; entry_headptr = 37
; inc/fileio.plh: 0038:     end
					; t_fileentry = 39
; inc/fileio.plh: 0039:     //
; inc/fileio.plh: 0040:     // File info struc
; inc/fileio.plh: 0041:     //
; inc/fileio.plh: 0042:     struc t_fileinfo
; inc/fileio.plh: 0043:         byte file_access
					; file_access = 0
; inc/fileio.plh: 0044:         byte file_type
					; file_type = 1
; inc/fileio.plh: 0045:         word aux_type
					; aux_type = 2
; inc/fileio.plh: 0046:         byte storage_type
					; storage_type = 4
; inc/fileio.plh: 0047:         word blocks_used
					; blocks_used = 5
; inc/fileio.plh: 0048:         word mod_date
					; mod_date = 7
; inc/fileio.plh: 0049:         word mod_time
					; mod_time = 9
; inc/fileio.plh: 0050:         word create_date
					; create_date = 11
; inc/fileio.plh: 0051:         word create_time
					; create_time = 13
; inc/fileio.plh: 0052:     end
					; t_fileinfo = 15
; inc/fileio.plh: 0053:     //
; inc/fileio.plh: 0054:     // File functions
; inc/fileio.plh: 0055:     //
; inc/fileio.plh: 0056:     struc t_fileio
; inc/fileio.plh: 0057:         word getpfx
					; getpfx = 0
; inc/fileio.plh: 0058:         word setpfx
					; setpfx = 2
; inc/fileio.plh: 0059:         word getfileinfo
					; getfileinfo = 4
; inc/fileio.plh: 0060:         word setfileinfo
					; setfileinfo = 6
; inc/fileio.plh: 0061:         word geteof
					; geteof = 8
; inc/fileio.plh: 0062:         word seteof
					; seteof = 10
; inc/fileio.plh: 0063:         word iobufalloc
					; iobufalloc = 12
; inc/fileio.plh: 0064:         word open
					; open = 14
; inc/fileio.plh: 0065:         word close
					; close = 16
; inc/fileio.plh: 0066:         word read
					; read = 18
; inc/fileio.plh: 0067:         word write
					; write = 20
; inc/fileio.plh: 0068:         word create
					; create = 22
; inc/fileio.plh: 0069:         word destroy
					; destroy = 24
; inc/fileio.plh: 0070:         word rename
					; rename = 26
; inc/fileio.plh: 0071:         word newline
					; newline = 28
; inc/fileio.plh: 0072:         word online
					; online = 30
; inc/fileio.plh: 0073:         word readblock
					; readblock = 32
; inc/fileio.plh: 0074:         word writeblock
					; writeblock = 34
; inc/fileio.plh: 0075:     end
					; t_fileio = 36
; inc/fileio.plh: 0076:     //
; inc/fileio.plh: 0077:     // Globally accessible error code
; inc/fileio.plh: 0078:     //
; inc/fileio.plh: 0079:     byte perr
					; PERR -> X032
; inc/fileio.plh: 0080: end
; toolsrc/plasm.pla: 0003: 
; toolsrc/plasm.pla: 0004: include "inc/longjmp.plh"
; inc/longjmp.plh: 0001: import longjmp
	; DCI STRING: LONGJMP
	!BYTE	$CC,$CF,$CE,$C7,$CA,$CD,$50
					; LONGJMP -> X033
; inc/longjmp.plh: 0002:     const t_except = $0140
					; t_except = 320
; inc/longjmp.plh: 0003:     predef except(env), throw(env, retval)
					; EXCEPT -> X034
					; THROW -> X035
; inc/longjmp.plh: 0004: end
; toolsrc/plasm.pla: 0004: 
; toolsrc/plasm.pla: 0005: //
; toolsrc/plasm.pla: 0006: // Tokens
; toolsrc/plasm.pla: 0007: //
; toolsrc/plasm.pla: 0008: const ID_LEN            = 32
	!BYTE	$00			; END OF MODULE DEPENDENCIES
					; ID_LEN = 32
; toolsrc/plasm.pla: 0009: const ID_TKN            = $D6 // V
					; ID_TKN = 214
; toolsrc/plasm.pla: 0010: const CHR_TKN           = $C3 // C
					; CHR_TKN = 195
; toolsrc/plasm.pla: 0011: const INT_TKN           = $C9 // I
					; INT_TKN = 201
; toolsrc/plasm.pla: 0012: const STR_TKN           = $D3 // S
					; STR_TKN = 211
; toolsrc/plasm.pla: 0013: const EOL_TKN           = $02
					; EOL_TKN = 2
; toolsrc/plasm.pla: 0014: const EOF_TKN           = $01
					; EOF_TKN = 1
; toolsrc/plasm.pla: 0015: const ERR_TKN           = $00
					; ERR_TKN = 0
; toolsrc/plasm.pla: 0016: //
; toolsrc/plasm.pla: 0017: //Ternary operand operators
; toolsrc/plasm.pla: 0018: //
; toolsrc/plasm.pla: 0019: const TERNARY_TKN       = $BF // ?
					; TERNARY_TKN = 191
; toolsrc/plasm.pla: 0020: const TRIELSE_TKN       = $DF // _
					; TRIELSE_TKN = 223
; toolsrc/plasm.pla: 0021: //
; toolsrc/plasm.pla: 0022: // Binary operand operators
; toolsrc/plasm.pla: 0023: //
; toolsrc/plasm.pla: 0024: const SET_TKN           = $BD // =
					; SET_TKN = 189
; toolsrc/plasm.pla: 0025: const ADD_TKN           = $AB // +
					; ADD_TKN = 171
; toolsrc/plasm.pla: 0026: const SUB_TKN           = $AD // -
					; SUB_TKN = 173
; toolsrc/plasm.pla: 0027: const MUL_TKN           = $AA // *
					; MUL_TKN = 170
; toolsrc/plasm.pla: 0028: const DIV_TKN           = $AF // /
					; DIV_TKN = 175
; toolsrc/plasm.pla: 0029: const MOD_TKN           = $A5 // %
					; MOD_TKN = 165
; toolsrc/plasm.pla: 0030: const OR_TKN            = $FC // |
					; OR_TKN = 252
; toolsrc/plasm.pla: 0031: const EOR_TKN           = $DE // ^
					; EOR_TKN = 222
; toolsrc/plasm.pla: 0032: const AND_TKN           = $A6 // &
					; AND_TKN = 166
; toolsrc/plasm.pla: 0033: const SHR_TKN           = $D2 // R
					; SHR_TKN = 210
; toolsrc/plasm.pla: 0034: const SHL_TKN           = $CC // L
					; SHL_TKN = 204
; toolsrc/plasm.pla: 0035: const GT_TKN            = $BE // >
					; GT_TKN = 190
; toolsrc/plasm.pla: 0036: const GE_TKN            = $C8 // H
					; GE_TKN = 200
; toolsrc/plasm.pla: 0037: const LT_TKN            = $BC // <
					; LT_TKN = 188
; toolsrc/plasm.pla: 0038: const LE_TKN            = $C2 // B
					; LE_TKN = 194
; toolsrc/plasm.pla: 0039: const NE_TKN            = $D5 // U
					; NE_TKN = 213
; toolsrc/plasm.pla: 0040: const EQ_TKN            = $C5 // E
					; EQ_TKN = 197
; toolsrc/plasm.pla: 0041: const LOGIC_AND_TKN     = $CE // N
					; LOGIC_AND_TKN = 206
; toolsrc/plasm.pla: 0042: const LOGIC_OR_TKN      = $CF // O
					; LOGIC_OR_TKN = 207
; toolsrc/plasm.pla: 0043: //
; toolsrc/plasm.pla: 0044: // Unary operand operators
; toolsrc/plasm.pla: 0045: //
; toolsrc/plasm.pla: 0046: const AT_TKN            = $C0 // @
					; AT_TKN = 192
; toolsrc/plasm.pla: 0047: const DOT_TKN           = $AE // .
					; DOT_TKN = 174
; toolsrc/plasm.pla: 0048: const COLON_TKN         = $BA // :
					; COLON_TKN = 186
; toolsrc/plasm.pla: 0049: const NEG_TKN           = $AD // -
					; NEG_TKN = 173
; toolsrc/plasm.pla: 0050: const POUND_TKN         = $A3 // #
					; POUND_TKN = 163
; toolsrc/plasm.pla: 0051: const COMP_TKN          = $FE // ~
					; COMP_TKN = 254
; toolsrc/plasm.pla: 0052: const LOGIC_NOT_TKN     = $A1 // !
					; LOGIC_NOT_TKN = 161
; toolsrc/plasm.pla: 0053: const BPTR_TKN          = $DE // ^
					; BPTR_TKN = 222
; toolsrc/plasm.pla: 0054: const WPTR_TKN          = $AA // *
					; WPTR_TKN = 170
; toolsrc/plasm.pla: 0055: const PTRB_TKN          = $D8 // X
					; PTRB_TKN = 216
; toolsrc/plasm.pla: 0056: const PTRW_TKN          = $D7 // W
					; PTRW_TKN = 215
; toolsrc/plasm.pla: 0057: const INC_TKN           = $C1 // A
					; INC_TKN = 193
; toolsrc/plasm.pla: 0058: const DEC_TKN           = $C4 // D
					; DEC_TKN = 196
; toolsrc/plasm.pla: 0059: const LAMBDA_TKN        = $A6 // &
					; LAMBDA_TKN = 166
; toolsrc/plasm.pla: 0060: //
; toolsrc/plasm.pla: 0061: // Enclosure tokens
; toolsrc/plasm.pla: 0062: //
; toolsrc/plasm.pla: 0063: const OPEN_PAREN_TKN    = $A8 // (
					; OPEN_PAREN_TKN = 168
; toolsrc/plasm.pla: 0064: const CLOSE_PAREN_TKN   = $A9 // )
					; CLOSE_PAREN_TKN = 169
; toolsrc/plasm.pla: 0065: const OPEN_BRACKET_TKN  = $DB // [
					; OPEN_BRACKET_TKN = 219
; toolsrc/plasm.pla: 0066: const CLOSE_BRACKET_TKN = $DD // ]
					; CLOSE_BRACKET_TKN = 221
; toolsrc/plasm.pla: 0067: //
; toolsrc/plasm.pla: 0068: // Misc. tokens
; toolsrc/plasm.pla: 0069: //
; toolsrc/plasm.pla: 0070: const COMMA_TKN         = $AC // ,
					; COMMA_TKN = 172
; toolsrc/plasm.pla: 0071: //const COMMENT_TKN       = $BB // //
; toolsrc/plasm.pla: 0072: const DROP_TKN          = $BB
					; DROP_TKN = 187
; toolsrc/plasm.pla: 0073: //
; toolsrc/plasm.pla: 0074: // Keyword tokens
; toolsrc/plasm.pla: 0075: //
; toolsrc/plasm.pla: 0076: const CONST_TKN         = $80
					; CONST_TKN = 128
; toolsrc/plasm.pla: 0077: const BYTE_TKN          = $81
					; BYTE_TKN = 129
; toolsrc/plasm.pla: 0078: const WORD_TKN          = $82
					; WORD_TKN = 130
; toolsrc/plasm.pla: 0079: const IF_TKN            = $83
					; IF_TKN = 131
; toolsrc/plasm.pla: 0080: const ELSEIF_TKN        = $84
					; ELSEIF_TKN = 132
; toolsrc/plasm.pla: 0081: const ELSE_TKN          = $85
					; ELSE_TKN = 133
; toolsrc/plasm.pla: 0082: const FIN_TKN           = $86
					; FIN_TKN = 134
; toolsrc/plasm.pla: 0083: const END_TKN           = $87
					; END_TKN = 135
; toolsrc/plasm.pla: 0084: const WHILE_TKN         = $88
					; WHILE_TKN = 136
; toolsrc/plasm.pla: 0085: const LOOP_TKN          = $89
					; LOOP_TKN = 137
; toolsrc/plasm.pla: 0086: const CASE_TKN          = $8A
					; CASE_TKN = 138
; toolsrc/plasm.pla: 0087: const OF_TKN            = $8B
					; OF_TKN = 139
; toolsrc/plasm.pla: 0088: const DEFAULT_TKN       = $8C
					; DEFAULT_TKN = 140
; toolsrc/plasm.pla: 0089: const ENDCASE_TKN       = $8D
					; ENDCASE_TKN = 141
; toolsrc/plasm.pla: 0090: const FOR_TKN           = $8E
					; FOR_TKN = 142
; toolsrc/plasm.pla: 0091: const TO_TKN            = $8F
					; TO_TKN = 143
; toolsrc/plasm.pla: 0092: const DOWNTO_TKN        = $90
					; DOWNTO_TKN = 144
; toolsrc/plasm.pla: 0093: const STEP_TKN          = $91
					; STEP_TKN = 145
; toolsrc/plasm.pla: 0094: const NEXT_TKN          = $92
					; NEXT_TKN = 146
; toolsrc/plasm.pla: 0095: const REPEAT_TKN        = $93
					; REPEAT_TKN = 147
; toolsrc/plasm.pla: 0096: const UNTIL_TKN         = $94
					; UNTIL_TKN = 148
; toolsrc/plasm.pla: 0097: const DEF_TKN           = $95
					; DEF_TKN = 149
; toolsrc/plasm.pla: 0098: const STRUC_TKN         = $96
					; STRUC_TKN = 150
; toolsrc/plasm.pla: 0099: const SYSFLAGS_TKN      = $97
					; SYSFLAGS_TKN = 151
; toolsrc/plasm.pla: 0100: const DONE_TKN          = $98
					; DONE_TKN = 152
; toolsrc/plasm.pla: 0101: const RETURN_TKN        = $99
					; RETURN_TKN = 153
; toolsrc/plasm.pla: 0102: const BREAK_TKN         = $9A
					; BREAK_TKN = 154
; toolsrc/plasm.pla: 0103: const CONT_TKN          = $9B
					; CONT_TKN = 155
; toolsrc/plasm.pla: 0104: const PREDEF_TKN        = $9C
					; PREDEF_TKN = 156
; toolsrc/plasm.pla: 0105: const IMPORT_TKN        = $9D
					; IMPORT_TKN = 157
; toolsrc/plasm.pla: 0106: const EXPORT_TKN        = $9E
					; EXPORT_TKN = 158
; toolsrc/plasm.pla: 0107: const INCLUDE_TKN       = $9F
					; INCLUDE_TKN = 159
; toolsrc/plasm.pla: 0108: //
; toolsrc/plasm.pla: 0109: // Types
; toolsrc/plasm.pla: 0110: //
; toolsrc/plasm.pla: 0111: const GLOBAL_TYPE       = $0000
					; GLOBAL_TYPE = 0
; toolsrc/plasm.pla: 0112: const CONST_TYPE        = $0001
					; CONST_TYPE = 1
; toolsrc/plasm.pla: 0113: const BYTE_TYPE         = $0002
					; BYTE_TYPE = 2
; toolsrc/plasm.pla: 0114: const WORD_TYPE         = $0004
					; WORD_TYPE = 4
; toolsrc/plasm.pla: 0115: const VAR_TYPE          = $0006 // (WORD_TYPE | BYTE_TYPE)
					; VAR_TYPE = 6
; toolsrc/plasm.pla: 0116: const FUNC_TYPE         = $0008
					; FUNC_TYPE = 8
; toolsrc/plasm.pla: 0117: const FUNC_CONST_TYPE   = $0009
					; FUNC_CONST_TYPE = 9
; toolsrc/plasm.pla: 0118: const ADDR_TYPE         = $000E // (VAR_TYPE | FUNC_TYPE)
					; ADDR_TYPE = 14
; toolsrc/plasm.pla: 0119: const LOCAL_TYPE        = $0010
					; LOCAL_TYPE = 16
; toolsrc/plasm.pla: 0120: const BPTR_TYPE         = $0020
					; BPTR_TYPE = 32
; toolsrc/plasm.pla: 0121: const WPTR_TYPE         = $0040
					; WPTR_TYPE = 64
; toolsrc/plasm.pla: 0122: const PTR_TYPE          = $0060 // (BPTR_TYPE | WPTR_TYPE)
					; PTR_TYPE = 96
; toolsrc/plasm.pla: 0123: const XBYTE_TYPE        = $0022 // (BPTR_TYPE | BYTE_TYPE)
					; XBYTE_TYPE = 34
; toolsrc/plasm.pla: 0124: const XWORD_TYPE        = $0044 // (WPTR_TYPE | WORD_TYPE)
					; XWORD_TYPE = 68
; toolsrc/plasm.pla: 0125: const CONSTADDR_TYPE    = $0061 // (CONST_TYPE | PTR_TYPE)
					; CONSTADDR_TYPE = 97
; toolsrc/plasm.pla: 0126: const STR_TYPE          = $0080
					; STR_TYPE = 128
; toolsrc/plasm.pla: 0127: const PREDEF_TYPE       = $0100
					; PREDEF_TYPE = 256
; toolsrc/plasm.pla: 0128: const EXPORT_TYPE       = $0200
					; EXPORT_TYPE = 512
; toolsrc/plasm.pla: 0129: const EXTERN_TYPE       = $0400
					; EXTERN_TYPE = 1024
; toolsrc/plasm.pla: 0130: const EXTACCESS_TYPE    = $0800
					; EXTACCESS_TYPE = 2048
; toolsrc/plasm.pla: 0131: const RELATIVE_TYPE     = $8000
					; RELATIVE_TYPE = 32768
; toolsrc/plasm.pla: 0132: //
; toolsrc/plasm.pla: 0133: // Fixup flags mask
; toolsrc/plasm.pla: 0134: //
; toolsrc/plasm.pla: 0135: const RESOLVED_FIXUP    = $01
					; RESOLVED_FIXUP = 1
; toolsrc/plasm.pla: 0136: const RELATIVE_FIXUP    = $02
					; RELATIVE_FIXUP = 2
; toolsrc/plasm.pla: 0137: const MASK_FIXUP        = $90
					; MASK_FIXUP = 144
; toolsrc/plasm.pla: 0138: const WORD_FIXUP        = $80
					; WORD_FIXUP = 128
; toolsrc/plasm.pla: 0139: const BYTE_FIXUP        = $00
					; BYTE_FIXUP = 0
; toolsrc/plasm.pla: 0140: const EXTERN_FIXUP      = $10
					; EXTERN_FIXUP = 16
; toolsrc/plasm.pla: 0141: //
; toolsrc/plasm.pla: 0142: // Keywords
; toolsrc/plasm.pla: 0143: //
; toolsrc/plasm.pla: 0144: byte keywrds            = "IF",       IF_TKN
_D036 					; keywrds            = "IF",       IF_TKN
	!BYTE	$02
	!BYTE	$49,$46
	!BYTE	$83
; toolsrc/plasm.pla: 0145: byte                    = "TO",       TO_TKN
	!BYTE	$02
	!BYTE	$54,$4F
	!BYTE	$8F
; toolsrc/plasm.pla: 0146: byte                    = "IS",       OF_TKN
	!BYTE	$02
	!BYTE	$49,$53
	!BYTE	$8B
; toolsrc/plasm.pla: 0147: byte                    = "OR",       LOGIC_OR_TKN
	!BYTE	$02
	!BYTE	$4F,$52
	!BYTE	$CF
; toolsrc/plasm.pla: 0148: byte                    = "FOR",      FOR_TKN
	!BYTE	$03
	!BYTE	$46,$4F,$52
	!BYTE	$8E
; toolsrc/plasm.pla: 0149: byte                    = "FIN",      FIN_TKN
	!BYTE	$03
	!BYTE	$46,$49,$4E
	!BYTE	$86
; toolsrc/plasm.pla: 0150: byte                    = "DEF",      DEF_TKN
	!BYTE	$03
	!BYTE	$44,$45,$46
	!BYTE	$95
; toolsrc/plasm.pla: 0151: byte                    = "END",      END_TKN
	!BYTE	$03
	!BYTE	$45,$4E,$44
	!BYTE	$87
; toolsrc/plasm.pla: 0152: byte                    = "AND",      LOGIC_AND_TKN
	!BYTE	$03
	!BYTE	$41,$4E,$44
	!BYTE	$CE
; toolsrc/plasm.pla: 0153: byte                    = "NOT",      LOGIC_NOT_TKN
	!BYTE	$03
	!BYTE	$4E,$4F,$54
	!BYTE	$A1
; toolsrc/plasm.pla: 0154: byte                    = "RES",      BYTE_TKN
	!BYTE	$03
	!BYTE	$52,$45,$53
	!BYTE	$81
; toolsrc/plasm.pla: 0155: byte                    = "VAR",      WORD_TKN
	!BYTE	$03
	!BYTE	$56,$41,$52
	!BYTE	$82
; toolsrc/plasm.pla: 0156: byte                    = "WORD",     WORD_TKN
	!BYTE	$04
	!BYTE	$57,$4F,$52,$44
	!BYTE	$82
; toolsrc/plasm.pla: 0157: byte                    = "CHAR",     BYTE_TKN
	!BYTE	$04
	!BYTE	$43,$48,$41,$52
	!BYTE	$81
; toolsrc/plasm.pla: 0158: byte                    = "BYTE",     BYTE_TKN
	!BYTE	$04
	!BYTE	$42,$59,$54,$45
	!BYTE	$81
; toolsrc/plasm.pla: 0159: byte                    = "ELSE",     ELSE_TKN
	!BYTE	$04
	!BYTE	$45,$4C,$53,$45
	!BYTE	$85
; toolsrc/plasm.pla: 0160: byte                    = "NEXT",     NEXT_TKN
	!BYTE	$04
	!BYTE	$4E,$45,$58,$54
	!BYTE	$92
; toolsrc/plasm.pla: 0161: byte                    = "WHEN",     CASE_TKN
	!BYTE	$04
	!BYTE	$57,$48,$45,$4E
	!BYTE	$8A
; toolsrc/plasm.pla: 0162: byte                    = "LOOP",     LOOP_TKN
	!BYTE	$04
	!BYTE	$4C,$4F,$4F,$50
	!BYTE	$89
; toolsrc/plasm.pla: 0163: byte                    = "STEP",     STEP_TKN
	!BYTE	$04
	!BYTE	$53,$54,$45,$50
	!BYTE	$91
; toolsrc/plasm.pla: 0164: byte                    = "DONE",     DONE_TKN
	!BYTE	$04
	!BYTE	$44,$4F,$4E,$45
	!BYTE	$98
; toolsrc/plasm.pla: 0165: byte                    = "WEND",     ENDCASE_TKN
	!BYTE	$04
	!BYTE	$57,$45,$4E,$44
	!BYTE	$8D
; toolsrc/plasm.pla: 0166: byte                    = "DROP",     DROP_TKN
	!BYTE	$04
	!BYTE	$44,$52,$4F,$50
	!BYTE	$BB
; toolsrc/plasm.pla: 0167: byte                    = "CONST",    CONST_TKN
	!BYTE	$05
	!BYTE	$43,$4F,$4E,$53,$54
	!BYTE	$80
; toolsrc/plasm.pla: 0168: byte                    = "STRUC",    STRUC_TKN
	!BYTE	$05
	!BYTE	$53,$54,$52,$55,$43
	!BYTE	$96
; toolsrc/plasm.pla: 0169: byte                    = "ELSIF",    ELSEIF_TKN
	!BYTE	$05
	!BYTE	$45,$4C,$53,$49,$46
	!BYTE	$84
; toolsrc/plasm.pla: 0170: byte                    = "WHILE",    WHILE_TKN
	!BYTE	$05
	!BYTE	$57,$48,$49,$4C,$45
	!BYTE	$88
; toolsrc/plasm.pla: 0171: byte                    = "UNTIL",    UNTIL_TKN
	!BYTE	$05
	!BYTE	$55,$4E,$54,$49,$4C
	!BYTE	$94
; toolsrc/plasm.pla: 0172: byte                    = "BREAK",    BREAK_TKN
	!BYTE	$05
	!BYTE	$42,$52,$45,$41,$4B
	!BYTE	$9A
; toolsrc/plasm.pla: 0173: byte                    = "IMPORT",   IMPORT_TKN
	!BYTE	$06
	!BYTE	$49,$4D,$50,$4F,$52,$54
	!BYTE	$9D
; toolsrc/plasm.pla: 0174: byte                    = "EXPORT",   EXPORT_TKN
	!BYTE	$06
	!BYTE	$45,$58,$50,$4F,$52,$54
	!BYTE	$9E
; toolsrc/plasm.pla: 0175: byte                    = "DOWNTO",   DOWNTO_TKN
	!BYTE	$06
	!BYTE	$44,$4F,$57,$4E,$54,$4F
	!BYTE	$90
; toolsrc/plasm.pla: 0176: byte                    = "REPEAT",   REPEAT_TKN
	!BYTE	$06
	!BYTE	$52,$45,$50,$45,$41,$54
	!BYTE	$93
; toolsrc/plasm.pla: 0177: byte                    = "RETURN",   RETURN_TKN
	!BYTE	$06
	!BYTE	$52,$45,$54,$55,$52,$4E
	!BYTE	$99
; toolsrc/plasm.pla: 0178: byte                    = "PREDEF",   PREDEF_TKN
	!BYTE	$06
	!BYTE	$50,$52,$45,$44,$45,$46
	!BYTE	$9C
; toolsrc/plasm.pla: 0179: byte                    = "INCLUDE",  INCLUDE_TKN
	!BYTE	$07
	!BYTE	$49,$4E,$43,$4C,$55,$44,$45
	!BYTE	$9F
; toolsrc/plasm.pla: 0180: byte                    = "CONTINUE", CONT_TKN
	!BYTE	$08
	!BYTE	$43,$4F,$4E,$54,$49,$4E,$55,$45
	!BYTE	$9B
; toolsrc/plasm.pla: 0181: byte                    = "SYSFLAGS", SYSFLAGS_TKN
	!BYTE	$08
	!BYTE	$53,$59,$53,$46,$4C,$41,$47,$53
	!BYTE	$97
; toolsrc/plasm.pla: 0182: byte                    = "OTHERWISE",DEFAULT_TKN
	!BYTE	$09
	!BYTE	$4F,$54,$48,$45,$52,$57,$49,$53
	!BYTE	$45
	!BYTE	$8C
; toolsrc/plasm.pla: 0183: byte                    = $FF
	!BYTE	$FF
; toolsrc/plasm.pla: 0184: //
; toolsrc/plasm.pla: 0185: // Mathematical ops
; toolsrc/plasm.pla: 0186: //
; toolsrc/plasm.pla: 0187: const bops_tblsz = 17 // minus 1
					; bops_tblsz = 17
; toolsrc/plasm.pla: 0188: byte[] bops_tbl // Highest precedence
_D037 					; bops_tbl // Highest precedence
; toolsrc/plasm.pla: 0189: byte                    = MUL_TKN, DIV_TKN, MOD_TKN
	!BYTE	$AA
	!BYTE	$AF
	!BYTE	$A5
; toolsrc/plasm.pla: 0190: byte                    = ADD_TKN, SUB_TKN
	!BYTE	$AB
	!BYTE	$AD
; toolsrc/plasm.pla: 0191: byte                    = SHR_TKN, SHL_TKN
	!BYTE	$D2
	!BYTE	$CC
; toolsrc/plasm.pla: 0192: byte                    = AND_TKN
	!BYTE	$A6
; toolsrc/plasm.pla: 0193: byte                    = EOR_TKN
	!BYTE	$DE
; toolsrc/plasm.pla: 0194: byte                    = OR_TKN
	!BYTE	$FC
; toolsrc/plasm.pla: 0195: byte                    = GT_TKN, GE_TKN, LT_TKN, LE_TKN
	!BYTE	$BE
	!BYTE	$C8
	!BYTE	$BC
	!BYTE	$C2
; toolsrc/plasm.pla: 0196: byte                    = EQ_TKN, NE_TKN
	!BYTE	$C5
	!BYTE	$D5
; toolsrc/plasm.pla: 0197:                         // Lowest precedence
; toolsrc/plasm.pla: 0198: byte[] bops_prec // Highest precedence
_D038 					; bops_prec // Highest precedence
; toolsrc/plasm.pla: 0199: byte                    = 1, 1, 1
	!BYTE	$01
	!BYTE	$01
	!BYTE	$01
; toolsrc/plasm.pla: 0200: byte                    = 2, 2
	!BYTE	$02
	!BYTE	$02
; toolsrc/plasm.pla: 0201: byte                    = 3, 3
	!BYTE	$03
	!BYTE	$03
; toolsrc/plasm.pla: 0202: byte                    = 4
	!BYTE	$04
; toolsrc/plasm.pla: 0203: byte                    = 5
	!BYTE	$05
; toolsrc/plasm.pla: 0204: byte                    = 6
	!BYTE	$06
; toolsrc/plasm.pla: 0205: byte                    = 7, 7, 7, 7
	!BYTE	$07
	!BYTE	$07
	!BYTE	$07
	!BYTE	$07
; toolsrc/plasm.pla: 0206: byte                    = 8, 8
	!BYTE	$08
	!BYTE	$08
; toolsrc/plasm.pla: 0207:                                  // Lowest precedence
; toolsrc/plasm.pla: 0208: byte[16] opstack
_D039 	!FILL	16			; opstack
; toolsrc/plasm.pla: 0209: byte[16] precstack
_D040 	!FILL	16			; precstack
; toolsrc/plasm.pla: 0210: word opsp
_D041 	!FILL	2			; opsp
; toolsrc/plasm.pla: 0211: word[16] valstack
_D042 	!FILL	32			; valstack
; toolsrc/plasm.pla: 0212: byte[16] sizestack
_D043 	!FILL	16			; sizestack
; toolsrc/plasm.pla: 0213: byte[16] typestack
_D044 	!FILL	16			; typestack
; toolsrc/plasm.pla: 0214: word valsp
_D045 	!FILL	2			; valsp
; toolsrc/plasm.pla: 0215: //
; toolsrc/plasm.pla: 0216: // Code sequence shared with optimizer
; toolsrc/plasm.pla: 0217: //
; toolsrc/plasm.pla: 0218: include "toolsrc/codeseq.plh"
; toolsrc/codeseq.plh: 0001: //
; toolsrc/codeseq.plh: 0002: // Constant code group
; toolsrc/codeseq.plh: 0003: //
; toolsrc/codeseq.plh: 0004: const CONST_GROUP       = $00
					; CONST_GROUP = 0
; toolsrc/codeseq.plh: 0005: const CONST_CODE        = $2C
					; CONST_CODE = 44
; toolsrc/codeseq.plh: 0006: const ADDI_CODE         = $38
					; ADDI_CODE = 56
; toolsrc/codeseq.plh: 0007: const SUBI_CODE         = $3A
					; SUBI_CODE = 58
; toolsrc/codeseq.plh: 0008: const ANDI_CODE         = $3C
					; ANDI_CODE = 60
; toolsrc/codeseq.plh: 0009: const ORI_CODE          = $3E
					; ORI_CODE = 62
; toolsrc/codeseq.plh: 0010: const CONSTR_GROUP      = $01
					; CONSTR_GROUP = 1
; toolsrc/codeseq.plh: 0011: const CONSTR_CODE       = $2E
					; CONSTR_CODE = 46
; toolsrc/codeseq.plh: 0012: //
; toolsrc/codeseq.plh: 0013: // Stack code group
; toolsrc/codeseq.plh: 0014: //
; toolsrc/codeseq.plh: 0015: const STACK_GROUP       = $02
					; STACK_GROUP = 2
; toolsrc/codeseq.plh: 0016: const INDEXB_CODE       = $82
					; INDEXB_CODE = 130
; toolsrc/codeseq.plh: 0017: const ADD_CODE          = $82
					; ADD_CODE = 130
; toolsrc/codeseq.plh: 0018: const SUB_CODE          = $84
					; SUB_CODE = 132
; toolsrc/codeseq.plh: 0019: const MUL_CODE          = $86
					; MUL_CODE = 134
; toolsrc/codeseq.plh: 0020: const DIV_CODE          = $88
					; DIV_CODE = 136
; toolsrc/codeseq.plh: 0021: const MOD_CODE          = $8A
					; MOD_CODE = 138
; toolsrc/codeseq.plh: 0022: const INC_CODE          = $8C
					; INC_CODE = 140
; toolsrc/codeseq.plh: 0023: const DEC_CODE          = $8E
					; DEC_CODE = 142
; toolsrc/codeseq.plh: 0024: const NEG_CODE          = $90
					; NEG_CODE = 144
; toolsrc/codeseq.plh: 0025: const COMP_CODE         = $92
					; COMP_CODE = 146
; toolsrc/codeseq.plh: 0026: const AND_CODE          = $94
					; AND_CODE = 148
; toolsrc/codeseq.plh: 0027: const OR_CODE           = $96
					; OR_CODE = 150
; toolsrc/codeseq.plh: 0028: const EOR_CODE          = $98
					; EOR_CODE = 152
; toolsrc/codeseq.plh: 0029: const SHL_CODE          = $9A
					; SHL_CODE = 154
; toolsrc/codeseq.plh: 0030: const SHR_CODE          = $9C
					; SHR_CODE = 156
; toolsrc/codeseq.plh: 0031: const INDEXW_CODE       = $9E
					; INDEXW_CODE = 158
; toolsrc/codeseq.plh: 0032: const LOGIC_NOT_CODE    = $80
					; LOGIC_NOT_CODE = 128
; toolsrc/codeseq.plh: 0033: const DROP_CODE         = $30
					; DROP_CODE = 48
; toolsrc/codeseq.plh: 0034: const DROP2_CODE        = $32
					; DROP2_CODE = 50
; toolsrc/codeseq.plh: 0035: const DUP_CODE          = $34
					; DUP_CODE = 52
; toolsrc/codeseq.plh: 0036: const EQ_CODE           = $40
					; EQ_CODE = 64
; toolsrc/codeseq.plh: 0037: const NE_CODE           = $42
					; NE_CODE = 66
; toolsrc/codeseq.plh: 0038: const GT_CODE           = $44
					; GT_CODE = 68
; toolsrc/codeseq.plh: 0039: const LT_CODE           = $46
					; LT_CODE = 70
; toolsrc/codeseq.plh: 0040: const GE_CODE           = $48
					; GE_CODE = 72
; toolsrc/codeseq.plh: 0041: const LE_CODE           = $4A
					; LE_CODE = 74
; toolsrc/codeseq.plh: 0042: const ICAL_CODE         = $56
					; ICAL_CODE = 86
; toolsrc/codeseq.plh: 0043: const RET_CODE          = $5C
					; RET_CODE = 92
; toolsrc/codeseq.plh: 0044: const LB_CODE           = $60
					; LB_CODE = 96
; toolsrc/codeseq.plh: 0045: const BPTR_CODE         = $60
					; BPTR_CODE = 96
; toolsrc/codeseq.plh: 0046: const LW_CODE           = $62
					; LW_CODE = 98
; toolsrc/codeseq.plh: 0047: const WPTR_CODE         = $62
					; WPTR_CODE = 98
; toolsrc/codeseq.plh: 0048: const SB_CODE           = $70
					; SB_CODE = 112
; toolsrc/codeseq.plh: 0049: const SW_CODE           = $72
					; SW_CODE = 114
; toolsrc/codeseq.plh: 0050: //
; toolsrc/codeseq.plh: 0051: // Local address code group
; toolsrc/codeseq.plh: 0052: //
; toolsrc/codeseq.plh: 0053: const LOCAL_GROUP       = $03
					; LOCAL_GROUP = 3
; toolsrc/codeseq.plh: 0054: const LADDR_CODE        = $28
					; LADDR_CODE = 40
; toolsrc/codeseq.plh: 0055: const LLB_CODE          = $64
					; LLB_CODE = 100
; toolsrc/codeseq.plh: 0056: const LLW_CODE          = $66
					; LLW_CODE = 102
; toolsrc/codeseq.plh: 0057: const DLB_CODE          = $6C
					; DLB_CODE = 108
; toolsrc/codeseq.plh: 0058: const DLW_CODE          = $6E
					; DLW_CODE = 110
; toolsrc/codeseq.plh: 0059: const SLB_CODE          = $74
					; SLB_CODE = 116
; toolsrc/codeseq.plh: 0060: const SLW_CODE          = $76
					; SLW_CODE = 118
; toolsrc/codeseq.plh: 0061: const ADDLB_CODE        = $B0
					; ADDLB_CODE = 176
; toolsrc/codeseq.plh: 0062: const ADDLW_CODE        = $B2
					; ADDLW_CODE = 178
; toolsrc/codeseq.plh: 0063: const IDXLB_CODE        = $B8
					; IDXLB_CODE = 184
; toolsrc/codeseq.plh: 0064: const IDXLW_CODE        = $BA
					; IDXLW_CODE = 186
; toolsrc/codeseq.plh: 0065: //
; toolsrc/codeseq.plh: 0066: // Global address code group
; toolsrc/codeseq.plh: 0067: //
; toolsrc/codeseq.plh: 0068: const GLOBAL_GROUP      = $04
					; GLOBAL_GROUP = 4
; toolsrc/codeseq.plh: 0069: const GADDR_CODE        = $26
					; GADDR_CODE = 38
; toolsrc/codeseq.plh: 0070: const CALL_CODE         = $54
					; CALL_CODE = 84
; toolsrc/codeseq.plh: 0071: const LAB_CODE          = $68
					; LAB_CODE = 104
; toolsrc/codeseq.plh: 0072: const LAW_CODE          = $6A
					; LAW_CODE = 106
; toolsrc/codeseq.plh: 0073: const SAB_CODE          = $78
					; SAB_CODE = 120
; toolsrc/codeseq.plh: 0074: const SAW_CODE          = $7A
					; SAW_CODE = 122
; toolsrc/codeseq.plh: 0075: const DAB_CODE          = $7C
					; DAB_CODE = 124
; toolsrc/codeseq.plh: 0076: const DAW_CODE          = $7E
					; DAW_CODE = 126
; toolsrc/codeseq.plh: 0077: const ADDAB_CODE        = $B4
					; ADDAB_CODE = 180
; toolsrc/codeseq.plh: 0078: const ADDAW_CODE        = $B6
					; ADDAW_CODE = 182
; toolsrc/codeseq.plh: 0079: const IDXAB_CODE        = $BC
					; IDXAB_CODE = 188
; toolsrc/codeseq.plh: 0080: const IDXAW_CODE        = $BE
					; IDXAW_CODE = 190
; toolsrc/codeseq.plh: 0081: //
; toolsrc/codeseq.plh: 0082: // Relative address code group
; toolsrc/codeseq.plh: 0083: //
; toolsrc/codeseq.plh: 0084: const RELATIVE_GROUP    = $05
					; RELATIVE_GROUP = 5
; toolsrc/codeseq.plh: 0085: const BREQ_CODE         = $22
					; BREQ_CODE = 34
; toolsrc/codeseq.plh: 0086: const BRNE_CODE         = $24
					; BRNE_CODE = 36
; toolsrc/codeseq.plh: 0087: const BRFALSE_CODE      = $4C
					; BRFALSE_CODE = 76
; toolsrc/codeseq.plh: 0088: const BRTRUE_CODE       = $4E
					; BRTRUE_CODE = 78
; toolsrc/codeseq.plh: 0089: const BRNCH_CODE        = $50
					; BRNCH_CODE = 80
; toolsrc/codeseq.plh: 0090: const BRAND_CODE        = $AC
					; BRAND_CODE = 172
; toolsrc/codeseq.plh: 0091: const BROR_CODE         = $AE
					; BROR_CODE = 174
; toolsrc/codeseq.plh: 0092: const BRGT_CODE         = $A0
					; BRGT_CODE = 160
; toolsrc/codeseq.plh: 0093: const BRLT_CODE         = $A2
					; BRLT_CODE = 162
; toolsrc/codeseq.plh: 0094: //
; toolsrc/codeseq.plh: 0095: // Code tag address group
; toolsrc/codeseq.plh: 0096: //
; toolsrc/codeseq.plh: 0097: const CODETAG_GROUP     = $06
					; CODETAG_GROUP = 6
; toolsrc/codeseq.plh: 0098: //
; toolsrc/codeseq.plh: 0099: // Invalid code
; toolsrc/codeseq.plh: 0100: //
; toolsrc/codeseq.plh: 0101: const INVALID_CODE      = $FF
					; INVALID_CODE = 255
; toolsrc/codeseq.plh: 0102: //
; toolsrc/codeseq.plh: 0103: // Code sequence op
; toolsrc/codeseq.plh: 0104: //
; toolsrc/codeseq.plh: 0105: struc t_opseq
; toolsrc/codeseq.plh: 0106:     byte opcode
					; opcode = 0
; toolsrc/codeseq.plh: 0107:     byte opgroup
					; opgroup = 1
; toolsrc/codeseq.plh: 0108:     word opval[]
					; opval = 2
; toolsrc/codeseq.plh: 0109:     word optag
					; optag = 2
; toolsrc/codeseq.plh: 0110:     word opoffset
					; opoffset = 4
; toolsrc/codeseq.plh: 0111:     word opnext
					; opnext = 6
; toolsrc/codeseq.plh: 0112: end
					; t_opseq = 8
; toolsrc/plasm.pla: 0218: 
; toolsrc/plasm.pla: 0219: //
; toolsrc/plasm.pla: 0220: //
; toolsrc/plasm.pla: 0221: // Symbol table variables
; toolsrc/plasm.pla: 0222: //
; toolsrc/plasm.pla: 0223: struc t_id
; toolsrc/plasm.pla: 0224:     word idval
					; idval = 0
; toolsrc/plasm.pla: 0225:     word idtype
					; idtype = 2
; toolsrc/plasm.pla: 0226:     byte funcparms
					; funcparms = 4
; toolsrc/plasm.pla: 0227:     byte funcvals
					; funcvals = 5
; toolsrc/plasm.pla: 0228:     byte extnum
					; extnum = 6
; toolsrc/plasm.pla: 0229:     byte idname
					; idname = 7
; toolsrc/plasm.pla: 0230: end
					; t_id = 8
; toolsrc/plasm.pla: 0231: //
; toolsrc/plasm.pla: 0232: // Generated code buffers
; toolsrc/plasm.pla: 0233: //
; toolsrc/plasm.pla: 0234: const OPSEQNUM          = 256
					; OPSEQNUM = 256
; toolsrc/plasm.pla: 0235: const DFDNUM            = 128
					; DFDNUM = 128
; toolsrc/plasm.pla: 0236: const TAGNUM            = 1024
					; TAGNUM = 1024
; toolsrc/plasm.pla: 0237: const FIXUPNUM          = 2048
					; FIXUPNUM = 2048
; toolsrc/plasm.pla: 0238: const MODDEPNUM         = 8
					; MODDEPNUM = 8
; toolsrc/plasm.pla: 0239: const IDGLOBALSZ        = 4096
					; IDGLOBALSZ = 4096
; toolsrc/plasm.pla: 0240: const IDLOCALSZ         = 512
					; IDLOCALSZ = 512
; toolsrc/plasm.pla: 0241: const CASENUM           = 64
					; CASENUM = 64
; toolsrc/plasm.pla: 0242: word fixup_cnt, tag_cnt = -1
_D046 	!FILL	2			; fixup_cnt, tag_cnt = -1
_D047 					; tag_cnt = -1
	!WORD	$FFFF
; toolsrc/plasm.pla: 0243: word dfd_tag, dfd_cnt
_D048 	!FILL	2			; dfd_tag, dfd_cnt
_D049 	!FILL	2			; dfd_cnt
; toolsrc/plasm.pla: 0244: word fixup_tag, fixup_addr
_D050 	!FILL	2			; fixup_tag, fixup_addr
_D051 	!FILL	2			; fixup_addr
; toolsrc/plasm.pla: 0245: word tag_addr, tag_type
_D052 	!FILL	2			; tag_addr, tag_type
_D053 	!FILL	2			; tag_type
; toolsrc/plasm.pla: 0246: word idglobal_tbl, idlocal_tbl
_D054 	!FILL	2			; idglobal_tbl, idlocal_tbl
_D055 	!FILL	2			; idlocal_tbl
; toolsrc/plasm.pla: 0247: word pending_seq
_D056 	!FILL	2			; pending_seq
; toolsrc/plasm.pla: 0248: word globals, lastglobal, lastglobalsize, lastlocal, savelast, savetbl
_D057 	!FILL	2			; globals, lastglobal, lastglobalsize, lastlocal, savelast, savetbl
_D058 	!FILL	2			; lastglobal, lastglobalsize, lastlocal, savelast, savetbl
_D059 	!FILL	2			; lastglobalsize, lastlocal, savelast, savetbl
_D060 	!FILL	2			; lastlocal, savelast, savetbl
_D061 	!FILL	2			; savelast, savetbl
_D062 	!FILL	2			; savetbl
; toolsrc/plasm.pla: 0249: word dfd_num, tag_num, fixup_num, globalbufsz, localbufsz, codebufsz
_D063 	!FILL	2			; dfd_num, tag_num, fixup_num, globalbufsz, localbufsz, codebufsz
_D064 	!FILL	2			; tag_num, fixup_num, globalbufsz, localbufsz, codebufsz
_D065 	!FILL	2			; fixup_num, globalbufsz, localbufsz, codebufsz
_D066 	!FILL	2			; globalbufsz, localbufsz, codebufsz
_D067 	!FILL	2			; localbufsz, codebufsz
_D068 	!FILL	2			; codebufsz
; toolsrc/plasm.pla: 0250: word datasize, framesize, savesize
_D069 	!FILL	2			; datasize, framesize, savesize
_D070 	!FILL	2			; framesize, savesize
_D071 	!FILL	2			; savesize
; toolsrc/plasm.pla: 0251: byte locals, savelocals
_D072 	!FILL	1			; locals, savelocals
_D073 	!FILL	1			; savelocals
; toolsrc/plasm.pla: 0252: word codebuff, codeptr, entrypoint
_D074 	!FILL	2			; codebuff, codeptr, entrypoint
_D075 	!FILL	2			; codeptr, entrypoint
_D076 	!FILL	2			; entrypoint
; toolsrc/plasm.pla: 0253: word modsysflags
_D077 	!FILL	2			; modsysflags
; toolsrc/plasm.pla: 0254: byte[16] moddep_tbl[MODDEPNUM]
_D078 	!FILL	128			; moddep_tbl[MODDEPNUM]
; toolsrc/plasm.pla: 0255: byte moddep_cnt, def_cnt = 1
_D079 	!FILL	1			; moddep_cnt, def_cnt = 1
_D080 					; def_cnt = 1
	!BYTE	$01
; toolsrc/plasm.pla: 0256: predef parse_mods
; toolsrc/plasm.pla: 0257: predef emit_pending_seq#0
; toolsrc/plasm.pla: 0258: //
; toolsrc/plasm.pla: 0259: // Module relocation base address
; toolsrc/plasm.pla: 0260: //
; toolsrc/plasm.pla: 0261: const RELADDR           = $1000
					; RELADDR = 4096
; toolsrc/plasm.pla: 0262: //
; toolsrc/plasm.pla: 0263: // Exports for optimizer module
; toolsrc/plasm.pla: 0264: //
; toolsrc/plasm.pla: 0265: export word freeop_lst
_D083 	!FILL	2			; freeop_lst
; toolsrc/plasm.pla: 0266: export word optimize_seq
_D084 	!FILL	2			; optimize_seq
; toolsrc/plasm.pla: 0267: //
; toolsrc/plasm.pla: 0268: // Compiler flags
; toolsrc/plasm.pla: 0269: //
; toolsrc/plasm.pla: 0270: const OPTIMIZE          = 1
					; OPTIMIZE = 1
; toolsrc/plasm.pla: 0271: const OPTIMIZE2         = 2
					; OPTIMIZE2 = 2
; toolsrc/plasm.pla: 0272: const NO_COMBINE        = 4
					; NO_COMBINE = 4
; toolsrc/plasm.pla: 0273: const WARNINGS          = 8
					; WARNINGS = 8
; toolsrc/plasm.pla: 0274: byte outflags
_D085 	!FILL	1			; outflags
; toolsrc/plasm.pla: 0275: //
; toolsrc/plasm.pla: 0276: // ProDOS/SOS file references
; toolsrc/plasm.pla: 0277: //
; toolsrc/plasm.pla: 0278: byte refnum, srcref, incref
_D086 	!FILL	1			; refnum, srcref, incref
_D087 	!FILL	1			; srcref, incref
_D088 	!FILL	1			; incref
; toolsrc/plasm.pla: 0279: byte[32] srcfile, incfile, relfile, modfile
_D089 	!FILL	32			; srcfile, incfile, relfile, modfile
_D090 	!FILL	32			; incfile, relfile, modfile
_D091 	!FILL	32			; relfile, modfile
_D092 	!FILL	32			; modfile
; toolsrc/plasm.pla: 0280: word parsefile            // Pointer to current file
_D093 	!FILL	2			; parsefile            // Pointer to current file
; toolsrc/plasm.pla: 0281: word srcline              // Saved source line number
_D094 	!FILL	2			; srcline              // Saved source line number
; toolsrc/plasm.pla: 0282: //
; toolsrc/plasm.pla: 0283: // Scanner variables
; toolsrc/plasm.pla: 0284: //
; toolsrc/plasm.pla: 0285: word instr
_D095 	!FILL	2			; instr
; toolsrc/plasm.pla: 0286: word inbuff
_D096 	!FILL	2			; inbuff
; toolsrc/plasm.pla: 0287: word scanptr
_D097 	!FILL	2			; scanptr
; toolsrc/plasm.pla: 0288: byte token             = EOL_TKN
_D098 					; token             = EOL_TKN
	!BYTE	$02
; toolsrc/plasm.pla: 0289: byte scanchr, tknlen
_D099 	!FILL	1			; scanchr, tknlen
_D100 	!FILL	1			; tknlen
; toolsrc/plasm.pla: 0290: word tknptr, parserrln
_D101 	!FILL	2			; tknptr, parserrln
_D102 	!FILL	2			; parserrln
; toolsrc/plasm.pla: 0291: word constval
_D103 	!FILL	2			; constval
; toolsrc/plasm.pla: 0292: word lineno
_D104 	!FILL	2			; lineno
; toolsrc/plasm.pla: 0293: //
; toolsrc/plasm.pla: 0294: // Parser variables
; toolsrc/plasm.pla: 0295: //
; toolsrc/plasm.pla: 0296: const LVALUE            = 0
					; LVALUE = 0
; toolsrc/plasm.pla: 0297: const RVALUE            = 1
					; RVALUE = 1
; toolsrc/plasm.pla: 0298: const LAMBDANUM         = 16
					; LAMBDANUM = 16
; toolsrc/plasm.pla: 0299: word strconstbuff
_D105 	!FILL	2			; strconstbuff
; toolsrc/plasm.pla: 0300: word strconstptr
_D106 	!FILL	2			; strconstptr
; toolsrc/plasm.pla: 0301: byte infunc, inlambda
_D107 	!FILL	1			; infunc, inlambda
_D108 	!FILL	1			; inlambda
; toolsrc/plasm.pla: 0302: byte stack_loop
_D109 	!FILL	1			; stack_loop
; toolsrc/plasm.pla: 0303: byte prevstmnt
_D110 	!FILL	1			; prevstmnt
; toolsrc/plasm.pla: 0304: word infuncvals
_D111 	!FILL	2			; infuncvals
; toolsrc/plasm.pla: 0305: word break_tag
_D112 	!FILL	2			; break_tag
; toolsrc/plasm.pla: 0306: word cont_tag
_D113 	!FILL	2			; cont_tag
; toolsrc/plasm.pla: 0307: byte lambda_cnt, lambda_num
_D114 	!FILL	1			; lambda_cnt, lambda_num
_D115 	!FILL	1			; lambda_num
; toolsrc/plasm.pla: 0308: byte[LAMBDANUM] lambda_cparms
_D116 	!FILL	16			; lambda_cparms
; toolsrc/plasm.pla: 0309: word[LAMBDANUM] lambda_seq, lambda_tag
_D117 	!FILL	32			; lambda_seq, lambda_tag
_D118 	!FILL	32			; lambda_tag
; toolsrc/plasm.pla: 0310: predef parse_constexpr#3, parse_expr(codeseq)#2, parse_lambda
; toolsrc/plasm.pla: 0311: byte bytesln = " bytes\n"
_D122 					; bytesln = " bytes\n"
	!BYTE	$07
	!BYTE	$20,$62,$79,$74,$65,$73,$0D
; toolsrc/plasm.pla: 0312: //
; toolsrc/plasm.pla: 0313: // Arg pointer
; toolsrc/plasm.pla: 0314: //
; toolsrc/plasm.pla: 0315: word arg, opt
_D123 	!FILL	2			; arg, opt
_D124 	!FILL	2			; opt
; toolsrc/plasm.pla: 0316: //
; toolsrc/plasm.pla: 0317: // Long jump environment
; toolsrc/plasm.pla: 0318: //
; toolsrc/plasm.pla: 0319: word exit
_D125 	!FILL	2			; exit
; toolsrc/plasm.pla: 0320: //
; toolsrc/plasm.pla: 0321: // Error string flags
; toolsrc/plasm.pla: 0322: //
; toolsrc/plasm.pla: 0323: const ERR_DUP           = $0001
					; ERR_DUP = 1
; toolsrc/plasm.pla: 0324: const ERR_UNDECL        = $0002
					; ERR_UNDECL = 2
; toolsrc/plasm.pla: 0325: const ERR_INVAL         = $0004
					; ERR_INVAL = 4
; toolsrc/plasm.pla: 0326: const ERR_MISS          = $0008
					; ERR_MISS = 8
; toolsrc/plasm.pla: 0327: const ERR_OVER          = $0010
					; ERR_OVER = 16
; toolsrc/plasm.pla: 0328: const ERR_CLOSE         = $0020
					; ERR_CLOSE = 32
; toolsrc/plasm.pla: 0329: const ERR_LOCAL         = $0040
					; ERR_LOCAL = 64
; toolsrc/plasm.pla: 0330: const ERR_GLOBAL        = $0080
					; ERR_GLOBAL = 128
; toolsrc/plasm.pla: 0331: const ERR_CODE          = $0100
					; ERR_CODE = 256
; toolsrc/plasm.pla: 0332: const ERR_ID            = $0200
					; ERR_ID = 512
; toolsrc/plasm.pla: 0333: const ERR_CONST         = $0400
					; ERR_CONST = 1024
; toolsrc/plasm.pla: 0334: const ERR_INIT          = $0800
					; ERR_INIT = 2048
; toolsrc/plasm.pla: 0335: const ERR_STATE         = $1000
					; ERR_STATE = 4096
; toolsrc/plasm.pla: 0336: const ERR_FRAME         = $2000
					; ERR_FRAME = 8192
; toolsrc/plasm.pla: 0337: const ERR_TABLE         = $4000
					; ERR_TABLE = 16384
; toolsrc/plasm.pla: 0338: const ERR_SYNTAX        = $8000
					; ERR_SYNTAX = 32768
; toolsrc/plasm.pla: 0339: 
; toolsrc/plasm.pla: 0340: //=====================================
; toolsrc/plasm.pla: 0341: //
; toolsrc/plasm.pla: 0342: //           PLASMA Compiler
; toolsrc/plasm.pla: 0343: //
; toolsrc/plasm.pla: 0344: //=====================================
; toolsrc/plasm.pla: 0345: 
; toolsrc/plasm.pla: 0346: //
; toolsrc/plasm.pla: 0347: // Lexical scanner helper for keyword/IDs
; toolsrc/plasm.pla: 0348: //
; toolsrc/plasm.pla: 0349: asm scanid(scanptr, keywrds)#3
_A000 					; scanid()
; toolsrc/plasm.pla: 0350:         !SOURCE    "vmsrc/plvmzp.inc"
        !SOURCE    "vmsrc/plvmzp.inc"
; toolsrc/plasm.pla: 0351:         LDA     ESTKL,X
        LDA     ESTKL,X
; toolsrc/plasm.pla: 0352:         STA     DSTL
        STA     DSTL
; toolsrc/plasm.pla: 0353:         LDA     ESTKH,X
        LDA     ESTKH,X
; toolsrc/plasm.pla: 0354:         STA     DSTH
        STA     DSTH
; toolsrc/plasm.pla: 0355:         LDA     ESTKL+1,X
        LDA     ESTKL+1,X
; toolsrc/plasm.pla: 0356:         STA     ESTKL,X         ; COPY OUTPUT SCANPTR
        STA     ESTKL,X         ; COPY OUTPUT SCANPTR
; toolsrc/plasm.pla: 0357:         STA     SRCL
        STA     SRCL
; toolsrc/plasm.pla: 0358:         LDA     ESTKH+1,X
        LDA     ESTKH+1,X
; toolsrc/plasm.pla: 0359:         STA     ESTKH,X
        STA     ESTKH,X
; toolsrc/plasm.pla: 0360:         STA     SRCH
        STA     SRCH
; toolsrc/plasm.pla: 0361:         DEX
        DEX
; toolsrc/plasm.pla: 0362:         LDA     #$00
        LDA     #$00
; toolsrc/plasm.pla: 0363:         STA     ESTKL,X         ; CLEAR OUTPUT TOKEN
        STA     ESTKL,X         ; CLEAR OUTPUT TOKEN
; toolsrc/plasm.pla: 0364:         STA     ESTKH,X
        STA     ESTKH,X
; toolsrc/plasm.pla: 0365:         STA     ESTKH+2,X       ; CLEAR MSB OF SCANCHR
        STA     ESTKH+2,X       ; CLEAR MSB OF SCANCHR
; toolsrc/plasm.pla: 0366:         TAY
        TAY
; toolsrc/plasm.pla: 0367:         LDA     (SRC),Y
        LDA     (SRC),Y
; toolsrc/plasm.pla: 0368:         AND     #$7F
        AND     #$7F
; toolsrc/plasm.pla: 0369:         CMP     #'a'
        CMP     #'a'
; toolsrc/plasm.pla: 0370:         BCC     +
        BCC     +
; toolsrc/plasm.pla: 0371:         CMP     #'z'+1
        CMP     #'z'+1
; toolsrc/plasm.pla: 0372:         BCS     +
        BCS     +
; toolsrc/plasm.pla: 0373:         SBC     #$1F
        SBC     #$1F
; toolsrc/plasm.pla: 0374:         STA     (SRC),Y
        STA     (SRC),Y
; toolsrc/plasm.pla: 0375: +       STA     ESTKL+2,X       ; SET SCANCHR
+       STA     ESTKL+2,X       ; SET SCANCHR
; toolsrc/plasm.pla: 0376:         CMP     #'_'
        CMP     #'_'
; toolsrc/plasm.pla: 0377:         BEQ     +
        BEQ     +
; toolsrc/plasm.pla: 0378:         CMP     #'A'
        CMP     #'A'
; toolsrc/plasm.pla: 0379:         BCC     SCANEX
        BCC     SCANEX
; toolsrc/plasm.pla: 0380:         CMP     #'Z'+1
        CMP     #'Z'+1
; toolsrc/plasm.pla: 0381:         BCS     SCANEX
        BCS     SCANEX
; toolsrc/plasm.pla: 0382: +       LDA     #$D6            ; ID_TKN
+       LDA     #$D6            ; ID_TKN
; toolsrc/plasm.pla: 0383:         STA     ESTKL,X         ; SET OUTPUT TOKEN = ID_TKN
        STA     ESTKL,X         ; SET OUTPUT TOKEN = ID_TKN
; toolsrc/plasm.pla: 0384: SCANID  INY
SCANID  INY
; toolsrc/plasm.pla: 0385:         LDA     (SRC),Y
        LDA     (SRC),Y
; toolsrc/plasm.pla: 0386:         AND     #$7F
        AND     #$7F
; toolsrc/plasm.pla: 0387:         BEQ     ++
        BEQ     ++
; toolsrc/plasm.pla: 0388:         CMP     #'a'
        CMP     #'a'
; toolsrc/plasm.pla: 0389:         BCC     +
        BCC     +
; toolsrc/plasm.pla: 0390:         CMP     #'z'+1
        CMP     #'z'+1
; toolsrc/plasm.pla: 0391:         BCS     ++
        BCS     ++
; toolsrc/plasm.pla: 0392:         SBC     #$1F
        SBC     #$1F
; toolsrc/plasm.pla: 0393:         STA     (SRC),Y         ; COPY UPPERCASE CHAR BACK TO ^SCANPTR
        STA     (SRC),Y         ; COPY UPPERCASE CHAR BACK TO ^SCANPTR
; toolsrc/plasm.pla: 0394:         BNE     SCANID
        BNE     SCANID
; toolsrc/plasm.pla: 0395: +       CMP     #'_'
+       CMP     #'_'
; toolsrc/plasm.pla: 0396:         BEQ     SCANID
        BEQ     SCANID
; toolsrc/plasm.pla: 0397:         CMP     #'0'
        CMP     #'0'
; toolsrc/plasm.pla: 0398:         BCC     ++
        BCC     ++
; toolsrc/plasm.pla: 0399:         CMP     #'9'+1
        CMP     #'9'+1
; toolsrc/plasm.pla: 0400:         BCC     SCANID
        BCC     SCANID
; toolsrc/plasm.pla: 0401:         CMP     #'A'
        CMP     #'A'
; toolsrc/plasm.pla: 0402:         BCC     ++
        BCC     ++
; toolsrc/plasm.pla: 0403:         CMP     #'Z'+1
        CMP     #'Z'+1
; toolsrc/plasm.pla: 0404:         BCC     SCANID
        BCC     SCANID
; toolsrc/plasm.pla: 0405: ++      STY     TMPL
++      STY     TMPL
; toolsrc/plasm.pla: 0406:         TYA
        TYA
; toolsrc/plasm.pla: 0407:         LDY     #$00
        LDY     #$00
; toolsrc/plasm.pla: 0408:         CLC
        CLC
; toolsrc/plasm.pla: 0409:         ADC     SRCL
        ADC     SRCL
; toolsrc/plasm.pla: 0410:         STA     ESTKL+1,X       ; UPDATE SCANPTR
        STA     ESTKL+1,X       ; UPDATE SCANPTR
; toolsrc/plasm.pla: 0411:         BCC     MATCHLEN
        BCC     MATCHLEN
; toolsrc/plasm.pla: 0412:         INC     ESTKH+1,X
        INC     ESTKH+1,X
; toolsrc/plasm.pla: 0413: MATCHLEN LDA    (DST),Y
MATCHLEN LDA    (DST),Y
; toolsrc/plasm.pla: 0414:         CMP     TMPL
        CMP     TMPL
; toolsrc/plasm.pla: 0415:         BCS     +
        BCS     +
; toolsrc/plasm.pla: 0416:         ADC     #$02
        ADC     #$02
; toolsrc/plasm.pla: 0417:         ADC     DSTL
        ADC     DSTL
; toolsrc/plasm.pla: 0418:         STA     DSTL
        STA     DSTL
; toolsrc/plasm.pla: 0419:         BCC     MATCHLEN
        BCC     MATCHLEN
; toolsrc/plasm.pla: 0420:         INC     DSTH
        INC     DSTH
; toolsrc/plasm.pla: 0421:         BNE     MATCHLEN
        BNE     MATCHLEN
; toolsrc/plasm.pla: 0422: +       BNE     SCANEX          ; NO KEY MATCH
+       BNE     SCANEX          ; NO KEY MATCH
; toolsrc/plasm.pla: 0423:         TAY
        TAY
; toolsrc/plasm.pla: 0424:         DEY
        DEY
; toolsrc/plasm.pla: 0425:         INC     DSTL
        INC     DSTL
; toolsrc/plasm.pla: 0426:         BNE     MATCHKEY
        BNE     MATCHKEY
; toolsrc/plasm.pla: 0427:         INC     DSTH
        INC     DSTH
; toolsrc/plasm.pla: 0428: MATCHKEY LDA     (SRC),Y
MATCHKEY LDA     (SRC),Y
; toolsrc/plasm.pla: 0429:         CMP     (DST),Y
        CMP     (DST),Y
; toolsrc/plasm.pla: 0430:         BNE     NEXTKEY
        BNE     NEXTKEY
; toolsrc/plasm.pla: 0431:         DEY
        DEY
; toolsrc/plasm.pla: 0432:         BPL     MATCHKEY
        BPL     MATCHKEY
; toolsrc/plasm.pla: 0433:         LDY     TMPL
        LDY     TMPL
; toolsrc/plasm.pla: 0434:         LDA     (DST),Y
        LDA     (DST),Y
; toolsrc/plasm.pla: 0435:         STA     ESTKL,X         ; SET OUTPUT TOKEN
        STA     ESTKL,X         ; SET OUTPUT TOKEN
; toolsrc/plasm.pla: 0436: SCANEX  RTS
SCANEX  RTS
; toolsrc/plasm.pla: 0437: NEXTKEY LDY     #$00
NEXTKEY LDY     #$00
; toolsrc/plasm.pla: 0438:         LDA     TMPL
        LDA     TMPL
; toolsrc/plasm.pla: 0439:         SEC
        SEC
; toolsrc/plasm.pla: 0440:         ADC     DSTL
        ADC     DSTL
; toolsrc/plasm.pla: 0441:         STA     DSTL
        STA     DSTL
; toolsrc/plasm.pla: 0442:         BCC     MATCHLEN
        BCC     MATCHLEN
; toolsrc/plasm.pla: 0443:         INC     DSTH
        INC     DSTH
; toolsrc/plasm.pla: 0444:         BNE     MATCHLEN
        BNE     MATCHLEN
; toolsrc/plasm.pla: 0445: end
; toolsrc/plasm.pla: 0446: //
; toolsrc/plasm.pla: 0447: // Handy functions
; toolsrc/plasm.pla: 0448: //
; toolsrc/plasm.pla: 0449: def nametostr(namestr, len, strptr)#0
_SUBSEG 				; BYTECODE STARTS
					; namestr -> [0]
					; len -> [2]
					; strptr -> [4]
_C000 					; nametostr()
; toolsrc/plasm.pla: 0450:     ^strptr = len
	!BYTE	$58,$06,$03		; ENTER	6,3
; toolsrc/plasm.pla: 0451:     memcpy(strptr + 1, namestr, len)
; toolsrc/plasm.pla: 0452: end
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_X018
_F000 	!WORD	0		
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/plasm.pla: 0453: def putcurln#0
_C001 					; putcurln()
; toolsrc/plasm.pla: 0454:     byte i
					; i -> [0]
; toolsrc/plasm.pla: 0455:     putln; puts(parsefile); putc('['); puti(lineno); puts("]\n")
	!BYTE	$58,$01,$00		; ENTER	1,0
	!BYTE	$54			; CALL	_X003
_F001 	!WORD	0		
	!BYTE	$6A			; LAW	_D093+0
_F002 	!WORD	_D093+0		
	!BYTE	$54			; CALL	_X004
_F003 	!WORD	0		
	!BYTE	$2A,$5B			; CB	91
	!BYTE	$54			; CALL	_X002
_F004 	!WORD	0		
	!BYTE	$6A			; LAW	_D104+0
_F005 	!WORD	_D104+0		
	!BYTE	$54			; CALL	_X005
_F006 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$5D,$0D
	!BYTE	$54			; CALL	_X004
_F007 	!WORD	0		
; toolsrc/plasm.pla: 0456:     puts(instr); putln
; toolsrc/plasm.pla: 0457:     for i = tknptr - inbuff downto 1
	!BYTE	$6A			; LAW	_D095+0
_F008 	!WORD	_D095+0		
	!BYTE	$54			; CALL	_X004
_F009 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F010 	!WORD	0		
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_D101+0
_F011 	!WORD	_D101+0		
	!BYTE	$6A			; LAW	_D096+0
_F012 	!WORD	_D096+0		
	!BYTE	$84			; SUB 
	!BYTE	$A2			; BRLT	_B001
	!WORD	_B001-*
_B002 
	!BYTE	$6C,$00			; DLB	[0]
; toolsrc/plasm.pla: 0458:         putc(' ')
; toolsrc/plasm.pla: 0459:     next
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_X002
_F013 	!WORD	0		
_B003 
	!BYTE	$A8			; DECBRGE	_B002
	!WORD	_B002-*
_B001 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; toolsrc/plasm.pla: 0460:     puts("^\n")
	!BYTE	$2E			; CS
	!BYTE	$02
	!BYTE	$5E,$0D
	!BYTE	$54			; CALL	_X004
_F014 	!WORD	0		
; toolsrc/plasm.pla: 0461: end
	!BYTE	$5A,$01			; LEAVE	1
; toolsrc/plasm.pla: 0462: //
; toolsrc/plasm.pla: 0463: // Error handler
; toolsrc/plasm.pla: 0464: //
; toolsrc/plasm.pla: 0465: def exit_err(err)#0
					; err -> [0]
_C002 					; exit_err()
; toolsrc/plasm.pla: 0466:     byte i
					; i -> [2]
; toolsrc/plasm.pla: 0467: 
; toolsrc/plasm.pla: 0468:     puts("\nError:")
	!BYTE	$58,$03,$01		; ENTER	3,1
	!BYTE	$2E			; CS
	!BYTE	$07
	!BYTE	$0D,$45,$72,$72,$6F,$72,$3A
	!BYTE	$54			; CALL	_X004
_F015 	!WORD	0		
; toolsrc/plasm.pla: 0469:     if err & ERR_DUP;    puts("duplicate ");  fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B004
	!WORD	_B004-*
	!BYTE	$2E			; CS
	!BYTE	$0A
	!BYTE	$64,$75,$70,$6C,$69,$63,$61,$74
	!BYTE	$65,$20
	!BYTE	$54			; CALL	_X004
_F016 	!WORD	0		
_B004 
_B005 
; toolsrc/plasm.pla: 0470:     if err & ERR_UNDECL; puts("undeclared "); fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B006
	!WORD	_B006-*
	!BYTE	$2E			; CS
	!BYTE	$0B
	!BYTE	$75,$6E,$64,$65,$63,$6C,$61,$72
	!BYTE	$65,$64,$20
	!BYTE	$54			; CALL	_X004
_F017 	!WORD	0		
_B006 
_B007 
; toolsrc/plasm.pla: 0471:     if err & ERR_INVAL;  puts("invalid ");    fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B008
	!WORD	_B008-*
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$69,$6E,$76,$61,$6C,$69,$64,$20
	!BYTE	$54			; CALL	_X004
_F018 	!WORD	0		
_B008 
_B009 
; toolsrc/plasm.pla: 0472:     if err & ERR_MISS;   puts("missing ");    fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B010
	!WORD	_B010-*
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$6D,$69,$73,$73,$69,$6E,$67,$20
	!BYTE	$54			; CALL	_X004
_F019 	!WORD	0		
_B010 
_B011 
; toolsrc/plasm.pla: 0473:     if err & ERR_OVER;   puts("overflowed "); fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B012
	!WORD	_B012-*
	!BYTE	$2E			; CS
	!BYTE	$0B
	!BYTE	$6F,$76,$65,$72,$66,$6C,$6F,$77
	!BYTE	$65,$64,$20
	!BYTE	$54			; CALL	_X004
_F020 	!WORD	0		
_B012 
_B013 
; toolsrc/plasm.pla: 0474:     if err & ERR_CLOSE;  puts("closing ");    fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$4C			; BRFLS	_B014
	!WORD	_B014-*
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$63,$6C,$6F,$73,$69,$6E,$67,$20
	!BYTE	$54			; CALL	_X004
_F021 	!WORD	0		
_B014 
_B015 
; toolsrc/plasm.pla: 0475:     if err & ERR_LOCAL;  puts("local ");      fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$40			; ANDI	64
	!BYTE	$4C			; BRFLS	_B016
	!WORD	_B016-*
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$6C,$6F,$63,$61,$6C,$20
	!BYTE	$54			; CALL	_X004
_F022 	!WORD	0		
_B016 
_B017 
; toolsrc/plasm.pla: 0476:     if err & ERR_GLOBAL; puts("global ");     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4C			; BRFLS	_B018
	!WORD	_B018-*
	!BYTE	$2E			; CS
	!BYTE	$07
	!BYTE	$67,$6C,$6F,$62,$61,$6C,$20
	!BYTE	$54			; CALL	_X004
_F023 	!WORD	0		
_B018 
_B019 
; toolsrc/plasm.pla: 0477:     if err & ERR_CODE;   puts("code ");       fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$00,$01		; CW	256
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B020
	!WORD	_B020-*
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$63,$6F,$64,$65,$20
	!BYTE	$54			; CALL	_X004
_F024 	!WORD	0		
_B020 
_B021 
; toolsrc/plasm.pla: 0478:     if err & ERR_ID;     puts("identifier "); fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B022
	!WORD	_B022-*
	!BYTE	$2E			; CS
	!BYTE	$0B
	!BYTE	$69,$64,$65,$6E,$74,$69,$66,$69
	!BYTE	$65,$72,$20
	!BYTE	$54			; CALL	_X004
_F025 	!WORD	0		
_B022 
_B023 
; toolsrc/plasm.pla: 0479:     if err & ERR_CONST;  puts("constant");    fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$00,$04		; CW	1024
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B024
	!WORD	_B024-*
	!BYTE	$2E			; CS
	!BYTE	$08
	!BYTE	$63,$6F,$6E,$73,$74,$61,$6E,$74
	!BYTE	$54			; CALL	_X004
_F026 	!WORD	0		
_B024 
_B025 
; toolsrc/plasm.pla: 0480:     if err & ERR_INIT;   puts("initializer"); fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B026
	!WORD	_B026-*
	!BYTE	$2E			; CS
	!BYTE	$0B
	!BYTE	$69,$6E,$69,$74,$69,$61,$6C,$69
	!BYTE	$7A,$65,$72
	!BYTE	$54			; CALL	_X004
_F027 	!WORD	0		
_B026 
_B027 
; toolsrc/plasm.pla: 0481:     if err & ERR_STATE;  puts("statement");   fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B028
	!WORD	_B028-*
	!BYTE	$2E			; CS
	!BYTE	$09
	!BYTE	$73,$74,$61,$74,$65,$6D,$65,$6E
	!BYTE	$74
	!BYTE	$54			; CALL	_X004
_F028 	!WORD	0		
_B028 
_B029 
; toolsrc/plasm.pla: 0482:     if err & ERR_FRAME;  puts("frame");       fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$00,$20		; CW	8192
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B030
	!WORD	_B030-*
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$66,$72,$61,$6D,$65
	!BYTE	$54			; CALL	_X004
_F029 	!WORD	0		
_B030 
_B031 
; toolsrc/plasm.pla: 0483:     if err & ERR_TABLE;  puts("table");       fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$00,$40		; CW	16384
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B032
	!WORD	_B032-*
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$74,$61,$62,$6C,$65
	!BYTE	$54			; CALL	_X004
_F030 	!WORD	0		
_B032 
_B033 
; toolsrc/plasm.pla: 0484:     if err & ERR_SYNTAX; puts("syntax");      fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$00,$80		; CW	32768
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B034
	!WORD	_B034-*
	!BYTE	$2E			; CS
	!BYTE	$06
	!BYTE	$73,$79,$6E,$74,$61,$78
	!BYTE	$54			; CALL	_X004
_F031 	!WORD	0		
_B034 
_B035 
; toolsrc/plasm.pla: 0485:     putcurln
; toolsrc/plasm.pla: 0486:     if incref
; toolsrc/plasm.pla: 0487:         fileio:close(incref) // Close include file if open
; toolsrc/plasm.pla: 0488:     fin
	!BYTE	$54			; CALL	_C001
_F032 	!WORD	_C001		
	!BYTE	$68			; LAB	_D088+0
_F033 	!WORD	_D088+0		
	!BYTE	$4C			; BRFLS	_B036
	!WORD	_B036-*
	!BYTE	$68			; LAB	_D088+0
_F034 	!WORD	_D088+0		
	!BYTE	$6A			; LAW	_X031+16
_F035 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
_B036 
_B037 
; toolsrc/plasm.pla: 0489:     fileio:close(srcref) // Close source file
; toolsrc/plasm.pla: 0490:     throw(exit, TRUE)
; toolsrc/plasm.pla: 0491: end
	!BYTE	$68			; LAB	_D087+0
_F036 	!WORD	_D087+0		
	!BYTE	$6A			; LAW	_X031+16
_F037 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D125+0
_F038 	!WORD	_D125+0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$54			; CALL	_X035
_F039 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$5A,$03			; LEAVE	3
; toolsrc/plasm.pla: 0492: //
; toolsrc/plasm.pla: 0493: // Warning
; toolsrc/plasm.pla: 0494: //
; toolsrc/plasm.pla: 0495: def parse_warn(msg)#0
					; msg -> [0]
_C003 					; parse_warn()
; toolsrc/plasm.pla: 0496:     if outflags & WARNINGS
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/plasm.pla: 0497:         puts("\nWarning:")
	!BYTE	$68			; LAB	_D085+0
_F040 	!WORD	_D085+0		
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B038
	!WORD	_B038-*
	!BYTE	$2E			; CS
	!BYTE	$09
	!BYTE	$0D,$57,$61,$72,$6E,$69,$6E,$67
	!BYTE	$3A
	!BYTE	$54			; CALL	_X004
_F041 	!WORD	0		
; toolsrc/plasm.pla: 0498:         puts(msg)
; toolsrc/plasm.pla: 0499:         putcurln
; toolsrc/plasm.pla: 0500:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X004
_F042 	!WORD	0		
	!BYTE	$54			; CALL	_C001
_F043 	!WORD	_C001		
_B038 
_B039 
; toolsrc/plasm.pla: 0501: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/plasm.pla: 0502: //
; toolsrc/plasm.pla: 0503: // Include code to reduce size of this file
; toolsrc/plasm.pla: 0504: //
; toolsrc/plasm.pla: 0505: include "toolsrc/codegen.pla"
; toolsrc/codegen.pla: 0001: //
; toolsrc/codegen.pla: 0002: // Address tags
; toolsrc/codegen.pla: 0003: //
; toolsrc/codegen.pla: 0004: def new_tag(type)
					; type -> [0]
_C004 					; new_tag()
; toolsrc/codegen.pla: 0005:     tag_cnt++
	!BYTE	$58,$02,$01		; ENTER	2,1
	!BYTE	$6A			; LAW	_D047+0
_F044 	!WORD	_D047+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0006:     if tag_cnt >= tag_num; exit_err(ERR_OVER|ERR_CODE|ERR_TABLE); fin
	!BYTE	$7E			; DAW	_D047+0
_F045 	!WORD	_D047+0		
	!BYTE	$6A			; LAW	_D064+0
_F046 	!WORD	_D064+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B040
	!WORD	_B040-*
	!BYTE	$2C,$10,$41		; CW	16656
	!BYTE	$54			; CALL	_C002
_F047 	!WORD	_C002		
_B040 
_B041 
; toolsrc/codegen.pla: 0007:     tag_addr=>[tag_cnt] = 0 // Unresolved, nothing to update yet
; toolsrc/codegen.pla: 0008:     tag_type->[tag_cnt] = type
; toolsrc/codegen.pla: 0009:     return tag_cnt
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D052+0
_F048 	!WORD	_D052+0		
	!BYTE	$BE			; IDXAW	_D047+0
_F049 	!WORD	_D047+0		
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D053+0
_F050 	!WORD	_D053+0		
	!BYTE	$B6			; ADDAW	_D047+0
_F051 	!WORD	_D047+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D047+0
_F052 	!WORD	_D047+0		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0010: end
; toolsrc/codegen.pla: 0011: //
; toolsrc/codegen.pla: 0012: // New/release sequence ops
; toolsrc/codegen.pla: 0013: //
; toolsrc/codegen.pla: 0014: def new_op
_C005 					; new_op()
; toolsrc/codegen.pla: 0015:     word op
					; op -> [0]
; toolsrc/codegen.pla: 0016:     op = freeop_lst
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/codegen.pla: 0017:     if not op
; toolsrc/codegen.pla: 0018:         puts("Compiler out of sequence ops!")
	!BYTE	$6A			; LAW	_D083+0
_F053 	!WORD	_D083+0		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$4E			; BRTRU	_B042
	!WORD	_B042-*
	!BYTE	$2E			; CS
	!BYTE	$1D
	!BYTE	$43,$6F,$6D,$70,$69,$6C,$65,$72
	!BYTE	$20,$6F,$75,$74,$20,$6F,$66,$20
	!BYTE	$73,$65,$71,$75,$65,$6E,$63,$65
	!BYTE	$20,$6F,$70,$73,$21
	!BYTE	$54			; CALL	_X004
_F054 	!WORD	0		
; toolsrc/codegen.pla: 0019:         return NULL
	!BYTE	$00			; CN	0
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0020:     fin
_B042 
_B043 
; toolsrc/codegen.pla: 0021:     freeop_lst = freeop_lst=>opnext
; toolsrc/codegen.pla: 0022:     op=>opnext = NULL
; toolsrc/codegen.pla: 0023:     return op
	!BYTE	$6A			; LAW	_D083+0
_F055 	!WORD	_D083+0		
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$7A			; SAW	_D083+0
_F056 	!WORD	_D083+0		
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0024: end
; toolsrc/codegen.pla: 0025: def release_op(op)#0
					; op -> [0]
_C006 					; release_op()
; toolsrc/codegen.pla: 0026:     if op
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0027:         op=>opnext = freeop_lst
; toolsrc/codegen.pla: 0028:         freeop_lst = op
; toolsrc/codegen.pla: 0029:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4C			; BRFLS	_B044
	!WORD	_B044-*
	!BYTE	$6A			; LAW	_D083+0
_F057 	!WORD	_D083+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D083+0
_F058 	!WORD	_D083+0		
_B044 
_B045 
; toolsrc/codegen.pla: 0030: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0031: def release_seq(seq)#0
					; seq -> [0]
_C007 					; release_seq()
; toolsrc/codegen.pla: 0032:     word op
					; op -> [2]
; toolsrc/codegen.pla: 0033: 
; toolsrc/codegen.pla: 0034:     while seq
	!BYTE	$58,$04,$01		; ENTER	4,1
	!BYTE	$50			; BRNCH	_B048
	!WORD	_B048-*
_B046 
; toolsrc/codegen.pla: 0035:         op = seq
; toolsrc/codegen.pla: 0036:         seq = seq=>opnext
; toolsrc/codegen.pla: 0037:         //
; toolsrc/codegen.pla: 0038:         //Free this op
; toolsrc/codegen.pla: 0039:         //
; toolsrc/codegen.pla: 0040:         op=>opnext = freeop_lst
; toolsrc/codegen.pla: 0041:         freeop_lst = op
; toolsrc/codegen.pla: 0042:     loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$6A			; LAW	_D083+0
_F059 	!WORD	_D083+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$7A			; SAW	_D083+0
_F060 	!WORD	_D083+0		
_B048 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B046
	!WORD	_B046-*
_B047 
; toolsrc/codegen.pla: 0043: end
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/codegen.pla: 0044: //
; toolsrc/codegen.pla: 0045: // Append one sequence to the end of another
; toolsrc/codegen.pla: 0046: //
; toolsrc/codegen.pla: 0047: def cat_seq(seq1, seq2)
					; seq1 -> [0]
					; seq2 -> [2]
_C008 					; cat_seq()
; toolsrc/codegen.pla: 0048:     word op
					; op -> [4]
; toolsrc/codegen.pla: 0049: 
; toolsrc/codegen.pla: 0050:     if not seq1; return seq2; fin
	!BYTE	$58,$06,$02		; ENTER	6,2
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B049
	!WORD	_B049-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$5A,$06			; LEAVE	6
_B049 
_B050 
; toolsrc/codegen.pla: 0051:     op = seq1
; toolsrc/codegen.pla: 0052:     while op=>opnext; op = op=>opnext; loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B053
	!WORD	_B053-*
_B051 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
_B053 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B051
	!WORD	_B051-*
_B052 
; toolsrc/codegen.pla: 0053:     op=>opnext = seq2
; toolsrc/codegen.pla: 0054:     return seq1
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/codegen.pla: 0055: end
; toolsrc/codegen.pla: 0056: //
; toolsrc/codegen.pla: 0057: // Emit data/bytecode
; toolsrc/codegen.pla: 0058: //
; toolsrc/codegen.pla: 0059: def emit_byte(bval)#0
					; bval -> [0]
_C009 					; emit_byte()
; toolsrc/codegen.pla: 0060:     ^codeptr = bval
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0061:     codeptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D075+0
_F061 	!WORD	_D075+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D075+0
_F062 	!WORD	_D075+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0062:     if codeptr - codebuff > codebufsz; exit_err(ERR_OVER|ERR_CODE|ERR_TABLE); fin
	!BYTE	$7E			; DAW	_D075+0
_F063 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D074+0
_F064 	!WORD	_D074+0		
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_D068+0
_F065 	!WORD	_D068+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B054
	!WORD	_B054-*
	!BYTE	$2C,$10,$41		; CW	16656
	!BYTE	$54			; CALL	_C002
_F066 	!WORD	_C002		
_B054 
_B055 
; toolsrc/codegen.pla: 0063: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0064: def emit_word(wval)#0
					; wval -> [0]
_C010 					; emit_word()
; toolsrc/codegen.pla: 0065:     *codeptr = wval
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0066:     codeptr  = codeptr + 2
; toolsrc/codegen.pla: 0067:     if codeptr - codebuff > codebufsz; exit_err(ERR_OVER|ERR_CODE|ERR_TABLE); fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D075+0
_F067 	!WORD	_D075+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D075+0
_F068 	!WORD	_D075+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7E			; DAW	_D075+0
_F069 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D074+0
_F070 	!WORD	_D074+0		
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_D068+0
_F071 	!WORD	_D068+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B056
	!WORD	_B056-*
	!BYTE	$2C,$10,$41		; CW	16656
	!BYTE	$54			; CALL	_C002
_F072 	!WORD	_C002		
_B056 
_B057 
; toolsrc/codegen.pla: 0068: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0069: def emit_fill(size)#0
					; size -> [0]
_C011 					; emit_fill()
; toolsrc/codegen.pla: 0070:     memset(codeptr, 0, size)
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0071:     codeptr = codeptr + size
; toolsrc/codegen.pla: 0072:     if codeptr - codebuff > codebufsz; exit_err(ERR_OVER|ERR_CODE|ERR_TABLE); fin
	!BYTE	$6A			; LAW	_D075+0
_F073 	!WORD	_D075+0		
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_X017
_F074 	!WORD	0		
	!BYTE	$6A			; LAW	_D075+0
_F075 	!WORD	_D075+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$7E			; DAW	_D075+0
_F076 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D074+0
_F077 	!WORD	_D074+0		
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_D068+0
_F078 	!WORD	_D068+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B058
	!WORD	_B058-*
	!BYTE	$2C,$10,$41		; CW	16656
	!BYTE	$54			; CALL	_C002
_F079 	!WORD	_C002		
_B058 
_B059 
; toolsrc/codegen.pla: 0073: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0074: def emit_addr(tag, offset)#0
					; tag -> [0]
					; offset -> [2]
_C012 					; emit_addr()
; toolsrc/codegen.pla: 0075:     if tag_type->[tag] & RELATIVE_FIXUP; puts("Global fixup to relative tag"); exit_err(0); fin // DEBUG
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$6A			; LAW	_D053+0
_F080 	!WORD	_D053+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B060
	!WORD	_B060-*
	!BYTE	$2E			; CS
	!BYTE	$1C
	!BYTE	$47,$6C,$6F,$62,$61,$6C,$20,$66
	!BYTE	$69,$78,$75,$70,$20,$74,$6F,$20
	!BYTE	$72,$65,$6C,$61,$74,$69,$76,$65
	!BYTE	$20,$74,$61,$67
	!BYTE	$54			; CALL	_X004
_F081 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C002
_F082 	!WORD	_C002		
_B060 
_B061 
; toolsrc/codegen.pla: 0076:     fixup_tag=>[fixup_cnt]  = tag
; toolsrc/codegen.pla: 0077:     fixup_addr=>[fixup_cnt] = codeptr
; toolsrc/codegen.pla: 0078:     fixup_cnt++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D050+0
_F083 	!WORD	_D050+0		
	!BYTE	$BE			; IDXAW	_D046+0
_F084 	!WORD	_D046+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D075+0
_F085 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D051+0
_F086 	!WORD	_D051+0		
	!BYTE	$BE			; IDXAW	_D046+0
_F087 	!WORD	_D046+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D046+0
_F088 	!WORD	_D046+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0079:     if fixup_cnt >= fixup_num; exit_err(ERR_OVER|ERR_ID|ERR_TABLE); fin
	!BYTE	$7E			; DAW	_D046+0
_F089 	!WORD	_D046+0		
	!BYTE	$6A			; LAW	_D065+0
_F090 	!WORD	_D065+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B062
	!WORD	_B062-*
	!BYTE	$2C,$10,$42		; CW	16912
	!BYTE	$54			; CALL	_C002
_F091 	!WORD	_C002		
_B062 
_B063 
; toolsrc/codegen.pla: 0080:     emit_word(offset + tag_addr=>[tag])
; toolsrc/codegen.pla: 0081: end
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D052+0
_F092 	!WORD	_D052+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_C010
_F093 	!WORD	_C010		
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/codegen.pla: 0082: def emit_reladdr(tag)#0
					; tag -> [0]
_C013 					; emit_reladdr()
; toolsrc/codegen.pla: 0083:     word updtptr
					; updtptr -> [2]
; toolsrc/codegen.pla: 0084: 
; toolsrc/codegen.pla: 0085:     if not (tag_type->[tag] & RELATIVE_FIXUP); puts("Not relative tag fixup"); exit_err(0); fin // DEBUG
	!BYTE	$58,$04,$01		; ENTER	4,1
	!BYTE	$6A			; LAW	_D053+0
_F094 	!WORD	_D053+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4E			; BRTRU	_B064
	!WORD	_B064-*
	!BYTE	$2E			; CS
	!BYTE	$16
	!BYTE	$4E,$6F,$74,$20,$72,$65,$6C,$61
	!BYTE	$74,$69,$76,$65,$20,$74,$61,$67
	!BYTE	$20,$66,$69,$78,$75,$70
	!BYTE	$54			; CALL	_X004
_F095 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C002
_F096 	!WORD	_C002		
_B064 
_B065 
; toolsrc/codegen.pla: 0086:     if tag_type->[tag] & RESOLVED_FIXUP
; toolsrc/codegen.pla: 0087:         updtptr = tag_addr=>[tag] - codeptr
; toolsrc/codegen.pla: 0088:     else
	!BYTE	$6A			; LAW	_D053+0
_F097 	!WORD	_D053+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B066
	!WORD	_B066-*
	!BYTE	$6A			; LAW	_D052+0
_F098 	!WORD	_D052+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D075+0
_F099 	!WORD	_D075+0		
	!BYTE	$84			; SUB 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B067
	!WORD	_B067-*
_B066 
; toolsrc/codegen.pla: 0089:         //
; toolsrc/codegen.pla: 0090:         // Add to list of tags needing resolution
; toolsrc/codegen.pla: 0091:         //
; toolsrc/codegen.pla: 0092:         updtptr         = tag_addr=>[tag]
; toolsrc/codegen.pla: 0093:         tag_addr=>[tag] = codeptr
; toolsrc/codegen.pla: 0094:     fin
	!BYTE	$6A			; LAW	_D052+0
_F100 	!WORD	_D052+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$6A			; LAW	_D075+0
_F101 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D052+0
_F102 	!WORD	_D052+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$72			; SW
_B067 
; toolsrc/codegen.pla: 0095:     emit_word(updtptr)
; toolsrc/codegen.pla: 0096: end
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C010
_F103 	!WORD	_C010		
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/codegen.pla: 0097: def emit_data(vartype, consttype, constval, constsize)
					; vartype -> [0]
					; consttype -> [2]
					; constval -> [4]
					; constsize -> [6]
_C014 					; emit_data()
; toolsrc/codegen.pla: 0098:     byte type
					; type -> [8]
; toolsrc/codegen.pla: 0099:     word size, chrptr
					; size -> [9]
					; chrptr -> [11]
; toolsrc/codegen.pla: 0100: 
; toolsrc/codegen.pla: 0101:     if consttype == 0
	!BYTE	$58,$0D,$04		; ENTER	13,4
; toolsrc/codegen.pla: 0102:         size = constsize
; toolsrc/codegen.pla: 0103:         emit_fill(constsize)
; toolsrc/codegen.pla: 0104:     elsif consttype == STR_TYPE
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B068
	!WORD	_B068-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$76,$09			; SLW	[9]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C011
_F104 	!WORD	_C011		
	!BYTE	$50			; BRNCH	_B069
	!WORD	_B069-*
_B068 
; toolsrc/codegen.pla: 0105:         constsize = ^constval
; toolsrc/codegen.pla: 0106:         size      = constsize + 1
; toolsrc/codegen.pla: 0107:         chrptr    = constval  + 1
; toolsrc/codegen.pla: 0108:         emit_byte(constsize)
; toolsrc/codegen.pla: 0109:         while constsize > 0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$80			; CB	128
	!BYTE	$24			; BRNE	_B070
	!WORD	_B070-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$60			; LB
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$8C			; INCR
	!BYTE	$76,$09			; SLW	[9]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$76,$0B			; SLW	[11]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C009
_F105 	!WORD	_C009		
	!BYTE	$50			; BRNCH	_B073
	!WORD	_B073-*
_B071 
; toolsrc/codegen.pla: 0110:             emit_byte(^chrptr)
; toolsrc/codegen.pla: 0111:             chrptr++
	!BYTE	$66,$0B			; LLW	[11]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_C009
_F106 	!WORD	_C009		
	!BYTE	$66,$0B			; LLW	[11]
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0112:             constsize--
	!BYTE	$76,$0B			; SLW	[11]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8E			; DECR
; toolsrc/codegen.pla: 0113:         loop
	!BYTE	$76,$06			; SLW	[6]
_B073 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B071
	!WORD	_B071-*
_B072 
; toolsrc/codegen.pla: 0114:     elsif consttype == CONSTADDR_TYPE
	!BYTE	$50			; BRNCH	_B069
	!WORD	_B069-*
_B070 
; toolsrc/codegen.pla: 0115:         size = 2
; toolsrc/codegen.pla: 0116:         emit_addr(constval, 0)
; toolsrc/codegen.pla: 0117:     else
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$61			; CB	97
	!BYTE	$24			; BRNE	_B074
	!WORD	_B074-*
	!BYTE	$04			; CN	2
	!BYTE	$76,$09			; SLW	[9]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C012
_F107 	!WORD	_C012		
	!BYTE	$50			; BRNCH	_B069
	!WORD	_B069-*
_B074 
; toolsrc/codegen.pla: 0118:         if vartype & BYTE_TYPE
; toolsrc/codegen.pla: 0119:             size = 1
; toolsrc/codegen.pla: 0120:             emit_byte(constval)
; toolsrc/codegen.pla: 0121:         else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B075
	!WORD	_B075-*
	!BYTE	$02			; CN	1
	!BYTE	$76,$09			; SLW	[9]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C009
_F108 	!WORD	_C009		
	!BYTE	$50			; BRNCH	_B076
	!WORD	_B076-*
_B075 
; toolsrc/codegen.pla: 0122:             size = 2
; toolsrc/codegen.pla: 0123:             emit_word(constval)
; toolsrc/codegen.pla: 0124:         fin
	!BYTE	$04			; CN	2
	!BYTE	$76,$09			; SLW	[9]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C010
_F109 	!WORD	_C010		
_B076 
; toolsrc/codegen.pla: 0125:     fin
_B069 
; toolsrc/codegen.pla: 0126:     return size
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$5A,$0D			; LEAVE	13
; toolsrc/codegen.pla: 0127: end
; toolsrc/codegen.pla: 0128: def emit_codeseg#0
_C015 					; emit_codeseg()
; toolsrc/codegen.pla: 0129:     if lastglobalsize == 0
; toolsrc/codegen.pla: 0130:         emit_byte($00)          // Pad byte between last data tag and code seg
; toolsrc/codegen.pla: 0131:     fin
	!BYTE	$6A			; LAW	_D059+0
_F110 	!WORD	_D059+0		
	!BYTE	$4E			; BRTRU	_B077
	!WORD	_B077-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C009
_F111 	!WORD	_C009		
_B077 
_B078 
; toolsrc/codegen.pla: 0132: end
	!BYTE	$5C			; RET
; toolsrc/codegen.pla: 0133: def emit_const(cval)#0
					; cval -> [0]
_C016 					; emit_const()
; toolsrc/codegen.pla: 0134:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0135:     if cval == $FFFF            // MINUS ONE
; toolsrc/codegen.pla: 0136:         emit_byte($20)
; toolsrc/codegen.pla: 0137:     elsif cval & $FFF0 == $0000 // Constant NYBBLE
	!BYTE	$54			; CALL	_P001
_F112 	!WORD	_P001		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$20			; MINUS ONE
	!BYTE	$24			; BRNE	_B079
	!WORD	_B079-*
	!BYTE	$2A,$20			; CB	32
	!BYTE	$54			; CALL	_C009
_F113 	!WORD	_C009		
	!BYTE	$50			; BRNCH	_B080
	!WORD	_B080-*
_B079 
; toolsrc/codegen.pla: 0138:         emit_byte(cval*2)
; toolsrc/codegen.pla: 0139:     elsif cval & $FF00 == $0000 // Constant BYTE
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5E,$F0			; CFFB	65520
	!BYTE	$94			; AND 
	!BYTE	$4E			; BRTRU	_B081
	!WORD	_B081-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_C009
_F114 	!WORD	_C009		
	!BYTE	$50			; BRNCH	_B080
	!WORD	_B080-*
_B081 
; toolsrc/codegen.pla: 0140:         emit_byte($2A)
; toolsrc/codegen.pla: 0141:         emit_byte(cval)
; toolsrc/codegen.pla: 0142:     elsif cval & $FF00 == $FF00 // Constant $FF00 | BYTE
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5E,$00			; CFFB	65280
	!BYTE	$94			; AND 
	!BYTE	$4E			; BRTRU	_B082
	!WORD	_B082-*
	!BYTE	$2A,$2A			; CB	42
	!BYTE	$54			; CALL	_C009
_F115 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C009
_F116 	!WORD	_C009		
	!BYTE	$50			; BRNCH	_B080
	!WORD	_B080-*
_B082 
; toolsrc/codegen.pla: 0143:         emit_byte($5E)
; toolsrc/codegen.pla: 0144:         emit_byte(cval)
; toolsrc/codegen.pla: 0145:     else                        // Constant WORD
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5E,$00			; CFFB	65280
	!BYTE	$94			; AND 
	!BYTE	$5E,$00			; CFFB	65280
	!BYTE	$24			; BRNE	_B083
	!WORD	_B083-*
	!BYTE	$2A,$5E			; CB	94
	!BYTE	$54			; CALL	_C009
_F117 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C009
_F118 	!WORD	_C009		
	!BYTE	$50			; BRNCH	_B080
	!WORD	_B080-*
_B083 
; toolsrc/codegen.pla: 0146:         emit_byte($2C)
; toolsrc/codegen.pla: 0147:         emit_word(cval)
; toolsrc/codegen.pla: 0148:     fin
	!BYTE	$2A,$2C			; CB	44
	!BYTE	$54			; CALL	_C009
_F119 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C010
_F120 	!WORD	_C010		
_B080 
; toolsrc/codegen.pla: 0149: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0150: def emit_code(bval)#0
					; bval -> [0]
_C017 					; emit_code()
; toolsrc/codegen.pla: 0151:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0152:     ^codeptr = bval
; toolsrc/codegen.pla: 0153:     codeptr++
	!BYTE	$54			; CALL	_P001
_F121 	!WORD	_P001		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D075+0
_F122 	!WORD	_D075+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D075+0
_F123 	!WORD	_D075+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0154:     if codeptr - codebuff > codebufsz; exit_err(ERR_OVER|ERR_CODE|ERR_TABLE); fin
	!BYTE	$7E			; DAW	_D075+0
_F124 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D074+0
_F125 	!WORD	_D074+0		
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_D068+0
_F126 	!WORD	_D068+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B084
	!WORD	_B084-*
	!BYTE	$2C,$10,$41		; CW	16656
	!BYTE	$54			; CALL	_C002
_F127 	!WORD	_C002		
_B084 
_B085 
; toolsrc/codegen.pla: 0155: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0156: def emit_slb(offset)#0
					; offset -> [0]
_C018 					; emit_slb()
; toolsrc/codegen.pla: 0157:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0158:     emit_byte($74)
; toolsrc/codegen.pla: 0159:     emit_byte(offset)
; toolsrc/codegen.pla: 0160: end
	!BYTE	$54			; CALL	_P001
_F128 	!WORD	_P001		
	!BYTE	$2A,$74			; CB	116
	!BYTE	$54			; CALL	_C009
_F129 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C009
_F130 	!WORD	_C009		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0161: def emit_slw(offset)#0
					; offset -> [0]
_C019 					; emit_slw()
; toolsrc/codegen.pla: 0162:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0163:     emit_byte($76)
; toolsrc/codegen.pla: 0164:     emit_byte(offset)
; toolsrc/codegen.pla: 0165: end
	!BYTE	$54			; CALL	_P001
_F131 	!WORD	_P001		
	!BYTE	$2A,$76			; CB	118
	!BYTE	$54			; CALL	_C009
_F132 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C009
_F133 	!WORD	_C009		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0166: def emit_sab(tag, offset)#0
					; tag -> [0]
					; offset -> [2]
_C020 					; emit_sab()
; toolsrc/codegen.pla: 0167:     emit_pending_seq
	!BYTE	$58,$04,$02		; ENTER	4,2
; toolsrc/codegen.pla: 0168:     emit_byte($78)
; toolsrc/codegen.pla: 0169:     emit_addr(tag, offset)
; toolsrc/codegen.pla: 0170: end
	!BYTE	$54			; CALL	_P001
_F134 	!WORD	_P001		
	!BYTE	$2A,$78			; CB	120
	!BYTE	$54			; CALL	_C009
_F135 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C012
_F136 	!WORD	_C012		
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/codegen.pla: 0171: def emit_saw(tag, offset)#0
					; tag -> [0]
					; offset -> [2]
_C021 					; emit_saw()
; toolsrc/codegen.pla: 0172:     emit_pending_seq
	!BYTE	$58,$04,$02		; ENTER	4,2
; toolsrc/codegen.pla: 0173:     emit_byte($7A)
; toolsrc/codegen.pla: 0174:     emit_addr(tag, offset)
; toolsrc/codegen.pla: 0175: end
	!BYTE	$54			; CALL	_P001
_F137 	!WORD	_P001		
	!BYTE	$2A,$7A			; CB	122
	!BYTE	$54			; CALL	_C009
_F138 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C012
_F139 	!WORD	_C012		
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/codegen.pla: 0176: def emit_dlb(offset)#0
					; offset -> [0]
_C022 					; emit_dlb()
; toolsrc/codegen.pla: 0177:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0178:     emit_byte($6C)
; toolsrc/codegen.pla: 0179:     emit_byte(offset)
; toolsrc/codegen.pla: 0180: end
	!BYTE	$54			; CALL	_P001
_F140 	!WORD	_P001		
	!BYTE	$2A,$6C			; CB	108
	!BYTE	$54			; CALL	_C009
_F141 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C009
_F142 	!WORD	_C009		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0181: def emit_dlw(offset)#0
					; offset -> [0]
_C023 					; emit_dlw()
; toolsrc/codegen.pla: 0182:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0183:     emit_byte($6E)
; toolsrc/codegen.pla: 0184:     emit_byte(offset)
; toolsrc/codegen.pla: 0185: end
	!BYTE	$54			; CALL	_P001
_F143 	!WORD	_P001		
	!BYTE	$2A,$6E			; CB	110
	!BYTE	$54			; CALL	_C009
_F144 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C009
_F145 	!WORD	_C009		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0186: def emit_dab(tag, offset)#0
					; tag -> [0]
					; offset -> [2]
_C024 					; emit_dab()
; toolsrc/codegen.pla: 0187:     emit_pending_seq
	!BYTE	$58,$04,$02		; ENTER	4,2
; toolsrc/codegen.pla: 0188:     emit_byte($7C)
; toolsrc/codegen.pla: 0189:     emit_addr(tag, offset)
; toolsrc/codegen.pla: 0190: end
	!BYTE	$54			; CALL	_P001
_F146 	!WORD	_P001		
	!BYTE	$2A,$7C			; CB	124
	!BYTE	$54			; CALL	_C009
_F147 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C012
_F148 	!WORD	_C012		
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/codegen.pla: 0191: def emit_daw(tag, offset)#0
					; tag -> [0]
					; offset -> [2]
_C025 					; emit_daw()
; toolsrc/codegen.pla: 0192:     emit_pending_seq
	!BYTE	$58,$04,$02		; ENTER	4,2
; toolsrc/codegen.pla: 0193:     emit_byte($7E)
; toolsrc/codegen.pla: 0194:     emit_addr(tag, offset)
; toolsrc/codegen.pla: 0195: end
	!BYTE	$54			; CALL	_P001
_F149 	!WORD	_P001		
	!BYTE	$2A,$7E			; CB	126
	!BYTE	$54			; CALL	_C009
_F150 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C012
_F151 	!WORD	_C012		
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/codegen.pla: 0196: def emit_select(tag)#0
					; tag -> [0]
_C026 					; emit_select()
; toolsrc/codegen.pla: 0197:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0198:     emit_byte($52)
; toolsrc/codegen.pla: 0199:     emit_reladdr(tag)
; toolsrc/codegen.pla: 0200: end
	!BYTE	$54			; CALL	_P001
_F152 	!WORD	_P001		
	!BYTE	$2A,$52			; CB	82
	!BYTE	$54			; CALL	_C009
_F153 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C013
_F154 	!WORD	_C013		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0201: def emit_caseblock(cnt, oflist, taglist)#0
					; cnt -> [0]
					; oflist -> [2]
					; taglist -> [4]
_C027 					; emit_caseblock()
; toolsrc/codegen.pla: 0202:     byte i
					; i -> [6]
; toolsrc/codegen.pla: 0203: 
; toolsrc/codegen.pla: 0204:     if not cnt or cnt > 256; exit_err(ERR_OVER|ERR_STATE); fin
	!BYTE	$58,$07,$03		; ENTER	7,3
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$80			; NOT
	!BYTE	$AE			; BROR	_B086
	!WORD	_B086-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$00,$01		; CW	256
	!BYTE	$44			; ISGT
_B086 
	!BYTE	$4C			; BRFLS	_B087
	!WORD	_B087-*
	!BYTE	$2C,$10,$10		; CW	4112
	!BYTE	$54			; CALL	_C002
_F155 	!WORD	_C002		
_B087 
_B088 
; toolsrc/codegen.pla: 0205:     emit_pending_seq
; toolsrc/codegen.pla: 0206:     emit_byte(cnt)
; toolsrc/codegen.pla: 0207:     for i = 0 to cnt-1
	!BYTE	$54			; CALL	_P001
_F156 	!WORD	_P001		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C009
_F157 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$8E			; DECR
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B089
	!WORD	_B089-*
_B090 
	!BYTE	$6C,$06			; DLB	[6]
; toolsrc/codegen.pla: 0208:         emit_word(oflist=>[i])
; toolsrc/codegen.pla: 0209:         emit_reladdr(taglist=>[i])
; toolsrc/codegen.pla: 0210:     next
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B8,$06			; IDXLB	[6]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C010
_F158 	!WORD	_C010		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$B8,$06			; IDXLB	[6]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C013
_F159 	!WORD	_C013		
_B091 
	!BYTE	$A4			; INCBRLE	_B090
	!WORD	_B090-*
_B089 
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$30			; DROP 
; toolsrc/codegen.pla: 0211: end
	!BYTE	$5A,$07			; LEAVE	7
; toolsrc/codegen.pla: 0212: def emit_branch(tag)#0
					; tag -> [0]
_C028 					; emit_branch()
; toolsrc/codegen.pla: 0213:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0214:     emit_byte($50)
; toolsrc/codegen.pla: 0215:     emit_reladdr(tag)
; toolsrc/codegen.pla: 0216: end
	!BYTE	$54			; CALL	_P001
_F160 	!WORD	_P001		
	!BYTE	$2A,$50			; CB	80
	!BYTE	$54			; CALL	_C009
_F161 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C013
_F162 	!WORD	_C013		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0217: def emit_brgt(tag)#0
					; tag -> [0]
_C029 					; emit_brgt()
; toolsrc/codegen.pla: 0218:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0219:     emit_byte($A0)
; toolsrc/codegen.pla: 0220:     emit_reladdr(tag)
; toolsrc/codegen.pla: 0221: end
	!BYTE	$54			; CALL	_P001
_F163 	!WORD	_P001		
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$54			; CALL	_C009
_F164 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C013
_F165 	!WORD	_C013		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0222: def emit_brlt(tag)#0
					; tag -> [0]
_C030 					; emit_brlt()
; toolsrc/codegen.pla: 0223:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0224:     emit_byte($A2)
; toolsrc/codegen.pla: 0225:     emit_reladdr(tag)
; toolsrc/codegen.pla: 0226: end
	!BYTE	$54			; CALL	_P001
_F166 	!WORD	_P001		
	!BYTE	$2A,$A2			; CB	162
	!BYTE	$54			; CALL	_C009
_F167 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C013
_F168 	!WORD	_C013		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0227: def emit_incbrle(tag)#0
					; tag -> [0]
_C031 					; emit_incbrle()
; toolsrc/codegen.pla: 0228:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0229:     emit_byte($A4)
; toolsrc/codegen.pla: 0230:     emit_reladdr(tag)
; toolsrc/codegen.pla: 0231: end
	!BYTE	$54			; CALL	_P001
_F169 	!WORD	_P001		
	!BYTE	$2A,$A4			; CB	164
	!BYTE	$54			; CALL	_C009
_F170 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C013
_F171 	!WORD	_C013		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0232: def emit_addbrle(tag)#0
					; tag -> [0]
_C032 					; emit_addbrle()
; toolsrc/codegen.pla: 0233:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0234:     emit_byte($A6)
; toolsrc/codegen.pla: 0235:     emit_reladdr(tag)
; toolsrc/codegen.pla: 0236: end
	!BYTE	$54			; CALL	_P001
_F172 	!WORD	_P001		
	!BYTE	$2A,$A6			; CB	166
	!BYTE	$54			; CALL	_C009
_F173 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C013
_F174 	!WORD	_C013		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0237: def emit_decbrge(tag)#0
					; tag -> [0]
_C033 					; emit_decbrge()
; toolsrc/codegen.pla: 0238:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0239:     emit_byte($A8)
; toolsrc/codegen.pla: 0240:     emit_reladdr(tag)
; toolsrc/codegen.pla: 0241: end
	!BYTE	$54			; CALL	_P001
_F175 	!WORD	_P001		
	!BYTE	$2A,$A8			; CB	168
	!BYTE	$54			; CALL	_C009
_F176 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C013
_F177 	!WORD	_C013		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0242: def emit_subbrge(tag)#0
					; tag -> [0]
_C034 					; emit_subbrge()
; toolsrc/codegen.pla: 0243:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0244:     emit_byte($AA)
; toolsrc/codegen.pla: 0245:     emit_reladdr(tag)
; toolsrc/codegen.pla: 0246: end
	!BYTE	$54			; CALL	_P001
_F178 	!WORD	_P001		
	!BYTE	$2A,$AA			; CB	170
	!BYTE	$54			; CALL	_C009
_F179 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C013
_F180 	!WORD	_C013		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0247: def emit_brand(tag)#0
					; tag -> [0]
_C035 					; emit_brand()
; toolsrc/codegen.pla: 0248:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0249:     emit_byte($AC)
; toolsrc/codegen.pla: 0250:     emit_reladdr(tag)
; toolsrc/codegen.pla: 0251: end
	!BYTE	$54			; CALL	_P001
_F181 	!WORD	_P001		
	!BYTE	$2A,$AC			; CB	172
	!BYTE	$54			; CALL	_C009
_F182 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C013
_F183 	!WORD	_C013		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0252: def emit_bror(tag)#0
					; tag -> [0]
_C036 					; emit_bror()
; toolsrc/codegen.pla: 0253:     emit_pending_seq
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0254:     emit_byte($AE)
; toolsrc/codegen.pla: 0255:     emit_reladdr(tag)
; toolsrc/codegen.pla: 0256: end
	!BYTE	$54			; CALL	_P001
_F184 	!WORD	_P001		
	!BYTE	$2A,$AE			; CB	174
	!BYTE	$54			; CALL	_C009
_F185 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C013
_F186 	!WORD	_C013		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0257: def emit_leave#0
_C037 					; emit_leave()
; toolsrc/codegen.pla: 0258:     emit_pending_seq
; toolsrc/codegen.pla: 0259:     if framesize
; toolsrc/codegen.pla: 0260:         emit_byte($5A)
; toolsrc/codegen.pla: 0261:         emit_byte(framesize)
; toolsrc/codegen.pla: 0262:     else
	!BYTE	$54			; CALL	_P001
_F187 	!WORD	_P001		
	!BYTE	$6A			; LAW	_D070+0
_F188 	!WORD	_D070+0		
	!BYTE	$4C			; BRFLS	_B092
	!WORD	_B092-*
	!BYTE	$2A,$5A			; CB	90
	!BYTE	$54			; CALL	_C009
_F189 	!WORD	_C009		
	!BYTE	$6A			; LAW	_D070+0
_F190 	!WORD	_D070+0		
	!BYTE	$54			; CALL	_C009
_F191 	!WORD	_C009		
	!BYTE	$50			; BRNCH	_B093
	!WORD	_B093-*
_B092 
; toolsrc/codegen.pla: 0263:         emit_byte($5C)
; toolsrc/codegen.pla: 0264:     fin
	!BYTE	$2A,$5C			; CB	92
	!BYTE	$54			; CALL	_C009
_F192 	!WORD	_C009		
_B093 
; toolsrc/codegen.pla: 0265: end
	!BYTE	$5C			; RET
; toolsrc/codegen.pla: 0266: def emit_enter(cparms)#0
					; cparms -> [0]
_C038 					; emit_enter()
; toolsrc/codegen.pla: 0267:     if framesize
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/codegen.pla: 0268:         emit_byte($58)
; toolsrc/codegen.pla: 0269:         emit_byte(framesize)
; toolsrc/codegen.pla: 0270:         emit_byte(cparms)
; toolsrc/codegen.pla: 0271:     fin
	!BYTE	$6A			; LAW	_D070+0
_F193 	!WORD	_D070+0		
	!BYTE	$4C			; BRFLS	_B094
	!WORD	_B094-*
	!BYTE	$2A,$58			; CB	88
	!BYTE	$54			; CALL	_C009
_F194 	!WORD	_C009		
	!BYTE	$6A			; LAW	_D070+0
_F195 	!WORD	_D070+0		
	!BYTE	$54			; CALL	_C009
_F196 	!WORD	_C009		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C009
_F197 	!WORD	_C009		
_B094 
_B095 
; toolsrc/codegen.pla: 0272: end
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0273: def emit_tag(tag)#0
					; tag -> [0]
_C039 					; emit_tag()
; toolsrc/codegen.pla: 0274:     word fixups, updtptr, nextptr, codeofst
					; fixups -> [2]
					; updtptr -> [4]
					; nextptr -> [6]
					; codeofst -> [8]
; toolsrc/codegen.pla: 0275: 
; toolsrc/codegen.pla: 0276:     emit_pending_seq
	!BYTE	$58,$0A,$01		; ENTER	10,1
; toolsrc/codegen.pla: 0277:     if tag_type->[tag] & RESOLVED_FIXUP; puts("Tag already resolved"); exit_err(0); fin // DEBUG
	!BYTE	$54			; CALL	_P001
_F198 	!WORD	_P001		
	!BYTE	$6A			; LAW	_D053+0
_F199 	!WORD	_D053+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B096
	!WORD	_B096-*
	!BYTE	$2E			; CS
	!BYTE	$14
	!BYTE	$54,$61,$67,$20,$61,$6C,$72,$65
	!BYTE	$61,$64,$79,$20,$72,$65,$73,$6F
	!BYTE	$6C,$76,$65,$64
	!BYTE	$54			; CALL	_X004
_F200 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C002
_F201 	!WORD	_C002		
_B096 
_B097 
; toolsrc/codegen.pla: 0278:     //
; toolsrc/codegen.pla: 0279:     // Update list of addresses needing resolution
; toolsrc/codegen.pla: 0280:     //
; toolsrc/codegen.pla: 0281:     if tag_type->[tag] & RELATIVE_FIXUP
; toolsrc/codegen.pla: 0282:         updtptr = tag_addr=>[tag]
; toolsrc/codegen.pla: 0283:         while updtptr
	!BYTE	$6A			; LAW	_D053+0
_F202 	!WORD	_D053+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B098
	!WORD	_B098-*
	!BYTE	$6A			; LAW	_D052+0
_F203 	!WORD	_D052+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B102
	!WORD	_B102-*
_B100 
; toolsrc/codegen.pla: 0284:             nextptr  = *updtptr
; toolsrc/codegen.pla: 0285:             *updtptr = codeptr - updtptr
; toolsrc/codegen.pla: 0286:             updtptr  = nextptr
; toolsrc/codegen.pla: 0287:         loop
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$6A			; LAW	_D075+0
_F204 	!WORD	_D075+0		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$84			; SUB 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$76,$04			; SLW	[4]
_B102 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$4E			; BRTRU	_B100
	!WORD	_B100-*
_B101 
; toolsrc/codegen.pla: 0288:         updtptr = codeptr
; toolsrc/codegen.pla: 0289:     else
	!BYTE	$6A			; LAW	_D075+0
_F205 	!WORD	_D075+0		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B099
	!WORD	_B099-*
_B098 
; toolsrc/codegen.pla: 0290:         codeofst = codeptr - codebuff
; toolsrc/codegen.pla: 0291:         for fixups = fixup_cnt-1 downto 0
	!BYTE	$6A			; LAW	_D075+0
_F206 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D074+0
_F207 	!WORD	_D074+0		
	!BYTE	$84			; SUB 
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D046+0
_F208 	!WORD	_D046+0		
	!BYTE	$8E			; DECR
	!BYTE	$A2			; BRLT	_B103
	!WORD	_B103-*
_B104 
	!BYTE	$6E,$02			; DLW	[2]
; toolsrc/codegen.pla: 0292:             if fixup_tag=>[fixups] == tag
; toolsrc/codegen.pla: 0293:                 updtptr  = fixup_addr=>[fixups]
; toolsrc/codegen.pla: 0294:                 *updtptr = *updtptr + codeofst
; toolsrc/codegen.pla: 0295:             fin
	!BYTE	$6A			; LAW	_D050+0
_F209 	!WORD	_D050+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$24			; BRNE	_B106
	!WORD	_B106-*
	!BYTE	$6A			; LAW	_D051+0
_F210 	!WORD	_D051+0		
	!BYTE	$BA,$02			; IDXLW	[2]
	!BYTE	$62			; LW
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$62			; LW
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$72			; SW
_B106 
_B107 
; toolsrc/codegen.pla: 0296:         next
_B105 
	!BYTE	$A8			; DECBRGE	_B104
	!WORD	_B104-*
_B103 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$30			; DROP 
; toolsrc/codegen.pla: 0297:         updtptr = codeptr - codebuff
; toolsrc/codegen.pla: 0298:     fin
	!BYTE	$6A			; LAW	_D075+0
_F211 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D074+0
_F212 	!WORD	_D074+0		
	!BYTE	$84			; SUB 
	!BYTE	$76,$04			; SLW	[4]
_B099 
; toolsrc/codegen.pla: 0299:     tag_addr=>[tag] = updtptr
; toolsrc/codegen.pla: 0300:     tag_type->[tag] = tag_type->[tag] | RESOLVED_FIXUP
; toolsrc/codegen.pla: 0301: end
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$6A			; LAW	_D052+0
_F213 	!WORD	_D052+0		
	!BYTE	$BA,$00			; IDXLW	[0]
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D053+0
_F214 	!WORD	_D053+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$60			; LB
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$6A			; LAW	_D053+0
_F215 	!WORD	_D053+0		
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$70			; SB
	!BYTE	$5A,$0A			; LEAVE	10
; toolsrc/codegen.pla: 0302: //
; toolsrc/codegen.pla: 0303: // Emit the pending sequence
; toolsrc/codegen.pla: 0304: //
; toolsrc/codegen.pla: 0305: def emit_pending_seq#0
_P001 					; emit_pending_seq#0()
_C040 					; emit_pending_seq()
; toolsrc/codegen.pla: 0306:     word op, pending
					; op -> [0]
					; pending -> [2]
; toolsrc/codegen.pla: 0307:     //
; toolsrc/codegen.pla: 0308:     // This is called by some of the emit_*() functions to ensure that any
; toolsrc/codegen.pla: 0309:     // pending ops are emitted before they emit their own op when they are
; toolsrc/codegen.pla: 0310:     // called from the parser. However, this function itself calls some of those
; toolsrc/codegen.pla: 0311:     // emit_*() functions to emit instructions from the pending sequence, which
; toolsrc/codegen.pla: 0312:     // would cause an infinite loop if we weren't careful. We therefore set
; toolsrc/codegen.pla: 0313:     // pending_seq to null on entry and work with a local copy, so if this
; toolsrc/codegen.pla: 0314:     // function calls back into itself it is a no-op.
; toolsrc/codegen.pla: 0315:     //
; toolsrc/codegen.pla: 0316:     if not pending_seq; return; fin
	!BYTE	$58,$04,$00		; ENTER	4,0
	!BYTE	$6A			; LAW	_D056+0
_F216 	!WORD	_D056+0		
	!BYTE	$4E			; BRTRU	_B108
	!WORD	_B108-*
	!BYTE	$5A,$04			; LEAVE	4
_B108 
_B109 
; toolsrc/codegen.pla: 0317:     pending = pending_seq; pending_seq = NULL
; toolsrc/codegen.pla: 0318:     if outflags & OPTIMIZE
; toolsrc/codegen.pla: 0319:         while optimize_seq(@pending, 0); loop
	!BYTE	$6A			; LAW	_D056+0
_F217 	!WORD	_D056+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D056+0
_F218 	!WORD	_D056+0		
	!BYTE	$68			; LAB	_D085+0
_F219 	!WORD	_D085+0		
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B110
	!WORD	_B110-*
	!BYTE	$50			; BRNCH	_B114
	!WORD	_B114-*
_B112 
_B114 
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D084+0
_F220 	!WORD	_D084+0		
	!BYTE	$56			; ICAL
	!BYTE	$4E			; BRTRU	_B112
	!WORD	_B112-*
_B113 
; toolsrc/codegen.pla: 0320:         if outflags & OPTIMIZE2
; toolsrc/codegen.pla: 0321:             while optimize_seq(@pending, 1); loop
	!BYTE	$68			; LAB	_D085+0
_F221 	!WORD	_D085+0		
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B115
	!WORD	_B115-*
	!BYTE	$50			; BRNCH	_B119
	!WORD	_B119-*
_B117 
_B119 
	!BYTE	$28,$02			; LLA	[2]
	!BYTE	$02			; CN	1
	!BYTE	$6A			; LAW	_D084+0
_F222 	!WORD	_D084+0		
	!BYTE	$56			; ICAL
	!BYTE	$4E			; BRTRU	_B117
	!WORD	_B117-*
_B118 
; toolsrc/codegen.pla: 0322:         fin
_B115 
_B116 
; toolsrc/codegen.pla: 0323:     fin
_B110 
_B111 
; toolsrc/codegen.pla: 0324:     while pending
	!BYTE	$50			; BRNCH	_B122
	!WORD	_B122-*
_B120 
; toolsrc/codegen.pla: 0325:         op = pending
; toolsrc/codegen.pla: 0326:         when op->opgroup
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B124-*
; toolsrc/codegen.pla: 0327:             //
; toolsrc/codegen.pla: 0328:             // Constant value
; toolsrc/codegen.pla: 0329:             //
; toolsrc/codegen.pla: 0330:             is CONST_GROUP
_B125 
; toolsrc/codegen.pla: 0331:                 if op->opcode == CONST_CODE
; toolsrc/codegen.pla: 0332:                     if op=>opval == $FFFF            // MINUS 1
; toolsrc/codegen.pla: 0333:                         ^codeptr = $20
; toolsrc/codegen.pla: 0334:                         codeptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$2A,$2C			; CB	44
	!BYTE	$24			; BRNE	_B126
	!WORD	_B126-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$20			; MINUS ONE
	!BYTE	$24			; BRNE	_B128
	!WORD	_B128-*
	!BYTE	$2A,$20			; CB	32
	!BYTE	$6A			; LAW	_D075+0
_F223 	!WORD	_D075+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D075+0
_F224 	!WORD	_D075+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0335:                     elsif op=>opval & $FFF0 == $0000 // Constant NYBBLE
	!BYTE	$7A			; SAW	_D075+0
_F225 	!WORD	_D075+0		
	!BYTE	$50			; BRNCH	_B129
	!WORD	_B129-*
_B128 
; toolsrc/codegen.pla: 0336:                         ^codeptr = op->opval*2
; toolsrc/codegen.pla: 0337:                         codeptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$5E,$F0			; CFFB	65520
	!BYTE	$94			; AND 
	!BYTE	$4E			; BRTRU	_B130
	!WORD	_B130-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$6A			; LAW	_D075+0
_F226 	!WORD	_D075+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D075+0
_F227 	!WORD	_D075+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0338:                     elsif op=>opval & $FF00 == $0000 // Constant BYTE
	!BYTE	$7A			; SAW	_D075+0
_F228 	!WORD	_D075+0		
	!BYTE	$50			; BRNCH	_B129
	!WORD	_B129-*
_B130 
; toolsrc/codegen.pla: 0339:                         *codeptr = $2A | (op->opval << 8)
; toolsrc/codegen.pla: 0340:                         codeptr  = codeptr + 2
; toolsrc/codegen.pla: 0341:                     elsif op=>opval & $FF00 == $FF00 // Constant $FF00 | BYTE
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$5E,$00			; CFFB	65280
	!BYTE	$94			; AND 
	!BYTE	$4E			; BRTRU	_B131
	!WORD	_B131-*
	!BYTE	$2A,$2A			; CB	42
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$10			; CN	8
	!BYTE	$9A			; SHL
	!BYTE	$96			; OR 
	!BYTE	$6A			; LAW	_D075+0
_F229 	!WORD	_D075+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D075+0
_F230 	!WORD	_D075+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D075+0
_F231 	!WORD	_D075+0		
	!BYTE	$50			; BRNCH	_B129
	!WORD	_B129-*
_B131 
; toolsrc/codegen.pla: 0342:                         *codeptr = $5E | (op->opval << 8)
; toolsrc/codegen.pla: 0343:                         codeptr  = codeptr + 2
; toolsrc/codegen.pla: 0344:                     else                             // Constant WORD
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$5E,$00			; CFFB	65280
	!BYTE	$94			; AND 
	!BYTE	$5E,$00			; CFFB	65280
	!BYTE	$24			; BRNE	_B132
	!WORD	_B132-*
	!BYTE	$2A,$5E			; CB	94
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$10			; CN	8
	!BYTE	$9A			; SHL
	!BYTE	$96			; OR 
	!BYTE	$6A			; LAW	_D075+0
_F232 	!WORD	_D075+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D075+0
_F233 	!WORD	_D075+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D075+0
_F234 	!WORD	_D075+0		
	!BYTE	$50			; BRNCH	_B129
	!WORD	_B129-*
_B132 
; toolsrc/codegen.pla: 0345:                         codeptr->0 = $2C
; toolsrc/codegen.pla: 0346:                         codeptr=>1 = op=>opval
; toolsrc/codegen.pla: 0347:                         codeptr    = codeptr + 3
; toolsrc/codegen.pla: 0348:                     fin
	!BYTE	$2A,$2C			; CB	44
	!BYTE	$6A			; LAW	_D075+0
_F235 	!WORD	_D075+0		
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$6A			; LAW	_D075+0
_F236 	!WORD	_D075+0		
	!BYTE	$8C			; INCR
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D075+0
_F237 	!WORD	_D075+0		
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$7A			; SAW	_D075+0
_F238 	!WORD	_D075+0		
_B129 
; toolsrc/codegen.pla: 0349:                 else
	!BYTE	$50			; BRNCH	_B127
	!WORD	_B127-*
_B126 
; toolsrc/codegen.pla: 0350:                     *codeptr = op->opcode | (op->opval << 8) // IMMEDIATE BYTE OP
; toolsrc/codegen.pla: 0351:                     codeptr  = codeptr + 2
; toolsrc/codegen.pla: 0352:                 fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$60			; LB
	!BYTE	$10			; CN	8
	!BYTE	$9A			; SHL
	!BYTE	$96			; OR 
	!BYTE	$6A			; LAW	_D075+0
_F239 	!WORD	_D075+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D075+0
_F240 	!WORD	_D075+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D075+0
_F241 	!WORD	_D075+0		
_B127 
; toolsrc/codegen.pla: 0353:                 break
	!BYTE	$50			; BRNCH	_B123
	!WORD	_B123-*
; toolsrc/codegen.pla: 0354:             //
; toolsrc/codegen.pla: 0355:             // Constant string
; toolsrc/codegen.pla: 0356:             //
; toolsrc/codegen.pla: 0357:             is CONSTR_GROUP
_B133 
; toolsrc/codegen.pla: 0358:                 ^codeptr = $2E
; toolsrc/codegen.pla: 0359:                 codeptr++
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$6A			; LAW	_D075+0
_F242 	!WORD	_D075+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D075+0
_F243 	!WORD	_D075+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0360:                 emit_data(0, STR_TYPE, op=>opval, 0)
; toolsrc/codegen.pla: 0361:                 break
	!BYTE	$7A			; SAW	_D075+0
_F244 	!WORD	_D075+0		
	!BYTE	$00			; CN	0
	!BYTE	$2A,$80			; CB	128
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C014
_F245 	!WORD	_C014		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B123
	!WORD	_B123-*
; toolsrc/codegen.pla: 0362:             //
; toolsrc/codegen.pla: 0363:             // Single op codes
; toolsrc/codegen.pla: 0364:             //
; toolsrc/codegen.pla: 0365:             is STACK_GROUP
_B134 
; toolsrc/codegen.pla: 0366:                 ^codeptr = op->opcode
; toolsrc/codegen.pla: 0367:                 codeptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$6A			; LAW	_D075+0
_F246 	!WORD	_D075+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D075+0
_F247 	!WORD	_D075+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0368:                 break
	!BYTE	$7A			; SAW	_D075+0
_F248 	!WORD	_D075+0		
	!BYTE	$50			; BRNCH	_B123
	!WORD	_B123-*
; toolsrc/codegen.pla: 0369:             //
; toolsrc/codegen.pla: 0370:             // Local address codes
; toolsrc/codegen.pla: 0371:             //
; toolsrc/codegen.pla: 0372:             is LOCAL_GROUP
_B135 
; toolsrc/codegen.pla: 0373:                 *codeptr = op->opcode | (op->opoffset << 8)
; toolsrc/codegen.pla: 0374:                 codeptr  = codeptr + 2
; toolsrc/codegen.pla: 0375:                 break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$60			; LB
	!BYTE	$10			; CN	8
	!BYTE	$9A			; SHL
	!BYTE	$96			; OR 
	!BYTE	$6A			; LAW	_D075+0
_F249 	!WORD	_D075+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D075+0
_F250 	!WORD	_D075+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D075+0
_F251 	!WORD	_D075+0		
	!BYTE	$50			; BRNCH	_B123
	!WORD	_B123-*
; toolsrc/codegen.pla: 0376:             //
; toolsrc/codegen.pla: 0377:             // Global address codes
; toolsrc/codegen.pla: 0378:             //
; toolsrc/codegen.pla: 0379:             is GLOBAL_GROUP
_B136 
; toolsrc/codegen.pla: 0380:                 ^codeptr = op->opcode
; toolsrc/codegen.pla: 0381:                 codeptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$6A			; LAW	_D075+0
_F252 	!WORD	_D075+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D075+0
_F253 	!WORD	_D075+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0382:                 emit_addr(op=>optag, op=>opoffset)
; toolsrc/codegen.pla: 0383:                 break
	!BYTE	$7A			; SAW	_D075+0
_F254 	!WORD	_D075+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C012
_F255 	!WORD	_C012		
	!BYTE	$50			; BRNCH	_B123
	!WORD	_B123-*
; toolsrc/codegen.pla: 0384:             //
; toolsrc/codegen.pla: 0385:             // Relative address codes
; toolsrc/codegen.pla: 0386:             //
; toolsrc/codegen.pla: 0387:             is RELATIVE_GROUP
_B137 
; toolsrc/codegen.pla: 0388:                 ^codeptr = op->opcode
; toolsrc/codegen.pla: 0389:                 codeptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$6A			; LAW	_D075+0
_F256 	!WORD	_D075+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D075+0
_F257 	!WORD	_D075+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0390:                 emit_reladdr(op=>optag)
; toolsrc/codegen.pla: 0391:                 break
	!BYTE	$7A			; SAW	_D075+0
_F258 	!WORD	_D075+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C013
_F259 	!WORD	_C013		
	!BYTE	$50			; BRNCH	_B123
	!WORD	_B123-*
; toolsrc/codegen.pla: 0392:             //
; toolsrc/codegen.pla: 0393:             // Code tags
; toolsrc/codegen.pla: 0394:             //
; toolsrc/codegen.pla: 0395:             is CODETAG_GROUP
_B138 
; toolsrc/codegen.pla: 0396:                 emit_tag(op=>optag)
; toolsrc/codegen.pla: 0397:                 break
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C039
_F260 	!WORD	_C039		
	!BYTE	$50			; BRNCH	_B123
	!WORD	_B123-*
; toolsrc/codegen.pla: 0398:             otherwise
_B124 
	!BYTE	$07			; CASEBLOCK
	!WORD	$0000
	!WORD	_B125-*
	!WORD	$0001
	!WORD	_B133-*
	!WORD	$0002
	!WORD	_B134-*
	!WORD	$0003
	!WORD	_B135-*
	!WORD	$0004
	!WORD	_B136-*
	!WORD	$0005
	!WORD	_B137-*
	!WORD	$0006
	!WORD	_B138-*
; toolsrc/codegen.pla: 0399:                 return
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/codegen.pla: 0400:         wend
_B123 
; toolsrc/codegen.pla: 0401:         pending = pending=>opnext;
; toolsrc/codegen.pla: 0402:         //
; toolsrc/codegen.pla: 0403:         // Free this op
; toolsrc/codegen.pla: 0404:         //
; toolsrc/codegen.pla: 0405:         op=>opnext = freeop_lst
; toolsrc/codegen.pla: 0406:         freeop_lst = op
; toolsrc/codegen.pla: 0407:     loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$6A			; LAW	_D083+0
_F261 	!WORD	_D083+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D083+0
_F262 	!WORD	_D083+0		
_B122 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B120
	!WORD	_B120-*
_B121 
; toolsrc/codegen.pla: 0408:     if codeptr - codebuff > codebufsz; exit_err(ERR_OVER|ERR_CODE|ERR_TABLE); fin
	!BYTE	$6A			; LAW	_D075+0
_F263 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D074+0
_F264 	!WORD	_D074+0		
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_D068+0
_F265 	!WORD	_D068+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B139
	!WORD	_B139-*
	!BYTE	$2C,$10,$41		; CW	16656
	!BYTE	$54			; CALL	_C002
_F266 	!WORD	_C002		
_B139 
_B140 
; toolsrc/codegen.pla: 0409: end
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/codegen.pla: 0410: //
; toolsrc/codegen.pla: 0411: // Emit a sequence of ops (into the pending sequence)
; toolsrc/codegen.pla: 0412: //
; toolsrc/codegen.pla: 0413: def emit_seq(seq)#0
					; seq -> [0]
_C041 					; emit_seq()
; toolsrc/codegen.pla: 0414:     word op
					; op -> [2]
; toolsrc/codegen.pla: 0415:     byte string
					; string -> [4]
; toolsrc/codegen.pla: 0416:     string = FALSE
	!BYTE	$58,$05,$01		; ENTER	5,1
; toolsrc/codegen.pla: 0417:     op = seq
; toolsrc/codegen.pla: 0418:     while op
	!BYTE	$00			; CN	0
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B143
	!WORD	_B143-*
_B141 
; toolsrc/codegen.pla: 0419:         if op->opcode == CONSTR_CODE; string = TRUE; break; fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$60			; LB
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$24			; BRNE	_B144
	!WORD	_B144-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B142
	!WORD	_B142-*
_B144 
_B145 
; toolsrc/codegen.pla: 0420:         op = op=>opnext
; toolsrc/codegen.pla: 0421:     loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$02			; SLW	[2]
_B143 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B141
	!WORD	_B141-*
_B142 
; toolsrc/codegen.pla: 0422:     pending_seq = cat_seq(pending_seq, seq)
; toolsrc/codegen.pla: 0423:     //
; toolsrc/codegen.pla: 0424:     // The source code comments in the output are much more logical if we don't
; toolsrc/codegen.pla: 0425:     // merge multiple sequences together. There's no value in doing this merging
; toolsrc/codegen.pla: 0426:     // if we're not optimizing, and we optionally allow it to be prevented even
; toolsrc/codegen.pla: 0427:     // when we are optimizing by specifing the -N (NO_COMBINE) flag.
; toolsrc/codegen.pla: 0428:     //
; toolsrc/codegen.pla: 0429:     // We must also force output if the sequence includes a CS opcode, as the
; toolsrc/codegen.pla: 0430:     // associated 'constant' is only temporarily valid.
; toolsrc/codegen.pla: 0431:     //
; toolsrc/codegen.pla: 0432:     if not (outflags & (OPTIMIZE|OPTIMIZE2)) or outflags & NO_COMBINE or string
; toolsrc/codegen.pla: 0433:         emit_pending_seq
; toolsrc/codegen.pla: 0434:     fin
	!BYTE	$6A			; LAW	_D056+0
_F267 	!WORD	_D056+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C008
_F268 	!WORD	_C008		
	!BYTE	$7A			; SAW	_D056+0
_F269 	!WORD	_D056+0		
	!BYTE	$68			; LAB	_D085+0
_F270 	!WORD	_D085+0		
	!BYTE	$3C,$03			; ANDI	3
	!BYTE	$80			; NOT
	!BYTE	$AE			; BROR	_B146
	!WORD	_B146-*
	!BYTE	$68			; LAB	_D085+0
_F271 	!WORD	_D085+0		
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$AE			; BROR	_B147
	!WORD	_B147-*
	!BYTE	$64,$04			; LLB	[4]
_B147 
_B146 
	!BYTE	$4C			; BRFLS	_B148
	!WORD	_B148-*
	!BYTE	$54			; CALL	_C040
_F272 	!WORD	_C040		
_B148 
_B149 
; toolsrc/codegen.pla: 0435: end
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/codegen.pla: 0436: //
; toolsrc/codegen.pla: 0437: // Emit lambda function
; toolsrc/codegen.pla: 0438: //
; toolsrc/codegen.pla: 0439: def emit_lambdafunc(tag, cparms, lambda_seq)#0
					; tag -> [0]
					; cparms -> [2]
					; lambda_seq -> [4]
_C042 					; emit_lambdafunc()
; toolsrc/codegen.pla: 0440:     emit_tag(tag)
	!BYTE	$58,$06,$03		; ENTER	6,3
; toolsrc/codegen.pla: 0441:     framesize = cparms * 2
; toolsrc/codegen.pla: 0442:     emit_enter(cparms)
; toolsrc/codegen.pla: 0443:     emit_seq(lambda_seq)
; toolsrc/codegen.pla: 0444:     emit_leave
; toolsrc/codegen.pla: 0445: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C039
_F273 	!WORD	_C039		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$7A			; SAW	_D070+0
_F274 	!WORD	_D070+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C038
_F275 	!WORD	_C038		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C041
_F276 	!WORD	_C041		
	!BYTE	$54			; CALL	_C037
_F277 	!WORD	_C037		
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/codegen.pla: 0446: //
; toolsrc/codegen.pla: 0447: // ID manager
; toolsrc/codegen.pla: 0448: //
; toolsrc/codegen.pla: 0449: def idmatch(nameptr, len, idptr, idcnt)
					; nameptr -> [0]
					; len -> [2]
					; idptr -> [4]
					; idcnt -> [6]
_C043 					; idmatch()
; toolsrc/codegen.pla: 0450:     byte i
					; i -> [8]
; toolsrc/codegen.pla: 0451: 
; toolsrc/codegen.pla: 0452:     if len > ID_LEN; len = ID_LEN; fin
	!BYTE	$58,$09,$04		; ENTER	9,4
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B150
	!WORD	_B150-*
	!BYTE	$2A,$20			; CB	32
	!BYTE	$76,$02			; SLW	[2]
_B150 
_B151 
; toolsrc/codegen.pla: 0453:     while idcnt
	!BYTE	$50			; BRNCH	_B154
	!WORD	_B154-*
_B152 
; toolsrc/codegen.pla: 0454:         if len == idptr->idname
; toolsrc/codegen.pla: 0455:             i = 1; while i <= len and nameptr->[i - 1] == idptr->idname.[i]; i++; loop
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B155
	!WORD	_B155-*
	!BYTE	$02			; CN	1
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$50			; BRNCH	_B159
	!WORD	_B159-*
_B157 
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$8C			; INCR
	!BYTE	$74,$08			; SLB	[8]
_B159 
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4A			; ISLE
	!BYTE	$AC			; BRAND	_B160
	!WORD	_B160-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$8E			; DECR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$B0,$08			; ADDLB	[8]
	!BYTE	$60			; LB
	!BYTE	$40			; ISEQ
_B160 
	!BYTE	$4E			; BRTRU	_B157
	!WORD	_B157-*
_B158 
; toolsrc/codegen.pla: 0456:             //for i = 1 to len
; toolsrc/codegen.pla: 0457:             //    if nameptr->[i - 1] <> idptr->idname.[i]; break; fin
; toolsrc/codegen.pla: 0458:             //next
; toolsrc/codegen.pla: 0459:             if i > len; return idptr; fin
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B161
	!WORD	_B161-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$5A,$09			; LEAVE	9
_B161 
_B162 
; toolsrc/codegen.pla: 0460:         fin
_B155 
_B156 
; toolsrc/codegen.pla: 0461:         idptr = idptr + idptr->idname + t_id
; toolsrc/codegen.pla: 0462:         idcnt--
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$34			; DUP
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8E			; DECR
; toolsrc/codegen.pla: 0463:     loop
	!BYTE	$76,$06			; SLW	[6]
_B154 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$4E			; BRTRU	_B152
	!WORD	_B152-*
_B153 
; toolsrc/codegen.pla: 0464:     return NULL
	!BYTE	$00			; CN	0
	!BYTE	$5A,$09			; LEAVE	9
; toolsrc/codegen.pla: 0465: end
; toolsrc/codegen.pla: 0466: def lookup_id(nameptr, len)
					; nameptr -> [0]
					; len -> [2]
_C044 					; lookup_id()
; toolsrc/codegen.pla: 0467:     word idptr
					; idptr -> [4]
; toolsrc/codegen.pla: 0468: 
; toolsrc/codegen.pla: 0469:     idptr = idmatch(nameptr, len, idlocal_tbl, locals)
	!BYTE	$58,$06,$02		; ENTER	6,2
; toolsrc/codegen.pla: 0470:     if not idptr
; toolsrc/codegen.pla: 0471:         idptr = idmatch(nameptr, len, idglobal_tbl, globals)
; toolsrc/codegen.pla: 0472:         if idptr
; toolsrc/codegen.pla: 0473:             if idptr=>idtype & EXTERN_TYPE
; toolsrc/codegen.pla: 0474:                 idptr=>idtype = idptr=>idtype | EXTACCESS_TYPE
; toolsrc/codegen.pla: 0475:             fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D055+0
_F278 	!WORD	_D055+0		
	!BYTE	$68			; LAB	_D072+0
_F279 	!WORD	_D072+0		
	!BYTE	$54			; CALL	_C043
_F280 	!WORD	_C043		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4E			; BRTRU	_B163
	!WORD	_B163-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D054+0
_F281 	!WORD	_D054+0		
	!BYTE	$6A			; LAW	_D057+0
_F282 	!WORD	_D057+0		
	!BYTE	$54			; CALL	_C043
_F283 	!WORD	_C043		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4C			; BRFLS	_B165
	!WORD	_B165-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$2C,$00,$04		; CW	1024
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B167
	!WORD	_B167-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$96			; OR 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
_B167 
_B168 
; toolsrc/codegen.pla: 0476:         fin
_B165 
_B166 
; toolsrc/codegen.pla: 0477:     fin
_B163 
_B164 
; toolsrc/codegen.pla: 0478:     return idptr
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/codegen.pla: 0479: end
; toolsrc/codegen.pla: 0480: def lookup_idglobal(nameptr, len)
					; nameptr -> [0]
					; len -> [2]
_C045 					; lookup_idglobal()
; toolsrc/codegen.pla: 0481:     word idptr
					; idptr -> [4]
; toolsrc/codegen.pla: 0482: 
; toolsrc/codegen.pla: 0483:     idptr = idmatch(nameptr, len, idglobal_tbl, globals)
	!BYTE	$58,$06,$02		; ENTER	6,2
; toolsrc/codegen.pla: 0484:     if idptr
; toolsrc/codegen.pla: 0485:         if idptr=>idtype & EXTERN_TYPE
; toolsrc/codegen.pla: 0486:             idptr=>idtype = idptr=>idtype | EXTACCESS_TYPE
; toolsrc/codegen.pla: 0487:         fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D054+0
_F284 	!WORD	_D054+0		
	!BYTE	$6A			; LAW	_D057+0
_F285 	!WORD	_D057+0		
	!BYTE	$54			; CALL	_C043
_F286 	!WORD	_C043		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4C			; BRFLS	_B169
	!WORD	_B169-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$2C,$00,$04		; CW	1024
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B171
	!WORD	_B171-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$96			; OR 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
_B171 
_B172 
; toolsrc/codegen.pla: 0488:     fin
_B169 
_B170 
; toolsrc/codegen.pla: 0489:     return idptr
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/codegen.pla: 0490: end
; toolsrc/codegen.pla: 0491: def new_iddata(nameptr, len, type, size)#0
					; nameptr -> [0]
					; len -> [2]
					; type -> [4]
					; size -> [6]
_C046 					; new_iddata()
; toolsrc/codegen.pla: 0492:     if idmatch(nameptr, len, idglobal_tbl, globals); exit_err(ERR_DUP|ERR_ID); fin
	!BYTE	$58,$08,$04		; ENTER	8,4
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D054+0
_F287 	!WORD	_D054+0		
	!BYTE	$6A			; LAW	_D057+0
_F288 	!WORD	_D057+0		
	!BYTE	$54			; CALL	_C043
_F289 	!WORD	_C043		
	!BYTE	$4C			; BRFLS	_B173
	!WORD	_B173-*
	!BYTE	$2C,$01,$02		; CW	513
	!BYTE	$54			; CALL	_C002
_F290 	!WORD	_C002		
_B173 
_B174 
; toolsrc/codegen.pla: 0493:     nametostr(nameptr, len, lastglobal + idname)
; toolsrc/codegen.pla: 0494:     lastglobal=>idtype = type
; toolsrc/codegen.pla: 0495:     if type & EXTERN_TYPE
; toolsrc/codegen.pla: 0496:         lastglobal=>idval = new_tag(EXTERN_FIXUP|WORD_FIXUP)//datasize
; toolsrc/codegen.pla: 0497:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D058+0
_F291 	!WORD	_D058+0		
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$54			; CALL	_C000
_F292 	!WORD	_C000		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$6A			; LAW	_D058+0
_F293 	!WORD	_D058+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$00,$04		; CW	1024
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B175
	!WORD	_B175-*
	!BYTE	$2A,$90			; CB	144
	!BYTE	$54			; CALL	_C004
_F294 	!WORD	_C004		
	!BYTE	$6A			; LAW	_D058+0
_F295 	!WORD	_D058+0		
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B176
	!WORD	_B176-*
_B175 
; toolsrc/codegen.pla: 0498:         lastglobal=>idval = new_tag(WORD_FIXUP)//datasize
; toolsrc/codegen.pla: 0499:         emit_tag(lastglobal=>idval)
; toolsrc/codegen.pla: 0500:         lastglobalsize = size
; toolsrc/codegen.pla: 0501:         if size
; toolsrc/codegen.pla: 0502:             emit_fill(size)
; toolsrc/codegen.pla: 0503:             datasize = datasize + size
; toolsrc/codegen.pla: 0504:         fin
	!BYTE	$2A,$80			; CB	128
	!BYTE	$54			; CALL	_C004
_F296 	!WORD	_C004		
	!BYTE	$6A			; LAW	_D058+0
_F297 	!WORD	_D058+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D058+0
_F298 	!WORD	_D058+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C039
_F299 	!WORD	_C039		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$7A			; SAW	_D059+0
_F300 	!WORD	_D059+0		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$4C			; BRFLS	_B177
	!WORD	_B177-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C011
_F301 	!WORD	_C011		
	!BYTE	$6A			; LAW	_D069+0
_F302 	!WORD	_D069+0		
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$7A			; SAW	_D069+0
_F303 	!WORD	_D069+0		
_B177 
_B178 
; toolsrc/codegen.pla: 0505:     fin
_B176 
; toolsrc/codegen.pla: 0506:     globals++
	!BYTE	$6A			; LAW	_D057+0
_F304 	!WORD	_D057+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0507:     lastglobal = lastglobal + t_id + len
; toolsrc/codegen.pla: 0508:     if lastglobal - idglobal_tbl >  globalbufsz; exit_err(ERR_OVER|ERR_GLOBAL|ERR_ID|ERR_TABLE); fin
	!BYTE	$7A			; SAW	_D057+0
_F305 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D058+0
_F306 	!WORD	_D058+0		
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$7E			; DAW	_D058+0
_F307 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D054+0
_F308 	!WORD	_D054+0		
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_D066+0
_F309 	!WORD	_D066+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B179
	!WORD	_B179-*
	!BYTE	$2C,$90,$42		; CW	17040
	!BYTE	$54			; CALL	_C002
_F310 	!WORD	_C002		
_B179 
_B180 
; toolsrc/codegen.pla: 0509: end
	!BYTE	$5A,$08			; LEAVE	8
; toolsrc/codegen.pla: 0510: def size_iddata(type, varsize, initsize)#0
					; type -> [0]
					; varsize -> [2]
					; initsize -> [4]
_C047 					; size_iddata()
; toolsrc/codegen.pla: 0511:     if varsize > initsize
	!BYTE	$58,$06,$03		; ENTER	6,3
; toolsrc/codegen.pla: 0512:         datasize = datasize + varsize
; toolsrc/codegen.pla: 0513:         emit_data(0, 0, 0, varsize - initsize)
; toolsrc/codegen.pla: 0514:     else
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B181
	!WORD	_B181-*
	!BYTE	$6A			; LAW	_D069+0
_F311 	!WORD	_D069+0		
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$7A			; SAW	_D069+0
_F312 	!WORD	_D069+0		
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_C014
_F313 	!WORD	_C014		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B182
	!WORD	_B182-*
_B181 
; toolsrc/codegen.pla: 0515:         datasize = datasize + initsize
; toolsrc/codegen.pla: 0516:     fin
	!BYTE	$6A			; LAW	_D069+0
_F314 	!WORD	_D069+0		
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$7A			; SAW	_D069+0
_F315 	!WORD	_D069+0		
_B182 
; toolsrc/codegen.pla: 0517: end
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/codegen.pla: 0518: def new_idglobal(nameptr, len, type, value, cparms, cvals)#0
					; nameptr -> [0]
					; len -> [2]
					; type -> [4]
					; value -> [6]
					; cparms -> [8]
					; cvals -> [10]
_C048 					; new_idglobal()
; toolsrc/codegen.pla: 0519:     if idmatch(nameptr, len, idglobal_tbl, globals); exit_err(ERR_DUP|ERR_ID); fin
	!BYTE	$58,$0C,$06		; ENTER	12,6
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D054+0
_F316 	!WORD	_D054+0		
	!BYTE	$6A			; LAW	_D057+0
_F317 	!WORD	_D057+0		
	!BYTE	$54			; CALL	_C043
_F318 	!WORD	_C043		
	!BYTE	$4C			; BRFLS	_B183
	!WORD	_B183-*
	!BYTE	$2C,$01,$02		; CW	513
	!BYTE	$54			; CALL	_C002
_F319 	!WORD	_C002		
_B183 
_B184 
; toolsrc/codegen.pla: 0520:     if len > ID_LEN; len = ID_LEN; fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B185
	!WORD	_B185-*
	!BYTE	$2A,$20			; CB	32
	!BYTE	$76,$02			; SLW	[2]
_B185 
_B186 
; toolsrc/codegen.pla: 0521:     lastglobal=>idval     = value
; toolsrc/codegen.pla: 0522:     lastglobal=>idtype    = type
; toolsrc/codegen.pla: 0523:     lastglobal->funcparms = cparms
; toolsrc/codegen.pla: 0524:     lastglobal->funcvals  = cvals
; toolsrc/codegen.pla: 0525:     nametostr(nameptr, len, lastglobal + idname)
; toolsrc/codegen.pla: 0526:     globals++
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$6A			; LAW	_D058+0
_F320 	!WORD	_D058+0		
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$6A			; LAW	_D058+0
_F321 	!WORD	_D058+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$6A			; LAW	_D058+0
_F322 	!WORD	_D058+0		
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$70			; SB
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$6A			; LAW	_D058+0
_F323 	!WORD	_D058+0		
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D058+0
_F324 	!WORD	_D058+0		
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$54			; CALL	_C000
_F325 	!WORD	_C000		
	!BYTE	$6A			; LAW	_D057+0
_F326 	!WORD	_D057+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0527:     lastglobal = lastglobal + t_id + len
; toolsrc/codegen.pla: 0528:     if lastglobal - idglobal_tbl > globalbufsz; exit_err(ERR_OVER|ERR_GLOBAL|ERR_ID|ERR_TABLE); fin
	!BYTE	$7A			; SAW	_D057+0
_F327 	!WORD	_D057+0		
	!BYTE	$6A			; LAW	_D058+0
_F328 	!WORD	_D058+0		
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$7E			; DAW	_D058+0
_F329 	!WORD	_D058+0		
	!BYTE	$6A			; LAW	_D054+0
_F330 	!WORD	_D054+0		
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_D066+0
_F331 	!WORD	_D066+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B187
	!WORD	_B187-*
	!BYTE	$2C,$90,$42		; CW	17040
	!BYTE	$54			; CALL	_C002
_F332 	!WORD	_C002		
_B187 
_B188 
; toolsrc/codegen.pla: 0529: end
	!BYTE	$5A,$0C			; LEAVE	12
; toolsrc/codegen.pla: 0530: def new_idconst(nameptr, len, value)#0
					; nameptr -> [0]
					; len -> [2]
					; value -> [4]
_C049 					; new_idconst()
; toolsrc/codegen.pla: 0531:     new_idglobal(nameptr, len, CONST_TYPE, value, 0, 0)
	!BYTE	$58,$06,$03		; ENTER	6,3
; toolsrc/codegen.pla: 0532: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$02			; CN	1
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C048
_F333 	!WORD	_C048		
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/codegen.pla: 0533: def new_idfunc(nameptr, len, type, tag, cfnparms, cfnvals)#0
					; nameptr -> [0]
					; len -> [2]
					; type -> [4]
					; tag -> [6]
					; cfnparms -> [8]
					; cfnvals -> [10]
_C050 					; new_idfunc()
; toolsrc/codegen.pla: 0534:     new_idglobal(nameptr, len, type|FUNC_TYPE, tag, cfnparms, cfnvals)
	!BYTE	$58,$0C,$06		; ENTER	12,6
; toolsrc/codegen.pla: 0535:     if not (type & EXTERN_TYPE); def_cnt++; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$3E,$08			; ORI	8
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$54			; CALL	_C048
_F334 	!WORD	_C048		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2C,$00,$04		; CW	1024
	!BYTE	$94			; AND 
	!BYTE	$4E			; BRTRU	_B189
	!WORD	_B189-*
	!BYTE	$68			; LAB	_D080+0
_F335 	!WORD	_D080+0		
	!BYTE	$8C			; INCR
	!BYTE	$78			; SAB	_D080+0
_F336 	!WORD	_D080+0		
_B189 
_B190 
; toolsrc/codegen.pla: 0536: end
	!BYTE	$5A,$0C			; LEAVE	12
; toolsrc/codegen.pla: 0537: def set_idfunc(nameptr, len, tag, cparms, cvals)#0
					; nameptr -> [0]
					; len -> [2]
					; tag -> [4]
					; cparms -> [6]
					; cvals -> [8]
_C051 					; set_idfunc()
; toolsrc/codegen.pla: 0538:     word idptr
					; idptr -> [10]
; toolsrc/codegen.pla: 0539: 
; toolsrc/codegen.pla: 0540:     idptr = lookup_idglobal(nameptr, len)
	!BYTE	$58,$0C,$05		; ENTER	12,5
; toolsrc/codegen.pla: 0541:     if idptr
; toolsrc/codegen.pla: 0542:         if not (idptr=>idtype & FUNC_TYPE); exit_err(ERR_UNDECL|ERR_CODE); fin // DEBUG
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C045
_F337 	!WORD	_C045		
	!BYTE	$6E,$0A			; DLW	[10]
	!BYTE	$4C			; BRFLS	_B191
	!WORD	_B191-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4E			; BRTRU	_B193
	!WORD	_B193-*
	!BYTE	$2C,$02,$01		; CW	258
	!BYTE	$54			; CALL	_C002
_F338 	!WORD	_C002		
_B193 
_B194 
; toolsrc/codegen.pla: 0543:         idptr=>idval     = tag
; toolsrc/codegen.pla: 0544:         idptr->funcparms = cparms
; toolsrc/codegen.pla: 0545:         idptr->funcvals  = cvals
; toolsrc/codegen.pla: 0546:     else
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$70			; SB
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B192
	!WORD	_B192-*
_B191 
; toolsrc/codegen.pla: 0547:         exit_err(ERR_UNDECL|ERR_ID)
; toolsrc/codegen.pla: 0548:     fin
	!BYTE	$2C,$02,$02		; CW	514
	!BYTE	$54			; CALL	_C002
_F339 	!WORD	_C002		
_B192 
; toolsrc/codegen.pla: 0549: end
	!BYTE	$5A,$0C			; LEAVE	12
; toolsrc/codegen.pla: 0550: def init_idglobal#0
_C052 					; init_idglobal()
; toolsrc/codegen.pla: 0551:     word op
					; op -> [0]
; toolsrc/codegen.pla: 0552:     word i
					; i -> [2]
; toolsrc/codegen.pla: 0553: 
; toolsrc/codegen.pla: 0554:     dfd_num     = DFDNUM
	!BYTE	$58,$04,$00		; ENTER	4,0
; toolsrc/codegen.pla: 0555:     tag_num     = TAGNUM
; toolsrc/codegen.pla: 0556:     fixup_num   = FIXUPNUM
; toolsrc/codegen.pla: 0557:     globalbufsz = IDGLOBALSZ
; toolsrc/codegen.pla: 0558:     localbufsz  = IDLOCALSZ
; toolsrc/codegen.pla: 0559:     if isult(heapavail, $6000)
; toolsrc/codegen.pla: 0560:         dfd_num     = DFDNUM/2
; toolsrc/codegen.pla: 0561:         tag_num     = TAGNUM/2
; toolsrc/codegen.pla: 0562:         fixup_num   = FIXUPNUM/2
; toolsrc/codegen.pla: 0563:         globalbufsz = IDGLOBALSZ
; toolsrc/codegen.pla: 0564:         localbufsz  = IDLOCALSZ/2
; toolsrc/codegen.pla: 0565:     fin
	!BYTE	$2A,$80			; CB	128
	!BYTE	$7A			; SAW	_D063+0
_F340 	!WORD	_D063+0		
	!BYTE	$2C,$00,$04		; CW	1024
	!BYTE	$7A			; SAW	_D064+0
_F341 	!WORD	_D064+0		
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$7A			; SAW	_D065+0
_F342 	!WORD	_D065+0		
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$7A			; SAW	_D066+0
_F343 	!WORD	_D066+0		
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$7A			; SAW	_D067+0
_F344 	!WORD	_D067+0		
	!BYTE	$54			; CALL	_X016
_F345 	!WORD	0		
	!BYTE	$2C,$00,$60		; CW	24576
	!BYTE	$54			; CALL	_X026
_F346 	!WORD	0		
	!BYTE	$4C			; BRFLS	_B195
	!WORD	_B195-*
	!BYTE	$2A,$40			; CB	64
	!BYTE	$7A			; SAW	_D063+0
_F347 	!WORD	_D063+0		
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$7A			; SAW	_D064+0
_F348 	!WORD	_D064+0		
	!BYTE	$2C,$00,$04		; CW	1024
	!BYTE	$7A			; SAW	_D065+0
_F349 	!WORD	_D065+0		
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$7A			; SAW	_D066+0
_F350 	!WORD	_D066+0		
	!BYTE	$2C,$00,$01		; CW	256
	!BYTE	$7A			; SAW	_D067+0
_F351 	!WORD	_D067+0		
_B195 
_B196 
; toolsrc/codegen.pla: 0566:     //
; toolsrc/codegen.pla: 0567:     //Init free op sequence list
; toolsrc/codegen.pla: 0568:     //
; toolsrc/codegen.pla: 0569:     freeop_lst = heapalloc(OPSEQNUM*t_opseq)
; toolsrc/codegen.pla: 0570:     op = freeop_lst
; toolsrc/codegen.pla: 0571:     for i = OPSEQNUM-1 downto 0
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$54			; CALL	_X014
_F352 	!WORD	0		
	!BYTE	$7E			; DAW	_D083+0
_F353 	!WORD	_D083+0		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$2A,$FF			; CB	255
_B198 
	!BYTE	$6E,$02			; DLW	[2]
; toolsrc/codegen.pla: 0572:         op=>opnext = op + t_opseq
; toolsrc/codegen.pla: 0573:         op = op + t_opseq
; toolsrc/codegen.pla: 0574:     next
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$76,$00			; SLW	[0]
_B199 
	!BYTE	$A8			; DECBRGE	_B198
	!WORD	_B198-*
_B197 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$30			; DROP 
; toolsrc/codegen.pla: 0575:     op=>opnext   = NULL
; toolsrc/codegen.pla: 0576:     //
; toolsrc/codegen.pla: 0577:     // Allocate remaining buffers
; toolsrc/codegen.pla: 0578:     //
; toolsrc/codegen.pla: 0579:     dfd_tag      = heapalloc(dfd_num*2)
; toolsrc/codegen.pla: 0580:     tag_addr     = heapalloc(tag_num*2)
; toolsrc/codegen.pla: 0581:     tag_type     = heapalloc(tag_num)
; toolsrc/codegen.pla: 0582:     fixup_tag    = heapalloc(fixup_num*2)
; toolsrc/codegen.pla: 0583:     fixup_addr   = heapalloc(fixup_num*2)
; toolsrc/codegen.pla: 0584:     idglobal_tbl = heapalloc(globalbufsz)
; toolsrc/codegen.pla: 0585:     idlocal_tbl  = heapalloc(localbufsz)
; toolsrc/codegen.pla: 0586:     codebufsz    = heapavail - 2048
; toolsrc/codegen.pla: 0587:     codebuff     = heapalloc(codebufsz)
; toolsrc/codegen.pla: 0588:     codeptr      = codebuff
; toolsrc/codegen.pla: 0589:     lastglobal   = idglobal_tbl
; toolsrc/codegen.pla: 0590: end
	!BYTE	$00			; CN	0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D063+0
_F354 	!WORD	_D063+0		
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X014
_F355 	!WORD	0		
	!BYTE	$7A			; SAW	_D048+0
_F356 	!WORD	_D048+0		
	!BYTE	$6A			; LAW	_D064+0
_F357 	!WORD	_D064+0		
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X014
_F358 	!WORD	0		
	!BYTE	$7A			; SAW	_D052+0
_F359 	!WORD	_D052+0		
	!BYTE	$6A			; LAW	_D064+0
_F360 	!WORD	_D064+0		
	!BYTE	$54			; CALL	_X014
_F361 	!WORD	0		
	!BYTE	$7A			; SAW	_D053+0
_F362 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D065+0
_F363 	!WORD	_D065+0		
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X014
_F364 	!WORD	0		
	!BYTE	$7A			; SAW	_D050+0
_F365 	!WORD	_D050+0		
	!BYTE	$6A			; LAW	_D065+0
_F366 	!WORD	_D065+0		
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$54			; CALL	_X014
_F367 	!WORD	0		
	!BYTE	$7A			; SAW	_D051+0
_F368 	!WORD	_D051+0		
	!BYTE	$6A			; LAW	_D066+0
_F369 	!WORD	_D066+0		
	!BYTE	$54			; CALL	_X014
_F370 	!WORD	0		
	!BYTE	$7A			; SAW	_D054+0
_F371 	!WORD	_D054+0		
	!BYTE	$6A			; LAW	_D067+0
_F372 	!WORD	_D067+0		
	!BYTE	$54			; CALL	_X014
_F373 	!WORD	0		
	!BYTE	$7A			; SAW	_D055+0
_F374 	!WORD	_D055+0		
	!BYTE	$54			; CALL	_X016
_F375 	!WORD	0		
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$84			; SUB 
	!BYTE	$7E			; DAW	_D068+0
_F376 	!WORD	_D068+0		
	!BYTE	$54			; CALL	_X014
_F377 	!WORD	0		
	!BYTE	$7E			; DAW	_D074+0
_F378 	!WORD	_D074+0		
	!BYTE	$7A			; SAW	_D075+0
_F379 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D054+0
_F380 	!WORD	_D054+0		
	!BYTE	$7A			; SAW	_D058+0
_F381 	!WORD	_D058+0		
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/codegen.pla: 0591: def new_idlocal(nameptr, len, type, size)#0
					; nameptr -> [0]
					; len -> [2]
					; type -> [4]
					; size -> [6]
_C053 					; new_idlocal()
; toolsrc/codegen.pla: 0592:     if idmatch(nameptr, len, @idlocal_tbl, locals); exit_err(ERR_DUP|ERR_ID); fin
	!BYTE	$58,$08,$04		; ENTER	8,4
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D055+0
_F382 	!WORD	_D055+0		
	!BYTE	$68			; LAB	_D072+0
_F383 	!WORD	_D072+0		
	!BYTE	$54			; CALL	_C043
_F384 	!WORD	_C043		
	!BYTE	$4C			; BRFLS	_B200
	!WORD	_B200-*
	!BYTE	$2C,$01,$02		; CW	513
	!BYTE	$54			; CALL	_C002
_F385 	!WORD	_C002		
_B200 
_B201 
; toolsrc/codegen.pla: 0593:     if len > ID_LEN; len = ID_LEN; fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2A,$20			; CB	32
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B202
	!WORD	_B202-*
	!BYTE	$2A,$20			; CB	32
	!BYTE	$76,$02			; SLW	[2]
_B202 
_B203 
; toolsrc/codegen.pla: 0594:     lastlocal=>idval  = framesize
; toolsrc/codegen.pla: 0595:     lastlocal=>idtype = type | LOCAL_TYPE
; toolsrc/codegen.pla: 0596:     nametostr(nameptr, len, lastlocal + idname)
; toolsrc/codegen.pla: 0597:     locals++
	!BYTE	$6A			; LAW	_D070+0
_F386 	!WORD	_D070+0		
	!BYTE	$6A			; LAW	_D060+0
_F387 	!WORD	_D060+0		
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$3E,$10			; ORI	16
	!BYTE	$6A			; LAW	_D060+0
_F388 	!WORD	_D060+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D060+0
_F389 	!WORD	_D060+0		
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$54			; CALL	_C000
_F390 	!WORD	_C000		
	!BYTE	$68			; LAB	_D072+0
_F391 	!WORD	_D072+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0598:     lastlocal = lastlocal + t_id + len
; toolsrc/codegen.pla: 0599:     if lastlocal - idlocal_tbl > localbufsz; exit_err(ERR_OVER|ERR_LOCAL|ERR_TABLE); fin
	!BYTE	$78			; SAB	_D072+0
_F392 	!WORD	_D072+0		
	!BYTE	$6A			; LAW	_D060+0
_F393 	!WORD	_D060+0		
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$7E			; DAW	_D060+0
_F394 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D055+0
_F395 	!WORD	_D055+0		
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_D067+0
_F396 	!WORD	_D067+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B204
	!WORD	_B204-*
	!BYTE	$2C,$50,$40		; CW	16464
	!BYTE	$54			; CALL	_C002
_F397 	!WORD	_C002		
_B204 
_B205 
; toolsrc/codegen.pla: 0600:     framesize = framesize + size
; toolsrc/codegen.pla: 0601:     if framesize > 255; exit_err(ERR_OVER|ERR_LOCAL|ERR_FRAME); fin
	!BYTE	$6A			; LAW	_D070+0
_F398 	!WORD	_D070+0		
	!BYTE	$B2,$06			; ADDLW	[6]
	!BYTE	$7E			; DAW	_D070+0
_F399 	!WORD	_D070+0		
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B206
	!WORD	_B206-*
	!BYTE	$2C,$50,$20		; CW	8272
	!BYTE	$54			; CALL	_C002
_F400 	!WORD	_C002		
_B206 
_B207 
; toolsrc/codegen.pla: 0602: end
	!BYTE	$5A,$08			; LEAVE	8
; toolsrc/codegen.pla: 0603: def init_idlocal#0
_C054 					; init_idlocal()
; toolsrc/codegen.pla: 0604:     locals    = 0
; toolsrc/codegen.pla: 0605:     framesize = 0
; toolsrc/codegen.pla: 0606:     lastlocal = idlocal_tbl
; toolsrc/codegen.pla: 0607: end
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D072+0
_F401 	!WORD	_D072+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D070+0
_F402 	!WORD	_D070+0		
	!BYTE	$6A			; LAW	_D055+0
_F403 	!WORD	_D055+0		
	!BYTE	$7A			; SAW	_D060+0
_F404 	!WORD	_D060+0		
	!BYTE	$5C			; RET
; toolsrc/codegen.pla: 0608: def save_idlocal#0
_C055 					; save_idlocal()
; toolsrc/codegen.pla: 0609:     savelocals = locals
; toolsrc/codegen.pla: 0610:     savesize   = framesize
; toolsrc/codegen.pla: 0611:     savelast   = lastlocal
; toolsrc/codegen.pla: 0612:     savetbl    = heapalloc(lastlocal - idlocal_tbl)
; toolsrc/codegen.pla: 0613:     memcpy(savetbl, idlocal_tbl, lastlocal - idlocal_tbl)
; toolsrc/codegen.pla: 0614: end
	!BYTE	$68			; LAB	_D072+0
_F405 	!WORD	_D072+0		
	!BYTE	$78			; SAB	_D073+0
_F406 	!WORD	_D073+0		
	!BYTE	$6A			; LAW	_D070+0
_F407 	!WORD	_D070+0		
	!BYTE	$7A			; SAW	_D071+0
_F408 	!WORD	_D071+0		
	!BYTE	$6A			; LAW	_D060+0
_F409 	!WORD	_D060+0		
	!BYTE	$7A			; SAW	_D061+0
_F410 	!WORD	_D061+0		
	!BYTE	$6A			; LAW	_D060+0
_F411 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D055+0
_F412 	!WORD	_D055+0		
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X014
_F413 	!WORD	0		
	!BYTE	$7E			; DAW	_D062+0
_F414 	!WORD	_D062+0		
	!BYTE	$6A			; LAW	_D055+0
_F415 	!WORD	_D055+0		
	!BYTE	$6A			; LAW	_D060+0
_F416 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D055+0
_F417 	!WORD	_D055+0		
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X018
_F418 	!WORD	0		
	!BYTE	$5C			; RET
; toolsrc/codegen.pla: 0615: def restore_idlocal#0
_C056 					; restore_idlocal()
; toolsrc/codegen.pla: 0616:     locals    = savelocals
; toolsrc/codegen.pla: 0617:     framesize = savesize
; toolsrc/codegen.pla: 0618:     lastlocal = savelast
; toolsrc/codegen.pla: 0619:     memcpy(idlocal_tbl, savetbl, lastlocal - idlocal_tbl)
; toolsrc/codegen.pla: 0620:     heaprelease(savetbl)
; toolsrc/codegen.pla: 0621: end
	!BYTE	$68			; LAB	_D073+0
_F419 	!WORD	_D073+0		
	!BYTE	$78			; SAB	_D072+0
_F420 	!WORD	_D072+0		
	!BYTE	$6A			; LAW	_D071+0
_F421 	!WORD	_D071+0		
	!BYTE	$7A			; SAW	_D070+0
_F422 	!WORD	_D070+0		
	!BYTE	$6A			; LAW	_D061+0
_F423 	!WORD	_D061+0		
	!BYTE	$7A			; SAW	_D060+0
_F424 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D055+0
_F425 	!WORD	_D055+0		
	!BYTE	$6A			; LAW	_D062+0
_F426 	!WORD	_D062+0		
	!BYTE	$6A			; LAW	_D060+0
_F427 	!WORD	_D060+0		
	!BYTE	$6A			; LAW	_D055+0
_F428 	!WORD	_D055+0		
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X018
_F429 	!WORD	0		
	!BYTE	$6A			; LAW	_D062+0
_F430 	!WORD	_D062+0		
	!BYTE	$54			; CALL	_X015
_F431 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$5C			; RET
; toolsrc/codegen.pla: 0622: //
; toolsrc/codegen.pla: 0623: // Module dependency list
; toolsrc/codegen.pla: 0624: //
; toolsrc/codegen.pla: 0625: def new_moddep(nameptr, len)#0
					; nameptr -> [0]
					; len -> [2]
_C057 					; new_moddep()
; toolsrc/codegen.pla: 0626:     if len > 15; len = 15; fin
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$1E			; CN	15
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B208
	!WORD	_B208-*
	!BYTE	$1E			; CN	15
	!BYTE	$76,$02			; SLW	[2]
_B208 
_B209 
; toolsrc/codegen.pla: 0627:     new_iddata(nameptr, len, EXTERN_TYPE|WORD_TYPE, 2)
; toolsrc/codegen.pla: 0628:     memcpy(@moddep_tbl[moddep_cnt*16] + 1, nameptr, len)
; toolsrc/codegen.pla: 0629:     moddep_tbl[moddep_cnt*16] = len
; toolsrc/codegen.pla: 0630:     moddep_cnt++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C046
_F432 	!WORD	_C046		
	!BYTE	$26			; LA	_D078+0
_F433 	!WORD	_D078+0		
	!BYTE	$68			; LAB	_D079+0
_F434 	!WORD	_D079+0		
	!BYTE	$08			; CN	4
	!BYTE	$9A			; SHL
	!BYTE	$82			; ADD 
	!BYTE	$8C			; INCR
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_X018
_F435 	!WORD	0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D078+0
_F436 	!WORD	_D078+0		
	!BYTE	$68			; LAB	_D079+0
_F437 	!WORD	_D079+0		
	!BYTE	$08			; CN	4
	!BYTE	$9A			; SHL
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
	!BYTE	$68			; LAB	_D079+0
_F438 	!WORD	_D079+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0631:     if moddep_cnt > MODDEPNUM; parse_warn("Module dependency overflow"); fin
	!BYTE	$7C			; DAB	_D079+0
_F439 	!WORD	_D079+0		
	!BYTE	$10			; CN	8
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B210
	!WORD	_B210-*
	!BYTE	$2E			; CS
	!BYTE	$1A
	!BYTE	$4D,$6F,$64,$75,$6C,$65,$20,$64
	!BYTE	$65,$70,$65,$6E,$64,$65,$6E,$63
	!BYTE	$79,$20,$6F,$76,$65,$72,$66,$6C
	!BYTE	$6F,$77
	!BYTE	$54			; CALL	_C003
_F440 	!WORD	_C003		
_B210 
_B211 
; toolsrc/codegen.pla: 0632: end
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/codegen.pla: 0633: //
; toolsrc/codegen.pla: 0634: // DFD list
; toolsrc/codegen.pla: 0635: //
; toolsrc/codegen.pla: 0636: def new_dfd(tag)#0
					; tag -> [0]
_C058 					; new_dfd()
; toolsrc/codegen.pla: 0637:     if dfd_cnt >= dfd_num; exit_err(ERR_OVER|ERR_CODE|ERR_TABLE); fin
	!BYTE	$58,$02,$01		; ENTER	2,1
	!BYTE	$6A			; LAW	_D049+0
_F441 	!WORD	_D049+0		
	!BYTE	$6A			; LAW	_D063+0
_F442 	!WORD	_D063+0		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B212
	!WORD	_B212-*
	!BYTE	$2C,$10,$41		; CW	16656
	!BYTE	$54			; CALL	_C002
_F443 	!WORD	_C002		
_B212 
_B213 
; toolsrc/codegen.pla: 0638:     dfd_tag=>[dfd_cnt] = tag
; toolsrc/codegen.pla: 0639:     dfd_cnt++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D048+0
_F444 	!WORD	_D048+0		
	!BYTE	$BE			; IDXAW	_D049+0
_F445 	!WORD	_D049+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D049+0
_F446 	!WORD	_D049+0		
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0640: end
	!BYTE	$7A			; SAW	_D049+0
_F447 	!WORD	_D049+0		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/codegen.pla: 0641: //
; toolsrc/codegen.pla: 0642: // Generate/add to a sequence of code
; toolsrc/codegen.pla: 0643: //
; toolsrc/codegen.pla: 0644: def gen_op(seq, code)
					; seq -> [0]
					; code -> [2]
_C059 					; gen_op()
; toolsrc/codegen.pla: 0645:     word op
					; op -> [4]
; toolsrc/codegen.pla: 0646: 
; toolsrc/codegen.pla: 0647:     if not seq
	!BYTE	$58,$06,$02		; ENTER	6,2
; toolsrc/codegen.pla: 0648:         seq = new_op
; toolsrc/codegen.pla: 0649:         op  = seq
; toolsrc/codegen.pla: 0650:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B214
	!WORD	_B214-*
	!BYTE	$54			; CALL	_C005
_F448 	!WORD	_C005		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B215
	!WORD	_B215-*
_B214 
; toolsrc/codegen.pla: 0651:         op = seq
; toolsrc/codegen.pla: 0652:         while op=>opnext; op = op=>opnext; loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B218
	!WORD	_B218-*
_B216 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
_B218 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B216
	!WORD	_B216-*
_B217 
; toolsrc/codegen.pla: 0653:         op=>opnext = new_op
; toolsrc/codegen.pla: 0654:         op = op=>opnext
; toolsrc/codegen.pla: 0655:     fin
	!BYTE	$54			; CALL	_C005
_F449 	!WORD	_C005		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
_B215 
; toolsrc/codegen.pla: 0656:     op->opcode  = code
; toolsrc/codegen.pla: 0657:     op->opgroup = STACK_GROUP
; toolsrc/codegen.pla: 0658:     return seq
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$04			; CN	2
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/codegen.pla: 0659: end
; toolsrc/codegen.pla: 0660: def gen_const(seq, cval)
					; seq -> [0]
					; cval -> [2]
_C060 					; gen_const()
; toolsrc/codegen.pla: 0661:     word op
					; op -> [4]
; toolsrc/codegen.pla: 0662: 
; toolsrc/codegen.pla: 0663:     if not seq
	!BYTE	$58,$06,$02		; ENTER	6,2
; toolsrc/codegen.pla: 0664:         seq = new_op
; toolsrc/codegen.pla: 0665:         op  = seq
; toolsrc/codegen.pla: 0666:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B219
	!WORD	_B219-*
	!BYTE	$54			; CALL	_C005
_F450 	!WORD	_C005		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B220
	!WORD	_B220-*
_B219 
; toolsrc/codegen.pla: 0667:         op = seq
; toolsrc/codegen.pla: 0668:         while op=>opnext; op = op=>opnext; loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B223
	!WORD	_B223-*
_B221 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
_B223 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B221
	!WORD	_B221-*
_B222 
; toolsrc/codegen.pla: 0669:         op=>opnext = new_op
; toolsrc/codegen.pla: 0670:         op = op=>opnext
; toolsrc/codegen.pla: 0671:     fin
	!BYTE	$54			; CALL	_C005
_F451 	!WORD	_C005		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
_B220 
; toolsrc/codegen.pla: 0672:     op->opcode  = CONST_CODE
; toolsrc/codegen.pla: 0673:     op->opgroup = CONST_GROUP
; toolsrc/codegen.pla: 0674:     op=>opval   = cval
; toolsrc/codegen.pla: 0675:     return seq
	!BYTE	$2A,$2C			; CB	44
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$00			; CN	0
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/codegen.pla: 0676: end
; toolsrc/codegen.pla: 0677: def gen_str(seq, cval)
					; seq -> [0]
					; cval -> [2]
_C061 					; gen_str()
; toolsrc/codegen.pla: 0678:     word op
					; op -> [4]
; toolsrc/codegen.pla: 0679: 
; toolsrc/codegen.pla: 0680:     if not seq
	!BYTE	$58,$06,$02		; ENTER	6,2
; toolsrc/codegen.pla: 0681:         seq = new_op
; toolsrc/codegen.pla: 0682:         op  = seq
; toolsrc/codegen.pla: 0683:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B224
	!WORD	_B224-*
	!BYTE	$54			; CALL	_C005
_F452 	!WORD	_C005		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B225
	!WORD	_B225-*
_B224 
; toolsrc/codegen.pla: 0684:         op = seq
; toolsrc/codegen.pla: 0685:         while op=>opnext; op = op=>opnext; loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B228
	!WORD	_B228-*
_B226 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
_B228 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B226
	!WORD	_B226-*
_B227 
; toolsrc/codegen.pla: 0686:         op=>opnext = new_op
; toolsrc/codegen.pla: 0687:         op = op=>opnext
; toolsrc/codegen.pla: 0688:     fin
	!BYTE	$54			; CALL	_C005
_F453 	!WORD	_C005		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
_B225 
; toolsrc/codegen.pla: 0689:     op->opcode  = CONSTR_CODE
; toolsrc/codegen.pla: 0690:     op->opgroup = CONSTR_GROUP
; toolsrc/codegen.pla: 0691:     op=>opval   = cval
; toolsrc/codegen.pla: 0692:     return seq
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$02			; CN	1
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/codegen.pla: 0693: end
; toolsrc/codegen.pla: 0694: def gen_oplcl(seq, code, offsz)
					; seq -> [0]
					; code -> [2]
					; offsz -> [4]
_C062 					; gen_oplcl()
; toolsrc/codegen.pla: 0695:     word op
					; op -> [6]
; toolsrc/codegen.pla: 0696: 
; toolsrc/codegen.pla: 0697:     if not seq
	!BYTE	$58,$08,$03		; ENTER	8,3
; toolsrc/codegen.pla: 0698:         seq = new_op
; toolsrc/codegen.pla: 0699:         op  = seq
; toolsrc/codegen.pla: 0700:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B229
	!WORD	_B229-*
	!BYTE	$54			; CALL	_C005
_F454 	!WORD	_C005		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$50			; BRNCH	_B230
	!WORD	_B230-*
_B229 
; toolsrc/codegen.pla: 0701:         op = seq
; toolsrc/codegen.pla: 0702:         while op=>opnext; op = op=>opnext; loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$50			; BRNCH	_B233
	!WORD	_B233-*
_B231 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
_B233 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B231
	!WORD	_B231-*
_B232 
; toolsrc/codegen.pla: 0703:         op=>opnext = new_op
; toolsrc/codegen.pla: 0704:         op = op=>opnext
; toolsrc/codegen.pla: 0705:     fin
	!BYTE	$54			; CALL	_C005
_F455 	!WORD	_C005		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
_B230 
; toolsrc/codegen.pla: 0706:     op->opcode   = code
; toolsrc/codegen.pla: 0707:     op->opgroup  = LOCAL_GROUP
; toolsrc/codegen.pla: 0708:     op=>opoffset = offsz
; toolsrc/codegen.pla: 0709:     return seq
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$70			; SB
	!BYTE	$06			; CN	3
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$08			; LEAVE	8
; toolsrc/codegen.pla: 0710: end
; toolsrc/codegen.pla: 0711: def gen_opglbl(seq, code, tag, offsz)
					; seq -> [0]
					; code -> [2]
					; tag -> [4]
					; offsz -> [6]
_C063 					; gen_opglbl()
; toolsrc/codegen.pla: 0712:     word op
					; op -> [8]
; toolsrc/codegen.pla: 0713: 
; toolsrc/codegen.pla: 0714:     if not seq
	!BYTE	$58,$0A,$04		; ENTER	10,4
; toolsrc/codegen.pla: 0715:         seq = new_op
; toolsrc/codegen.pla: 0716:         op  = seq
; toolsrc/codegen.pla: 0717:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B234
	!WORD	_B234-*
	!BYTE	$54			; CALL	_C005
_F456 	!WORD	_C005		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B235
	!WORD	_B235-*
_B234 
; toolsrc/codegen.pla: 0718:         op = seq
; toolsrc/codegen.pla: 0719:         while op=>opnext; op = op=>opnext; loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B238
	!WORD	_B238-*
_B236 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
_B238 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B236
	!WORD	_B236-*
_B237 
; toolsrc/codegen.pla: 0720:         op=>opnext = new_op
; toolsrc/codegen.pla: 0721:         op = op=>opnext
; toolsrc/codegen.pla: 0722:     fin
	!BYTE	$54			; CALL	_C005
_F457 	!WORD	_C005		
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$08			; SLW	[8]
_B235 
; toolsrc/codegen.pla: 0723:     op->opcode   = code
; toolsrc/codegen.pla: 0724:     op->opgroup  = GLOBAL_GROUP
; toolsrc/codegen.pla: 0725:     op=>optag    = tag
; toolsrc/codegen.pla: 0726:     op=>opoffset = offsz
; toolsrc/codegen.pla: 0727:     return seq
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$70			; SB
	!BYTE	$08			; CN	4
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$0A			; LEAVE	10
; toolsrc/codegen.pla: 0728: end
; toolsrc/codegen.pla: 0729: def gen_oprel(seq, code, tag)
					; seq -> [0]
					; code -> [2]
					; tag -> [4]
_C064 					; gen_oprel()
; toolsrc/codegen.pla: 0730:     word op
					; op -> [6]
; toolsrc/codegen.pla: 0731: 
; toolsrc/codegen.pla: 0732:     if not seq
	!BYTE	$58,$08,$03		; ENTER	8,3
; toolsrc/codegen.pla: 0733:         seq = new_op
; toolsrc/codegen.pla: 0734:         op  = seq
; toolsrc/codegen.pla: 0735:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B239
	!WORD	_B239-*
	!BYTE	$54			; CALL	_C005
_F458 	!WORD	_C005		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$50			; BRNCH	_B240
	!WORD	_B240-*
_B239 
; toolsrc/codegen.pla: 0736:         op = seq
; toolsrc/codegen.pla: 0737:         while op=>opnext; op = op=>opnext; loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$50			; BRNCH	_B243
	!WORD	_B243-*
_B241 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
_B243 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B241
	!WORD	_B241-*
_B242 
; toolsrc/codegen.pla: 0738:         op=>opnext = new_op
; toolsrc/codegen.pla: 0739:         op = op=>opnext
; toolsrc/codegen.pla: 0740:     fin
	!BYTE	$54			; CALL	_C005
_F459 	!WORD	_C005		
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
_B240 
; toolsrc/codegen.pla: 0741:     op->opcode  = code
; toolsrc/codegen.pla: 0742:     op->opgroup = RELATIVE_GROUP
; toolsrc/codegen.pla: 0743:     op=>optag   = tag
; toolsrc/codegen.pla: 0744:     return seq
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$70			; SB
	!BYTE	$0A			; CN	5
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$08			; LEAVE	8
; toolsrc/codegen.pla: 0745: end
; toolsrc/codegen.pla: 0746: def gen_ctag(seq, tag)
					; seq -> [0]
					; tag -> [2]
_C065 					; gen_ctag()
; toolsrc/codegen.pla: 0747:     word op
					; op -> [4]
; toolsrc/codegen.pla: 0748: 
; toolsrc/codegen.pla: 0749:     if not seq
	!BYTE	$58,$06,$02		; ENTER	6,2
; toolsrc/codegen.pla: 0750:         seq = new_op
; toolsrc/codegen.pla: 0751:         op  = seq
; toolsrc/codegen.pla: 0752:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B244
	!WORD	_B244-*
	!BYTE	$54			; CALL	_C005
_F460 	!WORD	_C005		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B245
	!WORD	_B245-*
_B244 
; toolsrc/codegen.pla: 0753:         op = seq
; toolsrc/codegen.pla: 0754:         while op=>opnext; op = op=>opnext; loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B248
	!WORD	_B248-*
_B246 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
_B248 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B246
	!WORD	_B246-*
_B247 
; toolsrc/codegen.pla: 0755:         op=>opnext = new_op
; toolsrc/codegen.pla: 0756:         op = op=>opnext
; toolsrc/codegen.pla: 0757:     fin
	!BYTE	$54			; CALL	_C005
_F461 	!WORD	_C005		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$04			; SLW	[4]
_B245 
; toolsrc/codegen.pla: 0758:     op->opcode  = INVALID_CODE
; toolsrc/codegen.pla: 0759:     op->opgroup = CODETAG_GROUP
; toolsrc/codegen.pla: 0760:     op=>optag   = tag
; toolsrc/codegen.pla: 0761:     return seq
	!BYTE	$2A,$FF			; CB	255
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$0C			; CN	6
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/codegen.pla: 0762: end
; toolsrc/codegen.pla: 0763: def gen_uop(seq, tkn)
					; seq -> [0]
					; tkn -> [2]
_C066 					; gen_uop()
; toolsrc/codegen.pla: 0764:     byte code
					; code -> [4]
; toolsrc/codegen.pla: 0765:     word op
					; op -> [5]
; toolsrc/codegen.pla: 0766: 
; toolsrc/codegen.pla: 0767:     if not seq
	!BYTE	$58,$07,$02		; ENTER	7,2
; toolsrc/codegen.pla: 0768:         seq = new_op
; toolsrc/codegen.pla: 0769:         op  = seq
; toolsrc/codegen.pla: 0770:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B249
	!WORD	_B249-*
	!BYTE	$54			; CALL	_C005
_F462 	!WORD	_C005		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$76,$05			; SLW	[5]
	!BYTE	$50			; BRNCH	_B250
	!WORD	_B250-*
_B249 
; toolsrc/codegen.pla: 0771:         op = seq
; toolsrc/codegen.pla: 0772:         while op=>opnext; op = op=>opnext; loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$05			; SLW	[5]
	!BYTE	$50			; BRNCH	_B253
	!WORD	_B253-*
_B251 
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$05			; SLW	[5]
_B253 
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B251
	!WORD	_B251-*
_B252 
; toolsrc/codegen.pla: 0773:         op=>opnext = new_op
; toolsrc/codegen.pla: 0774:         op = op=>opnext
; toolsrc/codegen.pla: 0775:     fin
	!BYTE	$54			; CALL	_C005
_F463 	!WORD	_C005		
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$05			; SLW	[5]
_B250 
; toolsrc/codegen.pla: 0776:     when tkn
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$52			; SEL
	!WORD	_B255-*
; toolsrc/codegen.pla: 0777:         is NEG_TKN
_B256 
; toolsrc/codegen.pla: 0778:             code = $90; break
	!BYTE	$2A,$90			; CB	144
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B254
	!WORD	_B254-*
; toolsrc/codegen.pla: 0779:         is COMP_TKN
_B257 
; toolsrc/codegen.pla: 0780:             code = $92; break
	!BYTE	$2A,$92			; CB	146
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B254
	!WORD	_B254-*
; toolsrc/codegen.pla: 0781:         is LOGIC_NOT_TKN
_B258 
; toolsrc/codegen.pla: 0782:             code = $80; break
	!BYTE	$2A,$80			; CB	128
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B254
	!WORD	_B254-*
; toolsrc/codegen.pla: 0783:         is INC_TKN
_B259 
; toolsrc/codegen.pla: 0784:             code = $8C; break
	!BYTE	$2A,$8C			; CB	140
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B254
	!WORD	_B254-*
; toolsrc/codegen.pla: 0785:         is DEC_TKN
_B260 
; toolsrc/codegen.pla: 0786:             code = $8E; break
	!BYTE	$2A,$8E			; CB	142
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B254
	!WORD	_B254-*
; toolsrc/codegen.pla: 0787:         is BPTR_TKN
_B261 
; toolsrc/codegen.pla: 0788:             code = $60; break
	!BYTE	$2A,$60			; CB	96
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B254
	!WORD	_B254-*
; toolsrc/codegen.pla: 0789:         is WPTR_TKN
_B262 
; toolsrc/codegen.pla: 0790:             code = $62; break
	!BYTE	$2A,$62			; CB	98
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B254
	!WORD	_B254-*
; toolsrc/codegen.pla: 0791:         otherwise
_B255 
	!BYTE	$07			; CASEBLOCK
	!WORD	$00A1
	!WORD	_B258-*
	!WORD	$00AA
	!WORD	_B262-*
	!WORD	$00AD
	!WORD	_B256-*
	!WORD	$00C1
	!WORD	_B259-*
	!WORD	$00C4
	!WORD	_B260-*
	!WORD	$00DE
	!WORD	_B261-*
	!WORD	$00FE
	!WORD	_B257-*
; toolsrc/codegen.pla: 0792:             exit_err(ERR_INVAL|ERR_SYNTAX)
; toolsrc/codegen.pla: 0793:     wend
	!BYTE	$2C,$04,$80		; CW	32772
	!BYTE	$54			; CALL	_C002
_F464 	!WORD	_C002		
_B254 
; toolsrc/codegen.pla: 0794:     op->opcode  = code
; toolsrc/codegen.pla: 0795:     op->opgroup = STACK_GROUP
; toolsrc/codegen.pla: 0796:     return seq
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$70			; SB
	!BYTE	$04			; CN	2
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$07			; LEAVE	7
; toolsrc/codegen.pla: 0797: end
; toolsrc/codegen.pla: 0798: def gen_bop(seq, tkn)
					; seq -> [0]
					; tkn -> [2]
_C067 					; gen_bop()
; toolsrc/codegen.pla: 0799:     byte code
					; code -> [4]
; toolsrc/codegen.pla: 0800:     word op
					; op -> [5]
; toolsrc/codegen.pla: 0801: 
; toolsrc/codegen.pla: 0802:     if not seq
	!BYTE	$58,$07,$02		; ENTER	7,2
; toolsrc/codegen.pla: 0803:         seq = new_op
; toolsrc/codegen.pla: 0804:         op = seq
; toolsrc/codegen.pla: 0805:     else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4E			; BRTRU	_B263
	!WORD	_B263-*
	!BYTE	$54			; CALL	_C005
_F465 	!WORD	_C005		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$76,$05			; SLW	[5]
	!BYTE	$50			; BRNCH	_B264
	!WORD	_B264-*
_B263 
; toolsrc/codegen.pla: 0806:         op = seq
; toolsrc/codegen.pla: 0807:         while op=>opnext; op = op=>opnext; loop
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$76,$05			; SLW	[5]
	!BYTE	$50			; BRNCH	_B267
	!WORD	_B267-*
_B265 
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$05			; SLW	[5]
_B267 
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B265
	!WORD	_B265-*
_B266 
; toolsrc/codegen.pla: 0808:         op=>opnext = new_op
; toolsrc/codegen.pla: 0809:         op = op=>opnext
; toolsrc/codegen.pla: 0810:     fin
	!BYTE	$54			; CALL	_C005
_F466 	!WORD	_C005		
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$72			; SW
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$62			; LW
	!BYTE	$76,$05			; SLW	[5]
_B264 
; toolsrc/codegen.pla: 0811:     when tkn
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$52			; SEL
	!WORD	_B269-*
; toolsrc/codegen.pla: 0812:         is MUL_TKN
_B270 
; toolsrc/codegen.pla: 0813:             code = $86; break
	!BYTE	$2A,$86			; CB	134
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0814:         is DIV_TKN
_B271 
; toolsrc/codegen.pla: 0815:             code = $88; break
	!BYTE	$2A,$88			; CB	136
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0816:         is MOD_TKN
_B272 
; toolsrc/codegen.pla: 0817:             code = $8A; break
	!BYTE	$2A,$8A			; CB	138
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0818:         is ADD_TKN
_B273 
; toolsrc/codegen.pla: 0819:             code = $82; break
	!BYTE	$2A,$82			; CB	130
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0820:         is SUB_TKN
_B274 
; toolsrc/codegen.pla: 0821:             code = $84; break
	!BYTE	$2A,$84			; CB	132
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0822:         is SHL_TKN
_B275 
; toolsrc/codegen.pla: 0823:             code = $9A; break
	!BYTE	$2A,$9A			; CB	154
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0824:         is SHR_TKN
_B276 
; toolsrc/codegen.pla: 0825:             code = $9C; break
	!BYTE	$2A,$9C			; CB	156
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0826:         is AND_TKN
_B277 
; toolsrc/codegen.pla: 0827:             code = $94; break
	!BYTE	$2A,$94			; CB	148
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0828:         is OR_TKN
_B278 
; toolsrc/codegen.pla: 0829:             code = $96; break
	!BYTE	$2A,$96			; CB	150
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0830:         is EOR_TKN
_B279 
; toolsrc/codegen.pla: 0831:             code = $98; break
	!BYTE	$2A,$98			; CB	152
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0832:         is EQ_TKN
_B280 
; toolsrc/codegen.pla: 0833:             code = $40; break
	!BYTE	$2A,$40			; CB	64
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0834:         is NE_TKN
_B281 
; toolsrc/codegen.pla: 0835:             code = $42; break
	!BYTE	$2A,$42			; CB	66
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0836:         is GE_TKN
_B282 
; toolsrc/codegen.pla: 0837:             code = $48; break
	!BYTE	$2A,$48			; CB	72
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0838:         is LT_TKN
_B283 
; toolsrc/codegen.pla: 0839:             code = $46; break
	!BYTE	$2A,$46			; CB	70
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0840:         is GT_TKN
_B284 
; toolsrc/codegen.pla: 0841:             code = $44; break
	!BYTE	$2A,$44			; CB	68
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0842:         is LE_TKN
_B285 
; toolsrc/codegen.pla: 0843:             code = $4A; break
	!BYTE	$2A,$4A			; CB	74
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$50			; BRNCH	_B268
	!WORD	_B268-*
; toolsrc/codegen.pla: 0844:         otherwise
_B269 
	!BYTE	$10			; CASEBLOCK
	!WORD	$00A5
	!WORD	_B272-*
	!WORD	$00A6
	!WORD	_B277-*
	!WORD	$00AA
	!WORD	_B270-*
	!WORD	$00AB
	!WORD	_B273-*
	!WORD	$00AD
	!WORD	_B274-*
	!WORD	$00AF
	!WORD	_B271-*
	!WORD	$00BC
	!WORD	_B283-*
	!WORD	$00BE
	!WORD	_B284-*
	!WORD	$00C2
	!WORD	_B285-*
	!WORD	$00C5
	!WORD	_B280-*
	!WORD	$00C8
	!WORD	_B282-*
	!WORD	$00CC
	!WORD	_B275-*
	!WORD	$00D2
	!WORD	_B276-*
	!WORD	$00D5
	!WORD	_B281-*
	!WORD	$00DE
	!WORD	_B279-*
	!WORD	$00FC
	!WORD	_B278-*
; toolsrc/codegen.pla: 0845:             exit_err(ERR_INVAL|ERR_SYNTAX)
; toolsrc/codegen.pla: 0846:     wend
	!BYTE	$2C,$04,$80		; CW	32772
	!BYTE	$54			; CALL	_C002
_F467 	!WORD	_C002		
_B268 
; toolsrc/codegen.pla: 0847:     op->opcode  = code
; toolsrc/codegen.pla: 0848:     op->opgroup = STACK_GROUP
; toolsrc/codegen.pla: 0849:     return seq
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$70			; SB
	!BYTE	$04			; CN	2
	!BYTE	$66,$05			; LLW	[5]
	!BYTE	$8C			; INCR
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$07			; LEAVE	7
; toolsrc/codegen.pla: 0850: end
; toolsrc/codegen.pla: 0851: //
; toolsrc/codegen.pla: 0852: // A DCI string is one that has the high bit set for every character except the last.
; toolsrc/codegen.pla: 0853: // More efficient than C or Pascal strings.
; toolsrc/codegen.pla: 0854: //
; toolsrc/codegen.pla: 0855: def dcitos(dci, str)
					; dci -> [0]
					; str -> [2]
_C068 					; dcitos()
; toolsrc/codegen.pla: 0856:     byte len, c
					; len -> [4]
					; c -> [5]
; toolsrc/codegen.pla: 0857:     len = 0
	!BYTE	$58,$06,$02		; ENTER	6,2
; toolsrc/codegen.pla: 0858:     repeat
	!BYTE	$00			; CN	0
	!BYTE	$74,$04			; SLB	[4]
_B287 
; toolsrc/codegen.pla: 0859:         c = ^(dci + len)
; toolsrc/codegen.pla: 0860:         len++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$60			; LB
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0861:         ^(str + len) = c & $7F
; toolsrc/codegen.pla: 0862:     until not (c & $80)
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$70			; SB
_B288 
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$3C,$80			; ANDI	128
	!BYTE	$4E			; BRTRU	_B287
	!WORD	_B287-*
_B286 
; toolsrc/codegen.pla: 0863:     ^str = len
; toolsrc/codegen.pla: 0864:     return len
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/codegen.pla: 0865: end
; toolsrc/codegen.pla: 0866: def stodci(str, dci)
					; str -> [0]
					; dci -> [2]
_C069 					; stodci()
; toolsrc/codegen.pla: 0867:     byte len, c
					; len -> [4]
					; c -> [5]
; toolsrc/codegen.pla: 0868:     len = ^str
	!BYTE	$58,$06,$02		; ENTER	6,2
; toolsrc/codegen.pla: 0869:     if not len; return 0; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$6C,$04			; DLB	[4]
	!BYTE	$4E			; BRTRU	_B289
	!WORD	_B289-*
	!BYTE	$00			; CN	0
	!BYTE	$5A,$06			; LEAVE	6
_B289 
_B290 
; toolsrc/codegen.pla: 0870:     c = toupper(^(str + len)) & $7F
; toolsrc/codegen.pla: 0871:     len--
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F468 	!WORD	0		
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8E			; DECR
; toolsrc/codegen.pla: 0872:     ^(dci + len) = c
; toolsrc/codegen.pla: 0873:     while len
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B293
	!WORD	_B293-*
_B291 
; toolsrc/codegen.pla: 0874:       c = toupper(^(str + len)) | $80
; toolsrc/codegen.pla: 0875:       len--
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F469 	!WORD	0		
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$8E			; DECR
; toolsrc/codegen.pla: 0876:       ^(dci + len) = c
; toolsrc/codegen.pla: 0877:     loop
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B0,$04			; ADDLB	[4]
	!BYTE	$70			; SB
_B293 
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$4E			; BRTRU	_B291
	!WORD	_B291-*
_B292 
; toolsrc/codegen.pla: 0878:     return ^str
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$60			; LB
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/codegen.pla: 0879: end
; toolsrc/codegen.pla: 0880: //
; toolsrc/codegen.pla: 0881: // Write Extended REL header
; toolsrc/codegen.pla: 0882: //
; toolsrc/codegen.pla: 0883: def writeheader(refnum)
					; refnum -> [0]
_C070 					; writeheader()
; toolsrc/codegen.pla: 0884:     word moddep, modfix
					; moddep -> [2]
					; modfix -> [4]
; toolsrc/codegen.pla: 0885:     byte len, header[128]
					; len -> [6]
					; header -> [7]
; toolsrc/codegen.pla: 0886: 
; toolsrc/codegen.pla: 0887:     moddep = @header:12 // Beginning of module dependency list
	!BYTE	$58,$87,$01		; ENTER	135,1
; toolsrc/codegen.pla: 0888:     while moddep_cnt
	!BYTE	$28,$13			; LLA	[19]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B296
	!WORD	_B296-*
_B294 
; toolsrc/codegen.pla: 0889:         moddep_cnt--
	!BYTE	$68			; LAB	_D079+0
_F470 	!WORD	_D079+0		
	!BYTE	$8E			; DECR
; toolsrc/codegen.pla: 0890:         moddep = moddep + stodci(@moddep_tbl[moddep_cnt*16], moddep)
; toolsrc/codegen.pla: 0891:     loop
	!BYTE	$78			; SAB	_D079+0
_F471 	!WORD	_D079+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D078+0
_F472 	!WORD	_D078+0		
	!BYTE	$68			; LAB	_D079+0
_F473 	!WORD	_D079+0		
	!BYTE	$08			; CN	4
	!BYTE	$9A			; SHL
	!BYTE	$82			; ADD 
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C069
_F474 	!WORD	_C069		
	!BYTE	$82			; ADD 
	!BYTE	$76,$02			; SLW	[2]
_B296 
	!BYTE	$68			; LAB	_D079+0
_F475 	!WORD	_D079+0		
	!BYTE	$4E			; BRTRU	_B294
	!WORD	_B294-*
_B295 
; toolsrc/codegen.pla: 0892:     ^moddep   = 0                        // Terminate dependency list
; toolsrc/codegen.pla: 0893:     len       = moddep - 1 - @header
; toolsrc/codegen.pla: 0894:     modfix    = len + RELADDR - codebuff // Convert generated address into module adress
; toolsrc/codegen.pla: 0895:     header:0  = len + codeptr - codebuff // sizeof header+data+bytecode
; toolsrc/codegen.pla: 0896:     header:2  = $6502                    // Magic #
; toolsrc/codegen.pla: 0897:     header:4  = modsysflags              // Module SYSFLAGS
; toolsrc/codegen.pla: 0898:     header:6  = len + RELADDR + datasize // Byte code offset
; toolsrc/codegen.pla: 0899:     header:8  = def_cnt                  // DEFinition count
; toolsrc/codegen.pla: 0900:     header:10 = entrypoint + modfix      // Init entrypoint
; toolsrc/codegen.pla: 0901:     fileio:write(refnum, @header, len + 2)
; toolsrc/codegen.pla: 0902:     return len
	!BYTE	$00			; CN	0
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$70			; SB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$8E			; DECR
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$84			; SUB 
	!BYTE	$6C,$06			; DLB	[6]
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$82			; ADD 
	!BYTE	$6A			; LAW	_D074+0
_F476 	!WORD	_D074+0		
	!BYTE	$84			; SUB 
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$B6			; ADDAW	_D075+0
_F477 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D074+0
_F478 	!WORD	_D074+0		
	!BYTE	$84			; SUB 
	!BYTE	$76,$07			; SLW	[7]
	!BYTE	$2C,$02,$65		; CW	25858
	!BYTE	$76,$09			; SLW	[9]
	!BYTE	$6A			; LAW	_D077+0
_F479 	!WORD	_D077+0		
	!BYTE	$76,$0B			; SLW	[11]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$82			; ADD 
	!BYTE	$B6			; ADDAW	_D069+0
_F480 	!WORD	_D069+0		
	!BYTE	$76,$0D			; SLW	[13]
	!BYTE	$68			; LAB	_D080+0
_F481 	!WORD	_D080+0		
	!BYTE	$76,$0F			; SLW	[15]
	!BYTE	$6A			; LAW	_D076+0
_F482 	!WORD	_D076+0		
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$76,$11			; SLW	[17]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$28,$07			; LLA	[7]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$6A			; LAW	_X031+20
_F483 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$5A,$87			; LEAVE	135
; toolsrc/codegen.pla: 0903: end
; toolsrc/codegen.pla: 0904: //
; toolsrc/codegen.pla: 0905: // Write DeFinition Directory
; toolsrc/codegen.pla: 0906: //
; toolsrc/codegen.pla: 0907: def writeDFD(refnum, modfix)#0
					; refnum -> [0]
					; modfix -> [2]
_C071 					; writeDFD()
; toolsrc/codegen.pla: 0908:     word dfd, idptr, cnt
					; dfd -> [4]
					; idptr -> [6]
					; cnt -> [8]
; toolsrc/codegen.pla: 0909:     byte defdir[128]
					; defdir -> [10]
; toolsrc/codegen.pla: 0910: 
; toolsrc/codegen.pla: 0911:     dfd = @defdir
	!BYTE	$58,$8A,$02		; ENTER	138,2
; toolsrc/codegen.pla: 0912:     for cnt = 0 to dfd_cnt-1
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$6A			; LAW	_D049+0
_F484 	!WORD	_D049+0		
	!BYTE	$8E			; DECR
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B297
	!WORD	_B297-*
_B298 
	!BYTE	$6E,$08			; DLW	[8]
; toolsrc/codegen.pla: 0913:         dfd->0 = $02
; toolsrc/codegen.pla: 0914:         dfd=>1 = tag_addr=>[dfd_tag=>[cnt]] + modfix
; toolsrc/codegen.pla: 0915:         dfd->3 = 0
; toolsrc/codegen.pla: 0916:         dfd    = dfd + 4
; toolsrc/codegen.pla: 0917:     next
	!BYTE	$04			; CN	2
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D052+0
_F485 	!WORD	_D052+0		
	!BYTE	$6A			; LAW	_D048+0
_F486 	!WORD	_D048+0		
	!BYTE	$BA,$08			; IDXLW	[8]
	!BYTE	$62			; LW
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8C			; INCR
	!BYTE	$72			; SW
	!BYTE	$00			; CN	0
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$76,$04			; SLW	[4]
_B299 
	!BYTE	$A4			; INCBRLE	_B298
	!WORD	_B298-*
_B297 
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$30			; DROP 
; toolsrc/codegen.pla: 0918:     fileio:write(refnum, @defdir, dfd - @defdir)
; toolsrc/codegen.pla: 0919: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$28,$0A			; LLA	[10]
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_X031+20
_F487 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$5A,$8A			; LEAVE	138
; toolsrc/codegen.pla: 0920: //
; toolsrc/codegen.pla: 0921: // Build External Symbol Directory on heap
; toolsrc/codegen.pla: 0922: //
; toolsrc/codegen.pla: 0923: def buildESD(modfix)#2
					; modfix -> [0]
_C072 					; buildESD()
; toolsrc/codegen.pla: 0924:     word modofst, esdtbl, esd, idptr, idcnt, len
					; modofst -> [2]
					; esdtbl -> [4]
					; esd -> [6]
					; idptr -> [8]
					; idcnt -> [10]
					; len -> [12]
; toolsrc/codegen.pla: 0925:     byte symnum
					; symnum -> [14]
; toolsrc/codegen.pla: 0926: 
; toolsrc/codegen.pla: 0927:     symnum, esdtbl, idptr, idcnt = 0, heapalloc(heapavail - 256), idglobal_tbl, globals
	!BYTE	$58,$0F,$01		; ENTER	15,1
; toolsrc/codegen.pla: 0928:     esd = esdtbl
; toolsrc/codegen.pla: 0929:     while idcnt
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_X016
_F488 	!WORD	0		
	!BYTE	$2C,$00,$01		; CW	256
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X014
_F489 	!WORD	0		
	!BYTE	$6A			; LAW	_D054+0
_F490 	!WORD	_D054+0		
	!BYTE	$6A			; LAW	_D057+0
_F491 	!WORD	_D057+0		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$74,$0E			; SLB	[14]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$50			; BRNCH	_B302
	!WORD	_B302-*
_B300 
; toolsrc/codegen.pla: 0930:         if idptr=>idtype & EXPORT_TYPE
; toolsrc/codegen.pla: 0931:             esd           = esd + stodci(@idptr->idname, esd)
; toolsrc/codegen.pla: 0932:             esd->0        = $08
; toolsrc/codegen.pla: 0933:             esd=>1        = tag_addr=>[idptr=>idval] + modfix
; toolsrc/codegen.pla: 0934:             esd           = esd + 3
; toolsrc/codegen.pla: 0935:         elsif idptr=>idtype & EXTACCESS_TYPE
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B303
	!WORD	_B303-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C069
_F492 	!WORD	_C069		
	!BYTE	$82			; ADD 
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$10			; CN	8
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D052+0
_F493 	!WORD	_D052+0		
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$62			; LW
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$B2,$00			; ADDLW	[0]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8C			; INCR
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$50			; BRNCH	_B304
	!WORD	_B304-*
_B303 
; toolsrc/codegen.pla: 0936:             esd           = esd + stodci(@idptr->idname, esd)
; toolsrc/codegen.pla: 0937:             esd->0        = $10
; toolsrc/codegen.pla: 0938:             esd=>1        = symnum
; toolsrc/codegen.pla: 0939:             esd           = esd + 3
; toolsrc/codegen.pla: 0940:             idptr->extnum = symnum
; toolsrc/codegen.pla: 0941:             symnum++
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$2C,$00,$08		; CW	2048
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B305
	!WORD	_B305-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C069
_F494 	!WORD	_C069		
	!BYTE	$82			; ADD 
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$2A,$10			; CB	16
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8C			; INCR
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$70			; SB
	!BYTE	$64,$0E			; LLB	[14]
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0942:         fin
	!BYTE	$74,$0E			; SLB	[14]
_B305 
_B304 
; toolsrc/codegen.pla: 0943:         idptr = idptr + idptr->idname + t_id
; toolsrc/codegen.pla: 0944:         idcnt--
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$34			; DUP
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$8E			; DECR
; toolsrc/codegen.pla: 0945:     loop
	!BYTE	$76,$0A			; SLW	[10]
_B302 
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$4E			; BRTRU	_B300
	!WORD	_B300-*
_B301 
; toolsrc/codegen.pla: 0946:     ^esd = 0
; toolsrc/codegen.pla: 0947:     len  = esd - esdtbl + 1
; toolsrc/codegen.pla: 0948:     heaprelease(esdtbl + len)
; toolsrc/codegen.pla: 0949:     return esdtbl, len
	!BYTE	$00			; CN	0
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$70			; SB
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$84			; SUB 
	!BYTE	$8C			; INCR
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$B2,$0C			; ADDLW	[12]
	!BYTE	$54			; CALL	_X015
_F495 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$5A,$0F			; LEAVE	15
; toolsrc/codegen.pla: 0950: end
; toolsrc/codegen.pla: 0951: //
; toolsrc/codegen.pla: 0952: // Write ReLocation Directory
; toolsrc/codegen.pla: 0953: //
; toolsrc/codegen.pla: 0954: def writeRLD(refnum, modofst)#0
					; refnum -> [0]
					; modofst -> [2]
_C073 					; writeRLD()
; toolsrc/codegen.pla: 0955:     word rldtbl, rld, rldlen, fixups, updtptr, idptr, idcnt, tag
					; rldtbl -> [4]
					; rld -> [6]
					; rldlen -> [8]
					; fixups -> [10]
					; updtptr -> [12]
					; idptr -> [14]
					; idcnt -> [16]
					; tag -> [18]
; toolsrc/codegen.pla: 0956:     byte type
					; type -> [20]
; toolsrc/codegen.pla: 0957: 
; toolsrc/codegen.pla: 0958:     rldtbl = heapalloc(heapavail - 256)
	!BYTE	$58,$15,$02		; ENTER	21,2
; toolsrc/codegen.pla: 0959:     rld    = rldtbl
; toolsrc/codegen.pla: 0960:     rldlen = 0
; toolsrc/codegen.pla: 0961:     for fixups = fixup_cnt-1 downto 0
	!BYTE	$54			; CALL	_X016
_F496 	!WORD	0		
	!BYTE	$2C,$00,$01		; CW	256
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X014
_F497 	!WORD	0		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$00			; CN	0
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D046+0
_F498 	!WORD	_D046+0		
	!BYTE	$8E			; DECR
	!BYTE	$A2			; BRLT	_B306
	!WORD	_B306-*
_B307 
	!BYTE	$6E,$0A			; DLW	[10]
; toolsrc/codegen.pla: 0962:         tag  = fixup_tag=>[fixups]
; toolsrc/codegen.pla: 0963:         type = tag_type->[tag]
; toolsrc/codegen.pla: 0964:         if not (type & RELATIVE_FIXUP)
; toolsrc/codegen.pla: 0965:             if rldlen == 64 // Write out blocks of entries
; toolsrc/codegen.pla: 0966:                 fileio:write(refnum, rldtbl, rld - rldtbl)
; toolsrc/codegen.pla: 0967:                 rld    = rldtbl
; toolsrc/codegen.pla: 0968:                 rldlen = 0
; toolsrc/codegen.pla: 0969:             fin
	!BYTE	$6A			; LAW	_D050+0
_F499 	!WORD	_D050+0		
	!BYTE	$BA,$0A			; IDXLW	[10]
	!BYTE	$62			; LW
	!BYTE	$76,$12			; SLW	[18]
	!BYTE	$6A			; LAW	_D053+0
_F500 	!WORD	_D053+0		
	!BYTE	$B2,$12			; ADDLW	[18]
	!BYTE	$60			; LB
	!BYTE	$6C,$14			; DLB	[20]
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4E			; BRTRU	_B309
	!WORD	_B309-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$2A,$40			; CB	64
	!BYTE	$24			; BRNE	_B311
	!WORD	_B311-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_X031+20
_F501 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$00			; CN	0
	!BYTE	$76,$08			; SLW	[8]
_B311 
_B312 
; toolsrc/codegen.pla: 0970:             if type & EXTERN_FIXUP
; toolsrc/codegen.pla: 0971:                 idptr = idglobal_tbl
; toolsrc/codegen.pla: 0972:                 for idcnt = globals-1 downto 0
	!BYTE	$64,$14			; LLB	[20]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B313
	!WORD	_B313-*
	!BYTE	$6A			; LAW	_D054+0
_F502 	!WORD	_D054+0		
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D057+0
_F503 	!WORD	_D057+0		
	!BYTE	$8E			; DECR
	!BYTE	$A2			; BRLT	_B315
	!WORD	_B315-*
_B316 
	!BYTE	$6E,$10			; DLW	[16]
; toolsrc/codegen.pla: 0973:                     if (idptr=>idtype & EXTERN_TYPE) and (idptr=>idval == tag)
; toolsrc/codegen.pla: 0974:                         rld->3 = idptr->extnum
; toolsrc/codegen.pla: 0975:                         break
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$2C,$00,$04		; CW	1024
	!BYTE	$94			; AND 
	!BYTE	$AC			; BRAND	_B318
	!WORD	_B318-*
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$62			; LW
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$40			; ISEQ
_B318 
	!BYTE	$4C			; BRFLS	_B319
	!WORD	_B319-*
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$38,$06			; ADDI	6
	!BYTE	$60			; LB
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B315
	!WORD	_B315-*
; toolsrc/codegen.pla: 0976:                     fin
_B319 
_B320 
; toolsrc/codegen.pla: 0977:                     idptr = idptr + idptr->idname + t_id
; toolsrc/codegen.pla: 0978:                 next
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$34			; DUP
	!BYTE	$38,$07			; ADDI	7
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$38,$08			; ADDI	8
	!BYTE	$76,$0E			; SLW	[14]
_B317 
	!BYTE	$A8			; DECBRGE	_B316
	!WORD	_B316-*
_B315 
	!BYTE	$76,$10			; SLW	[16]
	!BYTE	$30			; DROP 
; toolsrc/codegen.pla: 0979:             else
	!BYTE	$50			; BRNCH	_B314
	!WORD	_B314-*
_B313 
; toolsrc/codegen.pla: 0980:                 rld->3 = 0
; toolsrc/codegen.pla: 0981:             fin
	!BYTE	$00			; CN	0
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$03			; ADDI	3
	!BYTE	$70			; SB
_B314 
; toolsrc/codegen.pla: 0982:             rld->0 = $01 | (type & MASK_FIXUP)
; toolsrc/codegen.pla: 0983:             rld=>1 = fixup_addr=>[fixups] + modofst
; toolsrc/codegen.pla: 0984:             rld    = rld + 4
; toolsrc/codegen.pla: 0985:             rldlen++
	!BYTE	$02			; CN	1
	!BYTE	$64,$14			; LLB	[20]
	!BYTE	$3C,$90			; ANDI	144
	!BYTE	$96			; OR 
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D051+0
_F504 	!WORD	_D051+0		
	!BYTE	$BA,$0A			; IDXLW	[10]
	!BYTE	$62			; LW
	!BYTE	$B2,$02			; ADDLW	[2]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$8C			; INCR
	!BYTE	$72			; SW
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8C			; INCR
; toolsrc/codegen.pla: 0986:         fin
	!BYTE	$76,$08			; SLW	[8]
_B309 
_B310 
; toolsrc/codegen.pla: 0987:     next
_B308 
	!BYTE	$A8			; DECBRGE	_B307
	!WORD	_B307-*
_B306 
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$30			; DROP 
; toolsrc/codegen.pla: 0988:     ^rld = 0
; toolsrc/codegen.pla: 0989:     fileio:write(refnum, rldtbl, rld - rldtbl + 1)
; toolsrc/codegen.pla: 0990:     heaprelease(rldtbl)
; toolsrc/codegen.pla: 0991: end
	!BYTE	$00			; CN	0
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$70			; SB
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$84			; SUB 
	!BYTE	$8C			; INCR
	!BYTE	$6A			; LAW	_X031+20
_F505 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_X015
_F506 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$5A,$15			; LEAVE	21
; toolsrc/codegen.pla: 0992: //
; toolsrc/codegen.pla: 0993: // Write Extended REL file
; toolsrc/codegen.pla: 0994: //
; toolsrc/codegen.pla: 0995: def writemodule(refnum)#0
					; refnum -> [0]
_C074 					; writemodule()
; toolsrc/codegen.pla: 0996:     word hdrlen, esd, esdlen, modfix, modadj, modofst, fixups, updtptr
					; hdrlen -> [2]
					; esd -> [4]
					; esdlen -> [6]
					; modfix -> [8]
					; modadj -> [10]
					; modofst -> [12]
					; fixups -> [14]
					; updtptr -> [16]
; toolsrc/codegen.pla: 0997: 
; toolsrc/codegen.pla: 0998:     //
; toolsrc/codegen.pla: 0999:     // Write module header
; toolsrc/codegen.pla: 1000:     //
; toolsrc/codegen.pla: 1001:     hdrlen  = writeheader(refnum)
	!BYTE	$58,$12,$01		; ENTER	18,1
; toolsrc/codegen.pla: 1002:     modfix  = hdrlen + RELADDR
; toolsrc/codegen.pla: 1003:     modofst = hdrlen - codebuff
; toolsrc/codegen.pla: 1004:     //
; toolsrc/codegen.pla: 1005:     // Adjust internal fixups for header size
; toolsrc/codegen.pla: 1006:     //
; toolsrc/codegen.pla: 1007:     for fixups = fixup_cnt-1 downto 0
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C070
_F507 	!WORD	_C070		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$82			; ADD 
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$6A			; LAW	_D074+0
_F508 	!WORD	_D074+0		
	!BYTE	$84			; SUB 
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D046+0
_F509 	!WORD	_D046+0		
	!BYTE	$8E			; DECR
	!BYTE	$A2			; BRLT	_B321
	!WORD	_B321-*
_B322 
	!BYTE	$6E,$0E			; DLW	[14]
; toolsrc/codegen.pla: 1008:         if not (tag_type->[fixup_tag=>[fixups]] & (EXTERN_FIXUP|RELATIVE_FIXUP))
; toolsrc/codegen.pla: 1009:             updtptr  = fixup_addr=>[fixups]
; toolsrc/codegen.pla: 1010:             *updtptr = *updtptr + modfix
; toolsrc/codegen.pla: 1011:         fin
	!BYTE	$6A			; LAW	_D053+0
_F510 	!WORD	_D053+0		
	!BYTE	$6A			; LAW	_D050+0
_F511 	!WORD	_D050+0		
	!BYTE	$BA,$0E			; IDXLW	[14]
	!BYTE	$62			; LW
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$3C,$12			; ANDI	18
	!BYTE	$4E			; BRTRU	_B324
	!WORD	_B324-*
	!BYTE	$6A			; LAW	_D051+0
_F512 	!WORD	_D051+0		
	!BYTE	$BA,$0E			; IDXLW	[14]
	!BYTE	$62			; LW
	!BYTE	$6E,$10			; DLW	[16]
	!BYTE	$62			; LW
	!BYTE	$B2,$08			; ADDLW	[8]
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$72			; SW
_B324 
_B325 
; toolsrc/codegen.pla: 1012:     next
_B323 
	!BYTE	$A8			; DECBRGE	_B322
	!WORD	_B322-*
_B321 
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$30			; DROP 
; toolsrc/codegen.pla: 1013:     //
; toolsrc/codegen.pla: 1014:     // Write data/code buffer
; toolsrc/codegen.pla: 1015:     //
; toolsrc/codegen.pla: 1016:     fileio:write(refnum, codebuff, codeptr - codebuff)
; toolsrc/codegen.pla: 1017:     //
; toolsrc/codegen.pla: 1018:     // Write bytecode definition directory
; toolsrc/codegen.pla: 1019:     //
; toolsrc/codegen.pla: 1020:     writeDFD(refnum, modfix)
; toolsrc/codegen.pla: 1021:     //
; toolsrc/codegen.pla: 1022:     // Build EXERN/ENTRY directory
; toolsrc/codegen.pla: 1023:     //
; toolsrc/codegen.pla: 1024:     esd, esdlen = buildESD(modfix)
; toolsrc/codegen.pla: 1025:     //
; toolsrc/codegen.pla: 1026:     // Write relocation directory
; toolsrc/codegen.pla: 1027:     //
; toolsrc/codegen.pla: 1028:     writeRLD(refnum, modofst)
; toolsrc/codegen.pla: 1029:     //
; toolsrc/codegen.pla: 1030:     // Write EXTERN/EBTRY directory
; toolsrc/codegen.pla: 1031:     //
; toolsrc/codegen.pla: 1032:     fileio:write(refnum, esd, esdlen)
; toolsrc/codegen.pla: 1033:     heaprelease(esd)
; toolsrc/codegen.pla: 1034: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D074+0
_F513 	!WORD	_D074+0		
	!BYTE	$6A			; LAW	_D075+0
_F514 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D074+0
_F515 	!WORD	_D074+0		
	!BYTE	$84			; SUB 
	!BYTE	$6A			; LAW	_X031+20
_F516 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$54			; CALL	_C071
_F517 	!WORD	_C071		
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$54			; CALL	_C072
_F518 	!WORD	_C072		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$54			; CALL	_C073
_F519 	!WORD	_C073		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$6A			; LAW	_X031+20
_F520 	!WORD	0+20		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_X015
_F521 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$5A,$12			; LEAVE	18
; toolsrc/plasm.pla: 0505: 
; toolsrc/plasm.pla: 0506: include "toolsrc/lex.pla"
; toolsrc/lex.pla: 0001: //
; toolsrc/lex.pla: 0002: // Lexical anaylzer
; toolsrc/lex.pla: 0003: //
; toolsrc/lex.pla: 0004: //def isalpha(c)
; toolsrc/lex.pla: 0005: //    if c >= 'A' and c <= 'Z'
; toolsrc/lex.pla: 0006: //        return TRUE
; toolsrc/lex.pla: 0007: //    //elsif c >= 'a' and c <= 'z'
; toolsrc/lex.pla: 0008: //    //    return TRUE
; toolsrc/lex.pla: 0009: //    elsif c == '_'
; toolsrc/lex.pla: 0010: //        return TRUE
; toolsrc/lex.pla: 0011: //    fin
; toolsrc/lex.pla: 0012: //    return FALSE
; toolsrc/lex.pla: 0013: //end
; toolsrc/lex.pla: 0014: //def isnum(c)
; toolsrc/lex.pla: 0015: //    return c >= '0' and c <= '9'
; toolsrc/lex.pla: 0016: //end
; toolsrc/lex.pla: 0017: //def isalphanum(c)
; toolsrc/lex.pla: 0018: //    if c >= 'A' and c <= 'Z'
; toolsrc/lex.pla: 0019: //        return TRUE
; toolsrc/lex.pla: 0020: //    //elsif c >= 'a' and c <= 'z'
; toolsrc/lex.pla: 0021: //    //    return TRUE
; toolsrc/lex.pla: 0022: //    elsif c >= '0' and c <= '9'
; toolsrc/lex.pla: 0023: //        return TRUE
; toolsrc/lex.pla: 0024: //    elsif c == '_'
; toolsrc/lex.pla: 0025: //        return TRUE
; toolsrc/lex.pla: 0026: //    fin
; toolsrc/lex.pla: 0027: //    return FALSE
; toolsrc/lex.pla: 0028: //end
; toolsrc/lex.pla: 0029: //def keymatch
; toolsrc/lex.pla: 0030: //    byte i, keypos
; toolsrc/lex.pla: 0031: //    word chrptr
; toolsrc/lex.pla: 0032: //
; toolsrc/lex.pla: 0033: //    keypos = 0
; toolsrc/lex.pla: 0034: //    while keywrds[keypos] < tknlen
; toolsrc/lex.pla: 0035: //        keypos = keypos + keywrds[keypos] + 2
; toolsrc/lex.pla: 0036: //    loop
; toolsrc/lex.pla: 0037: //    chrptr = tknptr - 1
; toolsrc/lex.pla: 0038: //    while keywrds[keypos] == tknlen
; toolsrc/lex.pla: 0039: //        for i = 1 to tknlen
; toolsrc/lex.pla: 0040: //            if ^(chrptr + i) <> keywrds[keypos + i]; break; fin
; toolsrc/lex.pla: 0041: //         next
; toolsrc/lex.pla: 0042: //        if i > tknlen
; toolsrc/lex.pla: 0043: //            return keywrds[keypos + keywrds[keypos] + 1]
; toolsrc/lex.pla: 0044: //        fin
; toolsrc/lex.pla: 0045: //        keypos = keypos + keywrds[keypos] + 2
; toolsrc/lex.pla: 0046: //    loop
; toolsrc/lex.pla: 0047: //    return ID_TKN
; toolsrc/lex.pla: 0048: //end
; toolsrc/lex.pla: 0049: def scannum
_C075 					; scannum()
; toolsrc/lex.pla: 0050:     word num
					; num -> [0]
; toolsrc/lex.pla: 0051:     num = 0
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/lex.pla: 0052: 
; toolsrc/lex.pla: 0053:     if ^scanptr == '$'
; toolsrc/lex.pla: 0054:         repeat
	!BYTE	$00			; CN	0
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$6A			; LAW	_D097+0
_F522 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$24			; CB	36
	!BYTE	$24			; BRNE	_B326
	!WORD	_B326-*
_B329 
; toolsrc/lex.pla: 0055:             scanptr++
	!BYTE	$6A			; LAW	_D097+0
_F523 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0056:             if ^scanptr >= '0' and ^scanptr <= '9'
; toolsrc/lex.pla: 0057:                 num = (num << 4) + ^scanptr - '0'
; toolsrc/lex.pla: 0058:             elsif ^scanptr >= 'A' and ^scanptr <= 'F'
	!BYTE	$7A			; SAW	_D097+0
_F524 	!WORD	_D097+0		
	!BYTE	$6A			; LAW	_D097+0
_F525 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B331
	!WORD	_B331-*
	!BYTE	$6A			; LAW	_D097+0
_F526 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$39			; CB	57
	!BYTE	$4A			; ISLE
_B331 
	!BYTE	$4C			; BRFLS	_B332
	!WORD	_B332-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$08			; CN	4
	!BYTE	$9A			; SHL
	!BYTE	$6A			; LAW	_D097+0
_F527 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B333
	!WORD	_B333-*
_B332 
; toolsrc/lex.pla: 0059:                 num = (num << 4) + ^scanptr - '7'// 'A'-10
; toolsrc/lex.pla: 0060:             elsif ^scanptr >= 'a' and ^scanptr <= 'f'
	!BYTE	$6A			; LAW	_D097+0
_F528 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$41			; CB	65
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B334
	!WORD	_B334-*
	!BYTE	$6A			; LAW	_D097+0
_F529 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$46			; CB	70
	!BYTE	$4A			; ISLE
_B334 
	!BYTE	$4C			; BRFLS	_B335
	!WORD	_B335-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$08			; CN	4
	!BYTE	$9A			; SHL
	!BYTE	$6A			; LAW	_D097+0
_F530 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$3A,$37			; SUBI	55
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B333
	!WORD	_B333-*
_B335 
; toolsrc/lex.pla: 0061:                 num = (num << 4) + ^scanptr - 'W'// 'a'-10
; toolsrc/lex.pla: 0062:             else
	!BYTE	$6A			; LAW	_D097+0
_F531 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$61			; CB	97
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B336
	!WORD	_B336-*
	!BYTE	$6A			; LAW	_D097+0
_F532 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$66			; CB	102
	!BYTE	$4A			; ISLE
_B336 
	!BYTE	$4C			; BRFLS	_B337
	!WORD	_B337-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$08			; CN	4
	!BYTE	$9A			; SHL
	!BYTE	$6A			; LAW	_D097+0
_F533 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$3A,$57			; SUBI	87
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B333
	!WORD	_B333-*
_B337 
; toolsrc/lex.pla: 0063:                 break
	!BYTE	$50			; BRNCH	_B328
	!WORD	_B328-*
; toolsrc/lex.pla: 0064:             fin
_B333 
; toolsrc/lex.pla: 0065:         until not ^scanptr
_B330 
	!BYTE	$6A			; LAW	_D097+0
_F534 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B329
	!WORD	_B329-*
_B328 
; toolsrc/lex.pla: 0066:     elsif ^scanptr < '0' or ^scanptr > '9'
	!BYTE	$50			; BRNCH	_B327
	!WORD	_B327-*
_B326 
; toolsrc/lex.pla: 0067:         repeat
	!BYTE	$6A			; LAW	_D097+0
_F535 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$46			; ISLT
	!BYTE	$AE			; BROR	_B338
	!WORD	_B338-*
	!BYTE	$6A			; LAW	_D097+0
_F536 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$39			; CB	57
	!BYTE	$44			; ISGT
_B338 
	!BYTE	$4C			; BRFLS	_B339
	!WORD	_B339-*
_B341 
; toolsrc/lex.pla: 0068:             num = num * 10 + ^scanptr - '0'
; toolsrc/lex.pla: 0069:             scanptr++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$14			; CN	10
	!BYTE	$86			; MUL
	!BYTE	$6A			; LAW	_D097+0
_F537 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$6A			; LAW	_D097+0
_F538 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0070:         until ^scanptr < '0' or ^scanptr > '9'
	!BYTE	$7A			; SAW	_D097+0
_F539 	!WORD	_D097+0		
_B342 
	!BYTE	$6A			; LAW	_D097+0
_F540 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$46			; ISLT
	!BYTE	$AE			; BROR	_B343
	!WORD	_B343-*
	!BYTE	$6A			; LAW	_D097+0
_F541 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$39			; CB	57
	!BYTE	$44			; ISGT
_B343 
	!BYTE	$4C			; BRFLS	_B341
	!WORD	_B341-*
_B340 
; toolsrc/lex.pla: 0071:     else
	!BYTE	$50			; BRNCH	_B327
	!WORD	_B327-*
_B339 
; toolsrc/lex.pla: 0072:         num = ^scanptr
; toolsrc/lex.pla: 0073:     fin
	!BYTE	$6A			; LAW	_D097+0
_F542 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$76,$00			; SLW	[0]
_B327 
; toolsrc/lex.pla: 0074:     return num
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/lex.pla: 0075: end
; toolsrc/lex.pla: 0076: 
; toolsrc/lex.pla: 0077: def scan
_C076 					; scan()
; toolsrc/lex.pla: 0078:     //
; toolsrc/lex.pla: 0079:     // Skip whitespace
; toolsrc/lex.pla: 0080:     //
; toolsrc/lex.pla: 0081:     while ^scanptr == ' '
	!BYTE	$50			; BRNCH	_B346
	!WORD	_B346-*
_B344 
; toolsrc/lex.pla: 0082:         scanptr++
	!BYTE	$6A			; LAW	_D097+0
_F543 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0083:     loop
	!BYTE	$7A			; SAW	_D097+0
_F544 	!WORD	_D097+0		
_B346 
	!BYTE	$6A			; LAW	_D097+0
_F545 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$20			; CB	32
	!BYTE	$22			; BREQ	_B344
	!WORD	_B344-*
_B345 
; toolsrc/lex.pla: 0084:     tknptr  = scanptr
; toolsrc/lex.pla: 0085:     scanchr, scanptr, token = scanid(scanptr, @keywrds) //scanchr = toupper(^scanptr)
; toolsrc/lex.pla: 0086:     //
; toolsrc/lex.pla: 0087:     // Scan for token based on first character
; toolsrc/lex.pla: 0088:     //
; toolsrc/lex.pla: 0089:     if token //if isalpha(scanchr)
; toolsrc/lex.pla: 0090:         //
; toolsrc/lex.pla: 0091:         // ID, either variable name or reserved word
; toolsrc/lex.pla: 0092:         //
; toolsrc/lex.pla: 0093:         //repeat
; toolsrc/lex.pla: 0094:         //    ^scanptr = scanchr
; toolsrc/lex.pla: 0095:         //    scanptr++
; toolsrc/lex.pla: 0096:         //    scanchr = toupper(^scanptr)
; toolsrc/lex.pla: 0097:         //until not isalphanum(scanchr)
; toolsrc/lex.pla: 0098:         tknlen = scanptr - tknptr
; toolsrc/lex.pla: 0099:     elsif scanchr >= '0' and scanchr <= '9' // isnum()
	!BYTE	$6A			; LAW	_D097+0
_F546 	!WORD	_D097+0		
	!BYTE	$7A			; SAW	_D101+0
_F547 	!WORD	_D101+0		
	!BYTE	$6A			; LAW	_D097+0
_F548 	!WORD	_D097+0		
	!BYTE	$26			; LA	_D036+0
_F549 	!WORD	_D036+0		
	!BYTE	$54			; CALL	_A000
_F550 	!WORD	_A000		
	!BYTE	$78			; SAB	_D098+0
_F551 	!WORD	_D098+0		
	!BYTE	$7A			; SAW	_D097+0
_F552 	!WORD	_D097+0		
	!BYTE	$78			; SAB	_D099+0
_F553 	!WORD	_D099+0		
	!BYTE	$68			; LAB	_D098+0
_F554 	!WORD	_D098+0		
	!BYTE	$4C			; BRFLS	_B347
	!WORD	_B347-*
	!BYTE	$6A			; LAW	_D097+0
_F555 	!WORD	_D097+0		
	!BYTE	$6A			; LAW	_D101+0
_F556 	!WORD	_D101+0		
	!BYTE	$84			; SUB 
	!BYTE	$78			; SAB	_D100+0
_F557 	!WORD	_D100+0		
	!BYTE	$50			; BRNCH	_B348
	!WORD	_B348-*
_B347 
; toolsrc/lex.pla: 0100:         //
; toolsrc/lex.pla: 0101:         // Decimal constant
; toolsrc/lex.pla: 0102:         //
; toolsrc/lex.pla: 0103:         token    = INT_TKN
; toolsrc/lex.pla: 0104:         constval = 0
; toolsrc/lex.pla: 0105:         repeat
	!BYTE	$68			; LAB	_D099+0
_F558 	!WORD	_D099+0		
	!BYTE	$2A,$30			; CB	48
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B349
	!WORD	_B349-*
	!BYTE	$68			; LAB	_D099+0
_F559 	!WORD	_D099+0		
	!BYTE	$2A,$39			; CB	57
	!BYTE	$4A			; ISLE
_B349 
	!BYTE	$4C			; BRFLS	_B350
	!WORD	_B350-*
	!BYTE	$2A,$C9			; CB	201
	!BYTE	$78			; SAB	_D098+0
_F560 	!WORD	_D098+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D103+0
_F561 	!WORD	_D103+0		
_B352 
; toolsrc/lex.pla: 0106:             constval = constval * 10 + ^scanptr - '0'
; toolsrc/lex.pla: 0107:             scanptr++
	!BYTE	$6A			; LAW	_D103+0
_F562 	!WORD	_D103+0		
	!BYTE	$14			; CN	10
	!BYTE	$86			; MUL
	!BYTE	$6A			; LAW	_D097+0
_F563 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$7A			; SAW	_D103+0
_F564 	!WORD	_D103+0		
	!BYTE	$6A			; LAW	_D097+0
_F565 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0108:         until ^scanptr < '0' or ^scanptr > '9'
	!BYTE	$7A			; SAW	_D097+0
_F566 	!WORD	_D097+0		
_B353 
	!BYTE	$6A			; LAW	_D097+0
_F567 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$46			; ISLT
	!BYTE	$AE			; BROR	_B354
	!WORD	_B354-*
	!BYTE	$6A			; LAW	_D097+0
_F568 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$39			; CB	57
	!BYTE	$44			; ISGT
_B354 
	!BYTE	$4C			; BRFLS	_B352
	!WORD	_B352-*
_B351 
; toolsrc/lex.pla: 0109:     else
	!BYTE	$50			; BRNCH	_B348
	!WORD	_B348-*
_B350 
; toolsrc/lex.pla: 0110:         //
; toolsrc/lex.pla: 0111:         // Potential multiple character tokens
; toolsrc/lex.pla: 0112:         //
; toolsrc/lex.pla: 0113:         when scanchr
	!BYTE	$68			; LAB	_D099+0
_F569 	!WORD	_D099+0		
	!BYTE	$52			; SEL
	!WORD	_B356-*
; toolsrc/lex.pla: 0114:             is '$'
_B357 
; toolsrc/lex.pla: 0115:                 //
; toolsrc/lex.pla: 0116:                 // Hexadecimal constant
; toolsrc/lex.pla: 0117:                 //
; toolsrc/lex.pla: 0118:                 token    = INT_TKN
; toolsrc/lex.pla: 0119:                 constval = 0
; toolsrc/lex.pla: 0120:                 repeat
	!BYTE	$2A,$C9			; CB	201
	!BYTE	$78			; SAB	_D098+0
_F570 	!WORD	_D098+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D103+0
_F571 	!WORD	_D103+0		
_B359 
; toolsrc/lex.pla: 0121:                     scanptr++
	!BYTE	$6A			; LAW	_D097+0
_F572 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0122:                     if ^scanptr >= '0' and ^scanptr <= '9'
; toolsrc/lex.pla: 0123:                         constval = (constval << 4) + ^scanptr - '0'
; toolsrc/lex.pla: 0124:                     elsif ^scanptr >= 'A' and ^scanptr <= 'F'
	!BYTE	$7A			; SAW	_D097+0
_F573 	!WORD	_D097+0		
	!BYTE	$6A			; LAW	_D097+0
_F574 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$30			; CB	48
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B361
	!WORD	_B361-*
	!BYTE	$6A			; LAW	_D097+0
_F575 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$39			; CB	57
	!BYTE	$4A			; ISLE
_B361 
	!BYTE	$4C			; BRFLS	_B362
	!WORD	_B362-*
	!BYTE	$6A			; LAW	_D103+0
_F576 	!WORD	_D103+0		
	!BYTE	$08			; CN	4
	!BYTE	$9A			; SHL
	!BYTE	$6A			; LAW	_D097+0
_F577 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$3A,$30			; SUBI	48
	!BYTE	$7A			; SAW	_D103+0
_F578 	!WORD	_D103+0		
	!BYTE	$50			; BRNCH	_B363
	!WORD	_B363-*
_B362 
; toolsrc/lex.pla: 0125:                         constval = (constval << 4) + ^scanptr - '7'// 'A'-10
; toolsrc/lex.pla: 0126:                     elsif ^scanptr >= 'a' and ^scanptr <= 'f'
	!BYTE	$6A			; LAW	_D097+0
_F579 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$41			; CB	65
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B364
	!WORD	_B364-*
	!BYTE	$6A			; LAW	_D097+0
_F580 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$46			; CB	70
	!BYTE	$4A			; ISLE
_B364 
	!BYTE	$4C			; BRFLS	_B365
	!WORD	_B365-*
	!BYTE	$6A			; LAW	_D103+0
_F581 	!WORD	_D103+0		
	!BYTE	$08			; CN	4
	!BYTE	$9A			; SHL
	!BYTE	$6A			; LAW	_D097+0
_F582 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$3A,$37			; SUBI	55
	!BYTE	$7A			; SAW	_D103+0
_F583 	!WORD	_D103+0		
	!BYTE	$50			; BRNCH	_B363
	!WORD	_B363-*
_B365 
; toolsrc/lex.pla: 0127:                         constval = (constval << 4) + ^scanptr - 'W'// 'a'-10
; toolsrc/lex.pla: 0128:                     else
	!BYTE	$6A			; LAW	_D097+0
_F584 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$61			; CB	97
	!BYTE	$48			; ISGE
	!BYTE	$AC			; BRAND	_B366
	!WORD	_B366-*
	!BYTE	$6A			; LAW	_D097+0
_F585 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$66			; CB	102
	!BYTE	$4A			; ISLE
_B366 
	!BYTE	$4C			; BRFLS	_B367
	!WORD	_B367-*
	!BYTE	$6A			; LAW	_D103+0
_F586 	!WORD	_D103+0		
	!BYTE	$08			; CN	4
	!BYTE	$9A			; SHL
	!BYTE	$6A			; LAW	_D097+0
_F587 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$3A,$57			; SUBI	87
	!BYTE	$7A			; SAW	_D103+0
_F588 	!WORD	_D103+0		
	!BYTE	$50			; BRNCH	_B363
	!WORD	_B363-*
_B367 
; toolsrc/lex.pla: 0129:                         break
	!BYTE	$50			; BRNCH	_B358
	!WORD	_B358-*
; toolsrc/lex.pla: 0130:                     fin
_B363 
; toolsrc/lex.pla: 0131:                 until not ^scanptr
_B360 
	!BYTE	$6A			; LAW	_D097+0
_F589 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B359
	!WORD	_B359-*
_B358 
; toolsrc/lex.pla: 0132:                 break
	!BYTE	$50			; BRNCH	_B355
	!WORD	_B355-*
; toolsrc/lex.pla: 0133:             is '\''
_B368 
; toolsrc/lex.pla: 0134:                 //
; toolsrc/lex.pla: 0135:                 // Character constant
; toolsrc/lex.pla: 0136:                 //
; toolsrc/lex.pla: 0137:                 token = CHR_TKN
; toolsrc/lex.pla: 0138:                 scanptr++
	!BYTE	$2A,$C3			; CB	195
	!BYTE	$78			; SAB	_D098+0
_F590 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F591 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0139:                 if ^scanptr <> '\\'
; toolsrc/lex.pla: 0140:                     constval = ^scanptr
; toolsrc/lex.pla: 0141:                 else
	!BYTE	$7A			; SAW	_D097+0
_F592 	!WORD	_D097+0		
	!BYTE	$6A			; LAW	_D097+0
_F593 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$5C			; CB	92
	!BYTE	$22			; BREQ	_B369
	!WORD	_B369-*
	!BYTE	$6A			; LAW	_D097+0
_F594 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$7A			; SAW	_D103+0
_F595 	!WORD	_D103+0		
	!BYTE	$50			; BRNCH	_B370
	!WORD	_B370-*
_B369 
; toolsrc/lex.pla: 0142:                     scanptr++
	!BYTE	$6A			; LAW	_D097+0
_F596 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0143:                     when ^scanptr
	!BYTE	$7A			; SAW	_D097+0
_F597 	!WORD	_D097+0		
	!BYTE	$6A			; LAW	_D097+0
_F598 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B372-*
; toolsrc/lex.pla: 0144:                         is 'n'
_B373 
; toolsrc/lex.pla: 0145:                         is 'N'
_B374 
; toolsrc/lex.pla: 0146:                             constval = $0D; break
	!BYTE	$1A			; CN	13
	!BYTE	$7A			; SAW	_D103+0
_F599 	!WORD	_D103+0		
	!BYTE	$50			; BRNCH	_B371
	!WORD	_B371-*
; toolsrc/lex.pla: 0147:                         is 'r'
_B375 
; toolsrc/lex.pla: 0148:                         is 'R'
_B376 
; toolsrc/lex.pla: 0149:                             constval = $0A; break
	!BYTE	$14			; CN	10
	!BYTE	$7A			; SAW	_D103+0
_F600 	!WORD	_D103+0		
	!BYTE	$50			; BRNCH	_B371
	!WORD	_B371-*
; toolsrc/lex.pla: 0150:                         is 't'
_B377 
; toolsrc/lex.pla: 0151:                         is 'T'
_B378 
; toolsrc/lex.pla: 0152:                             constval = $09; break
	!BYTE	$12			; CN	9
	!BYTE	$7A			; SAW	_D103+0
_F601 	!WORD	_D103+0		
	!BYTE	$50			; BRNCH	_B371
	!WORD	_B371-*
; toolsrc/lex.pla: 0153:                         is '\\'
_B379 
; toolsrc/lex.pla: 0154:                             constval = '\\'; break
	!BYTE	$2A,$5C			; CB	92
	!BYTE	$7A			; SAW	_D103+0
_F602 	!WORD	_D103+0		
	!BYTE	$50			; BRNCH	_B371
	!WORD	_B371-*
; toolsrc/lex.pla: 0155:                         otherwise
_B372 
	!BYTE	$07			; CASEBLOCK
	!WORD	$004E
	!WORD	_B374-*
	!WORD	$0052
	!WORD	_B376-*
	!WORD	$0054
	!WORD	_B378-*
	!WORD	$005C
	!WORD	_B379-*
	!WORD	$006E
	!WORD	_B373-*
	!WORD	$0072
	!WORD	_B375-*
	!WORD	$0074
	!WORD	_B377-*
; toolsrc/lex.pla: 0156:                             constval = scannum
; toolsrc/lex.pla: 0157:                             scanptr--
	!BYTE	$54			; CALL	_C075
_F603 	!WORD	_C075		
	!BYTE	$7A			; SAW	_D103+0
_F604 	!WORD	_D103+0		
	!BYTE	$6A			; LAW	_D097+0
_F605 	!WORD	_D097+0		
	!BYTE	$8E			; DECR
; toolsrc/lex.pla: 0158:                     wend
	!BYTE	$7A			; SAW	_D097+0
_F606 	!WORD	_D097+0		
_B371 
; toolsrc/lex.pla: 0159:                 fin
_B370 
; toolsrc/lex.pla: 0160:                 if ^(scanptr + 1) <> '\''; exit_err(ERR_INVAL|ERR_CONST); fin
	!BYTE	$6A			; LAW	_D097+0
_F607 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$27			; CB	39
	!BYTE	$22			; BREQ	_B380
	!WORD	_B380-*
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$54			; CALL	_C002
_F608 	!WORD	_C002		
_B380 
_B381 
; toolsrc/lex.pla: 0161:                 scanptr = scanptr + 2
; toolsrc/lex.pla: 0162:                 break
	!BYTE	$6A			; LAW	_D097+0
_F609 	!WORD	_D097+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D097+0
_F610 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B355
	!WORD	_B355-*
; toolsrc/lex.pla: 0163:             is '"'
_B382 
; toolsrc/lex.pla: 0164:                 //
; toolsrc/lex.pla: 0165:                 // String constant
; toolsrc/lex.pla: 0166:                 //
; toolsrc/lex.pla: 0167:                 token     = STR_TKN
; toolsrc/lex.pla: 0168:                 constval  = strconstptr
; toolsrc/lex.pla: 0169:                 ^constval = 0
; toolsrc/lex.pla: 0170:                 strconstptr++
	!BYTE	$2A,$D3			; CB	211
	!BYTE	$78			; SAB	_D098+0
_F611 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D106+0
_F612 	!WORD	_D106+0		
	!BYTE	$7A			; SAW	_D103+0
_F613 	!WORD	_D103+0		
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D103+0
_F614 	!WORD	_D103+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D106+0
_F615 	!WORD	_D106+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0171:                 scanptr++
	!BYTE	$7A			; SAW	_D106+0
_F616 	!WORD	_D106+0		
	!BYTE	$6A			; LAW	_D097+0
_F617 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0172:                 while ^scanptr and ^scanptr <> '"'
	!BYTE	$7A			; SAW	_D097+0
_F618 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B385
	!WORD	_B385-*
_B383 
; toolsrc/lex.pla: 0173:                     if ^scanptr <> '\\'
; toolsrc/lex.pla: 0174:                         ^strconstptr = ^scanptr
; toolsrc/lex.pla: 0175:                    else
	!BYTE	$6A			; LAW	_D097+0
_F619 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$5C			; CB	92
	!BYTE	$22			; BREQ	_B387
	!WORD	_B387-*
	!BYTE	$6A			; LAW	_D097+0
_F620 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$6A			; LAW	_D106+0
_F621 	!WORD	_D106+0		
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B388
	!WORD	_B388-*
_B387 
; toolsrc/lex.pla: 0176:                         scanptr++
	!BYTE	$6A			; LAW	_D097+0
_F622 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0177:                         when ^scanptr
	!BYTE	$7A			; SAW	_D097+0
_F623 	!WORD	_D097+0		
	!BYTE	$6A			; LAW	_D097+0
_F624 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$52			; SEL
	!WORD	_B390-*
; toolsrc/lex.pla: 0178:                             is 'n'
_B391 
; toolsrc/lex.pla: 0179:                             is 'N'
_B392 
; toolsrc/lex.pla: 0180:                                 ^strconstptr = $0D; break
	!BYTE	$1A			; CN	13
	!BYTE	$6A			; LAW	_D106+0
_F625 	!WORD	_D106+0		
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B389
	!WORD	_B389-*
; toolsrc/lex.pla: 0181:                             is 'r'
_B393 
; toolsrc/lex.pla: 0182:                             is 'R'
_B394 
; toolsrc/lex.pla: 0183:                                 ^strconstptr = $0A; break
	!BYTE	$14			; CN	10
	!BYTE	$6A			; LAW	_D106+0
_F626 	!WORD	_D106+0		
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B389
	!WORD	_B389-*
; toolsrc/lex.pla: 0184:                             is 't'
_B395 
; toolsrc/lex.pla: 0185:                             is 'T'
_B396 
; toolsrc/lex.pla: 0186:                                 ^strconstptr = $09; break
	!BYTE	$12			; CN	9
	!BYTE	$6A			; LAW	_D106+0
_F627 	!WORD	_D106+0		
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B389
	!WORD	_B389-*
; toolsrc/lex.pla: 0187:                             is '\\'
_B397 
; toolsrc/lex.pla: 0188:                                 ^strconstptr = '\\'; break
	!BYTE	$2A,$5C			; CB	92
	!BYTE	$6A			; LAW	_D106+0
_F628 	!WORD	_D106+0		
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B389
	!WORD	_B389-*
; toolsrc/lex.pla: 0189:                             otherwise
_B390 
	!BYTE	$07			; CASEBLOCK
	!WORD	$004E
	!WORD	_B392-*
	!WORD	$0052
	!WORD	_B394-*
	!WORD	$0054
	!WORD	_B396-*
	!WORD	$005C
	!WORD	_B397-*
	!WORD	$006E
	!WORD	_B391-*
	!WORD	$0072
	!WORD	_B393-*
	!WORD	$0074
	!WORD	_B395-*
; toolsrc/lex.pla: 0190:                                 ^strconstptr = scannum
; toolsrc/lex.pla: 0191:                                 scanptr--
	!BYTE	$54			; CALL	_C075
_F629 	!WORD	_C075		
	!BYTE	$6A			; LAW	_D106+0
_F630 	!WORD	_D106+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D097+0
_F631 	!WORD	_D097+0		
	!BYTE	$8E			; DECR
; toolsrc/lex.pla: 0192:                         wend
	!BYTE	$7A			; SAW	_D097+0
_F632 	!WORD	_D097+0		
_B389 
; toolsrc/lex.pla: 0193:                     fin
_B388 
; toolsrc/lex.pla: 0194:                     strconstptr++
	!BYTE	$6A			; LAW	_D106+0
_F633 	!WORD	_D106+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0195:                     ^constval++
	!BYTE	$7A			; SAW	_D106+0
_F634 	!WORD	_D106+0		
	!BYTE	$6A			; LAW	_D103+0
_F635 	!WORD	_D103+0		
	!BYTE	$60			; LB
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0196:                     scanptr++
	!BYTE	$6A			; LAW	_D103+0
_F636 	!WORD	_D103+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D097+0
_F637 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0197:                 loop
	!BYTE	$7A			; SAW	_D097+0
_F638 	!WORD	_D097+0		
_B385 
	!BYTE	$6A			; LAW	_D097+0
_F639 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$AC			; BRAND	_B386
	!WORD	_B386-*
	!BYTE	$6A			; LAW	_D097+0
_F640 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$22			; CB	34
	!BYTE	$42			; ISNE
_B386 
	!BYTE	$4E			; BRTRU	_B383
	!WORD	_B383-*
_B384 
; toolsrc/lex.pla: 0198:                 if not ^scanptr; exit_err(ERR_INVAL|ERR_CONST); fin
	!BYTE	$6A			; LAW	_D097+0
_F641 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$4E			; BRTRU	_B398
	!WORD	_B398-*
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$54			; CALL	_C002
_F642 	!WORD	_C002		
_B398 
_B399 
; toolsrc/lex.pla: 0199:                 strconstptr++
	!BYTE	$6A			; LAW	_D106+0
_F643 	!WORD	_D106+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0200:                 scanptr++
	!BYTE	$7A			; SAW	_D106+0
_F644 	!WORD	_D106+0		
	!BYTE	$6A			; LAW	_D097+0
_F645 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0201:                 break
	!BYTE	$7A			; SAW	_D097+0
_F646 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B355
	!WORD	_B355-*
; toolsrc/lex.pla: 0202:             is '/'
_B400 
; toolsrc/lex.pla: 0203:                 if ^(scanptr + 1) == '/'
; toolsrc/lex.pla: 0204:                     token    = EOL_TKN
; toolsrc/lex.pla: 0205:                     ^scanptr = $00
; toolsrc/lex.pla: 0206:                 else
	!BYTE	$6A			; LAW	_D097+0
_F647 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$2F			; CB	47
	!BYTE	$24			; BRNE	_B401
	!WORD	_B401-*
	!BYTE	$04			; CN	2
	!BYTE	$78			; SAB	_D098+0
_F648 	!WORD	_D098+0		
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D097+0
_F649 	!WORD	_D097+0		
	!BYTE	$70			; SB
	!BYTE	$50			; BRNCH	_B402
	!WORD	_B402-*
_B401 
; toolsrc/lex.pla: 0207:                     token = DIV_TKN
; toolsrc/lex.pla: 0208:                     scanptr++
	!BYTE	$2A,$AF			; CB	175
	!BYTE	$78			; SAB	_D098+0
_F650 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F651 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0209:                 fin
	!BYTE	$7A			; SAW	_D097+0
_F652 	!WORD	_D097+0		
_B402 
; toolsrc/lex.pla: 0210:                 break
	!BYTE	$50			; BRNCH	_B355
	!WORD	_B355-*
; toolsrc/lex.pla: 0211:             is '='
_B403 
; toolsrc/lex.pla: 0212:                 if ^(scanptr + 1) == '='
; toolsrc/lex.pla: 0213:                     token   = EQ_TKN
; toolsrc/lex.pla: 0214:                     scanptr = scanptr + 2
; toolsrc/lex.pla: 0215:                 elsif ^(scanptr + 1) == '>'
	!BYTE	$6A			; LAW	_D097+0
_F653 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$3D			; CB	61
	!BYTE	$24			; BRNE	_B404
	!WORD	_B404-*
	!BYTE	$2A,$C5			; CB	197
	!BYTE	$78			; SAB	_D098+0
_F654 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F655 	!WORD	_D097+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D097+0
_F656 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B405
	!WORD	_B405-*
_B404 
; toolsrc/lex.pla: 0216:                     token   = PTRW_TKN
; toolsrc/lex.pla: 0217:                     scanptr = scanptr + 2
; toolsrc/lex.pla: 0218:                 else
	!BYTE	$6A			; LAW	_D097+0
_F657 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$3E			; CB	62
	!BYTE	$24			; BRNE	_B406
	!WORD	_B406-*
	!BYTE	$2A,$D7			; CB	215
	!BYTE	$78			; SAB	_D098+0
_F658 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F659 	!WORD	_D097+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D097+0
_F660 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B405
	!WORD	_B405-*
_B406 
; toolsrc/lex.pla: 0219:                     token = SET_TKN
; toolsrc/lex.pla: 0220:                     scanptr++
	!BYTE	$2A,$BD			; CB	189
	!BYTE	$78			; SAB	_D098+0
_F661 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F662 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0221:                 fin
	!BYTE	$7A			; SAW	_D097+0
_F663 	!WORD	_D097+0		
_B405 
; toolsrc/lex.pla: 0222:                 break
	!BYTE	$50			; BRNCH	_B355
	!WORD	_B355-*
; toolsrc/lex.pla: 0223:             is '-'
_B407 
; toolsrc/lex.pla: 0224:                 if ^(scanptr + 1) == '>'
; toolsrc/lex.pla: 0225:                     token   = PTRB_TKN
; toolsrc/lex.pla: 0226:                     scanptr = scanptr + 2
; toolsrc/lex.pla: 0227:                 elsif ^(scanptr + 1) == '-'
	!BYTE	$6A			; LAW	_D097+0
_F664 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$3E			; CB	62
	!BYTE	$24			; BRNE	_B408
	!WORD	_B408-*
	!BYTE	$2A,$D8			; CB	216
	!BYTE	$78			; SAB	_D098+0
_F665 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F666 	!WORD	_D097+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D097+0
_F667 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B409
	!WORD	_B409-*
_B408 
; toolsrc/lex.pla: 0228:                     token   = DEC_TKN
; toolsrc/lex.pla: 0229:                     scanptr = scanptr + 2
; toolsrc/lex.pla: 0230:                 else
	!BYTE	$6A			; LAW	_D097+0
_F668 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$2D			; CB	45
	!BYTE	$24			; BRNE	_B410
	!WORD	_B410-*
	!BYTE	$2A,$C4			; CB	196
	!BYTE	$78			; SAB	_D098+0
_F669 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F670 	!WORD	_D097+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D097+0
_F671 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B409
	!WORD	_B409-*
_B410 
; toolsrc/lex.pla: 0231:                     token = SUB_TKN
; toolsrc/lex.pla: 0232:                     scanptr++
	!BYTE	$2A,$AD			; CB	173
	!BYTE	$78			; SAB	_D098+0
_F672 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F673 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0233:                 fin
	!BYTE	$7A			; SAW	_D097+0
_F674 	!WORD	_D097+0		
_B409 
; toolsrc/lex.pla: 0234:                 break
	!BYTE	$50			; BRNCH	_B355
	!WORD	_B355-*
; toolsrc/lex.pla: 0235:             is '+'
_B411 
; toolsrc/lex.pla: 0236:                 if ^(scanptr + 1) == '+'
; toolsrc/lex.pla: 0237:                     token   = INC_TKN
; toolsrc/lex.pla: 0238:                     scanptr = scanptr + 2
; toolsrc/lex.pla: 0239:                 else
	!BYTE	$6A			; LAW	_D097+0
_F675 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$2B			; CB	43
	!BYTE	$24			; BRNE	_B412
	!WORD	_B412-*
	!BYTE	$2A,$C1			; CB	193
	!BYTE	$78			; SAB	_D098+0
_F676 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F677 	!WORD	_D097+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D097+0
_F678 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B413
	!WORD	_B413-*
_B412 
; toolsrc/lex.pla: 0240:                     token = ADD_TKN
; toolsrc/lex.pla: 0241:                     scanptr++
	!BYTE	$2A,$AB			; CB	171
	!BYTE	$78			; SAB	_D098+0
_F679 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F680 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0242:                 fin
	!BYTE	$7A			; SAW	_D097+0
_F681 	!WORD	_D097+0		
_B413 
; toolsrc/lex.pla: 0243:                 break
	!BYTE	$50			; BRNCH	_B355
	!WORD	_B355-*
; toolsrc/lex.pla: 0244:             is '>'
_B414 
; toolsrc/lex.pla: 0245:                 if ^(scanptr + 1) == '>'
; toolsrc/lex.pla: 0246:                     token   = SHR_TKN
; toolsrc/lex.pla: 0247:                     scanptr = scanptr + 2
; toolsrc/lex.pla: 0248:                 elsif ^(scanptr + 1) == '='
	!BYTE	$6A			; LAW	_D097+0
_F682 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$3E			; CB	62
	!BYTE	$24			; BRNE	_B415
	!WORD	_B415-*
	!BYTE	$2A,$D2			; CB	210
	!BYTE	$78			; SAB	_D098+0
_F683 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F684 	!WORD	_D097+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D097+0
_F685 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B416
	!WORD	_B416-*
_B415 
; toolsrc/lex.pla: 0249:                     token   = GE_TKN
; toolsrc/lex.pla: 0250:                     scanptr = scanptr + 2
; toolsrc/lex.pla: 0251:                 else
	!BYTE	$6A			; LAW	_D097+0
_F686 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$3D			; CB	61
	!BYTE	$24			; BRNE	_B417
	!WORD	_B417-*
	!BYTE	$2A,$C8			; CB	200
	!BYTE	$78			; SAB	_D098+0
_F687 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F688 	!WORD	_D097+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D097+0
_F689 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B416
	!WORD	_B416-*
_B417 
; toolsrc/lex.pla: 0252:                     token = GT_TKN
; toolsrc/lex.pla: 0253:                     scanptr++
	!BYTE	$2A,$BE			; CB	190
	!BYTE	$78			; SAB	_D098+0
_F690 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F691 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0254:                 fin
	!BYTE	$7A			; SAW	_D097+0
_F692 	!WORD	_D097+0		
_B416 
; toolsrc/lex.pla: 0255:                 break
	!BYTE	$50			; BRNCH	_B355
	!WORD	_B355-*
; toolsrc/lex.pla: 0256:             is '<'
_B418 
; toolsrc/lex.pla: 0257:                 if ^(scanptr + 1) == '<'
; toolsrc/lex.pla: 0258:                     token   = SHL_TKN
; toolsrc/lex.pla: 0259:                     scanptr = scanptr + 2
; toolsrc/lex.pla: 0260:                 elsif ^(scanptr + 1) == '='
	!BYTE	$6A			; LAW	_D097+0
_F693 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$3C			; CB	60
	!BYTE	$24			; BRNE	_B419
	!WORD	_B419-*
	!BYTE	$2A,$CC			; CB	204
	!BYTE	$78			; SAB	_D098+0
_F694 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F695 	!WORD	_D097+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D097+0
_F696 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B420
	!WORD	_B420-*
_B419 
; toolsrc/lex.pla: 0261:                     token   = LE_TKN
; toolsrc/lex.pla: 0262:                     scanptr = scanptr + 2
; toolsrc/lex.pla: 0263:                 elsif ^(scanptr + 1) == '>'
	!BYTE	$6A			; LAW	_D097+0
_F697 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$3D			; CB	61
	!BYTE	$24			; BRNE	_B421
	!WORD	_B421-*
	!BYTE	$2A,$C2			; CB	194
	!BYTE	$78			; SAB	_D098+0
_F698 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F699 	!WORD	_D097+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D097+0
_F700 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B420
	!WORD	_B420-*
_B421 
; toolsrc/lex.pla: 0264:                     token   = NE_TKN
; toolsrc/lex.pla: 0265:                     scanptr = scanptr + 2
; toolsrc/lex.pla: 0266:                 else
	!BYTE	$6A			; LAW	_D097+0
_F701 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$3E			; CB	62
	!BYTE	$24			; BRNE	_B422
	!WORD	_B422-*
	!BYTE	$2A,$D5			; CB	213
	!BYTE	$78			; SAB	_D098+0
_F702 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F703 	!WORD	_D097+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D097+0
_F704 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B420
	!WORD	_B420-*
_B422 
; toolsrc/lex.pla: 0267:                     token = LT_TKN
; toolsrc/lex.pla: 0268:                     scanptr++
	!BYTE	$2A,$BC			; CB	188
	!BYTE	$78			; SAB	_D098+0
_F705 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F706 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0269:                 fin
	!BYTE	$7A			; SAW	_D097+0
_F707 	!WORD	_D097+0		
_B420 
; toolsrc/lex.pla: 0270:                 break
	!BYTE	$50			; BRNCH	_B355
	!WORD	_B355-*
; toolsrc/lex.pla: 0271:             is ':'
_B423 
; toolsrc/lex.pla: 0272:                 if ^(scanptr + 1) == ':'
; toolsrc/lex.pla: 0273:                     token = TRIELSE_TKN;
; toolsrc/lex.pla: 0274:                     scanptr = scanptr + 2
; toolsrc/lex.pla: 0275:                 else
	!BYTE	$6A			; LAW	_D097+0
_F708 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$3A			; CB	58
	!BYTE	$24			; BRNE	_B424
	!WORD	_B424-*
	!BYTE	$2A,$DF			; CB	223
	!BYTE	$78			; SAB	_D098+0
_F709 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F710 	!WORD	_D097+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D097+0
_F711 	!WORD	_D097+0		
	!BYTE	$50			; BRNCH	_B425
	!WORD	_B425-*
_B424 
; toolsrc/lex.pla: 0276:                     token = COLON_TKN;
; toolsrc/lex.pla: 0277:                     scanptr++
	!BYTE	$2A,$BA			; CB	186
	!BYTE	$78			; SAB	_D098+0
_F712 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F713 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0278:                 fin
	!BYTE	$7A			; SAW	_D097+0
_F714 	!WORD	_D097+0		
_B425 
; toolsrc/lex.pla: 0279:                 break
	!BYTE	$50			; BRNCH	_B355
	!WORD	_B355-*
; toolsrc/lex.pla: 0280:             is '?'
_B426 
; toolsrc/lex.pla: 0281:                 if ^(scanptr + 1) == '?'
; toolsrc/lex.pla: 0282:                     token = TERNARY_TKN;
; toolsrc/lex.pla: 0283:                     scanptr = scanptr + 2
; toolsrc/lex.pla: 0284:                 fin
	!BYTE	$6A			; LAW	_D097+0
_F715 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$3F			; CB	63
	!BYTE	$24			; BRNE	_B427
	!WORD	_B427-*
	!BYTE	$2A,$BF			; CB	191
	!BYTE	$78			; SAB	_D098+0
_F716 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F717 	!WORD	_D097+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D097+0
_F718 	!WORD	_D097+0		
_B427 
_B428 
; toolsrc/lex.pla: 0285:                 break
	!BYTE	$50			; BRNCH	_B355
	!WORD	_B355-*
; toolsrc/lex.pla: 0286:             is 0
_B429 
; toolsrc/lex.pla: 0287:             is ';'
_B430 
; toolsrc/lex.pla: 0288:                 if token <> EOF_TKN
; toolsrc/lex.pla: 0289:                     token = EOL_TKN
; toolsrc/lex.pla: 0290:                 fin
	!BYTE	$68			; LAB	_D098+0
_F719 	!WORD	_D098+0		
	!BYTE	$02			; CN	1
	!BYTE	$22			; BREQ	_B431
	!WORD	_B431-*
	!BYTE	$04			; CN	2
	!BYTE	$78			; SAB	_D098+0
_F720 	!WORD	_D098+0		
_B431 
_B432 
; toolsrc/lex.pla: 0291:                 break
	!BYTE	$50			; BRNCH	_B355
	!WORD	_B355-*
; toolsrc/lex.pla: 0292:             otherwise
_B356 
	!BYTE	$0D			; CASEBLOCK
	!WORD	$0000
	!WORD	_B429-*
	!WORD	$0022
	!WORD	_B382-*
	!WORD	$0024
	!WORD	_B357-*
	!WORD	$0027
	!WORD	_B368-*
	!WORD	$002B
	!WORD	_B411-*
	!WORD	$002D
	!WORD	_B407-*
	!WORD	$002F
	!WORD	_B400-*
	!WORD	$003A
	!WORD	_B423-*
	!WORD	$003B
	!WORD	_B430-*
	!WORD	$003C
	!WORD	_B418-*
	!WORD	$003D
	!WORD	_B403-*
	!WORD	$003E
	!WORD	_B414-*
	!WORD	$003F
	!WORD	_B426-*
; toolsrc/lex.pla: 0293:                 //
; toolsrc/lex.pla: 0294:                 // Simple single character tokens
; toolsrc/lex.pla: 0295:                 //
; toolsrc/lex.pla: 0296:                 token = scanchr | $80
; toolsrc/lex.pla: 0297:                 scanptr++
	!BYTE	$68			; LAB	_D099+0
_F721 	!WORD	_D099+0		
	!BYTE	$3E,$80			; ORI	128
	!BYTE	$78			; SAB	_D098+0
_F722 	!WORD	_D098+0		
	!BYTE	$6A			; LAW	_D097+0
_F723 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0298:         wend
	!BYTE	$7A			; SAW	_D097+0
_F724 	!WORD	_D097+0		
_B355 
; toolsrc/lex.pla: 0299:     fin
_B348 
; toolsrc/lex.pla: 0300:     tknlen = scanptr - tknptr
; toolsrc/lex.pla: 0301:     return token
	!BYTE	$6A			; LAW	_D097+0
_F725 	!WORD	_D097+0		
	!BYTE	$6A			; LAW	_D101+0
_F726 	!WORD	_D101+0		
	!BYTE	$84			; SUB 
	!BYTE	$78			; SAB	_D100+0
_F727 	!WORD	_D100+0		
	!BYTE	$68			; LAB	_D098+0
_F728 	!WORD	_D098+0		
	!BYTE	$5C			; RET
; toolsrc/lex.pla: 0302: end
; toolsrc/lex.pla: 0303: def rewind(ptr)#0
					; ptr -> [0]
_C077 					; rewind()
; toolsrc/lex.pla: 0304:     scanptr = ptr
	!BYTE	$58,$02,$01		; ENTER	2,1
; toolsrc/lex.pla: 0305:     tknptr  = ptr
; toolsrc/lex.pla: 0306: end
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D097+0
_F729 	!WORD	_D097+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D101+0
_F730 	!WORD	_D101+0		
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/lex.pla: 0307: def lookahead
_C078 					; lookahead()
; toolsrc/lex.pla: 0308:     word backptr, backtkn
					; backptr -> [0]
					; backtkn -> [2]
; toolsrc/lex.pla: 0309:     byte prevtkn, prevlen, look
					; prevtkn -> [4]
					; prevlen -> [5]
					; look -> [6]
; toolsrc/lex.pla: 0310:     backptr = scanptr
	!BYTE	$58,$07,$00		; ENTER	7,0
; toolsrc/lex.pla: 0311:     backtkn = tknptr
; toolsrc/lex.pla: 0312:     prevtkn = token
; toolsrc/lex.pla: 0313:     prevlen = tknlen
; toolsrc/lex.pla: 0314:     look    = scan
; toolsrc/lex.pla: 0315:     scanptr = backptr
; toolsrc/lex.pla: 0316:     tknptr  = backtkn
; toolsrc/lex.pla: 0317:     token   = prevtkn
; toolsrc/lex.pla: 0318:     tknlen  = prevlen
; toolsrc/lex.pla: 0319:     return look
	!BYTE	$6A			; LAW	_D097+0
_F731 	!WORD	_D097+0		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$6A			; LAW	_D101+0
_F732 	!WORD	_D101+0		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$68			; LAB	_D098+0
_F733 	!WORD	_D098+0		
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$68			; LAB	_D100+0
_F734 	!WORD	_D100+0		
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$54			; CALL	_C076
_F735 	!WORD	_C076		
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$7A			; SAW	_D097+0
_F736 	!WORD	_D097+0		
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$7A			; SAW	_D101+0
_F737 	!WORD	_D101+0		
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$78			; SAB	_D098+0
_F738 	!WORD	_D098+0		
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$78			; SAB	_D100+0
_F739 	!WORD	_D100+0		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$5A,$07			; LEAVE	7
; toolsrc/lex.pla: 0320: end
; toolsrc/lex.pla: 0321: //
; toolsrc/lex.pla: 0322: // Get next line of input
; toolsrc/lex.pla: 0323: //
; toolsrc/lex.pla: 0324: def nextln
_C079 					; nextln()
; toolsrc/lex.pla: 0325:     strconstptr = strconstbuff // Reset string constant buffer
; toolsrc/lex.pla: 0326:     if ^scanptr == ';'
; toolsrc/lex.pla: 0327:         scanptr++
	!BYTE	$6A			; LAW	_D105+0
_F740 	!WORD	_D105+0		
	!BYTE	$7A			; SAW	_D106+0
_F741 	!WORD	_D106+0		
	!BYTE	$6A			; LAW	_D097+0
_F742 	!WORD	_D097+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$3B			; CB	59
	!BYTE	$24			; BRNE	_B433
	!WORD	_B433-*
	!BYTE	$6A			; LAW	_D097+0
_F743 	!WORD	_D097+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0328:         scan
; toolsrc/lex.pla: 0329:     else
	!BYTE	$7A			; SAW	_D097+0
_F744 	!WORD	_D097+0		
	!BYTE	$54			; CALL	_C076
_F745 	!WORD	_C076		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B434
	!WORD	_B434-*
_B433 
; toolsrc/lex.pla: 0330:         if token <> EOL_TKN and token <> EOF_TKN; putc(token&$7F); puts("Extraneous characters\n"); exit_err(0); fin
	!BYTE	$68			; LAB	_D098+0
_F746 	!WORD	_D098+0		
	!BYTE	$04			; CN	2
	!BYTE	$42			; ISNE
	!BYTE	$AC			; BRAND	_B435
	!WORD	_B435-*
	!BYTE	$68			; LAB	_D098+0
_F747 	!WORD	_D098+0		
	!BYTE	$02			; CN	1
	!BYTE	$42			; ISNE
_B435 
	!BYTE	$4C			; BRFLS	_B436
	!WORD	_B436-*
	!BYTE	$68			; LAB	_D098+0
_F748 	!WORD	_D098+0		
	!BYTE	$3C,$7F			; ANDI	127
	!BYTE	$54			; CALL	_X002
_F749 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$16
	!BYTE	$45,$78,$74,$72,$61,$6E,$65,$6F
	!BYTE	$75,$73,$20,$63,$68,$61,$72,$61
	!BYTE	$63,$74,$65,$72,$73,$0D
	!BYTE	$54			; CALL	_X004
_F750 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C002
_F751 	!WORD	_C002		
_B436 
_B437 
; toolsrc/lex.pla: 0331:         scanptr = inbuff
; toolsrc/lex.pla: 0332:         ^instr  = fileio:read(refnum, inbuff, 127)
; toolsrc/lex.pla: 0333:         if ^instr
; toolsrc/lex.pla: 0334:             ^(instr + ^instr) = NULL // NULL terminate string
; toolsrc/lex.pla: 0335:             lineno++
	!BYTE	$6A			; LAW	_D096+0
_F752 	!WORD	_D096+0		
	!BYTE	$7A			; SAW	_D097+0
_F753 	!WORD	_D097+0		
	!BYTE	$68			; LAB	_D086+0
_F754 	!WORD	_D086+0		
	!BYTE	$6A			; LAW	_D096+0
_F755 	!WORD	_D096+0		
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$6A			; LAW	_X031+18
_F756 	!WORD	0+18		
	!BYTE	$56			; ICAL
	!BYTE	$6A			; LAW	_D095+0
_F757 	!WORD	_D095+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D095+0
_F758 	!WORD	_D095+0		
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B438
	!WORD	_B438-*
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D095+0
_F759 	!WORD	_D095+0		
	!BYTE	$34			; DUP
	!BYTE	$60			; LB
	!BYTE	$82			; ADD 
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D104+0
_F760 	!WORD	_D104+0		
	!BYTE	$8C			; INCR
; toolsrc/lex.pla: 0336:             if !(lineno & $0F); putc('.'); fin
	!BYTE	$7E			; DAW	_D104+0
_F761 	!WORD	_D104+0		
	!BYTE	$3C,$0F			; ANDI	15
	!BYTE	$4E			; BRTRU	_B440
	!WORD	_B440-*
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$54			; CALL	_X002
_F762 	!WORD	0		
_B440 
_B441 
; toolsrc/lex.pla: 0337:             if scan == INCLUDE_TKN
; toolsrc/lex.pla: 0338:                 if incref; puts("Nested INCLUDEs not allowed\n"); exit_err(0); fin
	!BYTE	$54			; CALL	_C076
_F763 	!WORD	_C076		
	!BYTE	$2A,$9F			; CB	159
	!BYTE	$24			; BRNE	_B442
	!WORD	_B442-*
	!BYTE	$68			; LAB	_D088+0
_F764 	!WORD	_D088+0		
	!BYTE	$4C			; BRFLS	_B444
	!WORD	_B444-*
	!BYTE	$2E			; CS
	!BYTE	$1C
	!BYTE	$4E,$65,$73,$74,$65,$64,$20,$49
	!BYTE	$4E,$43,$4C,$55,$44,$45,$73,$20
	!BYTE	$6E,$6F,$74,$20,$61,$6C,$6C,$6F
	!BYTE	$77,$65,$64,$0D
	!BYTE	$54			; CALL	_X004
_F765 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C002
_F766 	!WORD	_C002		
_B444 
_B445 
; toolsrc/lex.pla: 0339:                 if scan <> STR_TKN; puts("Missing INCLUDE file\n"); exit_err(0); fin
	!BYTE	$54			; CALL	_C076
_F767 	!WORD	_C076		
	!BYTE	$2A,$D3			; CB	211
	!BYTE	$22			; BREQ	_B446
	!WORD	_B446-*
	!BYTE	$2E			; CS
	!BYTE	$15
	!BYTE	$4D,$69,$73,$73,$69,$6E,$67,$20
	!BYTE	$49,$4E,$43,$4C,$55,$44,$45,$20
	!BYTE	$66,$69,$6C,$65,$0D
	!BYTE	$54			; CALL	_X004
_F768 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C002
_F769 	!WORD	_C002		
_B446 
_B447 
; toolsrc/lex.pla: 0340:                 strcpy(@incfile, constval)
; toolsrc/lex.pla: 0341:                 incref    = fileio:open(@incfile)
; toolsrc/lex.pla: 0342:                 if not incref
; toolsrc/lex.pla: 0343:                     puts("Unable to open INCLUDE file: ")
	!BYTE	$26			; LA	_D090+0
_F770 	!WORD	_D090+0		
	!BYTE	$6A			; LAW	_D103+0
_F771 	!WORD	_D103+0		
	!BYTE	$54			; CALL	_X019
_F772 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D090+0
_F773 	!WORD	_D090+0		
	!BYTE	$6A			; LAW	_X031+14
_F774 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$7C			; DAB	_D088+0
_F775 	!WORD	_D088+0		
	!BYTE	$4E			; BRTRU	_B448
	!WORD	_B448-*
	!BYTE	$2E			; CS
	!BYTE	$1D
	!BYTE	$55,$6E,$61,$62,$6C,$65,$20,$74
	!BYTE	$6F,$20,$6F,$70,$65,$6E,$20,$49
	!BYTE	$4E,$43,$4C,$55,$44,$45,$20,$66
	!BYTE	$69,$6C,$65,$3A,$20
	!BYTE	$54			; CALL	_X004
_F776 	!WORD	0		
; toolsrc/lex.pla: 0344:                     puts(@incfile)
; toolsrc/lex.pla: 0345:                     putln
; toolsrc/lex.pla: 0346:                     exit_err(0)
; toolsrc/lex.pla: 0347:                 fin
	!BYTE	$26			; LA	_D090+0
_F777 	!WORD	_D090+0		
	!BYTE	$54			; CALL	_X004
_F778 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F779 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C002
_F780 	!WORD	_C002		
_B448 
_B449 
; toolsrc/lex.pla: 0348:                 fileio:newline(incref, $7F, $0D)
; toolsrc/lex.pla: 0349:                 refnum    = incref
; toolsrc/lex.pla: 0350:                 parsefile = @incfile
; toolsrc/lex.pla: 0351:                 srcline   = lineno
; toolsrc/lex.pla: 0352:                 lineno    = 0
; toolsrc/lex.pla: 0353:                 scan
; toolsrc/lex.pla: 0354:                 return nextln
	!BYTE	$68			; LAB	_D088+0
_F781 	!WORD	_D088+0		
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$1A			; CN	13
	!BYTE	$6A			; LAW	_X031+28
_F782 	!WORD	0+28		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$68			; LAB	_D088+0
_F783 	!WORD	_D088+0		
	!BYTE	$78			; SAB	_D086+0
_F784 	!WORD	_D086+0		
	!BYTE	$26			; LA	_D090+0
_F785 	!WORD	_D090+0		
	!BYTE	$7A			; SAW	_D093+0
_F786 	!WORD	_D093+0		
	!BYTE	$6A			; LAW	_D104+0
_F787 	!WORD	_D104+0		
	!BYTE	$7A			; SAW	_D094+0
_F788 	!WORD	_D094+0		
	!BYTE	$00			; CN	0
	!BYTE	$7A			; SAW	_D104+0
_F789 	!WORD	_D104+0		
	!BYTE	$54			; CALL	_C076
_F790 	!WORD	_C076		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C079
_F791 	!WORD	_C079		
	!BYTE	$5C			; RET
; toolsrc/lex.pla: 0355:             fin
_B442 
_B443 
; toolsrc/lex.pla: 0356:         else
	!BYTE	$50			; BRNCH	_B439
	!WORD	_B439-*
_B438 
; toolsrc/lex.pla: 0357:             if refnum == incref
; toolsrc/lex.pla: 0358:                 fileio:close(incref)
; toolsrc/lex.pla: 0359:                 incref    = 0
; toolsrc/lex.pla: 0360:                 refnum    = srcref
; toolsrc/lex.pla: 0361:                 parsefile = @srcfile
; toolsrc/lex.pla: 0362:                 lineno    = srcline
; toolsrc/lex.pla: 0363:                 return nextln
	!BYTE	$68			; LAB	_D086+0
_F792 	!WORD	_D086+0		
	!BYTE	$68			; LAB	_D088+0
_F793 	!WORD	_D088+0		
	!BYTE	$24			; BRNE	_B450
	!WORD	_B450-*
	!BYTE	$68			; LAB	_D088+0
_F794 	!WORD	_D088+0		
	!BYTE	$6A			; LAW	_X031+16
_F795 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D088+0
_F796 	!WORD	_D088+0		
	!BYTE	$68			; LAB	_D087+0
_F797 	!WORD	_D087+0		
	!BYTE	$78			; SAB	_D086+0
_F798 	!WORD	_D086+0		
	!BYTE	$26			; LA	_D089+0
_F799 	!WORD	_D089+0		
	!BYTE	$7A			; SAW	_D093+0
_F800 	!WORD	_D093+0		
	!BYTE	$6A			; LAW	_D094+0
_F801 	!WORD	_D094+0		
	!BYTE	$7A			; SAW	_D104+0
_F802 	!WORD	_D104+0		
	!BYTE	$54			; CALL	_C079
_F803 	!WORD	_C079		
	!BYTE	$5C			; RET
; toolsrc/lex.pla: 0364:             else
	!BYTE	$50			; BRNCH	_B451
	!WORD	_B451-*
_B450 
; toolsrc/lex.pla: 0365:                 *instr = NULL // NULL terminated 0 length string
; toolsrc/lex.pla: 0366:                 token  = EOF_TKN
; toolsrc/lex.pla: 0367:             fin
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D095+0
_F804 	!WORD	_D095+0		
	!BYTE	$72			; SW
	!BYTE	$02			; CN	1
	!BYTE	$78			; SAB	_D098+0
_F805 	!WORD	_D098+0		
_B451 
; toolsrc/lex.pla: 0368:         fin
_B439 
; toolsrc/lex.pla: 0369:     fin
_B434 
; toolsrc/lex.pla: 0370:     return token
	!BYTE	$68			; LAB	_D098+0
_F806 	!WORD	_D098+0		
	!BYTE	$5C			; RET
; toolsrc/lex.pla: 0371: end
; toolsrc/plasm.pla: 0506: 
; toolsrc/plasm.pla: 0507: include "toolsrc/parse.pla"
; toolsrc/parse.pla: 0001: //
; toolsrc/parse.pla: 0002: // Alebraic op to stack op
; toolsrc/parse.pla: 0003: //
; toolsrc/parse.pla: 0004: def push_op(op, prec)#0
					; op -> [0]
					; prec -> [2]
_C080 					; push_op()
; toolsrc/parse.pla: 0005:     if opsp == 16; exit_err(ERR_OVER|ERR_CODE|ERR_FRAME); fin
	!BYTE	$58,$04,$02		; ENTER	4,2
	!BYTE	$6A			; LAW	_D041+0
_F807 	!WORD	_D041+0		
	!BYTE	$2A,$10			; CB	16
	!BYTE	$24			; BRNE	_B452
	!WORD	_B452-*
	!BYTE	$2C,$10,$21		; CW	8464
	!BYTE	$54			; CALL	_C002
_F808 	!WORD	_C002		
_B452 
_B453 
; toolsrc/parse.pla: 0006:     opstack[opsp]   = op
; toolsrc/parse.pla: 0007:     precstack[opsp] = prec
; toolsrc/parse.pla: 0008:     opsp++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D039+0
_F809 	!WORD	_D039+0		
	!BYTE	$B6			; ADDAW	_D041+0
_F810 	!WORD	_D041+0		
	!BYTE	$70			; SB
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D040+0
_F811 	!WORD	_D040+0		
	!BYTE	$B6			; ADDAW	_D041+0
_F812 	!WORD	_D041+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D041+0
_F813 	!WORD	_D041+0		
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 0009: end
	!BYTE	$7A			; SAW	_D041+0
_F814 	!WORD	_D041+0		
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/parse.pla: 0010: def pop_op
_C081 					; pop_op()
; toolsrc/parse.pla: 0011:     opsp--
	!BYTE	$6A			; LAW	_D041+0
_F815 	!WORD	_D041+0		
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0012:     if opsp < 0; exit_err(ERR_INVAL|ERR_CODE|ERR_FRAME); fin
	!BYTE	$7E			; DAW	_D041+0
_F816 	!WORD	_D041+0		
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B454
	!WORD	_B454-*
	!BYTE	$2C,$04,$21		; CW	8452
	!BYTE	$54			; CALL	_C002
_F817 	!WORD	_C002		
_B454 
_B455 
; toolsrc/parse.pla: 0013:     return opstack[opsp]
	!BYTE	$26			; LA	_D039+0
_F818 	!WORD	_D039+0		
	!BYTE	$B6			; ADDAW	_D041+0
_F819 	!WORD	_D041+0		
	!BYTE	$60			; LB
	!BYTE	$5C			; RET
; toolsrc/parse.pla: 0014: end
; toolsrc/parse.pla: 0015: def tos_op
_C082 					; tos_op()
; toolsrc/parse.pla: 0016:     return opsp < 0 ?? 0 :: opstack[opsp-1]
	!BYTE	$6A			; LAW	_D041+0
_F820 	!WORD	_D041+0		
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B456
	!WORD	_B456-*
	!BYTE	$00			; CN	0
	!BYTE	$50			; BRNCH	_B457
	!WORD	_B457-*
_B456 
	!BYTE	$26			; LA	_D039+0
_F821 	!WORD	_D039+0		
	!BYTE	$6A			; LAW	_D041+0
_F822 	!WORD	_D041+0		
	!BYTE	$8E			; DECR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
_B457 
	!BYTE	$5C			; RET
; toolsrc/parse.pla: 0017: end
; toolsrc/parse.pla: 0018: def tos_op_prec(tos)
					; tos -> [0]
_C083 					; tos_op_prec()
; toolsrc/parse.pla: 0019:     return opsp <= tos ?? 100 :: precstack[opsp-1]
	!BYTE	$58,$02,$01		; ENTER	2,1
	!BYTE	$6A			; LAW	_D041+0
_F823 	!WORD	_D041+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4A			; ISLE
	!BYTE	$4C			; BRFLS	_B458
	!WORD	_B458-*
	!BYTE	$2A,$64			; CB	100
	!BYTE	$50			; BRNCH	_B459
	!WORD	_B459-*
_B458 
	!BYTE	$26			; LA	_D040+0
_F824 	!WORD	_D040+0		
	!BYTE	$6A			; LAW	_D041+0
_F825 	!WORD	_D041+0		
	!BYTE	$8E			; DECR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
_B459 
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/parse.pla: 0020: end
; toolsrc/parse.pla: 0021: def push_val(value, size, type)#0
					; value -> [0]
					; size -> [2]
					; type -> [4]
_C084 					; push_val()
; toolsrc/parse.pla: 0022:     byte i
					; i -> [6]
; toolsrc/parse.pla: 0023:     if valsp == 16; exit_err(ERR_OVER|ERR_CODE|ERR_FRAME); fin
	!BYTE	$58,$07,$03		; ENTER	7,3
	!BYTE	$6A			; LAW	_D045+0
_F826 	!WORD	_D045+0		
	!BYTE	$2A,$10			; CB	16
	!BYTE	$24			; BRNE	_B460
	!WORD	_B460-*
	!BYTE	$2C,$10,$21		; CW	8464
	!BYTE	$54			; CALL	_C002
_F827 	!WORD	_C002		
_B460 
_B461 
; toolsrc/parse.pla: 0024:     valstack[valsp]  = value
; toolsrc/parse.pla: 0025:     sizestack[valsp] = size
; toolsrc/parse.pla: 0026:     typestack[valsp] = type
; toolsrc/parse.pla: 0027:     valsp++
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$26			; LA	_D042+0
_F828 	!WORD	_D042+0		
	!BYTE	$BE			; IDXAW	_D045+0
_F829 	!WORD	_D045+0		
	!BYTE	$72			; SW
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$26			; LA	_D043+0
_F830 	!WORD	_D043+0		
	!BYTE	$B6			; ADDAW	_D045+0
_F831 	!WORD	_D045+0		
	!BYTE	$70			; SB
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$26			; LA	_D044+0
_F832 	!WORD	_D044+0		
	!BYTE	$B6			; ADDAW	_D045+0
_F833 	!WORD	_D045+0		
	!BYTE	$70			; SB
	!BYTE	$6A			; LAW	_D045+0
_F834 	!WORD	_D045+0		
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 0028: end
	!BYTE	$7A			; SAW	_D045+0
_F835 	!WORD	_D045+0		
	!BYTE	$5A,$07			; LEAVE	7
; toolsrc/parse.pla: 0029: def pop_val#3
_C085 					; pop_val()
; toolsrc/parse.pla: 0030:     byte i
					; i -> [0]
; toolsrc/parse.pla: 0031:     valsp--
	!BYTE	$58,$01,$00		; ENTER	1,0
	!BYTE	$6A			; LAW	_D045+0
_F836 	!WORD	_D045+0		
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0032:     if valsp < 0; exit_err(ERR_INVAL|ERR_CODE|ERR_FRAME); fin
	!BYTE	$7E			; DAW	_D045+0
_F837 	!WORD	_D045+0		
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B462
	!WORD	_B462-*
	!BYTE	$2C,$04,$21		; CW	8452
	!BYTE	$54			; CALL	_C002
_F838 	!WORD	_C002		
_B462 
_B463 
; toolsrc/parse.pla: 0033:     return valstack[valsp], sizestack[valsp], typestack[valsp]
	!BYTE	$26			; LA	_D042+0
_F839 	!WORD	_D042+0		
	!BYTE	$BE			; IDXAW	_D045+0
_F840 	!WORD	_D045+0		
	!BYTE	$62			; LW
	!BYTE	$26			; LA	_D043+0
_F841 	!WORD	_D043+0		
	!BYTE	$B6			; ADDAW	_D045+0
_F842 	!WORD	_D045+0		
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D044+0
_F843 	!WORD	_D044+0		
	!BYTE	$B6			; ADDAW	_D045+0
_F844 	!WORD	_D045+0		
	!BYTE	$60			; LB
	!BYTE	$5A,$01			; LEAVE	1
; toolsrc/parse.pla: 0034: end
; toolsrc/parse.pla: 0035: //
; toolsrc/parse.pla: 0036: // Constant expression parsing
; toolsrc/parse.pla: 0037: //
; toolsrc/parse.pla: 0038: def calc_binaryop(op)#0
					; op -> [0]
_C086 					; calc_binaryop()
; toolsrc/parse.pla: 0039:     word val1, val2
					; val1 -> [2]
					; val2 -> [4]
; toolsrc/parse.pla: 0040:     byte size1, size2, type1, type2
					; size1 -> [6]
					; size2 -> [7]
					; type1 -> [8]
					; type2 -> [9]
; toolsrc/parse.pla: 0041: 
; toolsrc/parse.pla: 0042:     val2, size2, type2 = pop_val
	!BYTE	$58,$0A,$01		; ENTER	10,1
; toolsrc/parse.pla: 0043:     val1, size1, type1 = pop_val
; toolsrc/parse.pla: 0044:     if type1 <> CONST_TYPE and type2 <> CONST_TYPE; exit_err(ERR_INVAL|ERR_CONST); fin
	!BYTE	$54			; CALL	_C085
_F845 	!WORD	_C085		
	!BYTE	$74,$09			; SLB	[9]
	!BYTE	$74,$07			; SLB	[7]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$54			; CALL	_C085
_F846 	!WORD	_C085		
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$02			; CN	1
	!BYTE	$42			; ISNE
	!BYTE	$AC			; BRAND	_B464
	!WORD	_B464-*
	!BYTE	$64,$09			; LLB	[9]
	!BYTE	$02			; CN	1
	!BYTE	$42			; ISNE
_B464 
	!BYTE	$4C			; BRFLS	_B465
	!WORD	_B465-*
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$54			; CALL	_C002
_F847 	!WORD	_C002		
_B465 
_B466 
; toolsrc/parse.pla: 0045:     when op
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$52			; SEL
	!WORD	_B468-*
; toolsrc/parse.pla: 0046:         is MUL_TKN
_B469 
; toolsrc/parse.pla: 0047:             val1 = val1 * val2
; toolsrc/parse.pla: 0048:             break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$86			; MUL
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B467
	!WORD	_B467-*
; toolsrc/parse.pla: 0049:         is DIV_TKN
_B470 
; toolsrc/parse.pla: 0050:             val1 = val1 / val2
; toolsrc/parse.pla: 0051:             break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$88			; DIV
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B467
	!WORD	_B467-*
; toolsrc/parse.pla: 0052:         is MOD_TKN
_B471 
; toolsrc/parse.pla: 0053:             val1 = val1 % val2
; toolsrc/parse.pla: 0054:             break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$8A			; MOD
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B467
	!WORD	_B467-*
; toolsrc/parse.pla: 0055:         is ADD_TKN
_B472 
; toolsrc/parse.pla: 0056:             val1 = val1 + val2
; toolsrc/parse.pla: 0057:             break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$B2,$04			; ADDLW	[4]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B467
	!WORD	_B467-*
; toolsrc/parse.pla: 0058:         is SUB_TKN
_B473 
; toolsrc/parse.pla: 0059:             val1 = val1 - val2
; toolsrc/parse.pla: 0060:             break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$84			; SUB 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B467
	!WORD	_B467-*
; toolsrc/parse.pla: 0061:         is SHL_TKN
_B474 
; toolsrc/parse.pla: 0062:             val1 = val1 << val2
; toolsrc/parse.pla: 0063:             break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$9A			; SHL
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B467
	!WORD	_B467-*
; toolsrc/parse.pla: 0064:         is SHR_TKN
_B475 
; toolsrc/parse.pla: 0065:             val1 = val1 >> val2
; toolsrc/parse.pla: 0066:             break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$9C			; SHR
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B467
	!WORD	_B467-*
; toolsrc/parse.pla: 0067:         is AND_TKN
_B476 
; toolsrc/parse.pla: 0068:             val1 = val1 & val2
; toolsrc/parse.pla: 0069:             break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$94			; AND 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B467
	!WORD	_B467-*
; toolsrc/parse.pla: 0070:         is OR_TKN
_B477 
; toolsrc/parse.pla: 0071:             val1 = val1 | val2
; toolsrc/parse.pla: 0072:             break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$96			; OR 
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B467
	!WORD	_B467-*
; toolsrc/parse.pla: 0073:         is EOR_TKN
_B478 
; toolsrc/parse.pla: 0074:             val1 = val1 ^ val2
; toolsrc/parse.pla: 0075:             break
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$98			; XOR
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B467
	!WORD	_B467-*
; toolsrc/parse.pla: 0076:         otherwise
_B468 
	!BYTE	$0A			; CASEBLOCK
	!WORD	$00A5
	!WORD	_B471-*
	!WORD	$00A6
	!WORD	_B476-*
	!WORD	$00AA
	!WORD	_B469-*
	!WORD	$00AB
	!WORD	_B472-*
	!WORD	$00AD
	!WORD	_B473-*
	!WORD	$00AF
	!WORD	_B470-*
	!WORD	$00CC
	!WORD	_B474-*
	!WORD	$00D2
	!WORD	_B475-*
	!WORD	$00DE
	!WORD	_B478-*
	!WORD	$00FC
	!WORD	_B477-*
; toolsrc/parse.pla: 0077:             exit_err(ERR_INVAL|ERR_CONST)
; toolsrc/parse.pla: 0078:     wend
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$54			; CALL	_C002
_F848 	!WORD	_C002		
_B467 
; toolsrc/parse.pla: 0079:     if size2 > size1; size1 = size2; fin
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B479
	!WORD	_B479-*
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$74,$06			; SLB	[6]
_B479 
_B480 
; toolsrc/parse.pla: 0080:     push_val(val1, size1, type1)
; toolsrc/parse.pla: 0081: end
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$54			; CALL	_C084
_F849 	!WORD	_C084		
	!BYTE	$5A,$0A			; LEAVE	10
; toolsrc/parse.pla: 0082: def parse_constterm
_C087 					; parse_constterm()
; toolsrc/parse.pla: 0083: 
; toolsrc/parse.pla: 0084:     when scan
	!BYTE	$54			; CALL	_C076
_F850 	!WORD	_C076		
	!BYTE	$52			; SEL
	!WORD	_B482-*
; toolsrc/parse.pla: 0085:         is OPEN_PAREN_TKN
_B483 
; toolsrc/parse.pla: 0086:             push_val(parse_constexpr)
; toolsrc/parse.pla: 0087:             if token <> CLOSE_PAREN_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_SYNTAX); fin
	!BYTE	$54			; CALL	_P002
_F851 	!WORD	_P002		
	!BYTE	$54			; CALL	_C084
_F852 	!WORD	_C084		
	!BYTE	$68			; LAB	_D098+0
_F853 	!WORD	_D098+0		
	!BYTE	$2A,$A9			; CB	169
	!BYTE	$22			; BREQ	_B484
	!WORD	_B484-*
	!BYTE	$2C,$28,$80		; CW	32808
	!BYTE	$54			; CALL	_C002
_F854 	!WORD	_C002		
_B484 
_B485 
; toolsrc/parse.pla: 0088:             return TRUE
	!BYTE	$20			; MINUS ONE
	!BYTE	$5C			; RET
; toolsrc/parse.pla: 0089:         is ID_TKN
_B486 
; toolsrc/parse.pla: 0090:         is INT_TKN
_B487 
; toolsrc/parse.pla: 0091:         is CHR_TKN
_B488 
; toolsrc/parse.pla: 0092:         is STR_TKN
_B489 
; toolsrc/parse.pla: 0093:             return TRUE
	!BYTE	$20			; MINUS ONE
	!BYTE	$5C			; RET
; toolsrc/parse.pla: 0094:     wend
	!BYTE	$50			; BRNCH	_B481
	!WORD	_B481-*
_B482 
	!BYTE	$05			; CASEBLOCK
	!WORD	$00A8
	!WORD	_B483-*
	!WORD	$00C3
	!WORD	_B488-*
	!WORD	$00C9
	!WORD	_B487-*
	!WORD	$00D3
	!WORD	_B489-*
	!WORD	$00D6
	!WORD	_B486-*
_B481 
; toolsrc/parse.pla: 0095:     return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
; toolsrc/parse.pla: 0096: end
; toolsrc/parse.pla: 0097: def parse_constval
_C088 					; parse_constval()
; toolsrc/parse.pla: 0098:     byte mod, size
					; mod -> [0]
					; size -> [1]
; toolsrc/parse.pla: 0099:     word type, idptr, value
					; type -> [2]
					; idptr -> [4]
					; value -> [6]
; toolsrc/parse.pla: 0100: 
; toolsrc/parse.pla: 0101:     mod = 0
	!BYTE	$58,$08,$00		; ENTER	8,0
; toolsrc/parse.pla: 0102:     while not parse_constterm
	!BYTE	$00			; CN	0
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B492
	!WORD	_B492-*
_B490 
; toolsrc/parse.pla: 0103:         when token
	!BYTE	$68			; LAB	_D098+0
_F855 	!WORD	_D098+0		
	!BYTE	$52			; SEL
	!WORD	_B494-*
; toolsrc/parse.pla: 0104:             is SUB_TKN
_B495 
; toolsrc/parse.pla: 0105:                 mod = mod | 1; break
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B493
	!WORD	_B493-*
; toolsrc/parse.pla: 0106:             is COMP_TKN
_B496 
; toolsrc/parse.pla: 0107:                 mod = mod | 2; break
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3E,$02			; ORI	2
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B493
	!WORD	_B493-*
; toolsrc/parse.pla: 0108:             is LOGIC_NOT_TKN
_B497 
; toolsrc/parse.pla: 0109:                 mod = mod | 4; break
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3E,$04			; ORI	4
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B493
	!WORD	_B493-*
; toolsrc/parse.pla: 0110:             is AT_TKN
_B498 
; toolsrc/parse.pla: 0111:                 mod = mod | 8; break
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3E,$08			; ORI	8
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$50			; BRNCH	_B493
	!WORD	_B493-*
; toolsrc/parse.pla: 0112:             is ADD_TKN
_B499 
; toolsrc/parse.pla: 0113:                 break
	!BYTE	$50			; BRNCH	_B493
	!WORD	_B493-*
; toolsrc/parse.pla: 0114:             otherwise
_B494 
	!BYTE	$05			; CASEBLOCK
	!WORD	$00A1
	!WORD	_B497-*
	!WORD	$00AB
	!WORD	_B499-*
	!WORD	$00AD
	!WORD	_B495-*
	!WORD	$00C0
	!WORD	_B498-*
	!WORD	$00FE
	!WORD	_B496-*
; toolsrc/parse.pla: 0115:                 return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$08			; LEAVE	8
; toolsrc/parse.pla: 0116:         wend
_B493 
; toolsrc/parse.pla: 0117:     loop
_B492 
	!BYTE	$54			; CALL	_C087
_F856 	!WORD	_C087		
	!BYTE	$4C			; BRFLS	_B490
	!WORD	_B490-*
_B491 
; toolsrc/parse.pla: 0118:     when token
	!BYTE	$68			; LAB	_D098+0
_F857 	!WORD	_D098+0		
	!BYTE	$52			; SEL
	!WORD	_B501-*
; toolsrc/parse.pla: 0119:         is CLOSE_PAREN_TKN
_B502 
; toolsrc/parse.pla: 0120:             value, size, type = pop_val
; toolsrc/parse.pla: 0121:             break
	!BYTE	$54			; CALL	_C085
_F858 	!WORD	_C085		
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$50			; BRNCH	_B500
	!WORD	_B500-*
; toolsrc/parse.pla: 0122:         is STR_TKN
_B503 
; toolsrc/parse.pla: 0123:             size  = tknlen - 1
; toolsrc/parse.pla: 0124:             value = constval
; toolsrc/parse.pla: 0125:             type  = STR_TYPE
; toolsrc/parse.pla: 0126:             if mod; exit_err(ERR_INVAL|ERR_CONST); fin
	!BYTE	$68			; LAB	_D100+0
_F859 	!WORD	_D100+0		
	!BYTE	$8E			; DECR
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$6A			; LAW	_D103+0
_F860 	!WORD	_D103+0		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$2A,$80			; CB	128
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$4C			; BRFLS	_B504
	!WORD	_B504-*
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$54			; CALL	_C002
_F861 	!WORD	_C002		
_B504 
_B505 
; toolsrc/parse.pla: 0127:             break
	!BYTE	$50			; BRNCH	_B500
	!WORD	_B500-*
; toolsrc/parse.pla: 0128:         is CHR_TKN
_B506 
; toolsrc/parse.pla: 0129:             size  = 1
; toolsrc/parse.pla: 0130:             value = constval
; toolsrc/parse.pla: 0131:             type  = CONST_TYPE
; toolsrc/parse.pla: 0132:             break
	!BYTE	$02			; CN	1
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$6A			; LAW	_D103+0
_F862 	!WORD	_D103+0		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$02			; CN	1
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B500
	!WORD	_B500-*
; toolsrc/parse.pla: 0133:         is INT_TKN
_B507 
; toolsrc/parse.pla: 0134:             size  = 2
; toolsrc/parse.pla: 0135:             value = constval
; toolsrc/parse.pla: 0136:             type  = CONST_TYPE
; toolsrc/parse.pla: 0137:             break
	!BYTE	$04			; CN	2
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$6A			; LAW	_D103+0
_F863 	!WORD	_D103+0		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$02			; CN	1
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B500
	!WORD	_B500-*
; toolsrc/parse.pla: 0138:         is ID_TKN
_B508 
; toolsrc/parse.pla: 0139:             size  = 2
; toolsrc/parse.pla: 0140:             idptr = lookup_id(tknptr, tknlen)
; toolsrc/parse.pla: 0141:             if not idptr; exit_err(ERR_INVAL|ERR_CONST); fin
	!BYTE	$04			; CN	2
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$6A			; LAW	_D101+0
_F864 	!WORD	_D101+0		
	!BYTE	$68			; LAB	_D100+0
_F865 	!WORD	_D100+0		
	!BYTE	$54			; CALL	_C044
_F866 	!WORD	_C044		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4E			; BRTRU	_B509
	!WORD	_B509-*
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$54			; CALL	_C002
_F867 	!WORD	_C002		
_B509 
_B510 
; toolsrc/parse.pla: 0142:             type = idptr=>idtype
; toolsrc/parse.pla: 0143:             if type & (FUNC_TYPE|ADDR_TYPE)
; toolsrc/parse.pla: 0144:                 if mod <> 8; exit_err(ERR_INVAL|ERR_CONST); fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$3C,$0E			; ANDI	14
	!BYTE	$4C			; BRFLS	_B511
	!WORD	_B511-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$10			; CN	8
	!BYTE	$22			; BREQ	_B513
	!WORD	_B513-*
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$54			; CALL	_C002
_F868 	!WORD	_C002		
_B513 
_B514 
; toolsrc/parse.pla: 0145:                 type = CONSTADDR_TYPE
; toolsrc/parse.pla: 0146:             elsif type <> CONST_TYPE
	!BYTE	$2A,$61			; CB	97
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$50			; BRNCH	_B512
	!WORD	_B512-*
_B511 
; toolsrc/parse.pla: 0147:                 exit_err(ERR_INVAL|ERR_CONST)
; toolsrc/parse.pla: 0148:             fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$02			; CN	1
	!BYTE	$22			; BREQ	_B515
	!WORD	_B515-*
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$54			; CALL	_C002
_F869 	!WORD	_C002		
_B515 
_B512 
; toolsrc/parse.pla: 0149:             value = idptr=>idval
; toolsrc/parse.pla: 0150:             break
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$62			; LW
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$50			; BRNCH	_B500
	!WORD	_B500-*
; toolsrc/parse.pla: 0151:         otherwise
_B501 
	!BYTE	$05			; CASEBLOCK
	!WORD	$00A9
	!WORD	_B502-*
	!WORD	$00C3
	!WORD	_B506-*
	!WORD	$00C9
	!WORD	_B507-*
	!WORD	$00D3
	!WORD	_B503-*
	!WORD	$00D6
	!WORD	_B508-*
; toolsrc/parse.pla: 0152:             return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$08			; LEAVE	8
; toolsrc/parse.pla: 0153:     wend
_B500 
; toolsrc/parse.pla: 0154:     if mod & 1
; toolsrc/parse.pla: 0155:         value = -value
; toolsrc/parse.pla: 0156:     fin
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B516
	!WORD	_B516-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$90			; NEG
	!BYTE	$76,$06			; SLW	[6]
_B516 
_B517 
; toolsrc/parse.pla: 0157:     if mod & 2
; toolsrc/parse.pla: 0158:         value = ~value
; toolsrc/parse.pla: 0159:     fin
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B518
	!WORD	_B518-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$92			; COMP
	!BYTE	$76,$06			; SLW	[6]
_B518 
_B519 
; toolsrc/parse.pla: 0160:     if mod & 4
; toolsrc/parse.pla: 0161:         value = !value
; toolsrc/parse.pla: 0162:     fin
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B520
	!WORD	_B520-*
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$80			; NOT
	!BYTE	$76,$06			; SLW	[6]
_B520 
_B521 
; toolsrc/parse.pla: 0163:     push_val(value, size, type)
; toolsrc/parse.pla: 0164:     return TRUE
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C084
_F870 	!WORD	_C084		
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$08			; LEAVE	8
; toolsrc/parse.pla: 0165: end
; toolsrc/parse.pla: 0166: def parse_constexpr#3
_P002 					; parse_constexpr#3()
_C089 					; parse_constexpr()
; toolsrc/parse.pla: 0167:     byte prevmatch, matchop, i
					; prevmatch -> [0]
					; matchop -> [1]
					; i -> [2]
; toolsrc/parse.pla: 0168:     word optos
					; optos -> [3]
; toolsrc/parse.pla: 0169: 
; toolsrc/parse.pla: 0170:     matchop  = 0
	!BYTE	$58,$05,$00		; ENTER	5,0
; toolsrc/parse.pla: 0171:     optos    = opsp
; toolsrc/parse.pla: 0172:     repeat
	!BYTE	$00			; CN	0
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$6A			; LAW	_D041+0
_F871 	!WORD	_D041+0		
	!BYTE	$76,$03			; SLW	[3]
_B523 
; toolsrc/parse.pla: 0173:         prevmatch = matchop
; toolsrc/parse.pla: 0174:         matchop   = 0
; toolsrc/parse.pla: 0175:         if parse_constval
; toolsrc/parse.pla: 0176:             matchop = 1
; toolsrc/parse.pla: 0177:             scan
; toolsrc/parse.pla: 0178:             for i = 0 to bops_tblsz
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$00			; CN	0
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$54			; CALL	_C088
_F872 	!WORD	_C088		
	!BYTE	$4C			; BRFLS	_B525
	!WORD	_B525-*
	!BYTE	$02			; CN	1
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$54			; CALL	_C076
_F873 	!WORD	_C076		
	!BYTE	$30			; DROP 
	!BYTE	$2A,$11			; CB	17
	!BYTE	$00			; CN	0
_B528 
	!BYTE	$6C,$02			; DLB	[2]
; toolsrc/parse.pla: 0179:                 if token == bops_tbl[i]
; toolsrc/parse.pla: 0180:                     matchop = 2
; toolsrc/parse.pla: 0181:                     if bops_prec[i] >= tos_op_prec(optos)
; toolsrc/parse.pla: 0182:                         calc_binaryop(pop_op)
; toolsrc/parse.pla: 0183:                     fin
	!BYTE	$68			; LAB	_D098+0
_F874 	!WORD	_D098+0		
	!BYTE	$26			; LA	_D037+0
_F875 	!WORD	_D037+0		
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B530
	!WORD	_B530-*
	!BYTE	$04			; CN	2
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$26			; LA	_D038+0
_F876 	!WORD	_D038+0		
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$60			; LB
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$54			; CALL	_C083
_F877 	!WORD	_C083		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B532
	!WORD	_B532-*
	!BYTE	$54			; CALL	_C081
_F878 	!WORD	_C081		
	!BYTE	$54			; CALL	_C086
_F879 	!WORD	_C086		
_B532 
_B533 
; toolsrc/parse.pla: 0184:                     push_op(token, bops_prec[i])
; toolsrc/parse.pla: 0185:                     break
	!BYTE	$68			; LAB	_D098+0
_F880 	!WORD	_D098+0		
	!BYTE	$26			; LA	_D038+0
_F881 	!WORD	_D038+0		
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_C080
_F882 	!WORD	_C080		
	!BYTE	$50			; BRNCH	_B527
	!WORD	_B527-*
; toolsrc/parse.pla: 0186:                 fin
_B530 
_B531 
; toolsrc/parse.pla: 0187:             next
_B529 
	!BYTE	$A4			; INCBRLE	_B528
	!WORD	_B528-*
_B527 
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$30			; DROP 
; toolsrc/parse.pla: 0188:         fin
_B525 
_B526 
; toolsrc/parse.pla: 0189:     until matchop <> 2
_B524 
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$04			; CN	2
	!BYTE	$22			; BREQ	_B523
	!WORD	_B523-*
_B522 
; toolsrc/parse.pla: 0190:     if matchop == 0 and prevmatch == 0; return 0, 0, 0; fin
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$80			; NOT
	!BYTE	$AC			; BRAND	_B534
	!WORD	_B534-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$80			; NOT
_B534 
	!BYTE	$4C			; BRFLS	_B535
	!WORD	_B535-*
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$05			; LEAVE	5
_B535 
_B536 
; toolsrc/parse.pla: 0191:     if matchop == 0 and prevmatch == 2; exit_err(ERR_INVAL|ERR_SYNTAX); fin
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$80			; NOT
	!BYTE	$AC			; BRAND	_B537
	!WORD	_B537-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$04			; CN	2
	!BYTE	$40			; ISEQ
_B537 
	!BYTE	$4C			; BRFLS	_B538
	!WORD	_B538-*
	!BYTE	$2C,$04,$80		; CW	32772
	!BYTE	$54			; CALL	_C002
_F883 	!WORD	_C002		
_B538 
_B539 
; toolsrc/parse.pla: 0192:     while optos < opsp
	!BYTE	$50			; BRNCH	_B542
	!WORD	_B542-*
_B540 
; toolsrc/parse.pla: 0193:         calc_binaryop(pop_op)
; toolsrc/parse.pla: 0194:     loop
	!BYTE	$54			; CALL	_C081
_F884 	!WORD	_C081		
	!BYTE	$54			; CALL	_C086
_F885 	!WORD	_C086		
_B542 
	!BYTE	$66,$03			; LLW	[3]
	!BYTE	$6A			; LAW	_D041+0
_F886 	!WORD	_D041+0		
	!BYTE	$46			; ISLT
	!BYTE	$4E			; BRTRU	_B540
	!WORD	_B540-*
_B541 
; toolsrc/parse.pla: 0195:     return pop_val
	!BYTE	$54			; CALL	_C085
_F887 	!WORD	_C085		
	!BYTE	$5A,$05			; LEAVE	5
; toolsrc/parse.pla: 0196: end
; toolsrc/parse.pla: 0197: def parse_const(valptr)
					; valptr -> [0]
_C090 					; parse_const()
; toolsrc/parse.pla: 0198:     word idptr
					; idptr -> [2]
; toolsrc/parse.pla: 0199: 
; toolsrc/parse.pla: 0200:     when scan
	!BYTE	$58,$04,$01		; ENTER	4,1
	!BYTE	$54			; CALL	_C076
_F888 	!WORD	_C076		
	!BYTE	$52			; SEL
	!WORD	_B544-*
; toolsrc/parse.pla: 0201:         is CHR_TKN
_B545 
; toolsrc/parse.pla: 0202:         is INT_TKN
_B546 
; toolsrc/parse.pla: 0203:             *valptr = constval
; toolsrc/parse.pla: 0204:             break
	!BYTE	$6A			; LAW	_D103+0
_F889 	!WORD	_D103+0		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B543
	!WORD	_B543-*
; toolsrc/parse.pla: 0205:         is ID_TKN
_B547 
; toolsrc/parse.pla: 0206:             idptr = lookup_id(tknptr, tknlen)
; toolsrc/parse.pla: 0207:             if idptr=>idtype & CONST_TYPE
; toolsrc/parse.pla: 0208:                 *valptr = idptr=>idval
; toolsrc/parse.pla: 0209:                 break
	!BYTE	$6A			; LAW	_D101+0
_F890 	!WORD	_D101+0		
	!BYTE	$68			; LAB	_D100+0
_F891 	!WORD	_D100+0		
	!BYTE	$54			; CALL	_C044
_F892 	!WORD	_C044		
	!BYTE	$6E,$02			; DLW	[2]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B548
	!WORD	_B548-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$62			; LW
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B543
	!WORD	_B543-*
; toolsrc/parse.pla: 0210:             fin
_B548 
_B549 
; toolsrc/parse.pla: 0211:         otherwise
	!BYTE	$50			; BRNCH	_B550
	!WORD	_B550-*
_B544 
	!BYTE	$03			; CASEBLOCK
	!WORD	$00C3
	!WORD	_B545-*
	!WORD	$00C9
	!WORD	_B546-*
	!WORD	$00D6
	!WORD	_B547-*
_B550 
; toolsrc/parse.pla: 0212:             return 0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/parse.pla: 0213:     wend
_B543 
; toolsrc/parse.pla: 0214:     return CONST_TYPE
	!BYTE	$02			; CN	1
	!BYTE	$5A,$04			; LEAVE	4
; toolsrc/parse.pla: 0215: end
; toolsrc/parse.pla: 0216: //
; toolsrc/parse.pla: 0217: // Normal expression parsing
; toolsrc/parse.pla: 0218: //
; toolsrc/parse.pla: 0219: def parse_list#2
_C091 					; parse_list()
; toolsrc/parse.pla: 0220:     byte listdepth, stackdepth
					; listdepth -> [0]
					; stackdepth -> [1]
; toolsrc/parse.pla: 0221:     word listseq, exprseq
					; listseq -> [2]
					; exprseq -> [4]
; toolsrc/parse.pla: 0222: 
; toolsrc/parse.pla: 0223:     listseq   = NULL
	!BYTE	$58,$06,$00		; ENTER	6,0
; toolsrc/parse.pla: 0224:     listdepth = 0
; toolsrc/parse.pla: 0225:     repeat
	!BYTE	$00			; CN	0
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$00			; CN	0
	!BYTE	$74,$00			; SLB	[0]
_B552 
; toolsrc/parse.pla: 0226:         listseq, stackdepth = parse_expr(listseq)
; toolsrc/parse.pla: 0227:         listdepth = listdepth + stackdepth
; toolsrc/parse.pla: 0228:     until token <> COMMA_TKN
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_P003
_F893 	!WORD	_P003		
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$76,$02			; SLW	[2]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$B0,$01			; ADDLB	[1]
	!BYTE	$74,$00			; SLB	[0]
_B553 
	!BYTE	$68			; LAB	_D098+0
_F894 	!WORD	_D098+0		
	!BYTE	$2A,$AC			; CB	172
	!BYTE	$22			; BREQ	_B552
	!WORD	_B552-*
_B551 
; toolsrc/parse.pla: 0229:     return listseq, listdepth
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$5A,$06			; LEAVE	6
; toolsrc/parse.pla: 0230: end
; toolsrc/parse.pla: 0231: def parse_value(codeseq, r_val)#2
					; codeseq -> [0]
					; r_val -> [2]
_C092 					; parse_value()
; toolsrc/parse.pla: 0232:     byte cfnparms, cfnvals, stackdepth, operation
					; cfnparms -> [4]
					; cfnvals -> [5]
					; stackdepth -> [6]
					; operation -> [7]
; toolsrc/parse.pla: 0233:     word deref, type, optos, idptr, value, const_offset
					; deref -> [8]
					; type -> [10]
					; optos -> [12]
					; idptr -> [14]
					; value -> [16]
					; const_offset -> [18]
; toolsrc/parse.pla: 0234:     word uopseq, valseq, idxseq
					; uopseq -> [20]
					; valseq -> [22]
					; idxseq -> [24]
; toolsrc/parse.pla: 0235: 
; toolsrc/parse.pla: 0236:     deref      = r_val
	!BYTE	$58,$1A,$02		; ENTER	26,2
; toolsrc/parse.pla: 0237:     optos      = opsp
; toolsrc/parse.pla: 0238:     type       = 0
; toolsrc/parse.pla: 0239:     value      = 0
; toolsrc/parse.pla: 0240:     cfnparms   = 0
; toolsrc/parse.pla: 0241:     cfnvals    = 1
; toolsrc/parse.pla: 0242:     stackdepth = 1
; toolsrc/parse.pla: 0243:     uopseq     = NULL
; toolsrc/parse.pla: 0244:     valseq     = NULL
; toolsrc/parse.pla: 0245:     idxseq     = NULL
; toolsrc/parse.pla: 0246:     //
; toolsrc/parse.pla: 0247:     // Parse pre-ops
; toolsrc/parse.pla: 0248:     //
; toolsrc/parse.pla: 0249:     operation = TRUE
; toolsrc/parse.pla: 0250:     repeat
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$6A			; LAW	_D041+0
_F895 	!WORD	_D041+0		
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$00			; CN	0
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$00			; CN	0
	!BYTE	$76,$10			; SLW	[16]
	!BYTE	$00			; CN	0
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$02			; CN	1
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$02			; CN	1
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$00			; CN	0
	!BYTE	$76,$14			; SLW	[20]
	!BYTE	$00			; CN	0
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$00			; CN	0
	!BYTE	$76,$18			; SLW	[24]
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$07			; SLB	[7]
_B555 
; toolsrc/parse.pla: 0251:         when scan
	!BYTE	$54			; CALL	_C076
_F896 	!WORD	_C076		
	!BYTE	$52			; SEL
	!WORD	_B558-*
; toolsrc/parse.pla: 0252:             is NEG_TKN
_B559 
; toolsrc/parse.pla: 0253:             is COMP_TKN
_B560 
; toolsrc/parse.pla: 0254:             is LOGIC_NOT_TKN
_B561 
; toolsrc/parse.pla: 0255:                 uopseq = gen_uop(uopseq, token);
; toolsrc/parse.pla: 0256:             is ADD_TKN
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$68			; LAB	_D098+0
_F897 	!WORD	_D098+0		
	!BYTE	$54			; CALL	_C066
_F898 	!WORD	_C066		
	!BYTE	$76,$14			; SLW	[20]
_B562 
; toolsrc/parse.pla: 0257:                 if not r_val; exit_err(ERR_INVAL|ERR_SYNTAX); fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B563
	!WORD	_B563-*
	!BYTE	$2C,$04,$80		; CW	32772
	!BYTE	$54			; CALL	_C002
_F899 	!WORD	_C002		
_B563 
_B564 
; toolsrc/parse.pla: 0258:                 break
	!BYTE	$50			; BRNCH	_B557
	!WORD	_B557-*
; toolsrc/parse.pla: 0259:             is BPTR_TKN
_B565 
; toolsrc/parse.pla: 0260:             is WPTR_TKN
_B566 
; toolsrc/parse.pla: 0261:                 if type & BPTR_TYPE; exit_err(ERR_INVAL|ERR_SYNTAX); fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$4C			; BRFLS	_B567
	!WORD	_B567-*
	!BYTE	$2C,$04,$80		; CW	32772
	!BYTE	$54			; CALL	_C002
_F900 	!WORD	_C002		
_B567 
_B568 
; toolsrc/parse.pla: 0262:                 type = token == BPTR_TKN ?? BPTR_TYPE :: WPTR_TYPE
; toolsrc/parse.pla: 0263:                 deref++
	!BYTE	$68			; LAB	_D098+0
_F901 	!WORD	_D098+0		
	!BYTE	$2A,$DE			; CB	222
	!BYTE	$24			; BRNE	_B569
	!WORD	_B569-*
	!BYTE	$2A,$20			; CB	32
	!BYTE	$50			; BRNCH	_B570
	!WORD	_B570-*
_B569 
	!BYTE	$2A,$40			; CB	64
_B570 
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 0264:                 break
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B557
	!WORD	_B557-*
; toolsrc/parse.pla: 0265:             is AT_TKN
_B571 
; toolsrc/parse.pla: 0266:                 if not deref; exit_err(ERR_INVAL|ERR_SYNTAX); fin
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$4E			; BRTRU	_B572
	!WORD	_B572-*
	!BYTE	$2C,$04,$80		; CW	32772
	!BYTE	$54			; CALL	_C002
_F902 	!WORD	_C002		
_B572 
_B573 
; toolsrc/parse.pla: 0267:                 deref--
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0268:                 break
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B557
	!WORD	_B557-*
; toolsrc/parse.pla: 0269:             otherwise
_B558 
	!BYTE	$07			; CASEBLOCK
	!WORD	$00A1
	!WORD	_B561-*
	!WORD	$00AA
	!WORD	_B566-*
	!WORD	$00AB
	!WORD	_B562-*
	!WORD	$00AD
	!WORD	_B559-*
	!WORD	$00C0
	!WORD	_B571-*
	!WORD	$00DE
	!WORD	_B565-*
	!WORD	$00FE
	!WORD	_B560-*
; toolsrc/parse.pla: 0270:                 operation = FALSE
; toolsrc/parse.pla: 0271:         wend
	!BYTE	$00			; CN	0
	!BYTE	$74,$07			; SLB	[7]
_B557 
; toolsrc/parse.pla: 0272:     until not operation
_B556 
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$4E			; BRTRU	_B555
	!WORD	_B555-*
_B554 
; toolsrc/parse.pla: 0273:     //
; toolsrc/parse.pla: 0274:     // Determine terminal type
; toolsrc/parse.pla: 0275:     //
; toolsrc/parse.pla: 0276:     when token
	!BYTE	$68			; LAB	_D098+0
_F903 	!WORD	_D098+0		
	!BYTE	$52			; SEL
	!WORD	_B575-*
; toolsrc/parse.pla: 0277:         is ID_TKN
_B576 
; toolsrc/parse.pla: 0278:             idptr = lookup_id(tknptr, tknlen)
; toolsrc/parse.pla: 0279:             if not idptr; return codeseq, 0; fin
	!BYTE	$6A			; LAW	_D101+0
_F904 	!WORD	_D101+0		
	!BYTE	$68			; LAB	_D100+0
_F905 	!WORD	_D100+0		
	!BYTE	$54			; CALL	_C044
_F906 	!WORD	_C044		
	!BYTE	$6E,$0E			; DLW	[14]
	!BYTE	$4E			; BRTRU	_B577
	!WORD	_B577-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$5A,$1A			; LEAVE	26
_B577 
_B578 
; toolsrc/parse.pla: 0280:             if not idptr=>idtype; return codeseq, 0; fin // DEBUG
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B579
	!WORD	_B579-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$5A,$1A			; LEAVE	26
_B579 
_B580 
; toolsrc/parse.pla: 0281:             type  = type | idptr=>idtype
; toolsrc/parse.pla: 0282:             value = idptr=>idval
; toolsrc/parse.pla: 0283:             if type & CONST_TYPE
; toolsrc/parse.pla: 0284:                 valseq = gen_const(NULL, value)
; toolsrc/parse.pla: 0285:                 deref--
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$96			; OR 
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$62			; LW
	!BYTE	$76,$10			; SLW	[16]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4C			; BRFLS	_B581
	!WORD	_B581-*
	!BYTE	$00			; CN	0
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$54			; CALL	_C060
_F907 	!WORD	_C060		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0286:             else
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B582
	!WORD	_B582-*
_B581 
; toolsrc/parse.pla: 0287:                 valseq = type & LOCAL_TYPE ?? gen_oplcl(NULL, LADDR_CODE, value) :: gen_opglbl(NULL, GADDR_CODE, value, 0)
; toolsrc/parse.pla: 0288:                 if type & FUNC_TYPE
; toolsrc/parse.pla: 0289:                     cfnparms = idptr->funcparms
; toolsrc/parse.pla: 0290:                     cfnvals  = idptr->funcvals
; toolsrc/parse.pla: 0291:                 fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B583
	!WORD	_B583-*
	!BYTE	$00			; CN	0
	!BYTE	$2A,$28			; CB	40
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$54			; CALL	_C062
_F908 	!WORD	_C062		
	!BYTE	$50			; BRNCH	_B584
	!WORD	_B584-*
_B583 
	!BYTE	$00			; CN	0
	!BYTE	$2A,$26			; CB	38
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C063
_F909 	!WORD	_C063		
_B584 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B585
	!WORD	_B585-*
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$60			; LB
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$60			; LB
	!BYTE	$74,$05			; SLB	[5]
_B585 
_B586 
; toolsrc/parse.pla: 0292:             fin
_B582 
; toolsrc/parse.pla: 0293:             break
	!BYTE	$50			; BRNCH	_B574
	!WORD	_B574-*
; toolsrc/parse.pla: 0294:         is INT_TKN
_B587 
; toolsrc/parse.pla: 0295:         is CHR_TKN
_B588 
; toolsrc/parse.pla: 0296:             value  = constval
; toolsrc/parse.pla: 0297:             valseq = gen_const(NULL, value)
; toolsrc/parse.pla: 0298:             deref--
	!BYTE	$6A			; LAW	_D103+0
_F910 	!WORD	_D103+0		
	!BYTE	$76,$10			; SLW	[16]
	!BYTE	$00			; CN	0
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$54			; CALL	_C060
_F911 	!WORD	_C060		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0299:             break
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B574
	!WORD	_B574-*
; toolsrc/parse.pla: 0300:         is STR_TKN
_B589 
; toolsrc/parse.pla: 0301:             codeseq = gen_str(codeseq, constval)
; toolsrc/parse.pla: 0302:             scan
; toolsrc/parse.pla: 0303:             return codeseq, stackdepth // Special case return
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$6A			; LAW	_D103+0
_F912 	!WORD	_D103+0		
	!BYTE	$54			; CALL	_C061
_F913 	!WORD	_C061		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$54			; CALL	_C076
_F914 	!WORD	_C076		
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$5A,$1A			; LEAVE	26
; toolsrc/parse.pla: 0304:             break
	!BYTE	$50			; BRNCH	_B574
	!WORD	_B574-*
; toolsrc/parse.pla: 0305:         is OPEN_PAREN_TKN
_B590 
; toolsrc/parse.pla: 0306:             valseq, stackdepth = parse_expr(NULL)
; toolsrc/parse.pla: 0307:             if token <> CLOSE_PAREN_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_SYNTAX); fin
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_P003
_F915 	!WORD	_P003		
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$68			; LAB	_D098+0
_F916 	!WORD	_D098+0		
	!BYTE	$2A,$A9			; CB	169
	!BYTE	$22			; BREQ	_B591
	!WORD	_B591-*
	!BYTE	$2C,$28,$80		; CW	32808
	!BYTE	$54			; CALL	_C002
_F917 	!WORD	_C002		
_B591 
_B592 
; toolsrc/parse.pla: 0308:             deref--
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0309:             break
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B574
	!WORD	_B574-*
; toolsrc/parse.pla: 0310:         is DROP_TKN
_B593 
; toolsrc/parse.pla: 0311:             if r_val; exit_err(ERR_INVAL|ERR_STATE); fin
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4C			; BRFLS	_B594
	!WORD	_B594-*
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F918 	!WORD	_C002		
_B594 
_B595 
; toolsrc/parse.pla: 0312:             codeseq = gen_op(codeseq, DROP_CODE)
; toolsrc/parse.pla: 0313:             scan
; toolsrc/parse.pla: 0314:             return codeseq, 0 // Special case return
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C059
_F919 	!WORD	_C059		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$54			; CALL	_C076
_F920 	!WORD	_C076		
	!BYTE	$30			; DROP 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$5A,$1A			; LEAVE	26
; toolsrc/parse.pla: 0315:         is LAMBDA_TKN
_B596 
; toolsrc/parse.pla: 0316:             if not r_val; return codeseq, 0; fin // Lambdas can't be LVALUES
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B597
	!WORD	_B597-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$5A,$1A			; LEAVE	26
_B597 
_B598 
; toolsrc/parse.pla: 0317:             value  = parse_lambda
; toolsrc/parse.pla: 0318:             valseq = gen_opglbl(NULL, GADDR_CODE, value, 0)
; toolsrc/parse.pla: 0319:             deref--
	!BYTE	$54			; CALL	_P004
_F921 	!WORD	_P004		
	!BYTE	$76,$10			; SLW	[16]
	!BYTE	$00			; CN	0
	!BYTE	$2A,$26			; CB	38
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C063
_F922 	!WORD	_C063		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0320:             break
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B574
	!WORD	_B574-*
; toolsrc/parse.pla: 0321:         otherwise
_B575 
	!BYTE	$07			; CASEBLOCK
	!WORD	$00A6
	!WORD	_B596-*
	!WORD	$00A8
	!WORD	_B590-*
	!WORD	$00BB
	!WORD	_B593-*
	!WORD	$00C3
	!WORD	_B588-*
	!WORD	$00C9
	!WORD	_B587-*
	!WORD	$00D3
	!WORD	_B589-*
	!WORD	$00D6
	!WORD	_B576-*
; toolsrc/parse.pla: 0322:             if uopseq;  release_seq(uopseq);  fin
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$4C			; BRFLS	_B599
	!WORD	_B599-*
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$54			; CALL	_C007
_F923 	!WORD	_C007		
_B599 
_B600 
; toolsrc/parse.pla: 0323:             if codeseq; release_seq(codeseq); fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$4C			; BRFLS	_B601
	!WORD	_B601-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C007
_F924 	!WORD	_C007		
_B601 
_B602 
; toolsrc/parse.pla: 0324:             return NULL, 0
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$5A,$1A			; LEAVE	26
; toolsrc/parse.pla: 0325:     wend
_B574 
; toolsrc/parse.pla: 0326:     //
; toolsrc/parse.pla: 0327:     // Parse post-ops
; toolsrc/parse.pla: 0328:     //
; toolsrc/parse.pla: 0329:     operation = TRUE
; toolsrc/parse.pla: 0330:     repeat
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$07			; SLB	[7]
_B604 
; toolsrc/parse.pla: 0331:         when scan
	!BYTE	$54			; CALL	_C076
_F925 	!WORD	_C076		
	!BYTE	$52			; SEL
	!WORD	_B607-*
; toolsrc/parse.pla: 0332:             is OPEN_PAREN_TKN
_B608 
; toolsrc/parse.pla: 0333:                 //
; toolsrc/parse.pla: 0334:                 // Function call - parameters generate before call address
; toolsrc/parse.pla: 0335:                 //
; toolsrc/parse.pla: 0336:                 idxseq, value = parse_list
; toolsrc/parse.pla: 0337:                 valseq = cat_seq(idxseq, valseq)
; toolsrc/parse.pla: 0338:                 if token <> CLOSE_PAREN_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_SYNTAX); fin
	!BYTE	$54			; CALL	_C091
_F926 	!WORD	_C091		
	!BYTE	$76,$10			; SLW	[16]
	!BYTE	$6E,$18			; DLW	[24]
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$54			; CALL	_C008
_F927 	!WORD	_C008		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$68			; LAB	_D098+0
_F928 	!WORD	_D098+0		
	!BYTE	$2A,$A9			; CB	169
	!BYTE	$22			; BREQ	_B609
	!WORD	_B609-*
	!BYTE	$2C,$28,$80		; CW	32808
	!BYTE	$54			; CALL	_C002
_F929 	!WORD	_C002		
_B609 
_B610 
; toolsrc/parse.pla: 0339:                 if type & FUNC_TYPE // Can't check parm count on function pointers
; toolsrc/parse.pla: 0340:                     if cfnparms <> value; exit_err(ERR_MISS|ERR_ID); fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B611
	!WORD	_B611-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$22			; BREQ	_B613
	!WORD	_B613-*
	!BYTE	$2C,$08,$02		; CW	520
	!BYTE	$54			; CALL	_C002
_F930 	!WORD	_C002		
_B613 
_B614 
; toolsrc/parse.pla: 0341:                 else
	!BYTE	$50			; BRNCH	_B612
	!WORD	_B612-*
_B611 
; toolsrc/parse.pla: 0342:                     if scan == POUND_TKN // Set function pointer return vals count - can't do this to regular function call
; toolsrc/parse.pla: 0343:                         if not parse_const(@value); exit_err(ERR_INVAL|ERR_CONST); fin
	!BYTE	$54			; CALL	_C076
_F931 	!WORD	_C076		
	!BYTE	$2A,$A3			; CB	163
	!BYTE	$24			; BRNE	_B615
	!WORD	_B615-*
	!BYTE	$28,$10			; LLA	[16]
	!BYTE	$54			; CALL	_C090
_F932 	!WORD	_C090		
	!BYTE	$4E			; BRTRU	_B617
	!WORD	_B617-*
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$54			; CALL	_C002
_F933 	!WORD	_C002		
_B617 
_B618 
; toolsrc/parse.pla: 0344:                         cfnvals = value
; toolsrc/parse.pla: 0345:                     else
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B616
	!WORD	_B616-*
_B615 
; toolsrc/parse.pla: 0346:                         rewind(tknptr)
; toolsrc/parse.pla: 0347:                     fin
	!BYTE	$6A			; LAW	_D101+0
_F934 	!WORD	_D101+0		
	!BYTE	$54			; CALL	_C077
_F935 	!WORD	_C077		
_B616 
; toolsrc/parse.pla: 0348:                     if type & WORD_TYPE
; toolsrc/parse.pla: 0349:                         valseq = gen_op(valseq, LW_CODE)
; toolsrc/parse.pla: 0350:                     elsif type & BYTE_TYPE
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B619
	!WORD	_B619-*
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$62			; CB	98
	!BYTE	$54			; CALL	_C059
_F936 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$50			; BRNCH	_B620
	!WORD	_B620-*
_B619 
; toolsrc/parse.pla: 0351:                         exit_err(ERR_INVAL|ERR_CODE)
; toolsrc/parse.pla: 0352:                     else
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B621
	!WORD	_B621-*
	!BYTE	$2C,$04,$01		; CW	260
	!BYTE	$54			; CALL	_C002
_F937 	!WORD	_C002		
	!BYTE	$50			; BRNCH	_B620
	!WORD	_B620-*
_B621 
; toolsrc/parse.pla: 0353:                         deref++
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 0354:                     fin
	!BYTE	$76,$08			; SLW	[8]
_B620 
; toolsrc/parse.pla: 0355:                 fin
_B612 
; toolsrc/parse.pla: 0356:                 valseq     = gen_op(valseq, ICAL_CODE)
; toolsrc/parse.pla: 0357:                 stackdepth = stackdepth + cfnvals - 1
; toolsrc/parse.pla: 0358:                 cfnparms   = 0
; toolsrc/parse.pla: 0359:                 cfnvals    = 1
; toolsrc/parse.pla: 0360:                 type       = type & PTR_TYPE
; toolsrc/parse.pla: 0361:                 deref--
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$56			; CB	86
	!BYTE	$54			; CALL	_C059
_F938 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$B0,$05			; ADDLB	[5]
	!BYTE	$8E			; DECR
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$00			; CN	0
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$02			; CN	1
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$60			; ANDI	96
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0362:                 break
	!BYTE	$76,$08			; SLW	[8]
	!BYTE	$50			; BRNCH	_B606
	!WORD	_B606-*
; toolsrc/parse.pla: 0363:             is OPEN_BRACKET_TKN
_B622 
; toolsrc/parse.pla: 0364:                 //
; toolsrc/parse.pla: 0365:                 // Array of arrays
; toolsrc/parse.pla: 0366:                 //
; toolsrc/parse.pla: 0367:                 if type & FUNC_TYPE // Function address dereference
; toolsrc/parse.pla: 0368:                     cfnparms = 0
; toolsrc/parse.pla: 0369:                     cfnvals  = 1
; toolsrc/parse.pla: 0370:                 fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B623
	!WORD	_B623-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$02			; CN	1
	!BYTE	$74,$05			; SLB	[5]
_B623 
_B624 
; toolsrc/parse.pla: 0371:                 repeat
_B626 
; toolsrc/parse.pla: 0372:                     valseq, drop = parse_expr(valseq)
; toolsrc/parse.pla: 0373:                     if token <> COMMA_TKN; break; fin
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$54			; CALL	_P003
_F939 	!WORD	_P003		
	!BYTE	$30			; DROP 
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$68			; LAB	_D098+0
_F940 	!WORD	_D098+0		
	!BYTE	$2A,$AC			; CB	172
	!BYTE	$22			; BREQ	_B628
	!WORD	_B628-*
	!BYTE	$50			; BRNCH	_B625
	!WORD	_B625-*
_B628 
_B629 
; toolsrc/parse.pla: 0374:                     valseq = gen_op(valseq, INDEXW_CODE)
; toolsrc/parse.pla: 0375:                     valseq = gen_op(valseq, LW_CODE) // Multi-dimenstion arrays are array pointers to arrays
; toolsrc/parse.pla: 0376:                 until FALSE
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$9E			; CB	158
	!BYTE	$54			; CALL	_C059
_F941 	!WORD	_C059		
	!BYTE	$6E,$16			; DLW	[22]
	!BYTE	$2A,$62			; CB	98
	!BYTE	$54			; CALL	_C059
_F942 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
_B627 
	!BYTE	$50			; BRNCH	_B626
	!WORD	_B626-*
_B625 
; toolsrc/parse.pla: 0377:                 if token <> CLOSE_BRACKET_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_SYNTAX); fin
	!BYTE	$68			; LAB	_D098+0
_F943 	!WORD	_D098+0		
	!BYTE	$2A,$DD			; CB	221
	!BYTE	$22			; BREQ	_B630
	!WORD	_B630-*
	!BYTE	$2C,$28,$80		; CW	32808
	!BYTE	$54			; CALL	_C002
_F944 	!WORD	_C002		
_B630 
_B631 
; toolsrc/parse.pla: 0378:                 if type & WORD_TYPE
; toolsrc/parse.pla: 0379:                     valseq = gen_op(valseq, INDEXW_CODE)
; toolsrc/parse.pla: 0380:                 else
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B632
	!WORD	_B632-*
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$9E			; CB	158
	!BYTE	$54			; CALL	_C059
_F945 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$50			; BRNCH	_B633
	!WORD	_B633-*
_B632 
; toolsrc/parse.pla: 0381:                     valseq = gen_op(valseq, INDEXB_CODE)
; toolsrc/parse.pla: 0382:                     if not (type & BYTE_TYPE)
; toolsrc/parse.pla: 0383:                         type = (type & PTR_TYPE) | BYTE_TYPE
; toolsrc/parse.pla: 0384:                         deref++
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$82			; CB	130
	!BYTE	$54			; CALL	_C059
_F946 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4E			; BRTRU	_B634
	!WORD	_B634-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$60			; ANDI	96
	!BYTE	$3E,$02			; ORI	2
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 0385:                     fin
	!BYTE	$76,$08			; SLW	[8]
_B634 
_B635 
; toolsrc/parse.pla: 0386:                 fin
_B633 
; toolsrc/parse.pla: 0387:                 break
	!BYTE	$50			; BRNCH	_B606
	!WORD	_B606-*
; toolsrc/parse.pla: 0388:             is PTRB_TKN
_B636 
; toolsrc/parse.pla: 0389:             is PTRW_TKN
_B637 
; toolsrc/parse.pla: 0390:                 //
; toolsrc/parse.pla: 0391:                 // Structure member pointer
; toolsrc/parse.pla: 0392:                 //
; toolsrc/parse.pla: 0393:                 if type & FUNC_TYPE // Function call dereference
; toolsrc/parse.pla: 0394:                     if cfnparms; exit_err(ERR_MISS|ERR_ID); fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B638
	!WORD	_B638-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$4C			; BRFLS	_B640
	!WORD	_B640-*
	!BYTE	$2C,$08,$02		; CW	520
	!BYTE	$54			; CALL	_C002
_F947 	!WORD	_C002		
_B640 
_B641 
; toolsrc/parse.pla: 0395:                     valseq     = gen_op(valseq, ICAL_CODE)
; toolsrc/parse.pla: 0396:                     stackdepth = stackdepth + cfnvals - 1
; toolsrc/parse.pla: 0397:                     cfnparms   = 0
; toolsrc/parse.pla: 0398:                     cfnvals    = 1
; toolsrc/parse.pla: 0399:                 elsif type & WORD_TYPE
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$56			; CB	86
	!BYTE	$54			; CALL	_C059
_F948 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$B0,$05			; ADDLB	[5]
	!BYTE	$8E			; DECR
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$00			; CN	0
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$02			; CN	1
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B639
	!WORD	_B639-*
_B638 
; toolsrc/parse.pla: 0400:                     valseq = gen_op(valseq, LW_CODE) // Pointer dereference
; toolsrc/parse.pla: 0401:                 elsif type & BYTE_TYPE
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B642
	!WORD	_B642-*
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$62			; CB	98
	!BYTE	$54			; CALL	_C059
_F949 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$50			; BRNCH	_B639
	!WORD	_B639-*
_B642 
; toolsrc/parse.pla: 0402:                     exit_err(ERR_INVAL|ERR_CODE)
; toolsrc/parse.pla: 0403:                 else
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B643
	!WORD	_B643-*
	!BYTE	$2C,$04,$01		; CW	260
	!BYTE	$54			; CALL	_C002
_F950 	!WORD	_C002		
	!BYTE	$50			; BRNCH	_B639
	!WORD	_B639-*
_B643 
; toolsrc/parse.pla: 0404:                     deref++
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 0405:                 fin
	!BYTE	$76,$08			; SLW	[8]
_B639 
; toolsrc/parse.pla: 0406:                 type = token == PTRB_TKN ?? BYTE_TYPE :: WORD_TYPE
; toolsrc/parse.pla: 0407:                 if not parse_const(@const_offset)
; toolsrc/parse.pla: 0408:                     rewind(tknptr) // Setting type override for following operations
; toolsrc/parse.pla: 0409:                 elsif const_offset <> 0
	!BYTE	$68			; LAB	_D098+0
_F951 	!WORD	_D098+0		
	!BYTE	$2A,$D8			; CB	216
	!BYTE	$24			; BRNE	_B644
	!WORD	_B644-*
	!BYTE	$04			; CN	2
	!BYTE	$50			; BRNCH	_B645
	!WORD	_B645-*
_B644 
	!BYTE	$08			; CN	4
_B645 
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$28,$12			; LLA	[18]
	!BYTE	$54			; CALL	_C090
_F952 	!WORD	_C090		
	!BYTE	$4E			; BRTRU	_B646
	!WORD	_B646-*
	!BYTE	$6A			; LAW	_D101+0
_F953 	!WORD	_D101+0		
	!BYTE	$54			; CALL	_C077
_F954 	!WORD	_C077		
	!BYTE	$50			; BRNCH	_B647
	!WORD	_B647-*
_B646 
; toolsrc/parse.pla: 0410:                     valseq = gen_const(valseq, const_offset) // Structure member pointer
; toolsrc/parse.pla: 0411:                     valseq = gen_op(valseq, ADD_CODE)
; toolsrc/parse.pla: 0412:                 fin
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$4C			; BRFLS	_B648
	!WORD	_B648-*
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$54			; CALL	_C060
_F955 	!WORD	_C060		
	!BYTE	$6E,$16			; DLW	[22]
	!BYTE	$2A,$82			; CB	130
	!BYTE	$54			; CALL	_C059
_F956 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
_B648 
_B647 
; toolsrc/parse.pla: 0413:                 break
	!BYTE	$50			; BRNCH	_B606
	!WORD	_B606-*
; toolsrc/parse.pla: 0414:             is DOT_TKN
_B649 
; toolsrc/parse.pla: 0415:             is COLON_TKN
_B650 
; toolsrc/parse.pla: 0416:                 //
; toolsrc/parse.pla: 0417:                 // Structure member offset
; toolsrc/parse.pla: 0418:                 //
; toolsrc/parse.pla: 0419:                 if type & FUNC_TYPE // Function address dereference
; toolsrc/parse.pla: 0420:                     cfnparms   = 0
; toolsrc/parse.pla: 0421:                     cfnvals    = 1
; toolsrc/parse.pla: 0422:                 elsif not (type & VAR_TYPE)
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B651
	!WORD	_B651-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$02			; CN	1
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$50			; BRNCH	_B652
	!WORD	_B652-*
_B651 
; toolsrc/parse.pla: 0423:                     deref++
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$06			; ANDI	6
	!BYTE	$4E			; BRTRU	_B653
	!WORD	_B653-*
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 0424:                 fin
	!BYTE	$76,$08			; SLW	[8]
_B653 
_B652 
; toolsrc/parse.pla: 0425:                 type = token == DOT_TKN ?? BYTE_TYPE :: WORD_TYPE
; toolsrc/parse.pla: 0426:                 if not parse_const(@const_offset)
; toolsrc/parse.pla: 0427:                     rewind(tknptr) // Setting type override for following operations
; toolsrc/parse.pla: 0428:                 elsif const_offset <> 0
	!BYTE	$68			; LAB	_D098+0
_F957 	!WORD	_D098+0		
	!BYTE	$2A,$AE			; CB	174
	!BYTE	$24			; BRNE	_B654
	!WORD	_B654-*
	!BYTE	$04			; CN	2
	!BYTE	$50			; BRNCH	_B655
	!WORD	_B655-*
_B654 
	!BYTE	$08			; CN	4
_B655 
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$28,$12			; LLA	[18]
	!BYTE	$54			; CALL	_C090
_F958 	!WORD	_C090		
	!BYTE	$4E			; BRTRU	_B656
	!WORD	_B656-*
	!BYTE	$6A			; LAW	_D101+0
_F959 	!WORD	_D101+0		
	!BYTE	$54			; CALL	_C077
_F960 	!WORD	_C077		
	!BYTE	$50			; BRNCH	_B657
	!WORD	_B657-*
_B656 
; toolsrc/parse.pla: 0429:                     valseq = gen_const(valseq, const_offset) // Structure member offset
; toolsrc/parse.pla: 0430:                     valseq = gen_op(valseq, ADD_CODE)
; toolsrc/parse.pla: 0431:                 fin
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$4C			; BRFLS	_B658
	!WORD	_B658-*
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$54			; CALL	_C060
_F961 	!WORD	_C060		
	!BYTE	$6E,$16			; DLW	[22]
	!BYTE	$2A,$82			; CB	130
	!BYTE	$54			; CALL	_C059
_F962 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
_B658 
_B657 
; toolsrc/parse.pla: 0432:                 break
	!BYTE	$50			; BRNCH	_B606
	!WORD	_B606-*
; toolsrc/parse.pla: 0433:             otherwise
_B607 
	!BYTE	$06			; CASEBLOCK
	!WORD	$00A8
	!WORD	_B608-*
	!WORD	$00AE
	!WORD	_B649-*
	!WORD	$00BA
	!WORD	_B650-*
	!WORD	$00D7
	!WORD	_B637-*
	!WORD	$00D8
	!WORD	_B636-*
	!WORD	$00DB
	!WORD	_B622-*
; toolsrc/parse.pla: 0434:                 operation = FALSE
; toolsrc/parse.pla: 0435:         wend
	!BYTE	$00			; CN	0
	!BYTE	$74,$07			; SLB	[7]
_B606 
; toolsrc/parse.pla: 0436:     until not operation
_B605 
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$4E			; BRTRU	_B604
	!WORD	_B604-*
_B603 
; toolsrc/parse.pla: 0437:     //
; toolsrc/parse.pla: 0438:     //Probably parsing RVALUE as LVALUE
; toolsrc/parse.pla: 0439:     //
; toolsrc/parse.pla: 0440:     if deref < 0
; toolsrc/parse.pla: 0441:         release_seq(valseq)
; toolsrc/parse.pla: 0442:         release_seq(uopseq)
; toolsrc/parse.pla: 0443:         return codeseq, 0
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$00			; CN	0
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B659
	!WORD	_B659-*
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$54			; CALL	_C007
_F963 	!WORD	_C007		
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$54			; CALL	_C007
_F964 	!WORD	_C007		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$5A,$1A			; LEAVE	26
; toolsrc/parse.pla: 0444:     fin
_B659 
_B660 
; toolsrc/parse.pla: 0445:     //
; toolsrc/parse.pla: 0446:     // Resolve outstanding dereference pointer loads
; toolsrc/parse.pla: 0447:     //
; toolsrc/parse.pla: 0448:     while deref > r_val
	!BYTE	$50			; BRNCH	_B663
	!WORD	_B663-*
_B661 
; toolsrc/parse.pla: 0449:         if type & FUNC_TYPE
; toolsrc/parse.pla: 0450:             if cfnparms; exit_err(ERR_MISS|ERR_ID); fin
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B664
	!WORD	_B664-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$4C			; BRFLS	_B666
	!WORD	_B666-*
	!BYTE	$2C,$08,$02		; CW	520
	!BYTE	$54			; CALL	_C002
_F965 	!WORD	_C002		
_B666 
_B667 
; toolsrc/parse.pla: 0451:             valseq     = gen_op(valseq, ICAL_CODE)
; toolsrc/parse.pla: 0452:             stackdepth = stackdepth + cfnvals - 1
; toolsrc/parse.pla: 0453:             cfnparms   = 0
; toolsrc/parse.pla: 0454:             cfnvals    = 1
; toolsrc/parse.pla: 0455:             type       = type & ~FUNC_TYPE;
; toolsrc/parse.pla: 0456:         else
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$56			; CB	86
	!BYTE	$54			; CALL	_C059
_F966 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$B0,$05			; ADDLB	[5]
	!BYTE	$8E			; DECR
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$00			; CN	0
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$02			; CN	1
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$5E,$F7			; CFFB	-9
	!BYTE	$94			; AND 
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$50			; BRNCH	_B665
	!WORD	_B665-*
_B664 
; toolsrc/parse.pla: 0457:             valseq = gen_op(valseq, LW_CODE)
; toolsrc/parse.pla: 0458:         fin
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$62			; CB	98
	!BYTE	$54			; CALL	_C059
_F967 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
_B665 
; toolsrc/parse.pla: 0459:         deref--
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0460:     loop
	!BYTE	$76,$08			; SLW	[8]
_B663 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B661
	!WORD	_B661-*
_B662 
; toolsrc/parse.pla: 0461:     if deref
; toolsrc/parse.pla: 0462:         if type & FUNC_TYPE
; toolsrc/parse.pla: 0463:             if cfnparms; exit_err(ERR_MISS|ERR_ID); fin
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$4C			; BRFLS	_B668
	!WORD	_B668-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$08			; ANDI	8
	!BYTE	$4C			; BRFLS	_B670
	!WORD	_B670-*
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$4C			; BRFLS	_B672
	!WORD	_B672-*
	!BYTE	$2C,$08,$02		; CW	520
	!BYTE	$54			; CALL	_C002
_F968 	!WORD	_C002		
_B672 
_B673 
; toolsrc/parse.pla: 0464:             valseq     = gen_op(valseq, ICAL_CODE)
; toolsrc/parse.pla: 0465:             stackdepth = stackdepth + cfnvals - 1
; toolsrc/parse.pla: 0466:             type       = type & ~FUNC_TYPE
; toolsrc/parse.pla: 0467:         elsif type & (BPTR_TYPE)  // Prefer the pointer type.
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$56			; CB	86
	!BYTE	$54			; CALL	_C059
_F969 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$B0,$05			; ADDLB	[5]
	!BYTE	$8E			; DECR
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$5E,$F7			; CFFB	-9
	!BYTE	$94			; AND 
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$50			; BRNCH	_B671
	!WORD	_B671-*
_B670 
; toolsrc/parse.pla: 0468:             valseq = gen_op(valseq, LB_CODE)
; toolsrc/parse.pla: 0469:         elsif type & (WPTR_TYPE)
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$20			; ANDI	32
	!BYTE	$4C			; BRFLS	_B674
	!WORD	_B674-*
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$60			; CB	96
	!BYTE	$54			; CALL	_C059
_F970 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$50			; BRNCH	_B671
	!WORD	_B671-*
_B674 
; toolsrc/parse.pla: 0470:             valseq = gen_op(valseq, LW_CODE)
; toolsrc/parse.pla: 0471:         elsif type & (BYTE_TYPE)
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$40			; ANDI	64
	!BYTE	$4C			; BRFLS	_B675
	!WORD	_B675-*
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$62			; CB	98
	!BYTE	$54			; CALL	_C059
_F971 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$50			; BRNCH	_B671
	!WORD	_B671-*
_B675 
; toolsrc/parse.pla: 0472:             valseq = gen_op(valseq, LB_CODE)
; toolsrc/parse.pla: 0473:         elsif type & (WORD_TYPE)
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B676
	!WORD	_B676-*
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$60			; CB	96
	!BYTE	$54			; CALL	_C059
_F972 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$50			; BRNCH	_B671
	!WORD	_B671-*
_B676 
; toolsrc/parse.pla: 0474:             valseq = gen_op(valseq, LW_CODE)
; toolsrc/parse.pla: 0475:         else
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B677
	!WORD	_B677-*
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$62			; CB	98
	!BYTE	$54			; CALL	_C059
_F973 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$50			; BRNCH	_B671
	!WORD	_B671-*
_B677 
; toolsrc/parse.pla: 0476:             exit_err(ERR_INVAL|ERR_CODE)
; toolsrc/parse.pla: 0477:         fin
	!BYTE	$2C,$04,$01		; CW	260
	!BYTE	$54			; CALL	_C002
_F974 	!WORD	_C002		
_B671 
; toolsrc/parse.pla: 0478:     fin
_B668 
_B669 
; toolsrc/parse.pla: 0479:     //
; toolsrc/parse.pla: 0480:     // Output pre-operations
; toolsrc/parse.pla: 0481:     //
; toolsrc/parse.pla: 0482:     valseq = cat_seq(valseq, uopseq)
; toolsrc/parse.pla: 0483:     //
; toolsrc/parse.pla: 0484:     // Wrap up LVALUE store
; toolsrc/parse.pla: 0485:     //
; toolsrc/parse.pla: 0486:     if not r_val
; toolsrc/parse.pla: 0487:         if type & (BYTE_TYPE | BPTR_TYPE)
; toolsrc/parse.pla: 0488:             valseq = gen_op(valseq, SB_CODE)
; toolsrc/parse.pla: 0489:         elsif type & (WORD_TYPE | WPTR_TYPE)
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$54			; CALL	_C008
_F975 	!WORD	_C008		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$4E			; BRTRU	_B678
	!WORD	_B678-*
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$22			; ANDI	34
	!BYTE	$4C			; BRFLS	_B680
	!WORD	_B680-*
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$70			; CB	112
	!BYTE	$54			; CALL	_C059
_F976 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$50			; BRNCH	_B681
	!WORD	_B681-*
_B680 
; toolsrc/parse.pla: 0490:             valseq = gen_op(valseq, SW_CODE)
; toolsrc/parse.pla: 0491:         else
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$3C,$44			; ANDI	68
	!BYTE	$4C			; BRFLS	_B682
	!WORD	_B682-*
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$2A,$72			; CB	114
	!BYTE	$54			; CALL	_C059
_F977 	!WORD	_C059		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$50			; BRNCH	_B681
	!WORD	_B681-*
_B682 
; toolsrc/parse.pla: 0492:             release_seq(valseq)
; toolsrc/parse.pla: 0493:             return codeseq, 0 // Function or const cannot be LVALUE, must be RVALUE
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$54			; CALL	_C007
_F978 	!WORD	_C007		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$5A,$1A			; LEAVE	26
; toolsrc/parse.pla: 0494:         fin
_B681 
; toolsrc/parse.pla: 0495:         stackdepth--
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0496:     fin
	!BYTE	$74,$06			; SLB	[6]
_B678 
_B679 
; toolsrc/parse.pla: 0497:     return cat_seq(codeseq, valseq), stackdepth
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$54			; CALL	_C008
_F979 	!WORD	_C008		
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$5A,$1A			; LEAVE	26
; toolsrc/parse.pla: 0498: end
; toolsrc/parse.pla: 0499: def parse_subexpr(codeseq)#2
					; codeseq -> [0]
_C093 					; parse_subexpr()
; toolsrc/parse.pla: 0500:     byte stackdepth, matchdepth, stkdepth1, prevmatch, matchop, i
					; stackdepth -> [2]
					; matchdepth -> [3]
					; stkdepth1 -> [4]
					; prevmatch -> [5]
					; matchop -> [6]
					; i -> [7]
; toolsrc/parse.pla: 0501:     word optos
					; optos -> [8]
; toolsrc/parse.pla: 0502:     word tag_else, tag_endop
					; tag_else -> [10]
					; tag_endop -> [12]
; toolsrc/parse.pla: 0503: 
; toolsrc/parse.pla: 0504:     stackdepth = 0
	!BYTE	$58,$0E,$01		; ENTER	14,1
; toolsrc/parse.pla: 0505:     matchop    = 0
; toolsrc/parse.pla: 0506:     optos      = opsp
; toolsrc/parse.pla: 0507:     repeat
	!BYTE	$00			; CN	0
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$00			; CN	0
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$6A			; LAW	_D041+0
_F980 	!WORD	_D041+0		
	!BYTE	$76,$08			; SLW	[8]
_B684 
; toolsrc/parse.pla: 0508:         prevmatch = matchop
; toolsrc/parse.pla: 0509:         matchop   = 0
; toolsrc/parse.pla: 0510:         codeseq, matchdepth = parse_value(codeseq, RVALUE)
; toolsrc/parse.pla: 0511:         if matchdepth
; toolsrc/parse.pla: 0512:             stackdepth = stackdepth + matchdepth
; toolsrc/parse.pla: 0513:             matchop = 1
; toolsrc/parse.pla: 0514:             for i = 0 to bops_tblsz
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$00			; CN	0
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C092
_F981 	!WORD	_C092		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$4C			; BRFLS	_B686
	!WORD	_B686-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$B0,$03			; ADDLB	[3]
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$02			; CN	1
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$2A,$11			; CB	17
	!BYTE	$00			; CN	0
_B689 
	!BYTE	$6C,$07			; DLB	[7]
; toolsrc/parse.pla: 0515:                 if token == bops_tbl[i]
; toolsrc/parse.pla: 0516:                     matchop = 2
; toolsrc/parse.pla: 0517:                     if bops_prec[i] >= tos_op_prec(optos)
; toolsrc/parse.pla: 0518:                         codeseq = gen_bop(codeseq, pop_op)
; toolsrc/parse.pla: 0519:                         stackdepth--
	!BYTE	$68			; LAB	_D098+0
_F982 	!WORD	_D098+0		
	!BYTE	$26			; LA	_D037+0
_F983 	!WORD	_D037+0		
	!BYTE	$B0,$07			; ADDLB	[7]
	!BYTE	$60			; LB
	!BYTE	$24			; BRNE	_B691
	!WORD	_B691-*
	!BYTE	$04			; CN	2
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$26			; LA	_D038+0
_F984 	!WORD	_D038+0		
	!BYTE	$B0,$07			; ADDLB	[7]
	!BYTE	$60			; LB
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$54			; CALL	_C083
_F985 	!WORD	_C083		
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B693
	!WORD	_B693-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C081
_F986 	!WORD	_C081		
	!BYTE	$54			; CALL	_C067
_F987 	!WORD	_C067		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0520:                     fin
	!BYTE	$74,$02			; SLB	[2]
_B693 
_B694 
; toolsrc/parse.pla: 0521:                     push_op(token, bops_prec[i])
; toolsrc/parse.pla: 0522:                     break
	!BYTE	$68			; LAB	_D098+0
_F988 	!WORD	_D098+0		
	!BYTE	$26			; LA	_D038+0
_F989 	!WORD	_D038+0		
	!BYTE	$B0,$07			; ADDLB	[7]
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_C080
_F990 	!WORD	_C080		
	!BYTE	$50			; BRNCH	_B688
	!WORD	_B688-*
; toolsrc/parse.pla: 0523:                 fin
_B691 
_B692 
; toolsrc/parse.pla: 0524:             next
_B690 
	!BYTE	$A4			; INCBRLE	_B689
	!WORD	_B689-*
_B688 
	!BYTE	$74,$07			; SLB	[7]
	!BYTE	$30			; DROP 
; toolsrc/parse.pla: 0525:         fin
_B686 
_B687 
; toolsrc/parse.pla: 0526:     until matchop <> 2
_B685 
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$04			; CN	2
	!BYTE	$22			; BREQ	_B684
	!WORD	_B684-*
_B683 
; toolsrc/parse.pla: 0527:     if matchop == 0 and prevmatch == 2; exit_err(ERR_SYNTAX); fin
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$80			; NOT
	!BYTE	$AC			; BRAND	_B695
	!WORD	_B695-*
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$04			; CN	2
	!BYTE	$40			; ISEQ
_B695 
	!BYTE	$4C			; BRFLS	_B696
	!WORD	_B696-*
	!BYTE	$2C,$00,$80		; CW	32768
	!BYTE	$54			; CALL	_C002
_F991 	!WORD	_C002		
_B696 
_B697 
; toolsrc/parse.pla: 0528:     while optos < opsp
	!BYTE	$50			; BRNCH	_B700
	!WORD	_B700-*
_B698 
; toolsrc/parse.pla: 0529:         codeseq = gen_bop(codeseq, pop_op)
; toolsrc/parse.pla: 0530:         stackdepth--
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C081
_F992 	!WORD	_C081		
	!BYTE	$54			; CALL	_C067
_F993 	!WORD	_C067		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0531:     loop
	!BYTE	$74,$02			; SLB	[2]
_B700 
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$6A			; LAW	_D041+0
_F994 	!WORD	_D041+0		
	!BYTE	$46			; ISLT
	!BYTE	$4E			; BRTRU	_B698
	!WORD	_B698-*
_B699 
; toolsrc/parse.pla: 0532:     if token == LOGIC_AND_TKN
; toolsrc/parse.pla: 0533:         if stackdepth <> 1; exit_err(ERR_OVER|ERR_SYNTAX); fin
	!BYTE	$68			; LAB	_D098+0
_F995 	!WORD	_D098+0		
	!BYTE	$2A,$CE			; CB	206
	!BYTE	$24			; BRNE	_B701
	!WORD	_B701-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$02			; CN	1
	!BYTE	$22			; BREQ	_B703
	!WORD	_B703-*
	!BYTE	$2C,$10,$80		; CW	32784
	!BYTE	$54			; CALL	_C002
_F996 	!WORD	_C002		
_B703 
_B704 
; toolsrc/parse.pla: 0534:         tag_endop          = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0535:         codeseq            = gen_oprel(codeseq, BRAND_CODE, tag_endop)
; toolsrc/parse.pla: 0536:         codeseq, stkdepth1 = parse_subexpr(codeseq)
; toolsrc/parse.pla: 0537:         if stkdepth1 <> stackdepth; exit_err(ERR_INVAL|ERR_CODE); fin
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F997 	!WORD	_C004		
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$AC			; CB	172
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$54			; CALL	_C064
_F998 	!WORD	_C064		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$54			; CALL	_C093
_F999 	!WORD	_C093		
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$22			; BREQ	_B705
	!WORD	_B705-*
	!BYTE	$2C,$04,$01		; CW	260
	!BYTE	$54			; CALL	_C002
_F1000 	!WORD	_C002		
_B705 
_B706 
; toolsrc/parse.pla: 0538:         codeseq            = gen_ctag(codeseq, tag_endop)
; toolsrc/parse.pla: 0539:     elsif token == LOGIC_OR_TKN
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$54			; CALL	_C065
_F1001 	!WORD	_C065		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$50			; BRNCH	_B702
	!WORD	_B702-*
_B701 
; toolsrc/parse.pla: 0540:         if stackdepth <> 1; exit_err(ERR_OVER|ERR_SYNTAX); fin
	!BYTE	$68			; LAB	_D098+0
_F1002 	!WORD	_D098+0		
	!BYTE	$2A,$CF			; CB	207
	!BYTE	$24			; BRNE	_B707
	!WORD	_B707-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$02			; CN	1
	!BYTE	$22			; BREQ	_B708
	!WORD	_B708-*
	!BYTE	$2C,$10,$80		; CW	32784
	!BYTE	$54			; CALL	_C002
_F1003 	!WORD	_C002		
_B708 
_B709 
; toolsrc/parse.pla: 0541:         tag_endop          = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0542:         codeseq            = gen_oprel(codeseq, BROR_CODE, tag_endop)
; toolsrc/parse.pla: 0543:         codeseq, stkdepth1 = parse_subexpr(codeseq)
; toolsrc/parse.pla: 0544:         if stkdepth1 <> stackdepth; exit_err(ERR_INVAL|ERR_CODE); fin
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1004 	!WORD	_C004		
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$AE			; CB	174
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$54			; CALL	_C064
_F1005 	!WORD	_C064		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$54			; CALL	_C093
_F1006 	!WORD	_C093		
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$22			; BREQ	_B710
	!WORD	_B710-*
	!BYTE	$2C,$04,$01		; CW	260
	!BYTE	$54			; CALL	_C002
_F1007 	!WORD	_C002		
_B710 
_B711 
; toolsrc/parse.pla: 0545:         codeseq            = gen_ctag(codeseq, tag_endop)
; toolsrc/parse.pla: 0546:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$54			; CALL	_C065
_F1008 	!WORD	_C065		
	!BYTE	$76,$00			; SLW	[0]
_B707 
_B702 
; toolsrc/parse.pla: 0547:     return codeseq, stackdepth
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$0E			; LEAVE	14
; toolsrc/parse.pla: 0548: end
; toolsrc/parse.pla: 0549: def parse_expr(codeseq)#2
					; codeseq -> [0]
_P003 					; parse_expr(codeseq)#2()
_C094 					; parse_expr()
; toolsrc/parse.pla: 0550:     byte stackdepth, stkdepth1
					; stackdepth -> [2]
					; stkdepth1 -> [3]
; toolsrc/parse.pla: 0551:     word tag_else, tag_endop
					; tag_else -> [4]
					; tag_endop -> [6]
; toolsrc/parse.pla: 0552: 
; toolsrc/parse.pla: 0553:     codeseq, stackdepth = parse_subexpr(codeseq)
	!BYTE	$58,$08,$01		; ENTER	8,1
; toolsrc/parse.pla: 0554:     if token == TERNARY_TKN
; toolsrc/parse.pla: 0555:         if stackdepth <> 1; exit_err(ERR_OVER|ERR_SYNTAX); fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$54			; CALL	_C093
_F1009 	!WORD	_C093		
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$68			; LAB	_D098+0
_F1010 	!WORD	_D098+0		
	!BYTE	$2A,$BF			; CB	191
	!BYTE	$24			; BRNE	_B712
	!WORD	_B712-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$02			; CN	1
	!BYTE	$22			; BREQ	_B714
	!WORD	_B714-*
	!BYTE	$2C,$10,$80		; CW	32784
	!BYTE	$54			; CALL	_C002
_F1011 	!WORD	_C002		
_B714 
_B715 
; toolsrc/parse.pla: 0556:         tag_else            = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0557:         tag_endop           = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0558:         codeseq             = gen_oprel(codeseq, BRFALSE_CODE, tag_else)
; toolsrc/parse.pla: 0559:         codeseq, stkdepth1  = parse_expr(codeseq)
; toolsrc/parse.pla: 0560:         if token <> TRIELSE_TKN; exit_err(ERR_MISS|ERR_SYNTAX); fin
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1012 	!WORD	_C004		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1013 	!WORD	_C004		
	!BYTE	$76,$06			; SLW	[6]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$4C			; CB	76
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C064
_F1014 	!WORD	_C064		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$54			; CALL	_C094
_F1015 	!WORD	_C094		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$68			; LAB	_D098+0
_F1016 	!WORD	_D098+0		
	!BYTE	$2A,$DF			; CB	223
	!BYTE	$22			; BREQ	_B716
	!WORD	_B716-*
	!BYTE	$2C,$08,$80		; CW	32776
	!BYTE	$54			; CALL	_C002
_F1017 	!WORD	_C002		
_B716 
_B717 
; toolsrc/parse.pla: 0561:         codeseq             = gen_oprel(codeseq, BRNCH_CODE, tag_endop)
; toolsrc/parse.pla: 0562:         codeseq             = gen_ctag(codeseq, tag_else)
; toolsrc/parse.pla: 0563:         codeseq, stackdepth = parse_expr(codeseq)
; toolsrc/parse.pla: 0564:         if stkdepth1 <> stackdepth; exit_err(ERR_INVAL|ERR_CODE); fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$50			; CB	80
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C064
_F1018 	!WORD	_C064		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C065
_F1019 	!WORD	_C065		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$54			; CALL	_C094
_F1020 	!WORD	_C094		
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$22			; BREQ	_B718
	!WORD	_B718-*
	!BYTE	$2C,$04,$01		; CW	260
	!BYTE	$54			; CALL	_C002
_F1021 	!WORD	_C002		
_B718 
_B719 
; toolsrc/parse.pla: 0565:         codeseq             = gen_ctag(codeseq, tag_endop)
; toolsrc/parse.pla: 0566:     fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C065
_F1022 	!WORD	_C065		
	!BYTE	$76,$00			; SLW	[0]
_B712 
_B713 
; toolsrc/parse.pla: 0567:     return codeseq, stackdepth
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$5A,$08			; LEAVE	8
; toolsrc/parse.pla: 0568: end
; toolsrc/parse.pla: 0569: def parse_set(codeseq)
					; codeseq -> [0]
_C095 					; parse_set()
; toolsrc/parse.pla: 0570:     word setptr, rseq, setseq[16]
					; setptr -> [2]
					; rseq -> [4]
					; setseq -> [6]
; toolsrc/parse.pla: 0571:     byte lparms, rparms, i, lambda_set
					; lparms -> [38]
					; rparms -> [39]
					; i -> [40]
					; lambda_set -> [41]
; toolsrc/parse.pla: 0572: 
; toolsrc/parse.pla: 0573:     lparms     = 0
	!BYTE	$58,$2A,$01		; ENTER	42,1
; toolsrc/parse.pla: 0574:     rparms     = 0
; toolsrc/parse.pla: 0575:     lambda_set = lambda_cnt
; toolsrc/parse.pla: 0576:     setptr     = tknptr
; toolsrc/parse.pla: 0577:     repeat
	!BYTE	$00			; CN	0
	!BYTE	$74,$26			; SLB	[38]
	!BYTE	$00			; CN	0
	!BYTE	$74,$27			; SLB	[39]
	!BYTE	$68			; LAB	_D114+0
_F1023 	!WORD	_D114+0		
	!BYTE	$74,$29			; SLB	[41]
	!BYTE	$6A			; LAW	_D101+0
_F1024 	!WORD	_D101+0		
	!BYTE	$76,$02			; SLW	[2]
_B721 
; toolsrc/parse.pla: 0578:         setseq[lparms], drop = parse_value(NULL, LVALUE)
; toolsrc/parse.pla: 0579:         if not setseq[lparms]; break; fin
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C092
_F1025 	!WORD	_C092		
	!BYTE	$30			; DROP 
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$B8,$26			; IDXLB	[38]
	!BYTE	$72			; SW
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$B8,$26			; IDXLB	[38]
	!BYTE	$62			; LW
	!BYTE	$4E			; BRTRU	_B723
	!WORD	_B723-*
	!BYTE	$50			; BRNCH	_B720
	!WORD	_B720-*
_B723 
_B724 
; toolsrc/parse.pla: 0580:         lparms++
	!BYTE	$64,$26			; LLB	[38]
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 0581:     until token <> COMMA_TKN
	!BYTE	$74,$26			; SLB	[38]
_B722 
	!BYTE	$68			; LAB	_D098+0
_F1026 	!WORD	_D098+0		
	!BYTE	$2A,$AC			; CB	172
	!BYTE	$22			; BREQ	_B721
	!WORD	_B721-*
_B720 
; toolsrc/parse.pla: 0582:     if not lparms or token <> SET_TKN
; toolsrc/parse.pla: 0583:         //
; toolsrc/parse.pla: 0584:         // Not a set list - free everything up
; toolsrc/parse.pla: 0585:         //
; toolsrc/parse.pla: 0586:         rewind(setptr)
; toolsrc/parse.pla: 0587:         while lparms
	!BYTE	$64,$26			; LLB	[38]
	!BYTE	$80			; NOT
	!BYTE	$AE			; BROR	_B725
	!WORD	_B725-*
	!BYTE	$68			; LAB	_D098+0
_F1027 	!WORD	_D098+0		
	!BYTE	$2A,$BD			; CB	189
	!BYTE	$42			; ISNE
_B725 
	!BYTE	$4C			; BRFLS	_B726
	!WORD	_B726-*
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C077
_F1028 	!WORD	_C077		
	!BYTE	$50			; BRNCH	_B730
	!WORD	_B730-*
_B728 
; toolsrc/parse.pla: 0588:             lparms--
	!BYTE	$64,$26			; LLB	[38]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0589:             release_seq(setseq[lparms])
; toolsrc/parse.pla: 0590:         loop
	!BYTE	$74,$26			; SLB	[38]
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$B8,$26			; IDXLB	[38]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C007
_F1029 	!WORD	_C007		
_B730 
	!BYTE	$64,$26			; LLB	[38]
	!BYTE	$4E			; BRTRU	_B728
	!WORD	_B728-*
_B729 
; toolsrc/parse.pla: 0591:         while lambda_cnt > lambda_set
	!BYTE	$50			; BRNCH	_B733
	!WORD	_B733-*
_B731 
; toolsrc/parse.pla: 0592:             lambda_cnt--
	!BYTE	$68			; LAB	_D114+0
_F1030 	!WORD	_D114+0		
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0593:             lambda_num--
	!BYTE	$78			; SAB	_D114+0
_F1031 	!WORD	_D114+0		
	!BYTE	$68			; LAB	_D115+0
_F1032 	!WORD	_D115+0		
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0594:             release_seq(lambda_seq[lambda_cnt])
; toolsrc/parse.pla: 0595:         loop
	!BYTE	$78			; SAB	_D115+0
_F1033 	!WORD	_D115+0		
	!BYTE	$26			; LA	_D117+0
_F1034 	!WORD	_D117+0		
	!BYTE	$BC			; IDXAB	_D114+0
_F1035 	!WORD	_D114+0		
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C007
_F1036 	!WORD	_C007		
_B733 
	!BYTE	$68			; LAB	_D114+0
_F1037 	!WORD	_D114+0		
	!BYTE	$64,$29			; LLB	[41]
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B731
	!WORD	_B731-*
_B732 
; toolsrc/parse.pla: 0596:         return NULL
	!BYTE	$00			; CN	0
	!BYTE	$5A,$2A			; LEAVE	42
; toolsrc/parse.pla: 0597:     fin
_B726 
_B727 
; toolsrc/parse.pla: 0598:     rseq, rparms = parse_list
; toolsrc/parse.pla: 0599:     if lparms > rparms; exit_err(ERR_MISS|ERR_CODE|ERR_FRAME); fin
	!BYTE	$54			; CALL	_C091
_F1038 	!WORD	_C091		
	!BYTE	$74,$27			; SLB	[39]
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$64,$26			; LLB	[38]
	!BYTE	$64,$27			; LLB	[39]
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B734
	!WORD	_B734-*
	!BYTE	$2C,$08,$21		; CW	8456
	!BYTE	$54			; CALL	_C002
_F1039 	!WORD	_C002		
_B734 
_B735 
; toolsrc/parse.pla: 0600:     codeseq = cat_seq(codeseq, rseq)
; toolsrc/parse.pla: 0601:     if lparms < rparms
; toolsrc/parse.pla: 0602:         parse_warn("Silently dropping extra set values")
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C008
_F1040 	!WORD	_C008		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$64,$26			; LLB	[38]
	!BYTE	$64,$27			; LLB	[39]
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B736
	!WORD	_B736-*
	!BYTE	$2E			; CS
	!BYTE	$22
	!BYTE	$53,$69,$6C,$65,$6E,$74,$6C,$79
	!BYTE	$20,$64,$72,$6F,$70,$70,$69,$6E
	!BYTE	$67,$20,$65,$78,$74,$72,$61,$20
	!BYTE	$73,$65,$74,$20,$76,$61,$6C,$75
	!BYTE	$65,$73
	!BYTE	$54			; CALL	_C003
_F1041 	!WORD	_C003		
; toolsrc/parse.pla: 0603:         for i = rparms - lparms downto 1
	!BYTE	$02			; CN	1
	!BYTE	$64,$27			; LLB	[39]
	!BYTE	$64,$26			; LLB	[38]
	!BYTE	$84			; SUB 
	!BYTE	$A2			; BRLT	_B738
	!WORD	_B738-*
_B739 
	!BYTE	$6C,$28			; DLB	[40]
; toolsrc/parse.pla: 0604:             codeseq = gen_op(codeseq, DROP_CODE)
; toolsrc/parse.pla: 0605:         next
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C059
_F1042 	!WORD	_C059		
	!BYTE	$76,$00			; SLW	[0]
_B740 
	!BYTE	$A8			; DECBRGE	_B739
	!WORD	_B739-*
_B738 
	!BYTE	$74,$28			; SLB	[40]
	!BYTE	$30			; DROP 
; toolsrc/parse.pla: 0606:     fin
_B736 
_B737 
; toolsrc/parse.pla: 0607:     while lparms
	!BYTE	$50			; BRNCH	_B743
	!WORD	_B743-*
_B741 
; toolsrc/parse.pla: 0608:         lparms--
	!BYTE	$64,$26			; LLB	[38]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0609:         codeseq = cat_seq(codeseq, setseq[lparms])
; toolsrc/parse.pla: 0610:     loop
	!BYTE	$74,$26			; SLB	[38]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$B8,$26			; IDXLB	[38]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C008
_F1043 	!WORD	_C008		
	!BYTE	$76,$00			; SLW	[0]
_B743 
	!BYTE	$64,$26			; LLB	[38]
	!BYTE	$4E			; BRTRU	_B741
	!WORD	_B741-*
_B742 
; toolsrc/parse.pla: 0611:     return codeseq
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$2A			; LEAVE	42
; toolsrc/parse.pla: 0612: end
; toolsrc/parse.pla: 0613: def parse_stmnt
_C096 					; parse_stmnt()
; toolsrc/parse.pla: 0614:     byte type, elem_type, elem_size, cfnvals
					; type -> [0]
					; elem_type -> [1]
					; elem_size -> [2]
					; cfnvals -> [3]
; toolsrc/parse.pla: 0615:     word seq, fromseq, toseq, tag_prevbrk, tag_prevcnt, tag_else, tag_endif, tag_while, tag_wend
					; seq -> [4]
					; fromseq -> [6]
					; toseq -> [8]
					; tag_prevbrk -> [10]
					; tag_prevcnt -> [12]
					; tag_else -> [14]
					; tag_endif -> [16]
					; tag_while -> [18]
					; tag_wend -> [20]
; toolsrc/parse.pla: 0616:     word tag_repeat, tag_for, tag_choice, tag_of, idptr, addr, stepdir
					; tag_repeat -> [22]
					; tag_for -> [24]
					; tag_choice -> [26]
					; tag_of -> [28]
					; idptr -> [30]
					; addr -> [32]
					; stepdir -> [34]
; toolsrc/parse.pla: 0617:     word caseconst, casecnt, caseval, casetag, i
					; caseconst -> [36]
					; casecnt -> [38]
					; caseval -> [40]
					; casetag -> [42]
					; i -> [44]
; toolsrc/parse.pla: 0618: 
; toolsrc/parse.pla: 0619:     if token <> END_TKN and token <> DONE_TKN and token <> OF_TKN and token <> DEFAULT_TKN
	!BYTE	$58,$2E,$00		; ENTER	46,0
; toolsrc/parse.pla: 0620:         prevstmnt = token
; toolsrc/parse.pla: 0621:     fin
	!BYTE	$68			; LAB	_D098+0
_F1044 	!WORD	_D098+0		
	!BYTE	$2A,$87			; CB	135
	!BYTE	$42			; ISNE
	!BYTE	$AC			; BRAND	_B744
	!WORD	_B744-*
	!BYTE	$68			; LAB	_D098+0
_F1045 	!WORD	_D098+0		
	!BYTE	$2A,$98			; CB	152
	!BYTE	$42			; ISNE
	!BYTE	$AC			; BRAND	_B745
	!WORD	_B745-*
	!BYTE	$68			; LAB	_D098+0
_F1046 	!WORD	_D098+0		
	!BYTE	$2A,$8B			; CB	139
	!BYTE	$42			; ISNE
	!BYTE	$AC			; BRAND	_B746
	!WORD	_B746-*
	!BYTE	$68			; LAB	_D098+0
_F1047 	!WORD	_D098+0		
	!BYTE	$2A,$8C			; CB	140
	!BYTE	$42			; ISNE
_B746 
_B745 
_B744 
	!BYTE	$4C			; BRFLS	_B747
	!WORD	_B747-*
	!BYTE	$68			; LAB	_D098+0
_F1048 	!WORD	_D098+0		
	!BYTE	$78			; SAB	_D110+0
_F1049 	!WORD	_D110+0		
_B747 
_B748 
; toolsrc/parse.pla: 0622:     when token
	!BYTE	$68			; LAB	_D098+0
_F1050 	!WORD	_D098+0		
	!BYTE	$52			; SEL
	!WORD	_B750-*
; toolsrc/parse.pla: 0623:         is IF_TKN
_B751 
; toolsrc/parse.pla: 0624:             seq, cfnvals = parse_expr(NULL)
; toolsrc/parse.pla: 0625:             if !seq; exit_err(ERR_INVAL|ERR_STATE); fin
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C094
_F1051 	!WORD	_C094		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4E			; BRTRU	_B752
	!WORD	_B752-*
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1052 	!WORD	_C002		
_B752 
_B753 
; toolsrc/parse.pla: 0626:             if cfnvals > 1
; toolsrc/parse.pla: 0627:                 parse_warn("Expression value overflow")
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B754
	!WORD	_B754-*
	!BYTE	$2E			; CS
	!BYTE	$19
	!BYTE	$45,$78,$70,$72,$65,$73,$73,$69
	!BYTE	$6F,$6E,$20,$76,$61,$6C,$75,$65
	!BYTE	$20,$6F,$76,$65,$72,$66,$6C,$6F
	!BYTE	$77
	!BYTE	$54			; CALL	_C003
_F1053 	!WORD	_C003		
; toolsrc/parse.pla: 0628:                 while cfnvals > 1; cfnvals--; seq = gen_op(seq, DROP_CODE); loop
	!BYTE	$50			; BRNCH	_B758
	!WORD	_B758-*
_B756 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$8E			; DECR
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C059
_F1054 	!WORD	_C059		
	!BYTE	$76,$04			; SLW	[4]
_B758 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B756
	!WORD	_B756-*
_B757 
; toolsrc/parse.pla: 0629:             fin
_B754 
_B755 
; toolsrc/parse.pla: 0630:             tag_else  = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0631:             tag_endif = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0632:             seq = gen_oprel(seq, BRFALSE_CODE, tag_else)
; toolsrc/parse.pla: 0633:             emit_seq(seq)
; toolsrc/parse.pla: 0634:             repeat
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1055 	!WORD	_C004		
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1056 	!WORD	_C004		
	!BYTE	$76,$10			; SLW	[16]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$4C			; CB	76
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$54			; CALL	_C064
_F1057 	!WORD	_C064		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$54			; CALL	_C041
_F1058 	!WORD	_C041		
_B760 
; toolsrc/parse.pla: 0635:                 while parse_stmnt
	!BYTE	$50			; BRNCH	_B764
	!WORD	_B764-*
_B762 
; toolsrc/parse.pla: 0636:                     nextln
; toolsrc/parse.pla: 0637:                 loop
	!BYTE	$54			; CALL	_C079
_F1059 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B764 
	!BYTE	$54			; CALL	_C096
_F1060 	!WORD	_C096		
	!BYTE	$4E			; BRTRU	_B762
	!WORD	_B762-*
_B763 
; toolsrc/parse.pla: 0638:                 if token <> ELSEIF_TKN
; toolsrc/parse.pla: 0639:                     break
	!BYTE	$68			; LAB	_D098+0
_F1061 	!WORD	_D098+0		
	!BYTE	$2A,$84			; CB	132
	!BYTE	$22			; BREQ	_B765
	!WORD	_B765-*
	!BYTE	$50			; BRNCH	_B759
	!WORD	_B759-*
; toolsrc/parse.pla: 0640:                 fin
_B765 
_B766 
; toolsrc/parse.pla: 0641:                 emit_branch(tag_endif)
; toolsrc/parse.pla: 0642:                 emit_tag(tag_else)
; toolsrc/parse.pla: 0643:                 seq, cfnvals = parse_expr(NULL)
; toolsrc/parse.pla: 0644:                 if !seq; exit_err(ERR_INVAL|ERR_STATE); fin
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$54			; CALL	_C028
_F1062 	!WORD	_C028		
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$54			; CALL	_C039
_F1063 	!WORD	_C039		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C094
_F1064 	!WORD	_C094		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4E			; BRTRU	_B767
	!WORD	_B767-*
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1065 	!WORD	_C002		
_B767 
_B768 
; toolsrc/parse.pla: 0645:                 if cfnvals > 1
; toolsrc/parse.pla: 0646:                     parse_warn("Expression value overflow")
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B769
	!WORD	_B769-*
	!BYTE	$2E			; CS
	!BYTE	$19
	!BYTE	$45,$78,$70,$72,$65,$73,$73,$69
	!BYTE	$6F,$6E,$20,$76,$61,$6C,$75,$65
	!BYTE	$20,$6F,$76,$65,$72,$66,$6C,$6F
	!BYTE	$77
	!BYTE	$54			; CALL	_C003
_F1066 	!WORD	_C003		
; toolsrc/parse.pla: 0647:                     while cfnvals > 1; cfnvals--; seq = gen_op(seq, DROP_CODE); loop
	!BYTE	$50			; BRNCH	_B773
	!WORD	_B773-*
_B771 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$8E			; DECR
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C059
_F1067 	!WORD	_C059		
	!BYTE	$76,$04			; SLW	[4]
_B773 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B771
	!WORD	_B771-*
_B772 
; toolsrc/parse.pla: 0648:                 fin
_B769 
_B770 
; toolsrc/parse.pla: 0649:                 tag_else = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0650:                 seq = gen_oprel(seq, BRFALSE_CODE, tag_else)
; toolsrc/parse.pla: 0651:                 emit_seq(seq)
; toolsrc/parse.pla: 0652:             until FALSE
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1068 	!WORD	_C004		
	!BYTE	$76,$0E			; SLW	[14]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$4C			; CB	76
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$54			; CALL	_C064
_F1069 	!WORD	_C064		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$54			; CALL	_C041
_F1070 	!WORD	_C041		
_B761 
	!BYTE	$50			; BRNCH	_B760
	!WORD	_B760-*
_B759 
; toolsrc/parse.pla: 0653:             if token == ELSE_TKN
; toolsrc/parse.pla: 0654:                 emit_branch(tag_endif)
; toolsrc/parse.pla: 0655:                 emit_tag(tag_else)
; toolsrc/parse.pla: 0656:                 scan
; toolsrc/parse.pla: 0657:                 while parse_stmnt
	!BYTE	$68			; LAB	_D098+0
_F1071 	!WORD	_D098+0		
	!BYTE	$2A,$85			; CB	133
	!BYTE	$24			; BRNE	_B774
	!WORD	_B774-*
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$54			; CALL	_C028
_F1072 	!WORD	_C028		
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$54			; CALL	_C039
_F1073 	!WORD	_C039		
	!BYTE	$54			; CALL	_C076
_F1074 	!WORD	_C076		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B778
	!WORD	_B778-*
_B776 
; toolsrc/parse.pla: 0658:                     nextln
; toolsrc/parse.pla: 0659:                 loop
	!BYTE	$54			; CALL	_C079
_F1075 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B778 
	!BYTE	$54			; CALL	_C096
_F1076 	!WORD	_C096		
	!BYTE	$4E			; BRTRU	_B776
	!WORD	_B776-*
_B777 
; toolsrc/parse.pla: 0660:                 emit_tag(tag_endif)
; toolsrc/parse.pla: 0661:             else
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$54			; CALL	_C039
_F1077 	!WORD	_C039		
	!BYTE	$50			; BRNCH	_B775
	!WORD	_B775-*
_B774 
; toolsrc/parse.pla: 0662:                 emit_tag(tag_else)
; toolsrc/parse.pla: 0663:                 emit_tag(tag_endif)
; toolsrc/parse.pla: 0664:             fin
	!BYTE	$66,$0E			; LLW	[14]
	!BYTE	$54			; CALL	_C039
_F1078 	!WORD	_C039		
	!BYTE	$66,$10			; LLW	[16]
	!BYTE	$54			; CALL	_C039
_F1079 	!WORD	_C039		
_B775 
; toolsrc/parse.pla: 0665:             if token <> FIN_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_STATE); fin
	!BYTE	$68			; LAB	_D098+0
_F1080 	!WORD	_D098+0		
	!BYTE	$2A,$86			; CB	134
	!BYTE	$22			; BREQ	_B779
	!WORD	_B779-*
	!BYTE	$2C,$28,$10		; CW	4136
	!BYTE	$54			; CALL	_C002
_F1081 	!WORD	_C002		
_B779 
_B780 
; toolsrc/parse.pla: 0666:             break
	!BYTE	$50			; BRNCH	_B749
	!WORD	_B749-*
; toolsrc/parse.pla: 0667:         is WHILE_TKN
_B781 
; toolsrc/parse.pla: 0668:             tag_while   = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0669:             tag_wend    = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0670:             tag_prevcnt = cont_tag
; toolsrc/parse.pla: 0671:             cont_tag    = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0672:             tag_prevbrk = break_tag
; toolsrc/parse.pla: 0673:             break_tag   = tag_wend
; toolsrc/parse.pla: 0674:             emit_branch(cont_tag)
; toolsrc/parse.pla: 0675:             emit_tag(tag_while)
; toolsrc/parse.pla: 0676:             seq, cfnvals = parse_expr(NULL)
; toolsrc/parse.pla: 0677:             if !seq; exit_err(ERR_INVAL|ERR_STATE); fin
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1082 	!WORD	_C004		
	!BYTE	$76,$12			; SLW	[18]
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1083 	!WORD	_C004		
	!BYTE	$76,$14			; SLW	[20]
	!BYTE	$6A			; LAW	_D113+0
_F1084 	!WORD	_D113+0		
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1085 	!WORD	_C004		
	!BYTE	$7A			; SAW	_D113+0
_F1086 	!WORD	_D113+0		
	!BYTE	$6A			; LAW	_D112+0
_F1087 	!WORD	_D112+0		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$7A			; SAW	_D112+0
_F1088 	!WORD	_D112+0		
	!BYTE	$6A			; LAW	_D113+0
_F1089 	!WORD	_D113+0		
	!BYTE	$54			; CALL	_C028
_F1090 	!WORD	_C028		
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$54			; CALL	_C039
_F1091 	!WORD	_C039		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C094
_F1092 	!WORD	_C094		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4E			; BRTRU	_B782
	!WORD	_B782-*
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1093 	!WORD	_C002		
_B782 
_B783 
; toolsrc/parse.pla: 0678:             if cfnvals > 1
; toolsrc/parse.pla: 0679:                 parse_warn("Expression value overflow")
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B784
	!WORD	_B784-*
	!BYTE	$2E			; CS
	!BYTE	$19
	!BYTE	$45,$78,$70,$72,$65,$73,$73,$69
	!BYTE	$6F,$6E,$20,$76,$61,$6C,$75,$65
	!BYTE	$20,$6F,$76,$65,$72,$66,$6C,$6F
	!BYTE	$77
	!BYTE	$54			; CALL	_C003
_F1094 	!WORD	_C003		
; toolsrc/parse.pla: 0680:                 while cfnvals > 1;cfnvals--; seq = gen_op(seq, DROP_CODE); loop
	!BYTE	$50			; BRNCH	_B788
	!WORD	_B788-*
_B786 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$8E			; DECR
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C059
_F1095 	!WORD	_C059		
	!BYTE	$76,$04			; SLW	[4]
_B788 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B786
	!WORD	_B786-*
_B787 
; toolsrc/parse.pla: 0681:             fin
_B784 
_B785 
; toolsrc/parse.pla: 0682:             seq = gen_oprel(seq, BRTRUE_CODE, tag_while)
; toolsrc/parse.pla: 0683:             while parse_stmnt
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$4E			; CB	78
	!BYTE	$66,$12			; LLW	[18]
	!BYTE	$54			; CALL	_C064
_F1096 	!WORD	_C064		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$50			; BRNCH	_B791
	!WORD	_B791-*
_B789 
; toolsrc/parse.pla: 0684:                 nextln
; toolsrc/parse.pla: 0685:             loop
	!BYTE	$54			; CALL	_C079
_F1097 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B791 
	!BYTE	$54			; CALL	_C096
_F1098 	!WORD	_C096		
	!BYTE	$4E			; BRTRU	_B789
	!WORD	_B789-*
_B790 
; toolsrc/parse.pla: 0686:             if token <> LOOP_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_STATE); fin
	!BYTE	$68			; LAB	_D098+0
_F1099 	!WORD	_D098+0		
	!BYTE	$2A,$89			; CB	137
	!BYTE	$22			; BREQ	_B792
	!WORD	_B792-*
	!BYTE	$2C,$28,$10		; CW	4136
	!BYTE	$54			; CALL	_C002
_F1100 	!WORD	_C002		
_B792 
_B793 
; toolsrc/parse.pla: 0687:             emit_tag(cont_tag)
; toolsrc/parse.pla: 0688:             emit_seq(seq)
; toolsrc/parse.pla: 0689:             emit_tag(tag_wend)
; toolsrc/parse.pla: 0690:             break_tag = tag_prevbrk
; toolsrc/parse.pla: 0691:             cont_tag  = tag_prevcnt
; toolsrc/parse.pla: 0692:             break
	!BYTE	$6A			; LAW	_D113+0
_F1101 	!WORD	_D113+0		
	!BYTE	$54			; CALL	_C039
_F1102 	!WORD	_C039		
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C041
_F1103 	!WORD	_C041		
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$54			; CALL	_C039
_F1104 	!WORD	_C039		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$7A			; SAW	_D112+0
_F1105 	!WORD	_D112+0		
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$7A			; SAW	_D113+0
_F1106 	!WORD	_D113+0		
	!BYTE	$50			; BRNCH	_B749
	!WORD	_B749-*
; toolsrc/parse.pla: 0693:         is REPEAT_TKN
_B794 
; toolsrc/parse.pla: 0694:             tag_repeat  = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0695:             tag_prevbrk = break_tag
; toolsrc/parse.pla: 0696:             break_tag   = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0697:             tag_prevcnt = cont_tag
; toolsrc/parse.pla: 0698:             cont_tag    = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0699:             emit_tag(tag_repeat)
; toolsrc/parse.pla: 0700:             scan
; toolsrc/parse.pla: 0701:             while parse_stmnt
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1107 	!WORD	_C004		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$6A			; LAW	_D112+0
_F1108 	!WORD	_D112+0		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1109 	!WORD	_C004		
	!BYTE	$7A			; SAW	_D112+0
_F1110 	!WORD	_D112+0		
	!BYTE	$6A			; LAW	_D113+0
_F1111 	!WORD	_D113+0		
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1112 	!WORD	_C004		
	!BYTE	$7A			; SAW	_D113+0
_F1113 	!WORD	_D113+0		
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$54			; CALL	_C039
_F1114 	!WORD	_C039		
	!BYTE	$54			; CALL	_C076
_F1115 	!WORD	_C076		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B797
	!WORD	_B797-*
_B795 
; toolsrc/parse.pla: 0702:                 nextln
; toolsrc/parse.pla: 0703:             loop
	!BYTE	$54			; CALL	_C079
_F1116 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B797 
	!BYTE	$54			; CALL	_C096
_F1117 	!WORD	_C096		
	!BYTE	$4E			; BRTRU	_B795
	!WORD	_B795-*
_B796 
; toolsrc/parse.pla: 0704:             if token <> UNTIL_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_STATE); fin
	!BYTE	$68			; LAB	_D098+0
_F1118 	!WORD	_D098+0		
	!BYTE	$2A,$94			; CB	148
	!BYTE	$22			; BREQ	_B798
	!WORD	_B798-*
	!BYTE	$2C,$28,$10		; CW	4136
	!BYTE	$54			; CALL	_C002
_F1119 	!WORD	_C002		
_B798 
_B799 
; toolsrc/parse.pla: 0705:             emit_tag(cont_tag)
; toolsrc/parse.pla: 0706:             cont_tag = tag_prevcnt
; toolsrc/parse.pla: 0707:             seq, cfnvals = parse_expr(NULL)
; toolsrc/parse.pla: 0708:             if !seq; exit_err(ERR_INVAL|ERR_STATE); fin
	!BYTE	$6A			; LAW	_D113+0
_F1120 	!WORD	_D113+0		
	!BYTE	$54			; CALL	_C039
_F1121 	!WORD	_C039		
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$7A			; SAW	_D113+0
_F1122 	!WORD	_D113+0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C094
_F1123 	!WORD	_C094		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4E			; BRTRU	_B800
	!WORD	_B800-*
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1124 	!WORD	_C002		
_B800 
_B801 
; toolsrc/parse.pla: 0709:             if cfnvals > 1
; toolsrc/parse.pla: 0710:                 parse_warn("Expression value overflow")
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B802
	!WORD	_B802-*
	!BYTE	$2E			; CS
	!BYTE	$19
	!BYTE	$45,$78,$70,$72,$65,$73,$73,$69
	!BYTE	$6F,$6E,$20,$76,$61,$6C,$75,$65
	!BYTE	$20,$6F,$76,$65,$72,$66,$6C,$6F
	!BYTE	$77
	!BYTE	$54			; CALL	_C003
_F1125 	!WORD	_C003		
; toolsrc/parse.pla: 0711:                 while cfnvals > 1; cfnvals--; seq = gen_op(seq, DROP_CODE); loop
	!BYTE	$50			; BRNCH	_B806
	!WORD	_B806-*
_B804 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$8E			; DECR
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C059
_F1126 	!WORD	_C059		
	!BYTE	$76,$04			; SLW	[4]
_B806 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B804
	!WORD	_B804-*
_B805 
; toolsrc/parse.pla: 0712:             fin
_B802 
_B803 
; toolsrc/parse.pla: 0713:             seq = gen_oprel(seq, BRFALSE_CODE, tag_repeat)
; toolsrc/parse.pla: 0714:             emit_seq(seq)
; toolsrc/parse.pla: 0715:             emit_tag(break_tag)
; toolsrc/parse.pla: 0716:             break_tag = tag_prevbrk
; toolsrc/parse.pla: 0717:             break
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$4C			; CB	76
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$54			; CALL	_C064
_F1127 	!WORD	_C064		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$54			; CALL	_C041
_F1128 	!WORD	_C041		
	!BYTE	$6A			; LAW	_D112+0
_F1129 	!WORD	_D112+0		
	!BYTE	$54			; CALL	_C039
_F1130 	!WORD	_C039		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$7A			; SAW	_D112+0
_F1131 	!WORD	_D112+0		
	!BYTE	$50			; BRNCH	_B749
	!WORD	_B749-*
; toolsrc/parse.pla: 0718:         is FOR_TKN
_B807 
; toolsrc/parse.pla: 0719:             stack_loop  = stack_loop + 2
; toolsrc/parse.pla: 0720:             tag_for     = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0721:             tag_prevcnt = cont_tag
; toolsrc/parse.pla: 0722:             cont_tag    = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0723:             tag_prevbrk = break_tag
; toolsrc/parse.pla: 0724:             break_tag   = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0725:             if scan <> ID_TKN; exit_err(ERR_MISS|ERR_ID); fin
	!BYTE	$68			; LAB	_D109+0
_F1132 	!WORD	_D109+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$78			; SAB	_D109+0
_F1133 	!WORD	_D109+0		
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1134 	!WORD	_C004		
	!BYTE	$76,$18			; SLW	[24]
	!BYTE	$6A			; LAW	_D113+0
_F1135 	!WORD	_D113+0		
	!BYTE	$76,$0C			; SLW	[12]
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1136 	!WORD	_C004		
	!BYTE	$7A			; SAW	_D113+0
_F1137 	!WORD	_D113+0		
	!BYTE	$6A			; LAW	_D112+0
_F1138 	!WORD	_D112+0		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1139 	!WORD	_C004		
	!BYTE	$7A			; SAW	_D112+0
_F1140 	!WORD	_D112+0		
	!BYTE	$54			; CALL	_C076
_F1141 	!WORD	_C076		
	!BYTE	$2A,$D6			; CB	214
	!BYTE	$22			; BREQ	_B808
	!WORD	_B808-*
	!BYTE	$2C,$08,$02		; CW	520
	!BYTE	$54			; CALL	_C002
_F1142 	!WORD	_C002		
_B808 
_B809 
; toolsrc/parse.pla: 0726:             idptr = lookup_id(tknptr, tknlen)
; toolsrc/parse.pla: 0727:             if idptr
; toolsrc/parse.pla: 0728:                 type  = idptr=>idtype
; toolsrc/parse.pla: 0729:                 addr  = idptr=>idval
; toolsrc/parse.pla: 0730:             else
	!BYTE	$6A			; LAW	_D101+0
_F1143 	!WORD	_D101+0		
	!BYTE	$68			; LAB	_D100+0
_F1144 	!WORD	_D100+0		
	!BYTE	$54			; CALL	_C044
_F1145 	!WORD	_C044		
	!BYTE	$6E,$1E			; DLW	[30]
	!BYTE	$4C			; BRFLS	_B810
	!WORD	_B810-*
	!BYTE	$66,$1E			; LLW	[30]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$66,$1E			; LLW	[30]
	!BYTE	$62			; LW
	!BYTE	$76,$20			; SLW	[32]
	!BYTE	$50			; BRNCH	_B811
	!WORD	_B811-*
_B810 
; toolsrc/parse.pla: 0731:                 exit_err(ERR_INVAL|ERR_ID)
; toolsrc/parse.pla: 0732:             fin
	!BYTE	$2C,$04,$02		; CW	516
	!BYTE	$54			; CALL	_C002
_F1146 	!WORD	_C002		
_B811 
; toolsrc/parse.pla: 0733:             if scan <> SET_TKN; exit_err(ERR_INVAL|ERR_STATE); fin
	!BYTE	$54			; CALL	_C076
_F1147 	!WORD	_C076		
	!BYTE	$2A,$BD			; CB	189
	!BYTE	$22			; BREQ	_B812
	!WORD	_B812-*
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1148 	!WORD	_C002		
_B812 
_B813 
; toolsrc/parse.pla: 0734:             fromseq, cfnvals = parse_expr(NULL)
; toolsrc/parse.pla: 0735:             if !fromseq; exit_err(ERR_INVAL|ERR_STATE); fin
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C094
_F1149 	!WORD	_C094		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$6E,$06			; DLW	[6]
	!BYTE	$4E			; BRTRU	_B814
	!WORD	_B814-*
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1150 	!WORD	_C002		
_B814 
_B815 
; toolsrc/parse.pla: 0736:             if cfnvals > 1
; toolsrc/parse.pla: 0737:                 parse_warn("Expression value overflow")
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B816
	!WORD	_B816-*
	!BYTE	$2E			; CS
	!BYTE	$19
	!BYTE	$45,$78,$70,$72,$65,$73,$73,$69
	!BYTE	$6F,$6E,$20,$76,$61,$6C,$75,$65
	!BYTE	$20,$6F,$76,$65,$72,$66,$6C,$6F
	!BYTE	$77
	!BYTE	$54			; CALL	_C003
_F1151 	!WORD	_C003		
; toolsrc/parse.pla: 0738:                 while cfnvals > 1;cfnvals--; seq = gen_op(seq, DROP_CODE); loop
	!BYTE	$50			; BRNCH	_B820
	!WORD	_B820-*
_B818 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$8E			; DECR
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C059
_F1152 	!WORD	_C059		
	!BYTE	$76,$04			; SLW	[4]
_B820 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B818
	!WORD	_B818-*
_B819 
; toolsrc/parse.pla: 0739:             fin
_B816 
_B817 
; toolsrc/parse.pla: 0740:             if token == TO_TKN
; toolsrc/parse.pla: 0741:                 stepdir = 1
; toolsrc/parse.pla: 0742:             elsif token == DOWNTO_TKN
	!BYTE	$68			; LAB	_D098+0
_F1153 	!WORD	_D098+0		
	!BYTE	$2A,$8F			; CB	143
	!BYTE	$24			; BRNE	_B821
	!WORD	_B821-*
	!BYTE	$02			; CN	1
	!BYTE	$76,$22			; SLW	[34]
	!BYTE	$50			; BRNCH	_B822
	!WORD	_B822-*
_B821 
; toolsrc/parse.pla: 0743:                 stepdir = -1
; toolsrc/parse.pla: 0744:             else
	!BYTE	$68			; LAB	_D098+0
_F1154 	!WORD	_D098+0		
	!BYTE	$2A,$90			; CB	144
	!BYTE	$24			; BRNE	_B823
	!WORD	_B823-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$76,$22			; SLW	[34]
	!BYTE	$50			; BRNCH	_B822
	!WORD	_B822-*
_B823 
; toolsrc/parse.pla: 0745:                 exit_err(ERR_INVAL|ERR_STATE)
; toolsrc/parse.pla: 0746:             fin
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1155 	!WORD	_C002		
_B822 
; toolsrc/parse.pla: 0747:             toseq, cfnvals = parse_expr(NULL)
; toolsrc/parse.pla: 0748:             if !toseq; exit_err(ERR_INVAL|ERR_STATE); fin
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C094
_F1156 	!WORD	_C094		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$6E,$08			; DLW	[8]
	!BYTE	$4E			; BRTRU	_B824
	!WORD	_B824-*
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1157 	!WORD	_C002		
_B824 
_B825 
; toolsrc/parse.pla: 0749:             if cfnvals > 1
; toolsrc/parse.pla: 0750:                 parse_warn("Expression value overflow")
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B826
	!WORD	_B826-*
	!BYTE	$2E			; CS
	!BYTE	$19
	!BYTE	$45,$78,$70,$72,$65,$73,$73,$69
	!BYTE	$6F,$6E,$20,$76,$61,$6C,$75,$65
	!BYTE	$20,$6F,$76,$65,$72,$66,$6C,$6F
	!BYTE	$77
	!BYTE	$54			; CALL	_C003
_F1158 	!WORD	_C003		
; toolsrc/parse.pla: 0751:                 while cfnvals > 1;cfnvals--; seq = gen_op(seq, DROP_CODE); loop
	!BYTE	$50			; BRNCH	_B830
	!WORD	_B830-*
_B828 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$8E			; DECR
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C059
_F1159 	!WORD	_C059		
	!BYTE	$76,$04			; SLW	[4]
_B830 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B828
	!WORD	_B828-*
_B829 
; toolsrc/parse.pla: 0752:             fin
_B826 
_B827 
; toolsrc/parse.pla: 0753:             if token == STEP_TKN
; toolsrc/parse.pla: 0754:                 seq, cfnvals = parse_expr(NULL)
; toolsrc/parse.pla: 0755:                 if !seq; exit_err(ERR_INVAL|ERR_STATE); fin
	!BYTE	$68			; LAB	_D098+0
_F1160 	!WORD	_D098+0		
	!BYTE	$2A,$91			; CB	145
	!BYTE	$24			; BRNE	_B831
	!WORD	_B831-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C094
_F1161 	!WORD	_C094		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4E			; BRTRU	_B833
	!WORD	_B833-*
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1162 	!WORD	_C002		
_B833 
_B834 
; toolsrc/parse.pla: 0756:                 if cfnvals > 1
; toolsrc/parse.pla: 0757:                     parse_warn("Expression value overflow")
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B835
	!WORD	_B835-*
	!BYTE	$2E			; CS
	!BYTE	$19
	!BYTE	$45,$78,$70,$72,$65,$73,$73,$69
	!BYTE	$6F,$6E,$20,$76,$61,$6C,$75,$65
	!BYTE	$20,$6F,$76,$65,$72,$66,$6C,$6F
	!BYTE	$77
	!BYTE	$54			; CALL	_C003
_F1163 	!WORD	_C003		
; toolsrc/parse.pla: 0758:                     while cfnvals > 1;cfnvals--; seq = gen_op(seq, DROP_CODE); loop
	!BYTE	$50			; BRNCH	_B839
	!WORD	_B839-*
_B837 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$8E			; DECR
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C059
_F1164 	!WORD	_C059		
	!BYTE	$76,$04			; SLW	[4]
_B839 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B837
	!WORD	_B837-*
_B838 
; toolsrc/parse.pla: 0759:                 fin
_B835 
_B836 
; toolsrc/parse.pla: 0760:             else
	!BYTE	$50			; BRNCH	_B832
	!WORD	_B832-*
_B831 
; toolsrc/parse.pla: 0761:                 seq = NULL
; toolsrc/parse.pla: 0762:             fin
	!BYTE	$00			; CN	0
	!BYTE	$76,$04			; SLW	[4]
_B832 
; toolsrc/parse.pla: 0763:             emit_seq(gen_oprel(cat_seq(toseq, fromseq), stepdir > 0 ?? BRGT_CODE :: BRLT_CODE, break_tag))
; toolsrc/parse.pla: 0764:             emit_tag(tag_for)
; toolsrc/parse.pla: 0765:             if type & LOCAL_TYPE
; toolsrc/parse.pla: 0766:                 if type & BYTE_TYPE; emit_dlb(addr); else; emit_dlw(addr); fin
	!BYTE	$66,$08			; LLW	[8]
	!BYTE	$66,$06			; LLW	[6]
	!BYTE	$54			; CALL	_C008
_F1165 	!WORD	_C008		
	!BYTE	$66,$22			; LLW	[34]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B842
	!WORD	_B842-*
	!BYTE	$2A,$A0			; CB	160
	!BYTE	$50			; BRNCH	_B843
	!WORD	_B843-*
_B842 
	!BYTE	$2A,$A2			; CB	162
_B843 
	!BYTE	$6A			; LAW	_D112+0
_F1166 	!WORD	_D112+0		
	!BYTE	$54			; CALL	_C064
_F1167 	!WORD	_C064		
	!BYTE	$54			; CALL	_C041
_F1168 	!WORD	_C041		
	!BYTE	$66,$18			; LLW	[24]
	!BYTE	$54			; CALL	_C039
_F1169 	!WORD	_C039		
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B844
	!WORD	_B844-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B846
	!WORD	_B846-*
	!BYTE	$66,$20			; LLW	[32]
	!BYTE	$54			; CALL	_C022
_F1170 	!WORD	_C022		
	!BYTE	$50			; BRNCH	_B847
	!WORD	_B847-*
_B846 
	!BYTE	$66,$20			; LLW	[32]
	!BYTE	$54			; CALL	_C023
_F1171 	!WORD	_C023		
_B847 
; toolsrc/parse.pla: 0767:             else
	!BYTE	$50			; BRNCH	_B845
	!WORD	_B845-*
_B844 
; toolsrc/parse.pla: 0768:                 if type & BYTE_TYPE; emit_dab(addr, 0); else; emit_daw(addr, 0); fin
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B848
	!WORD	_B848-*
	!BYTE	$66,$20			; LLW	[32]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C024
_F1172 	!WORD	_C024		
	!BYTE	$50			; BRNCH	_B849
	!WORD	_B849-*
_B848 
	!BYTE	$66,$20			; LLW	[32]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C025
_F1173 	!WORD	_C025		
_B849 
; toolsrc/parse.pla: 0769:             fin
_B845 
; toolsrc/parse.pla: 0770:             while parse_stmnt
	!BYTE	$50			; BRNCH	_B852
	!WORD	_B852-*
_B850 
; toolsrc/parse.pla: 0771:                 nextln
; toolsrc/parse.pla: 0772:             loop
	!BYTE	$54			; CALL	_C079
_F1174 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B852 
	!BYTE	$54			; CALL	_C096
_F1175 	!WORD	_C096		
	!BYTE	$4E			; BRTRU	_B850
	!WORD	_B850-*
_B851 
; toolsrc/parse.pla: 0773:             if token <> NEXT_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_STATE); fin
	!BYTE	$68			; LAB	_D098+0
_F1176 	!WORD	_D098+0		
	!BYTE	$2A,$92			; CB	146
	!BYTE	$22			; BREQ	_B853
	!WORD	_B853-*
	!BYTE	$2C,$28,$10		; CW	4136
	!BYTE	$54			; CALL	_C002
_F1177 	!WORD	_C002		
_B853 
_B854 
; toolsrc/parse.pla: 0774:             emit_tag(cont_tag)
; toolsrc/parse.pla: 0775:             cont_tag = tag_prevcnt
; toolsrc/parse.pla: 0776:             if stepdir > 0
; toolsrc/parse.pla: 0777:                 if seq
; toolsrc/parse.pla: 0778:                     emit_seq(seq)
; toolsrc/parse.pla: 0779:                     emit_addbrle(tag_for)
; toolsrc/parse.pla: 0780:                 else
	!BYTE	$6A			; LAW	_D113+0
_F1178 	!WORD	_D113+0		
	!BYTE	$54			; CALL	_C039
_F1179 	!WORD	_C039		
	!BYTE	$66,$0C			; LLW	[12]
	!BYTE	$7A			; SAW	_D113+0
_F1180 	!WORD	_D113+0		
	!BYTE	$66,$22			; LLW	[34]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B855
	!WORD	_B855-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$4C			; BRFLS	_B857
	!WORD	_B857-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C041
_F1181 	!WORD	_C041		
	!BYTE	$66,$18			; LLW	[24]
	!BYTE	$54			; CALL	_C032
_F1182 	!WORD	_C032		
	!BYTE	$50			; BRNCH	_B858
	!WORD	_B858-*
_B857 
; toolsrc/parse.pla: 0781:                     emit_incbrle(tag_for)
; toolsrc/parse.pla: 0782:                 fin
	!BYTE	$66,$18			; LLW	[24]
	!BYTE	$54			; CALL	_C031
_F1183 	!WORD	_C031		
_B858 
; toolsrc/parse.pla: 0783:             else
	!BYTE	$50			; BRNCH	_B856
	!WORD	_B856-*
_B855 
; toolsrc/parse.pla: 0784:                 if seq
; toolsrc/parse.pla: 0785:                     emit_seq(seq)
; toolsrc/parse.pla: 0786:                     emit_subbrge(tag_for)
; toolsrc/parse.pla: 0787:                 else
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$4C			; BRFLS	_B859
	!WORD	_B859-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C041
_F1184 	!WORD	_C041		
	!BYTE	$66,$18			; LLW	[24]
	!BYTE	$54			; CALL	_C034
_F1185 	!WORD	_C034		
	!BYTE	$50			; BRNCH	_B860
	!WORD	_B860-*
_B859 
; toolsrc/parse.pla: 0788:                     emit_decbrge(tag_for)
; toolsrc/parse.pla: 0789:                 fin
	!BYTE	$66,$18			; LLW	[24]
	!BYTE	$54			; CALL	_C033
_F1186 	!WORD	_C033		
_B860 
; toolsrc/parse.pla: 0790:             fin
_B856 
; toolsrc/parse.pla: 0791:             emit_tag(break_tag)
; toolsrc/parse.pla: 0792:             if type & LOCAL_TYPE
; toolsrc/parse.pla: 0793:                 if type & BYTE_TYPE; emit_slb(addr); else; emit_slw(addr); fin
	!BYTE	$6A			; LAW	_D112+0
_F1187 	!WORD	_D112+0		
	!BYTE	$54			; CALL	_C039
_F1188 	!WORD	_C039		
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B861
	!WORD	_B861-*
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B863
	!WORD	_B863-*
	!BYTE	$66,$20			; LLW	[32]
	!BYTE	$54			; CALL	_C018
_F1189 	!WORD	_C018		
	!BYTE	$50			; BRNCH	_B864
	!WORD	_B864-*
_B863 
	!BYTE	$66,$20			; LLW	[32]
	!BYTE	$54			; CALL	_C019
_F1190 	!WORD	_C019		
_B864 
; toolsrc/parse.pla: 0794:             else
	!BYTE	$50			; BRNCH	_B862
	!WORD	_B862-*
_B861 
; toolsrc/parse.pla: 0795:                 if type & BYTE_TYPE; emit_sab(addr, 0); else; emit_saw(addr, 0); fin
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$3C,$02			; ANDI	2
	!BYTE	$4C			; BRFLS	_B865
	!WORD	_B865-*
	!BYTE	$66,$20			; LLW	[32]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C020
_F1191 	!WORD	_C020		
	!BYTE	$50			; BRNCH	_B866
	!WORD	_B866-*
_B865 
	!BYTE	$66,$20			; LLW	[32]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C021
_F1192 	!WORD	_C021		
_B866 
; toolsrc/parse.pla: 0796:             fin
_B862 
; toolsrc/parse.pla: 0797:             emit_code(DROP_CODE)
; toolsrc/parse.pla: 0798:             break_tag  = tag_prevbrk
; toolsrc/parse.pla: 0799:             stack_loop = stack_loop - 2
; toolsrc/parse.pla: 0800:             break
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C017
_F1193 	!WORD	_C017		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$7A			; SAW	_D112+0
_F1194 	!WORD	_D112+0		
	!BYTE	$68			; LAB	_D109+0
_F1195 	!WORD	_D109+0		
	!BYTE	$3A,$02			; SUBI	2
	!BYTE	$78			; SAB	_D109+0
_F1196 	!WORD	_D109+0		
	!BYTE	$50			; BRNCH	_B749
	!WORD	_B749-*
; toolsrc/parse.pla: 0801:         is CASE_TKN
_B867 
; toolsrc/parse.pla: 0802:             tag_prevbrk = break_tag
; toolsrc/parse.pla: 0803:             break_tag   = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0804:             tag_choice  = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0805:             caseval     = heapalloc(CASENUM)
; toolsrc/parse.pla: 0806:             casetag     = heapalloc(CASENUM)
; toolsrc/parse.pla: 0807:             casecnt     = 0
; toolsrc/parse.pla: 0808:             seq, cfnvals = parse_expr(NULL)
; toolsrc/parse.pla: 0809:             if !seq; exit_err(ERR_INVAL|ERR_STATE); fin
	!BYTE	$6A			; LAW	_D112+0
_F1197 	!WORD	_D112+0		
	!BYTE	$76,$0A			; SLW	[10]
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1198 	!WORD	_C004		
	!BYTE	$7A			; SAW	_D112+0
_F1199 	!WORD	_D112+0		
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1200 	!WORD	_C004		
	!BYTE	$76,$1A			; SLW	[26]
	!BYTE	$2A,$40			; CB	64
	!BYTE	$54			; CALL	_X014
_F1201 	!WORD	0		
	!BYTE	$76,$28			; SLW	[40]
	!BYTE	$2A,$40			; CB	64
	!BYTE	$54			; CALL	_X014
_F1202 	!WORD	0		
	!BYTE	$76,$2A			; SLW	[42]
	!BYTE	$00			; CN	0
	!BYTE	$76,$26			; SLW	[38]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C094
_F1203 	!WORD	_C094		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4E			; BRTRU	_B868
	!WORD	_B868-*
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1204 	!WORD	_C002		
_B868 
_B869 
; toolsrc/parse.pla: 0810:             if cfnvals > 1
; toolsrc/parse.pla: 0811:                 parse_warn("Expression value overflow")
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B870
	!WORD	_B870-*
	!BYTE	$2E			; CS
	!BYTE	$19
	!BYTE	$45,$78,$70,$72,$65,$73,$73,$69
	!BYTE	$6F,$6E,$20,$76,$61,$6C,$75,$65
	!BYTE	$20,$6F,$76,$65,$72,$66,$6C,$6F
	!BYTE	$77
	!BYTE	$54			; CALL	_C003
_F1205 	!WORD	_C003		
; toolsrc/parse.pla: 0812:                 while cfnvals > 1;cfnvals--; seq = gen_op(seq, DROP_CODE); loop
	!BYTE	$50			; BRNCH	_B874
	!WORD	_B874-*
_B872 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$8E			; DECR
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C059
_F1206 	!WORD	_C059		
	!BYTE	$76,$04			; SLW	[4]
_B874 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B872
	!WORD	_B872-*
_B873 
; toolsrc/parse.pla: 0813:             fin
_B870 
_B871 
; toolsrc/parse.pla: 0814:             emit_seq(seq)
; toolsrc/parse.pla: 0815:             emit_select(tag_choice)
; toolsrc/parse.pla: 0816:             nextln
; toolsrc/parse.pla: 0817:             while token <> ENDCASE_TKN
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C041
_F1207 	!WORD	_C041		
	!BYTE	$66,$1A			; LLW	[26]
	!BYTE	$54			; CALL	_C026
_F1208 	!WORD	_C026		
	!BYTE	$54			; CALL	_C079
_F1209 	!WORD	_C079		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B877
	!WORD	_B877-*
_B875 
; toolsrc/parse.pla: 0818:                 when token
	!BYTE	$68			; LAB	_D098+0
_F1210 	!WORD	_D098+0		
	!BYTE	$52			; SEL
	!WORD	_B879-*
; toolsrc/parse.pla: 0819:                     is OF_TKN
_B880 
; toolsrc/parse.pla: 0820:                         if casecnt == CASENUM; exit_err(ERR_OVER|ERR_TABLE); fin
	!BYTE	$66,$26			; LLW	[38]
	!BYTE	$2A,$40			; CB	64
	!BYTE	$24			; BRNE	_B881
	!WORD	_B881-*
	!BYTE	$2C,$10,$40		; CW	16400
	!BYTE	$54			; CALL	_C002
_F1211 	!WORD	_C002		
_B881 
_B882 
; toolsrc/parse.pla: 0821:                         caseconst, drop, drop = parse_constexpr
; toolsrc/parse.pla: 0822:                         tag_of                = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0823:                         i                     = casecnt
; toolsrc/parse.pla: 0824:                         while i > 0 and caseval=>[i-1] > caseconst
	!BYTE	$54			; CALL	_C089
_F1212 	!WORD	_C089		
	!BYTE	$30			; DROP 
	!BYTE	$30			; DROP 
	!BYTE	$76,$24			; SLW	[36]
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1213 	!WORD	_C004		
	!BYTE	$76,$1C			; SLW	[28]
	!BYTE	$66,$26			; LLW	[38]
	!BYTE	$76,$2C			; SLW	[44]
	!BYTE	$50			; BRNCH	_B885
	!WORD	_B885-*
_B883 
; toolsrc/parse.pla: 0825:                             //
; toolsrc/parse.pla: 0826:                             // Move larger case consts up
; toolsrc/parse.pla: 0827:                             //
; toolsrc/parse.pla: 0828:                             caseval=>[i] = caseval=>[i-1]
; toolsrc/parse.pla: 0829:                             casetag=>[i] = casetag=>[i-1]
; toolsrc/parse.pla: 0830:                             i--
	!BYTE	$66,$28			; LLW	[40]
	!BYTE	$66,$2C			; LLW	[44]
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$66,$28			; LLW	[40]
	!BYTE	$BA,$2C			; IDXLW	[44]
	!BYTE	$72			; SW
	!BYTE	$66,$2A			; LLW	[42]
	!BYTE	$66,$2C			; LLW	[44]
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$66,$2A			; LLW	[42]
	!BYTE	$BA,$2C			; IDXLW	[44]
	!BYTE	$72			; SW
	!BYTE	$66,$2C			; LLW	[44]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0831:                         loop
	!BYTE	$76,$2C			; SLW	[44]
_B885 
	!BYTE	$66,$2C			; LLW	[44]
	!BYTE	$00			; CN	0
	!BYTE	$44			; ISGT
	!BYTE	$AC			; BRAND	_B886
	!WORD	_B886-*
	!BYTE	$66,$28			; LLW	[40]
	!BYTE	$66,$2C			; LLW	[44]
	!BYTE	$8E			; DECR
	!BYTE	$9E			; IDXW
	!BYTE	$62			; LW
	!BYTE	$66,$24			; LLW	[36]
	!BYTE	$44			; ISGT
_B886 
	!BYTE	$4E			; BRTRU	_B883
	!WORD	_B883-*
_B884 
; toolsrc/parse.pla: 0832:                         if i < casecnt and caseval=>[i] == caseconst; exit_err(ERR_DUP|ERR_STATE); fin
	!BYTE	$66,$2C			; LLW	[44]
	!BYTE	$66,$26			; LLW	[38]
	!BYTE	$46			; ISLT
	!BYTE	$AC			; BRAND	_B887
	!WORD	_B887-*
	!BYTE	$66,$28			; LLW	[40]
	!BYTE	$BA,$2C			; IDXLW	[44]
	!BYTE	$62			; LW
	!BYTE	$66,$24			; LLW	[36]
	!BYTE	$40			; ISEQ
_B887 
	!BYTE	$4C			; BRFLS	_B888
	!WORD	_B888-*
	!BYTE	$2C,$01,$10		; CW	4097
	!BYTE	$54			; CALL	_C002
_F1214 	!WORD	_C002		
_B888 
_B889 
; toolsrc/parse.pla: 0833:                         caseval=>[i] = caseconst
; toolsrc/parse.pla: 0834:                         casetag=>[i] = tag_of
; toolsrc/parse.pla: 0835:                         casecnt++
	!BYTE	$66,$24			; LLW	[36]
	!BYTE	$66,$28			; LLW	[40]
	!BYTE	$BA,$2C			; IDXLW	[44]
	!BYTE	$72			; SW
	!BYTE	$66,$1C			; LLW	[28]
	!BYTE	$66,$2A			; LLW	[42]
	!BYTE	$BA,$2C			; IDXLW	[44]
	!BYTE	$72			; SW
	!BYTE	$66,$26			; LLW	[38]
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 0836:                         emit_tag(tag_of)
; toolsrc/parse.pla: 0837:                         while parse_stmnt
	!BYTE	$76,$26			; SLW	[38]
	!BYTE	$66,$1C			; LLW	[28]
	!BYTE	$54			; CALL	_C039
_F1215 	!WORD	_C039		
	!BYTE	$50			; BRNCH	_B892
	!WORD	_B892-*
_B890 
; toolsrc/parse.pla: 0838:                             nextln
; toolsrc/parse.pla: 0839:                         loop
	!BYTE	$54			; CALL	_C079
_F1216 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B892 
	!BYTE	$54			; CALL	_C096
_F1217 	!WORD	_C096		
	!BYTE	$4E			; BRTRU	_B890
	!WORD	_B890-*
_B891 
; toolsrc/parse.pla: 0840:                         break
	!BYTE	$50			; BRNCH	_B878
	!WORD	_B878-*
; toolsrc/parse.pla: 0841:                     is DEFAULT_TKN
_B893 
; toolsrc/parse.pla: 0842:                         tag_of = 0
; toolsrc/parse.pla: 0843:                         if prevstmnt <> BREAK_TKN // Branch around caseblock if falling through
; toolsrc/parse.pla: 0844:                             tag_of = new_tag(RELATIVE_FIXUP)
; toolsrc/parse.pla: 0845:                             emit_branch(tag_of)
; toolsrc/parse.pla: 0846:                         fin
	!BYTE	$00			; CN	0
	!BYTE	$76,$1C			; SLW	[28]
	!BYTE	$68			; LAB	_D110+0
_F1218 	!WORD	_D110+0		
	!BYTE	$2A,$9A			; CB	154
	!BYTE	$22			; BREQ	_B894
	!WORD	_B894-*
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C004
_F1219 	!WORD	_C004		
	!BYTE	$6E,$1C			; DLW	[28]
	!BYTE	$54			; CALL	_C028
_F1220 	!WORD	_C028		
_B894 
_B895 
; toolsrc/parse.pla: 0847:                         emit_tag(tag_choice)
; toolsrc/parse.pla: 0848:                         emit_caseblock(casecnt, caseval, casetag)
; toolsrc/parse.pla: 0849:                         tag_choice = 0
; toolsrc/parse.pla: 0850:                         if tag_of
; toolsrc/parse.pla: 0851:                             emit_tag(tag_of)
; toolsrc/parse.pla: 0852:                         fin
	!BYTE	$66,$1A			; LLW	[26]
	!BYTE	$54			; CALL	_C039
_F1221 	!WORD	_C039		
	!BYTE	$66,$26			; LLW	[38]
	!BYTE	$66,$28			; LLW	[40]
	!BYTE	$66,$2A			; LLW	[42]
	!BYTE	$54			; CALL	_C027
_F1222 	!WORD	_C027		
	!BYTE	$00			; CN	0
	!BYTE	$76,$1A			; SLW	[26]
	!BYTE	$66,$1C			; LLW	[28]
	!BYTE	$4C			; BRFLS	_B896
	!WORD	_B896-*
	!BYTE	$66,$1C			; LLW	[28]
	!BYTE	$54			; CALL	_C039
_F1223 	!WORD	_C039		
_B896 
_B897 
; toolsrc/parse.pla: 0853:                         scan
; toolsrc/parse.pla: 0854:                         while parse_stmnt
	!BYTE	$54			; CALL	_C076
_F1224 	!WORD	_C076		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B900
	!WORD	_B900-*
_B898 
; toolsrc/parse.pla: 0855:                             nextln
; toolsrc/parse.pla: 0856:                         loop
	!BYTE	$54			; CALL	_C079
_F1225 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B900 
	!BYTE	$54			; CALL	_C096
_F1226 	!WORD	_C096		
	!BYTE	$4E			; BRTRU	_B898
	!WORD	_B898-*
_B899 
; toolsrc/parse.pla: 0857:                         if token <> ENDCASE_TKN; exit_err(ERR_INVAL|ERR_STATE); fin
	!BYTE	$68			; LAB	_D098+0
_F1227 	!WORD	_D098+0		
	!BYTE	$2A,$8D			; CB	141
	!BYTE	$22			; BREQ	_B901
	!WORD	_B901-*
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1228 	!WORD	_C002		
_B901 
_B902 
; toolsrc/parse.pla: 0858:                         break
	!BYTE	$50			; BRNCH	_B878
	!WORD	_B878-*
; toolsrc/parse.pla: 0859:                     is EOL_TKN
_B903 
; toolsrc/parse.pla: 0860:                         nextln
; toolsrc/parse.pla: 0861:                         break
	!BYTE	$54			; CALL	_C079
_F1229 	!WORD	_C079		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B878
	!WORD	_B878-*
; toolsrc/parse.pla: 0862:                     otherwise
_B879 
	!BYTE	$03			; CASEBLOCK
	!WORD	$0002
	!WORD	_B903-*
	!WORD	$008B
	!WORD	_B880-*
	!WORD	$008C
	!WORD	_B893-*
; toolsrc/parse.pla: 0863:                         exit_err(ERR_MISS|ERR_CLOSE|ERR_STATE)
; toolsrc/parse.pla: 0864:                 wend
	!BYTE	$2C,$28,$10		; CW	4136
	!BYTE	$54			; CALL	_C002
_F1230 	!WORD	_C002		
_B878 
; toolsrc/parse.pla: 0865:             loop
_B877 
	!BYTE	$68			; LAB	_D098+0
_F1231 	!WORD	_D098+0		
	!BYTE	$2A,$8D			; CB	141
	!BYTE	$24			; BRNE	_B875
	!WORD	_B875-*
_B876 
; toolsrc/parse.pla: 0866:             if tag_choice
; toolsrc/parse.pla: 0867:                 emit_branch(break_tag)
; toolsrc/parse.pla: 0868:                 emit_tag(tag_choice)
; toolsrc/parse.pla: 0869:                 emit_caseblock(casecnt, caseval, casetag)
; toolsrc/parse.pla: 0870:             fin
	!BYTE	$66,$1A			; LLW	[26]
	!BYTE	$4C			; BRFLS	_B904
	!WORD	_B904-*
	!BYTE	$6A			; LAW	_D112+0
_F1232 	!WORD	_D112+0		
	!BYTE	$54			; CALL	_C028
_F1233 	!WORD	_C028		
	!BYTE	$66,$1A			; LLW	[26]
	!BYTE	$54			; CALL	_C039
_F1234 	!WORD	_C039		
	!BYTE	$66,$26			; LLW	[38]
	!BYTE	$66,$28			; LLW	[40]
	!BYTE	$66,$2A			; LLW	[42]
	!BYTE	$54			; CALL	_C027
_F1235 	!WORD	_C027		
_B904 
_B905 
; toolsrc/parse.pla: 0871:             heaprelease(caseval)
; toolsrc/parse.pla: 0872:             emit_tag(break_tag)
; toolsrc/parse.pla: 0873:             break_tag = tag_prevbrk
; toolsrc/parse.pla: 0874:             break
	!BYTE	$66,$28			; LLW	[40]
	!BYTE	$54			; CALL	_X015
_F1236 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D112+0
_F1237 	!WORD	_D112+0		
	!BYTE	$54			; CALL	_C039
_F1238 	!WORD	_C039		
	!BYTE	$66,$0A			; LLW	[10]
	!BYTE	$7A			; SAW	_D112+0
_F1239 	!WORD	_D112+0		
	!BYTE	$50			; BRNCH	_B749
	!WORD	_B749-*
; toolsrc/parse.pla: 0875:         is BREAK_TKN
_B906 
; toolsrc/parse.pla: 0876:             if break_tag
; toolsrc/parse.pla: 0877:                 emit_branch(break_tag)
; toolsrc/parse.pla: 0878:             else
	!BYTE	$6A			; LAW	_D112+0
_F1240 	!WORD	_D112+0		
	!BYTE	$4C			; BRFLS	_B907
	!WORD	_B907-*
	!BYTE	$6A			; LAW	_D112+0
_F1241 	!WORD	_D112+0		
	!BYTE	$54			; CALL	_C028
_F1242 	!WORD	_C028		
	!BYTE	$50			; BRNCH	_B908
	!WORD	_B908-*
_B907 
; toolsrc/parse.pla: 0879:                 exit_err(ERR_INVAL|ERR_STATE)
; toolsrc/parse.pla: 0880:             fin
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1243 	!WORD	_C002		
_B908 
; toolsrc/parse.pla: 0881:             break
	!BYTE	$50			; BRNCH	_B749
	!WORD	_B749-*
; toolsrc/parse.pla: 0882:         is CONT_TKN
_B909 
; toolsrc/parse.pla: 0883:             if cont_tag
; toolsrc/parse.pla: 0884:                 emit_branch(cont_tag)
; toolsrc/parse.pla: 0885:             else
	!BYTE	$6A			; LAW	_D113+0
_F1244 	!WORD	_D113+0		
	!BYTE	$4C			; BRFLS	_B910
	!WORD	_B910-*
	!BYTE	$6A			; LAW	_D113+0
_F1245 	!WORD	_D113+0		
	!BYTE	$54			; CALL	_C028
_F1246 	!WORD	_C028		
	!BYTE	$50			; BRNCH	_B911
	!WORD	_B911-*
_B910 
; toolsrc/parse.pla: 0886:                 exit_err(ERR_INVAL|ERR_STATE)
; toolsrc/parse.pla: 0887:             fin
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1247 	!WORD	_C002		
_B911 
; toolsrc/parse.pla: 0888:             break
	!BYTE	$50			; BRNCH	_B749
	!WORD	_B749-*
; toolsrc/parse.pla: 0889:         is RETURN_TKN
_B912 
; toolsrc/parse.pla: 0890:             i = stack_loop
; toolsrc/parse.pla: 0891:             while i >= 2
	!BYTE	$68			; LAB	_D109+0
_F1248 	!WORD	_D109+0		
	!BYTE	$76,$2C			; SLW	[44]
	!BYTE	$50			; BRNCH	_B915
	!WORD	_B915-*
_B913 
; toolsrc/parse.pla: 0892:                 emit_code(DROP2_CODE)
; toolsrc/parse.pla: 0893:                 i = i - 2
; toolsrc/parse.pla: 0894:             loop
	!BYTE	$2A,$32			; CB	50
	!BYTE	$54			; CALL	_C017
_F1249 	!WORD	_C017		
	!BYTE	$66,$2C			; LLW	[44]
	!BYTE	$3A,$02			; SUBI	2
	!BYTE	$76,$2C			; SLW	[44]
_B915 
	!BYTE	$66,$2C			; LLW	[44]
	!BYTE	$04			; CN	2
	!BYTE	$48			; ISGE
	!BYTE	$4E			; BRTRU	_B913
	!WORD	_B913-*
_B914 
; toolsrc/parse.pla: 0895:             if i
; toolsrc/parse.pla: 0896:                 emit_code(DROP_CODE)
; toolsrc/parse.pla: 0897:             fin
	!BYTE	$66,$2C			; LLW	[44]
	!BYTE	$4C			; BRFLS	_B916
	!WORD	_B916-*
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C017
_F1250 	!WORD	_C017		
_B916 
_B917 
; toolsrc/parse.pla: 0898:             if infunc
; toolsrc/parse.pla: 0899:                 seq, cfnvals = parse_list
; toolsrc/parse.pla: 0900:                 emit_seq(seq)
; toolsrc/parse.pla: 0901:                 if cfnvals > infuncvals
; toolsrc/parse.pla: 0902:                     exit_err(ERR_OVER|ERR_CLOSE|ERR_STATE)
; toolsrc/parse.pla: 0903:                 elsif cfnvals < infuncvals
	!BYTE	$68			; LAB	_D107+0
_F1251 	!WORD	_D107+0		
	!BYTE	$4C			; BRFLS	_B918
	!WORD	_B918-*
	!BYTE	$54			; CALL	_C091
_F1252 	!WORD	_C091		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$54			; CALL	_C041
_F1253 	!WORD	_C041		
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$6A			; LAW	_D111+0
_F1254 	!WORD	_D111+0		
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B920
	!WORD	_B920-*
	!BYTE	$2C,$30,$10		; CW	4144
	!BYTE	$54			; CALL	_C002
_F1255 	!WORD	_C002		
	!BYTE	$50			; BRNCH	_B921
	!WORD	_B921-*
_B920 
; toolsrc/parse.pla: 0904:                     parse_warn("Too few return values")
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$6A			; LAW	_D111+0
_F1256 	!WORD	_D111+0		
	!BYTE	$46			; ISLT
	!BYTE	$4C			; BRFLS	_B922
	!WORD	_B922-*
	!BYTE	$2E			; CS
	!BYTE	$15
	!BYTE	$54,$6F,$6F,$20,$66,$65,$77,$20
	!BYTE	$72,$65,$74,$75,$72,$6E,$20,$76
	!BYTE	$61,$6C,$75,$65,$73
	!BYTE	$54			; CALL	_C003
_F1257 	!WORD	_C003		
; toolsrc/parse.pla: 0905:                     while cfnvals < infuncvals
	!BYTE	$50			; BRNCH	_B925
	!WORD	_B925-*
_B923 
; toolsrc/parse.pla: 0906:                         cfnvals++
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 0907:                         emit_const(0)
; toolsrc/parse.pla: 0908:                     loop
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C016
_F1258 	!WORD	_C016		
_B925 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$6A			; LAW	_D111+0
_F1259 	!WORD	_D111+0		
	!BYTE	$46			; ISLT
	!BYTE	$4E			; BRTRU	_B923
	!WORD	_B923-*
_B924 
; toolsrc/parse.pla: 0909:                 fin
_B922 
_B921 
; toolsrc/parse.pla: 0910:                 emit_leave
; toolsrc/parse.pla: 0911:             else
	!BYTE	$54			; CALL	_C037
_F1260 	!WORD	_C037		
	!BYTE	$50			; BRNCH	_B919
	!WORD	_B919-*
_B918 
; toolsrc/parse.pla: 0912:                 seq, cfnvals = parse_expr(NULL)
; toolsrc/parse.pla: 0913:                 if not seq
; toolsrc/parse.pla: 0914:                     emit_const(0)
; toolsrc/parse.pla: 0915:                 else
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C094
_F1261 	!WORD	_C094		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4E			; BRTRU	_B926
	!WORD	_B926-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C016
_F1262 	!WORD	_C016		
	!BYTE	$50			; BRNCH	_B927
	!WORD	_B927-*
_B926 
; toolsrc/parse.pla: 0916:                     if cfnvals > 1
; toolsrc/parse.pla: 0917:                         exit_err(ERR_OVER|ERR_CLOSE|ERR_STATE)
; toolsrc/parse.pla: 0918:                         while cfnvals > 1;cfnvals--; seq = gen_op(seq, DROP_CODE); loop
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B928
	!WORD	_B928-*
	!BYTE	$2C,$30,$10		; CW	4144
	!BYTE	$54			; CALL	_C002
_F1263 	!WORD	_C002		
	!BYTE	$50			; BRNCH	_B932
	!WORD	_B932-*
_B930 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$8E			; DECR
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C059
_F1264 	!WORD	_C059		
	!BYTE	$76,$04			; SLW	[4]
_B932 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$02			; CN	1
	!BYTE	$44			; ISGT
	!BYTE	$4E			; BRTRU	_B930
	!WORD	_B930-*
_B931 
; toolsrc/parse.pla: 0919:                     fin
_B928 
_B929 
; toolsrc/parse.pla: 0920:                     emit_seq(seq)
; toolsrc/parse.pla: 0921:                 fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C041
_F1265 	!WORD	_C041		
_B927 
; toolsrc/parse.pla: 0922:                 emit_code(RET_CODE)
; toolsrc/parse.pla: 0923:             fin
	!BYTE	$2A,$5C			; CB	92
	!BYTE	$54			; CALL	_C017
_F1266 	!WORD	_C017		
_B919 
; toolsrc/parse.pla: 0924:             break
	!BYTE	$50			; BRNCH	_B749
	!WORD	_B749-*
; toolsrc/parse.pla: 0925:         is EOL_TKN
_B933 
; toolsrc/parse.pla: 0926:             return TRUE
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$2E			; LEAVE	46
; toolsrc/parse.pla: 0927:         is ELSE_TKN
_B934 
; toolsrc/parse.pla: 0928:         is ELSEIF_TKN
_B935 
; toolsrc/parse.pla: 0929:         is FIN_TKN
_B936 
; toolsrc/parse.pla: 0930:         is LOOP_TKN
_B937 
; toolsrc/parse.pla: 0931:         is UNTIL_TKN
_B938 
; toolsrc/parse.pla: 0932:         is NEXT_TKN
_B939 
; toolsrc/parse.pla: 0933:         is OF_TKN
_B940 
; toolsrc/parse.pla: 0934:         is DEFAULT_TKN
_B941 
; toolsrc/parse.pla: 0935:         is ENDCASE_TKN
_B942 
; toolsrc/parse.pla: 0936:         is END_TKN
_B943 
; toolsrc/parse.pla: 0937:         is DONE_TKN
_B944 
; toolsrc/parse.pla: 0938:         is DEF_TKN
_B945 
; toolsrc/parse.pla: 0939:         is EOF_TKN
_B946 
; toolsrc/parse.pla: 0940:             return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$2E			; LEAVE	46
; toolsrc/parse.pla: 0941:         otherwise
	!BYTE	$50			; BRNCH	_B947
	!WORD	_B947-*
_B750 
	!BYTE	$16			; CASEBLOCK
	!WORD	$0001
	!WORD	_B946-*
	!WORD	$0002
	!WORD	_B933-*
	!WORD	$0083
	!WORD	_B751-*
	!WORD	$0084
	!WORD	_B935-*
	!WORD	$0085
	!WORD	_B934-*
	!WORD	$0086
	!WORD	_B936-*
	!WORD	$0087
	!WORD	_B943-*
	!WORD	$0088
	!WORD	_B781-*
	!WORD	$0089
	!WORD	_B937-*
	!WORD	$008A
	!WORD	_B867-*
	!WORD	$008B
	!WORD	_B940-*
	!WORD	$008C
	!WORD	_B941-*
	!WORD	$008D
	!WORD	_B942-*
	!WORD	$008E
	!WORD	_B807-*
	!WORD	$0092
	!WORD	_B939-*
	!WORD	$0093
	!WORD	_B794-*
	!WORD	$0094
	!WORD	_B938-*
	!WORD	$0095
	!WORD	_B945-*
	!WORD	$0098
	!WORD	_B944-*
	!WORD	$0099
	!WORD	_B912-*
	!WORD	$009A
	!WORD	_B906-*
	!WORD	$009B
	!WORD	_B909-*
_B947 
; toolsrc/parse.pla: 0942:             rewind(tknptr)
; toolsrc/parse.pla: 0943:             seq = parse_set(NULL)
; toolsrc/parse.pla: 0944:             if seq
; toolsrc/parse.pla: 0945:                 emit_seq(seq)
; toolsrc/parse.pla: 0946:             else
	!BYTE	$6A			; LAW	_D101+0
_F1267 	!WORD	_D101+0		
	!BYTE	$54			; CALL	_C077
_F1268 	!WORD	_C077		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C095
_F1269 	!WORD	_C095		
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4C			; BRFLS	_B948
	!WORD	_B948-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C041
_F1270 	!WORD	_C041		
	!BYTE	$50			; BRNCH	_B949
	!WORD	_B949-*
_B948 
; toolsrc/parse.pla: 0947:                 idptr = tknptr
; toolsrc/parse.pla: 0948:                 seq, cfnvals = parse_value(NULL, RVALUE)
; toolsrc/parse.pla: 0949:                 if seq
; toolsrc/parse.pla: 0950:                     if token == INC_TKN or token == DEC_TKN
; toolsrc/parse.pla: 0951:                         emit_seq(seq)
; toolsrc/parse.pla: 0952:                         emit_code(token == INC_TKN ?? INC_CODE :: DEC_CODE)
; toolsrc/parse.pla: 0953:                         rewind(idptr)
; toolsrc/parse.pla: 0954:                         seq, drop = parse_value(NULL, LVALUE)
; toolsrc/parse.pla: 0955:                         emit_seq(seq)
; toolsrc/parse.pla: 0956:                     else
	!BYTE	$6A			; LAW	_D101+0
_F1271 	!WORD	_D101+0		
	!BYTE	$76,$1E			; SLW	[30]
	!BYTE	$00			; CN	0
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C092
_F1272 	!WORD	_C092		
	!BYTE	$74,$03			; SLB	[3]
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$4C			; BRFLS	_B950
	!WORD	_B950-*
	!BYTE	$68			; LAB	_D098+0
_F1273 	!WORD	_D098+0		
	!BYTE	$2A,$C1			; CB	193
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B952
	!WORD	_B952-*
	!BYTE	$68			; LAB	_D098+0
_F1274 	!WORD	_D098+0		
	!BYTE	$2A,$C4			; CB	196
	!BYTE	$40			; ISEQ
_B952 
	!BYTE	$4C			; BRFLS	_B953
	!WORD	_B953-*
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C041
_F1275 	!WORD	_C041		
	!BYTE	$68			; LAB	_D098+0
_F1276 	!WORD	_D098+0		
	!BYTE	$2A,$C1			; CB	193
	!BYTE	$24			; BRNE	_B957
	!WORD	_B957-*
	!BYTE	$2A,$8C			; CB	140
	!BYTE	$50			; BRNCH	_B958
	!WORD	_B958-*
_B957 
	!BYTE	$2A,$8E			; CB	142
_B958 
	!BYTE	$54			; CALL	_C017
_F1277 	!WORD	_C017		
	!BYTE	$66,$1E			; LLW	[30]
	!BYTE	$54			; CALL	_C077
_F1278 	!WORD	_C077		
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C092
_F1279 	!WORD	_C092		
	!BYTE	$30			; DROP 
	!BYTE	$6E,$04			; DLW	[4]
	!BYTE	$54			; CALL	_C041
_F1280 	!WORD	_C041		
	!BYTE	$50			; BRNCH	_B954
	!WORD	_B954-*
_B953 
; toolsrc/parse.pla: 0957:                         while cfnvals
	!BYTE	$50			; BRNCH	_B961
	!WORD	_B961-*
_B959 
; toolsrc/parse.pla: 0958:                             seq = cat_seq(seq, gen_op(NULL, DROP_CODE))
; toolsrc/parse.pla: 0959:                             cfnvals--
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$00			; CN	0
	!BYTE	$2A,$30			; CB	48
	!BYTE	$54			; CALL	_C059
_F1281 	!WORD	_C059		
	!BYTE	$54			; CALL	_C008
_F1282 	!WORD	_C008		
	!BYTE	$76,$04			; SLW	[4]
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$8E			; DECR
; toolsrc/parse.pla: 0960:                         loop
	!BYTE	$74,$03			; SLB	[3]
_B961 
	!BYTE	$64,$03			; LLB	[3]
	!BYTE	$4E			; BRTRU	_B959
	!WORD	_B959-*
_B960 
; toolsrc/parse.pla: 0961:                         emit_seq(seq)
; toolsrc/parse.pla: 0962:                     fin
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$54			; CALL	_C041
_F1283 	!WORD	_C041		
_B954 
; toolsrc/parse.pla: 0963:                 else
	!BYTE	$50			; BRNCH	_B951
	!WORD	_B951-*
_B950 
; toolsrc/parse.pla: 0964:                     exit_err(ERR_SYNTAX)
; toolsrc/parse.pla: 0965:                 fin
	!BYTE	$2C,$00,$80		; CW	32768
	!BYTE	$54			; CALL	_C002
_F1284 	!WORD	_C002		
_B951 
; toolsrc/parse.pla: 0966:             fin
_B949 
; toolsrc/parse.pla: 0967:     wend
_B749 
; toolsrc/parse.pla: 0968:     return scan == EOL_TKN
	!BYTE	$54			; CALL	_C076
_F1285 	!WORD	_C076		
	!BYTE	$04			; CN	2
	!BYTE	$40			; ISEQ
	!BYTE	$5A,$2E			; LEAVE	46
; toolsrc/parse.pla: 0969: end
; toolsrc/parse.pla: 0970: def parse_var(type, basesize, ignore_var)#0
					; type -> [0]
					; basesize -> [2]
					; ignore_var -> [4]
_C097 					; parse_var()
; toolsrc/parse.pla: 0971:     byte consttype, constsize, idlen
					; consttype -> [6]
					; constsize -> [7]
					; idlen -> [8]
; toolsrc/parse.pla: 0972:     word idptr, constval, arraysize, size
					; idptr -> [9]
					; constval -> [11]
					; arraysize -> [13]
					; size -> [15]
; toolsrc/parse.pla: 0973: 
; toolsrc/parse.pla: 0974:     idlen = 0
	!BYTE	$58,$11,$03		; ENTER	17,3
; toolsrc/parse.pla: 0975:     size  = 1
; toolsrc/parse.pla: 0976:     if scan == ID_TKN
; toolsrc/parse.pla: 0977:         idptr = tknptr
; toolsrc/parse.pla: 0978:         idlen = tknlen
; toolsrc/parse.pla: 0979:         if scan == OPEN_BRACKET_TKN
; toolsrc/parse.pla: 0980:             size, constsize, consttype = parse_constexpr
; toolsrc/parse.pla: 0981:             if token <> CLOSE_BRACKET_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_SYNTAX); fin
	!BYTE	$00			; CN	0
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$02			; CN	1
	!BYTE	$76,$0F			; SLW	[15]
	!BYTE	$54			; CALL	_C076
_F1286 	!WORD	_C076		
	!BYTE	$2A,$D6			; CB	214
	!BYTE	$24			; BRNE	_B962
	!WORD	_B962-*
	!BYTE	$6A			; LAW	_D101+0
_F1287 	!WORD	_D101+0		
	!BYTE	$76,$09			; SLW	[9]
	!BYTE	$68			; LAB	_D100+0
_F1288 	!WORD	_D100+0		
	!BYTE	$74,$08			; SLB	[8]
	!BYTE	$54			; CALL	_C076
_F1289 	!WORD	_C076		
	!BYTE	$2A,$DB			; CB	219
	!BYTE	$24			; BRNE	_B964
	!WORD	_B964-*
	!BYTE	$54			; CALL	_C089
_F1290 	!WORD	_C089		
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$74,$07			; SLB	[7]
	!BYTE	$76,$0F			; SLW	[15]
	!BYTE	$68			; LAB	_D098+0
_F1291 	!WORD	_D098+0		
	!BYTE	$2A,$DD			; CB	221
	!BYTE	$22			; BREQ	_B966
	!WORD	_B966-*
	!BYTE	$2C,$28,$80		; CW	32808
	!BYTE	$54			; CALL	_C002
_F1292 	!WORD	_C002		
_B966 
_B967 
; toolsrc/parse.pla: 0982:             scan
; toolsrc/parse.pla: 0983:         fin
	!BYTE	$54			; CALL	_C076
_F1293 	!WORD	_C076		
	!BYTE	$30			; DROP 
_B964 
_B965 
; toolsrc/parse.pla: 0984:     fin
_B962 
_B963 
; toolsrc/parse.pla: 0985:     size = size * basesize
; toolsrc/parse.pla: 0986:     if token == SET_TKN
; toolsrc/parse.pla: 0987:         if type & (EXTERN_TYPE|LOCAL_TYPE); exit_err(ERR_INVAL|ERR_LOCAL|ERR_INIT); fin
	!BYTE	$66,$0F			; LLW	[15]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$86			; MUL
	!BYTE	$76,$0F			; SLW	[15]
	!BYTE	$68			; LAB	_D098+0
_F1294 	!WORD	_D098+0		
	!BYTE	$2A,$BD			; CB	189
	!BYTE	$24			; BRNE	_B968
	!WORD	_B968-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$10,$04		; CW	1040
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B970
	!WORD	_B970-*
	!BYTE	$2C,$44,$08		; CW	2116
	!BYTE	$54			; CALL	_C002
_F1295 	!WORD	_C002		
_B970 
_B971 
; toolsrc/parse.pla: 0988:         if idlen
; toolsrc/parse.pla: 0989:             new_iddata(idptr, idlen, type, 0)
; toolsrc/parse.pla: 0990:         fin
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$4C			; BRFLS	_B972
	!WORD	_B972-*
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C046
_F1296 	!WORD	_C046		
_B972 
_B973 
; toolsrc/parse.pla: 0991:         constval, constsize, consttype = parse_constexpr
; toolsrc/parse.pla: 0992:         arraysize = emit_data(type, consttype, constval, constsize)
; toolsrc/parse.pla: 0993:         while token == COMMA_TKN
	!BYTE	$54			; CALL	_C089
_F1297 	!WORD	_C089		
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$74,$07			; SLB	[7]
	!BYTE	$76,$0B			; SLW	[11]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$66,$0B			; LLW	[11]
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$54			; CALL	_C014
_F1298 	!WORD	_C014		
	!BYTE	$76,$0D			; SLW	[13]
	!BYTE	$50			; BRNCH	_B976
	!WORD	_B976-*
_B974 
; toolsrc/parse.pla: 0994:             constval, constsize, consttype = parse_constexpr
; toolsrc/parse.pla: 0995:             arraysize = arraysize + emit_data(type, consttype, constval, constsize)
; toolsrc/parse.pla: 0996:         loop
	!BYTE	$54			; CALL	_C089
_F1299 	!WORD	_C089		
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$74,$07			; SLB	[7]
	!BYTE	$76,$0B			; SLW	[11]
	!BYTE	$66,$0D			; LLW	[13]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$66,$0B			; LLW	[11]
	!BYTE	$64,$07			; LLB	[7]
	!BYTE	$54			; CALL	_C014
_F1300 	!WORD	_C014		
	!BYTE	$82			; ADD 
	!BYTE	$76,$0D			; SLW	[13]
_B976 
	!BYTE	$68			; LAB	_D098+0
_F1301 	!WORD	_D098+0		
	!BYTE	$2A,$AC			; CB	172
	!BYTE	$22			; BREQ	_B974
	!WORD	_B974-*
_B975 
; toolsrc/parse.pla: 0997:         size_iddata(PTR_TYPE, size, arraysize)
; toolsrc/parse.pla: 0998:     elsif not ignore_var
	!BYTE	$2A,$60			; CB	96
	!BYTE	$66,$0F			; LLW	[15]
	!BYTE	$66,$0D			; LLW	[13]
	!BYTE	$54			; CALL	_C047
_F1302 	!WORD	_C047		
	!BYTE	$50			; BRNCH	_B969
	!WORD	_B969-*
_B968 
; toolsrc/parse.pla: 0999:         if idlen
; toolsrc/parse.pla: 1000:             if infunc
; toolsrc/parse.pla: 1001:                 new_idlocal(idptr, idlen, type, size)
; toolsrc/parse.pla: 1002:             else
	!BYTE	$66,$04			; LLW	[4]
	!BYTE	$4E			; BRTRU	_B977
	!WORD	_B977-*
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$4C			; BRFLS	_B978
	!WORD	_B978-*
	!BYTE	$68			; LAB	_D107+0
_F1303 	!WORD	_D107+0		
	!BYTE	$4C			; BRFLS	_B980
	!WORD	_B980-*
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$0F			; LLW	[15]
	!BYTE	$54			; CALL	_C053
_F1304 	!WORD	_C053		
	!BYTE	$50			; BRNCH	_B981
	!WORD	_B981-*
_B980 
; toolsrc/parse.pla: 1003:                 new_iddata(idptr, idlen, type, size)
; toolsrc/parse.pla: 1004:             fin
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$64,$08			; LLB	[8]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$0F			; LLW	[15]
	!BYTE	$54			; CALL	_C046
_F1305 	!WORD	_C046		
_B981 
; toolsrc/parse.pla: 1005:         elsif not type & EXTERN_TYPE
	!BYTE	$50			; BRNCH	_B979
	!WORD	_B979-*
_B978 
; toolsrc/parse.pla: 1006:             if type & LOCAL_TYPE
; toolsrc/parse.pla: 1007:                 framesize = framesize + size
; toolsrc/parse.pla: 1008:             else
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$80			; NOT
	!BYTE	$2C,$00,$04		; CW	1024
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B982
	!WORD	_B982-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B983
	!WORD	_B983-*
	!BYTE	$6A			; LAW	_D070+0
_F1306 	!WORD	_D070+0		
	!BYTE	$B2,$0F			; ADDLW	[15]
	!BYTE	$7A			; SAW	_D070+0
_F1307 	!WORD	_D070+0		
	!BYTE	$50			; BRNCH	_B984
	!WORD	_B984-*
_B983 
; toolsrc/parse.pla: 1009:                 size_iddata(type, size, 0)
; toolsrc/parse.pla: 1010:             fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$0F			; LLW	[15]
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C047
_F1308 	!WORD	_C047		
_B984 
; toolsrc/parse.pla: 1011:         fin
_B982 
_B979 
; toolsrc/parse.pla: 1012:     fin
_B977 
_B969 
; toolsrc/parse.pla: 1013: end
	!BYTE	$5A,$11			; LEAVE	17
; toolsrc/parse.pla: 1014: def parse_struc#0
_C098 					; parse_struc()
; toolsrc/parse.pla: 1015:     byte strucid[16]
					; strucid -> [0]
; toolsrc/parse.pla: 1016:     byte idlen, struclen, constsize, consttype
					; idlen -> [16]
					; struclen -> [17]
					; constsize -> [18]
					; consttype -> [19]
; toolsrc/parse.pla: 1017:     word type, basesize, size, offset, idstr
					; type -> [20]
					; basesize -> [22]
					; size -> [24]
					; offset -> [26]
					; idstr -> [28]
; toolsrc/parse.pla: 1018: 
; toolsrc/parse.pla: 1019:     struclen = 0
	!BYTE	$58,$1E,$00		; ENTER	30,0
; toolsrc/parse.pla: 1020:     if scan == ID_TKN
; toolsrc/parse.pla: 1021:         struclen = tknlen
; toolsrc/parse.pla: 1022:         if struclen > 16
; toolsrc/parse.pla: 1023:             struclen = 16
; toolsrc/parse.pla: 1024:         fin
	!BYTE	$00			; CN	0
	!BYTE	$74,$11			; SLB	[17]
	!BYTE	$54			; CALL	_C076
_F1309 	!WORD	_C076		
	!BYTE	$2A,$D6			; CB	214
	!BYTE	$24			; BRNE	_B985
	!WORD	_B985-*
	!BYTE	$68			; LAB	_D100+0
_F1310 	!WORD	_D100+0		
	!BYTE	$6C,$11			; DLB	[17]
	!BYTE	$2A,$10			; CB	16
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B987
	!WORD	_B987-*
	!BYTE	$2A,$10			; CB	16
	!BYTE	$74,$11			; SLB	[17]
_B987 
_B988 
; toolsrc/parse.pla: 1025:         for idlen = 0 to struclen
	!BYTE	$64,$11			; LLB	[17]
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B989
	!WORD	_B989-*
_B990 
	!BYTE	$6C,$10			; DLB	[16]
; toolsrc/parse.pla: 1026:             strucid[idlen] = ^(tknptr + idlen)
; toolsrc/parse.pla: 1027:         next
	!BYTE	$6A			; LAW	_D101+0
_F1311 	!WORD	_D101+0		
	!BYTE	$B0,$10			; ADDLB	[16]
	!BYTE	$60			; LB
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$B0,$10			; ADDLB	[16]
	!BYTE	$70			; SB
_B991 
	!BYTE	$A4			; INCBRLE	_B990
	!WORD	_B990-*
_B989 
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$30			; DROP 
; toolsrc/parse.pla: 1028:         scan
; toolsrc/parse.pla: 1029:     fin
	!BYTE	$54			; CALL	_C076
_F1312 	!WORD	_C076		
	!BYTE	$30			; DROP 
_B985 
_B986 
; toolsrc/parse.pla: 1030:     offset = 0
; toolsrc/parse.pla: 1031:     while nextln == BYTE_TKN or token == WORD_TKN or token == EOL_TKN
	!BYTE	$00			; CN	0
	!BYTE	$76,$1A			; SLW	[26]
	!BYTE	$50			; BRNCH	_B994
	!WORD	_B994-*
_B992 
; toolsrc/parse.pla: 1032:         if token <> EOL_TKN
; toolsrc/parse.pla: 1033:             basesize = 1
; toolsrc/parse.pla: 1034:             type = token == BYTE_TKN ?? BYTE_TYPE :: WORD_TYPE
; toolsrc/parse.pla: 1035:             if scan == OPEN_BRACKET_TKN
; toolsrc/parse.pla: 1036:                 basesize, constsize, consttype = parse_constexpr
; toolsrc/parse.pla: 1037:                 if token <> CLOSE_BRACKET_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_SYNTAX); fin
	!BYTE	$68			; LAB	_D098+0
_F1313 	!WORD	_D098+0		
	!BYTE	$04			; CN	2
	!BYTE	$22			; BREQ	_B997
	!WORD	_B997-*
	!BYTE	$02			; CN	1
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$68			; LAB	_D098+0
_F1314 	!WORD	_D098+0		
	!BYTE	$2A,$81			; CB	129
	!BYTE	$24			; BRNE	_B999
	!WORD	_B999-*
	!BYTE	$04			; CN	2
	!BYTE	$50			; BRNCH	_B1000
	!WORD	_B1000-*
_B999 
	!BYTE	$08			; CN	4
_B1000 
	!BYTE	$76,$14			; SLW	[20]
	!BYTE	$54			; CALL	_C076
_F1315 	!WORD	_C076		
	!BYTE	$2A,$DB			; CB	219
	!BYTE	$24			; BRNE	_B1001
	!WORD	_B1001-*
	!BYTE	$54			; CALL	_C089
_F1316 	!WORD	_C089		
	!BYTE	$74,$13			; SLB	[19]
	!BYTE	$74,$12			; SLB	[18]
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$68			; LAB	_D098+0
_F1317 	!WORD	_D098+0		
	!BYTE	$2A,$DD			; CB	221
	!BYTE	$22			; BREQ	_B1003
	!WORD	_B1003-*
	!BYTE	$2C,$28,$80		; CW	32808
	!BYTE	$54			; CALL	_C002
_F1318 	!WORD	_C002		
_B1003 
_B1004 
; toolsrc/parse.pla: 1038:                 scan
; toolsrc/parse.pla: 1039:             fin
	!BYTE	$54			; CALL	_C076
_F1319 	!WORD	_C076		
	!BYTE	$30			; DROP 
_B1001 
_B1002 
; toolsrc/parse.pla: 1040:             repeat
_B1006 
; toolsrc/parse.pla: 1041:                 size  = 1
; toolsrc/parse.pla: 1042:                 idlen = 0
; toolsrc/parse.pla: 1043:                 if token == ID_TKN
; toolsrc/parse.pla: 1044:                     idstr = tknptr
; toolsrc/parse.pla: 1045:                     idlen = tknlen
; toolsrc/parse.pla: 1046:                     if scan == OPEN_BRACKET_TKN
; toolsrc/parse.pla: 1047:                         size, constsize, consttype = parse_constexpr
; toolsrc/parse.pla: 1048:                         if token <> CLOSE_BRACKET_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_SYNTAX); fin
	!BYTE	$02			; CN	1
	!BYTE	$76,$18			; SLW	[24]
	!BYTE	$00			; CN	0
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$68			; LAB	_D098+0
_F1320 	!WORD	_D098+0		
	!BYTE	$2A,$D6			; CB	214
	!BYTE	$24			; BRNE	_B1008
	!WORD	_B1008-*
	!BYTE	$6A			; LAW	_D101+0
_F1321 	!WORD	_D101+0		
	!BYTE	$76,$1C			; SLW	[28]
	!BYTE	$68			; LAB	_D100+0
_F1322 	!WORD	_D100+0		
	!BYTE	$74,$10			; SLB	[16]
	!BYTE	$54			; CALL	_C076
_F1323 	!WORD	_C076		
	!BYTE	$2A,$DB			; CB	219
	!BYTE	$24			; BRNE	_B1010
	!WORD	_B1010-*
	!BYTE	$54			; CALL	_C089
_F1324 	!WORD	_C089		
	!BYTE	$74,$13			; SLB	[19]
	!BYTE	$74,$12			; SLB	[18]
	!BYTE	$76,$18			; SLW	[24]
	!BYTE	$68			; LAB	_D098+0
_F1325 	!WORD	_D098+0		
	!BYTE	$2A,$DD			; CB	221
	!BYTE	$22			; BREQ	_B1012
	!WORD	_B1012-*
	!BYTE	$2C,$28,$80		; CW	32808
	!BYTE	$54			; CALL	_C002
_F1326 	!WORD	_C002		
_B1012 
_B1013 
; toolsrc/parse.pla: 1049:                         scan
; toolsrc/parse.pla: 1050:                     fin
	!BYTE	$54			; CALL	_C076
_F1327 	!WORD	_C076		
	!BYTE	$30			; DROP 
_B1010 
_B1011 
; toolsrc/parse.pla: 1051:                 fin
_B1008 
_B1009 
; toolsrc/parse.pla: 1052:                 size = size * basesize
; toolsrc/parse.pla: 1053:                 if type & WORD_TYPE
; toolsrc/parse.pla: 1054:                     size = size * 2
; toolsrc/parse.pla: 1055:                 fin
	!BYTE	$66,$18			; LLW	[24]
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$86			; MUL
	!BYTE	$76,$18			; SLW	[24]
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B1014
	!WORD	_B1014-*
	!BYTE	$66,$18			; LLW	[24]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$76,$18			; SLW	[24]
_B1014 
_B1015 
; toolsrc/parse.pla: 1056:                 if idlen
; toolsrc/parse.pla: 1057:                     new_idconst(idstr, idlen, offset)
; toolsrc/parse.pla: 1058:                 fin
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$4C			; BRFLS	_B1016
	!WORD	_B1016-*
	!BYTE	$66,$1C			; LLW	[28]
	!BYTE	$64,$10			; LLB	[16]
	!BYTE	$66,$1A			; LLW	[26]
	!BYTE	$54			; CALL	_C049
_F1328 	!WORD	_C049		
_B1016 
_B1017 
; toolsrc/parse.pla: 1059:                 offset = offset + size
; toolsrc/parse.pla: 1060:             until token <> COMMA_TKN
	!BYTE	$66,$1A			; LLW	[26]
	!BYTE	$B2,$18			; ADDLW	[24]
	!BYTE	$76,$1A			; SLW	[26]
_B1007 
	!BYTE	$68			; LAB	_D098+0
_F1329 	!WORD	_D098+0		
	!BYTE	$2A,$AC			; CB	172
	!BYTE	$22			; BREQ	_B1006
	!WORD	_B1006-*
_B1005 
; toolsrc/parse.pla: 1061:         fin
_B997 
_B998 
; toolsrc/parse.pla: 1062:     loop
_B994 
	!BYTE	$54			; CALL	_C079
_F1330 	!WORD	_C079		
	!BYTE	$2A,$81			; CB	129
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B995
	!WORD	_B995-*
	!BYTE	$68			; LAB	_D098+0
_F1331 	!WORD	_D098+0		
	!BYTE	$2A,$82			; CB	130
	!BYTE	$40			; ISEQ
	!BYTE	$AE			; BROR	_B996
	!WORD	_B996-*
	!BYTE	$68			; LAB	_D098+0
_F1332 	!WORD	_D098+0		
	!BYTE	$04			; CN	2
	!BYTE	$40			; ISEQ
_B996 
_B995 
	!BYTE	$4E			; BRTRU	_B992
	!WORD	_B992-*
_B993 
; toolsrc/parse.pla: 1063:     if struclen
; toolsrc/parse.pla: 1064:         new_idconst(@strucid, struclen, offset)
; toolsrc/parse.pla: 1065:     fin
	!BYTE	$64,$11			; LLB	[17]
	!BYTE	$4C			; BRFLS	_B1018
	!WORD	_B1018-*
	!BYTE	$28,$00			; LLA	[0]
	!BYTE	$64,$11			; LLB	[17]
	!BYTE	$66,$1A			; LLW	[26]
	!BYTE	$54			; CALL	_C049
_F1333 	!WORD	_C049		
_B1018 
_B1019 
; toolsrc/parse.pla: 1066:     if token <> END_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_STATE); fin
	!BYTE	$68			; LAB	_D098+0
_F1334 	!WORD	_D098+0		
	!BYTE	$2A,$87			; CB	135
	!BYTE	$22			; BREQ	_B1020
	!WORD	_B1020-*
	!BYTE	$2C,$28,$10		; CW	4136
	!BYTE	$54			; CALL	_C002
_F1335 	!WORD	_C002		
_B1020 
_B1021 
; toolsrc/parse.pla: 1067:     scan
; toolsrc/parse.pla: 1068: end
	!BYTE	$54			; CALL	_C076
_F1336 	!WORD	_C076		
	!BYTE	$30			; DROP 
	!BYTE	$5A,$1E			; LEAVE	30
; toolsrc/parse.pla: 1069: def parse_vars(type, ignore_vars)
					; type -> [0]
					; ignore_vars -> [2]
_C099 					; parse_vars()
; toolsrc/parse.pla: 1070:     byte idlen, cfnparms, cfnvals
					; idlen -> [4]
					; cfnparms -> [5]
					; cfnvals -> [6]
; toolsrc/parse.pla: 1071:     word size, value, idptr
					; size -> [7]
					; value -> [9]
					; idptr -> [11]
; toolsrc/parse.pla: 1072: 
; toolsrc/parse.pla: 1073:     when token
	!BYTE	$58,$0D,$02		; ENTER	13,2
	!BYTE	$68			; LAB	_D098+0
_F1337 	!WORD	_D098+0		
	!BYTE	$52			; SEL
	!WORD	_B1023-*
; toolsrc/parse.pla: 1074:         is SYSFLAGS_TKN
_B1024 
; toolsrc/parse.pla: 1075:             if type & (EXTERN_TYPE | LOCAL_TYPE); exit_err(ERR_INVAL|ERR_GLOBAL|ERR_INIT); fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$10,$04		; CW	1040
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B1025
	!WORD	_B1025-*
	!BYTE	$2C,$84,$08		; CW	2180
	!BYTE	$54			; CALL	_C002
_F1338 	!WORD	_C002		
_B1025 
_B1026 
; toolsrc/parse.pla: 1076:             modsysflags, drop, drop = parse_constexpr
; toolsrc/parse.pla: 1077:             break
	!BYTE	$54			; CALL	_C089
_F1339 	!WORD	_C089		
	!BYTE	$30			; DROP 
	!BYTE	$30			; DROP 
	!BYTE	$7A			; SAW	_D077+0
_F1340 	!WORD	_D077+0		
	!BYTE	$50			; BRNCH	_B1022
	!WORD	_B1022-*
; toolsrc/parse.pla: 1078:         is CONST_TKN
_B1027 
; toolsrc/parse.pla: 1079:             if type & LOCAL_TYPE; exit_err(ERR_INVAL|ERR_GLOBAL|ERR_INIT); fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$10			; ANDI	16
	!BYTE	$4C			; BRFLS	_B1028
	!WORD	_B1028-*
	!BYTE	$2C,$84,$08		; CW	2180
	!BYTE	$54			; CALL	_C002
_F1341 	!WORD	_C002		
_B1028 
_B1029 
; toolsrc/parse.pla: 1080:             if scan <> ID_TKN; exit_err(ERR_INVAL|ERR_CONST); fin
	!BYTE	$54			; CALL	_C076
_F1342 	!WORD	_C076		
	!BYTE	$2A,$D6			; CB	214
	!BYTE	$22			; BREQ	_B1030
	!WORD	_B1030-*
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$54			; CALL	_C002
_F1343 	!WORD	_C002		
_B1030 
_B1031 
; toolsrc/parse.pla: 1081:             idptr = tknptr
; toolsrc/parse.pla: 1082:             idlen = tknlen
; toolsrc/parse.pla: 1083:             if scan <> SET_TKN; exit_err(ERR_INVAL|ERR_CONST); fin
	!BYTE	$6A			; LAW	_D101+0
_F1344 	!WORD	_D101+0		
	!BYTE	$76,$0B			; SLW	[11]
	!BYTE	$68			; LAB	_D100+0
_F1345 	!WORD	_D100+0		
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$54			; CALL	_C076
_F1346 	!WORD	_C076		
	!BYTE	$2A,$BD			; CB	189
	!BYTE	$22			; BREQ	_B1032
	!WORD	_B1032-*
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$54			; CALL	_C002
_F1347 	!WORD	_C002		
_B1032 
_B1033 
; toolsrc/parse.pla: 1084:             value, size, type = parse_constexpr
; toolsrc/parse.pla: 1085:             new_idconst(idptr, idlen, value)
; toolsrc/parse.pla: 1086:             break
	!BYTE	$54			; CALL	_C089
_F1348 	!WORD	_C089		
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$76,$07			; SLW	[7]
	!BYTE	$76,$09			; SLW	[9]
	!BYTE	$66,$0B			; LLW	[11]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$66,$09			; LLW	[9]
	!BYTE	$54			; CALL	_C049
_F1349 	!WORD	_C049		
	!BYTE	$50			; BRNCH	_B1022
	!WORD	_B1022-*
; toolsrc/parse.pla: 1087:         is STRUC_TKN
_B1034 
; toolsrc/parse.pla: 1088:             parse_struc
; toolsrc/parse.pla: 1089:             break
	!BYTE	$54			; CALL	_C098
_F1350 	!WORD	_C098		
	!BYTE	$50			; BRNCH	_B1022
	!WORD	_B1022-*
; toolsrc/parse.pla: 1090:         is EXPORT_TKN
_B1035 
; toolsrc/parse.pla: 1091:             if type & (EXTERN_TYPE|LOCAL_TYPE); exit_err(ERR_INVAL|ERR_LOCAL|ERR_SYNTAX); fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$10,$04		; CW	1040
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B1036
	!WORD	_B1036-*
	!BYTE	$2C,$44,$80		; CW	32836
	!BYTE	$54			; CALL	_C002
_F1351 	!WORD	_C002		
_B1036 
_B1037 
; toolsrc/parse.pla: 1092:             type  = EXPORT_TYPE
; toolsrc/parse.pla: 1093:             idptr = tknptr
; toolsrc/parse.pla: 1094:             if scan <> BYTE_TKN and token <> WORD_TKN // This could be an exported definition
; toolsrc/parse.pla: 1095:                 rewind(idptr)
; toolsrc/parse.pla: 1096:                 scan
; toolsrc/parse.pla: 1097:                 return FALSE
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$6A			; LAW	_D101+0
_F1352 	!WORD	_D101+0		
	!BYTE	$76,$0B			; SLW	[11]
	!BYTE	$54			; CALL	_C076
_F1353 	!WORD	_C076		
	!BYTE	$2A,$81			; CB	129
	!BYTE	$42			; ISNE
	!BYTE	$AC			; BRAND	_B1038
	!WORD	_B1038-*
	!BYTE	$68			; LAB	_D098+0
_F1354 	!WORD	_D098+0		
	!BYTE	$2A,$82			; CB	130
	!BYTE	$42			; ISNE
_B1038 
	!BYTE	$4C			; BRFLS	_B1039
	!WORD	_B1039-*
	!BYTE	$66,$0B			; LLW	[11]
	!BYTE	$54			; CALL	_C077
_F1355 	!WORD	_C077		
	!BYTE	$54			; CALL	_C076
_F1356 	!WORD	_C076		
	!BYTE	$30			; DROP 
	!BYTE	$00			; CN	0
	!BYTE	$5A,$0D			; LEAVE	13
; toolsrc/parse.pla: 1098:             fin
_B1039 
_B1040 
; toolsrc/parse.pla: 1099:             // Fall through to BYTE or WORD declaration
; toolsrc/parse.pla: 1100:         is BYTE_TKN
_B1041 
; toolsrc/parse.pla: 1101:         is WORD_TKN
_B1042 
; toolsrc/parse.pla: 1102:             type = type | (token == BYTE_TKN ?? BYTE_TYPE :: WORD_TYPE)
; toolsrc/parse.pla: 1103:             size = 1
; toolsrc/parse.pla: 1104:             if scan == OPEN_BRACKET_TKN // Get basesize for data elements
; toolsrc/parse.pla: 1105:               size, drop, drop = parse_constexpr
; toolsrc/parse.pla: 1106:               if token <> CLOSE_BRACKET_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_SYNTAX); fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$68			; LAB	_D098+0
_F1357 	!WORD	_D098+0		
	!BYTE	$2A,$81			; CB	129
	!BYTE	$24			; BRNE	_B1043
	!WORD	_B1043-*
	!BYTE	$04			; CN	2
	!BYTE	$50			; BRNCH	_B1044
	!WORD	_B1044-*
_B1043 
	!BYTE	$08			; CN	4
_B1044 
	!BYTE	$96			; OR 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$02			; CN	1
	!BYTE	$76,$07			; SLW	[7]
	!BYTE	$54			; CALL	_C076
_F1358 	!WORD	_C076		
	!BYTE	$2A,$DB			; CB	219
	!BYTE	$24			; BRNE	_B1045
	!WORD	_B1045-*
	!BYTE	$54			; CALL	_C089
_F1359 	!WORD	_C089		
	!BYTE	$30			; DROP 
	!BYTE	$30			; DROP 
	!BYTE	$76,$07			; SLW	[7]
	!BYTE	$68			; LAB	_D098+0
_F1360 	!WORD	_D098+0		
	!BYTE	$2A,$DD			; CB	221
	!BYTE	$22			; BREQ	_B1047
	!WORD	_B1047-*
	!BYTE	$2C,$28,$80		; CW	32808
	!BYTE	$54			; CALL	_C002
_F1361 	!WORD	_C002		
_B1047 
_B1048 
; toolsrc/parse.pla: 1107:             else
	!BYTE	$50			; BRNCH	_B1046
	!WORD	_B1046-*
_B1045 
; toolsrc/parse.pla: 1108:                 rewind(tknptr)
; toolsrc/parse.pla: 1109:             fin
	!BYTE	$6A			; LAW	_D101+0
_F1362 	!WORD	_D101+0		
	!BYTE	$54			; CALL	_C077
_F1363 	!WORD	_C077		
_B1046 
; toolsrc/parse.pla: 1110:             if type & WORD_TYPE; size = size * 2; fin
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$3C,$04			; ANDI	4
	!BYTE	$4C			; BRFLS	_B1049
	!WORD	_B1049-*
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$34			; DUP
	!BYTE	$82			; ADD 
	!BYTE	$76,$07			; SLW	[7]
_B1049 
_B1050 
; toolsrc/parse.pla: 1111:             repeat; parse_var(type, size, ignore_vars); until token <> COMMA_TKN
_B1052 
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$66,$07			; LLW	[7]
	!BYTE	$66,$02			; LLW	[2]
	!BYTE	$54			; CALL	_C097
_F1364 	!WORD	_C097		
_B1053 
	!BYTE	$68			; LAB	_D098+0
_F1365 	!WORD	_D098+0		
	!BYTE	$2A,$AC			; CB	172
	!BYTE	$22			; BREQ	_B1052
	!WORD	_B1052-*
_B1051 
; toolsrc/parse.pla: 1112:             break
	!BYTE	$50			; BRNCH	_B1022
	!WORD	_B1022-*
; toolsrc/parse.pla: 1113:         is PREDEF_TKN
_B1054 
; toolsrc/parse.pla: 1114:             repeat
_B1056 
; toolsrc/parse.pla: 1115:                 if scan == ID_TKN
; toolsrc/parse.pla: 1116:                     type     = type | PREDEF_TYPE
; toolsrc/parse.pla: 1117:                     idptr    = tknptr
; toolsrc/parse.pla: 1118:                     idlen    = tknlen
; toolsrc/parse.pla: 1119:                     cfnparms = 0
; toolsrc/parse.pla: 1120:                     cfnvals  = 1 // Default to one return value for compatibility
; toolsrc/parse.pla: 1121:                     if scan == OPEN_PAREN_TKN
; toolsrc/parse.pla: 1122:                         repeat
	!BYTE	$54			; CALL	_C076
_F1366 	!WORD	_C076		
	!BYTE	$2A,$D6			; CB	214
	!BYTE	$24			; BRNE	_B1058
	!WORD	_B1058-*
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$2C,$00,$01		; CW	256
	!BYTE	$96			; OR 
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$6A			; LAW	_D101+0
_F1367 	!WORD	_D101+0		
	!BYTE	$76,$0B			; SLW	[11]
	!BYTE	$68			; LAB	_D100+0
_F1368 	!WORD	_D100+0		
	!BYTE	$74,$04			; SLB	[4]
	!BYTE	$00			; CN	0
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$02			; CN	1
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$54			; CALL	_C076
_F1369 	!WORD	_C076		
	!BYTE	$2A,$A8			; CB	168
	!BYTE	$24			; BRNE	_B1060
	!WORD	_B1060-*
_B1063 
; toolsrc/parse.pla: 1123:                             if scan == ID_TKN
; toolsrc/parse.pla: 1124:                                 cfnparms++
	!BYTE	$54			; CALL	_C076
_F1370 	!WORD	_C076		
	!BYTE	$2A,$D6			; CB	214
	!BYTE	$24			; BRNE	_B1065
	!WORD	_B1065-*
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 1125:                                 scan
; toolsrc/parse.pla: 1126:                             fin
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$54			; CALL	_C076
_F1371 	!WORD	_C076		
	!BYTE	$30			; DROP 
_B1065 
_B1066 
; toolsrc/parse.pla: 1127:                         until token <> COMMA_TKN
_B1064 
	!BYTE	$68			; LAB	_D098+0
_F1372 	!WORD	_D098+0		
	!BYTE	$2A,$AC			; CB	172
	!BYTE	$22			; BREQ	_B1063
	!WORD	_B1063-*
_B1062 
; toolsrc/parse.pla: 1128:                         if token <> CLOSE_PAREN_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_SYNTAX); fin
	!BYTE	$68			; LAB	_D098+0
_F1373 	!WORD	_D098+0		
	!BYTE	$2A,$A9			; CB	169
	!BYTE	$22			; BREQ	_B1067
	!WORD	_B1067-*
	!BYTE	$2C,$28,$80		; CW	32808
	!BYTE	$54			; CALL	_C002
_F1374 	!WORD	_C002		
_B1067 
_B1068 
; toolsrc/parse.pla: 1129:                         scan
; toolsrc/parse.pla: 1130:                     fin
	!BYTE	$54			; CALL	_C076
_F1375 	!WORD	_C076		
	!BYTE	$30			; DROP 
_B1060 
_B1061 
; toolsrc/parse.pla: 1131:                     if token == POUND_TKN
; toolsrc/parse.pla: 1132:                         if not parse_const(@cfnvals); exit_err(ERR_INVAL|ERR_CONST); fin
	!BYTE	$68			; LAB	_D098+0
_F1376 	!WORD	_D098+0		
	!BYTE	$2A,$A3			; CB	163
	!BYTE	$24			; BRNE	_B1069
	!WORD	_B1069-*
	!BYTE	$28,$06			; LLA	[6]
	!BYTE	$54			; CALL	_C090
_F1377 	!WORD	_C090		
	!BYTE	$4E			; BRTRU	_B1071
	!WORD	_B1071-*
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$54			; CALL	_C002
_F1378 	!WORD	_C002		
_B1071 
_B1072 
; toolsrc/parse.pla: 1133:                         scan
; toolsrc/parse.pla: 1134:                     fin
	!BYTE	$54			; CALL	_C076
_F1379 	!WORD	_C076		
	!BYTE	$30			; DROP 
_B1069 
_B1070 
; toolsrc/parse.pla: 1135:                     new_idfunc(idptr, idlen, type, new_tag(type & EXTERN_TYPE ?? EXTERN_FIXUP|WORD_FIXUP :: WORD_FIXUP), cfnparms, cfnvals)
; toolsrc/parse.pla: 1136:                 else
	!BYTE	$66,$0B			; LLW	[11]
	!BYTE	$64,$04			; LLB	[4]
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$34			; DUP
	!BYTE	$2C,$00,$04		; CW	1024
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B1075
	!WORD	_B1075-*
	!BYTE	$2A,$90			; CB	144
	!BYTE	$50			; BRNCH	_B1076
	!WORD	_B1076-*
_B1075 
	!BYTE	$2A,$80			; CB	128
_B1076 
	!BYTE	$54			; CALL	_C004
_F1380 	!WORD	_C004		
	!BYTE	$64,$05			; LLB	[5]
	!BYTE	$64,$06			; LLB	[6]
	!BYTE	$54			; CALL	_C050
_F1381 	!WORD	_C050		
	!BYTE	$50			; BRNCH	_B1059
	!WORD	_B1059-*
_B1058 
; toolsrc/parse.pla: 1137:                     exit_err(ERR_MISS|ERR_ID)
; toolsrc/parse.pla: 1138:                 fin
	!BYTE	$2C,$08,$02		; CW	520
	!BYTE	$54			; CALL	_C002
_F1382 	!WORD	_C002		
_B1059 
; toolsrc/parse.pla: 1139:             until token <> COMMA_TKN
_B1057 
	!BYTE	$68			; LAB	_D098+0
_F1383 	!WORD	_D098+0		
	!BYTE	$2A,$AC			; CB	172
	!BYTE	$22			; BREQ	_B1056
	!WORD	_B1056-*
_B1055 
; toolsrc/parse.pla: 1140:             break
	!BYTE	$50			; BRNCH	_B1022
	!WORD	_B1022-*
; toolsrc/parse.pla: 1141:         is IMPORT_TKN
_B1077 
; toolsrc/parse.pla: 1142:             if codeptr <> codebuff or type <> GLOBAL_TYPE; exit_err(ERR_INVAL|ERR_INIT); fin
	!BYTE	$6A			; LAW	_D075+0
_F1384 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D074+0
_F1385 	!WORD	_D074+0		
	!BYTE	$42			; ISNE
	!BYTE	$AE			; BROR	_B1078
	!WORD	_B1078-*
	!BYTE	$66,$00			; LLW	[0]
_B1078 
	!BYTE	$4C			; BRFLS	_B1079
	!WORD	_B1079-*
	!BYTE	$2C,$04,$08		; CW	2052
	!BYTE	$54			; CALL	_C002
_F1386 	!WORD	_C002		
_B1079 
_B1080 
; toolsrc/parse.pla: 1143:             parse_mods
; toolsrc/parse.pla: 1144:             break
	!BYTE	$54			; CALL	_P000
_F1387 	!WORD	_P000		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B1022
	!WORD	_B1022-*
; toolsrc/parse.pla: 1145:         is EOL_TKN
_B1081 
; toolsrc/parse.pla: 1146:             break
	!BYTE	$50			; BRNCH	_B1022
	!WORD	_B1022-*
; toolsrc/parse.pla: 1147:         otherwise
_B1023 
	!BYTE	$09			; CASEBLOCK
	!WORD	$0002
	!WORD	_B1081-*
	!WORD	$0080
	!WORD	_B1027-*
	!WORD	$0081
	!WORD	_B1041-*
	!WORD	$0082
	!WORD	_B1042-*
	!WORD	$0096
	!WORD	_B1034-*
	!WORD	$0097
	!WORD	_B1024-*
	!WORD	$009C
	!WORD	_B1054-*
	!WORD	$009D
	!WORD	_B1077-*
	!WORD	$009E
	!WORD	_B1035-*
; toolsrc/parse.pla: 1148:             return FALSE
	!BYTE	$00			; CN	0
	!BYTE	$5A,$0D			; LEAVE	13
; toolsrc/parse.pla: 1149:     wend
_B1022 
; toolsrc/parse.pla: 1150:     return TRUE
	!BYTE	$20			; MINUS ONE
	!BYTE	$5A,$0D			; LEAVE	13
; toolsrc/parse.pla: 1151: end
; toolsrc/parse.pla: 1152: def parse_mods
_P000 					; parse_mods()
_C100 					; parse_mods()
; toolsrc/parse.pla: 1153:     byte i, ignore_emit
					; i -> [0]
					; ignore_emit -> [1]
; toolsrc/parse.pla: 1154: 
; toolsrc/parse.pla: 1155:     if token == IMPORT_TKN
	!BYTE	$58,$02,$00		; ENTER	2,0
; toolsrc/parse.pla: 1156:         if scan <> ID_TKN; exit_err(ERR_MISS|ERR_ID); fin
	!BYTE	$68			; LAB	_D098+0
_F1388 	!WORD	_D098+0		
	!BYTE	$2A,$9D			; CB	157
	!BYTE	$24			; BRNE	_B1082
	!WORD	_B1082-*
	!BYTE	$54			; CALL	_C076
_F1389 	!WORD	_C076		
	!BYTE	$2A,$D6			; CB	214
	!BYTE	$22			; BREQ	_B1084
	!WORD	_B1084-*
	!BYTE	$2C,$08,$02		; CW	520
	!BYTE	$54			; CALL	_C002
_F1390 	!WORD	_C002		
_B1084 
_B1085 
; toolsrc/parse.pla: 1157:         if tknlen == modfile
; toolsrc/parse.pla: 1158:             ignore_emit = TRUE
; toolsrc/parse.pla: 1159:             for i = 1 to tknlen
	!BYTE	$68			; LAB	_D100+0
_F1391 	!WORD	_D100+0		
	!BYTE	$68			; LAB	_D092+0
_F1392 	!WORD	_D092+0		
	!BYTE	$24			; BRNE	_B1086
	!WORD	_B1086-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$68			; LAB	_D100+0
_F1393 	!WORD	_D100+0		
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B1088
	!WORD	_B1088-*
_B1089 
	!BYTE	$6C,$00			; DLB	[0]
; toolsrc/parse.pla: 1160:                 if toupper(tknptr->[i - 1]) <> modfile[i]; ignore_emit = FALSE; break; fin
	!BYTE	$6A			; LAW	_D101+0
_F1394 	!WORD	_D101+0		
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$8E			; DECR
	!BYTE	$82			; ADD 
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F1395 	!WORD	0		
	!BYTE	$26			; LA	_D092+0
_F1396 	!WORD	_D092+0		
	!BYTE	$B0,$00			; ADDLB	[0]
	!BYTE	$60			; LB
	!BYTE	$22			; BREQ	_B1091
	!WORD	_B1091-*
	!BYTE	$00			; CN	0
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$50			; BRNCH	_B1088
	!WORD	_B1088-*
_B1091 
_B1092 
; toolsrc/parse.pla: 1161:             next
_B1090 
	!BYTE	$A4			; INCBRLE	_B1089
	!WORD	_B1089-*
_B1088 
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$30			; DROP 
; toolsrc/parse.pla: 1162:         else
	!BYTE	$50			; BRNCH	_B1087
	!WORD	_B1087-*
_B1086 
; toolsrc/parse.pla: 1163:             ignore_emit = FALSE
; toolsrc/parse.pla: 1164:         fin
	!BYTE	$00			; CN	0
	!BYTE	$74,$01			; SLB	[1]
_B1087 
; toolsrc/parse.pla: 1165:         if not ignore_emit
; toolsrc/parse.pla: 1166:             new_moddep(tknptr, tknlen)
; toolsrc/parse.pla: 1167:         fin
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$4E			; BRTRU	_B1093
	!WORD	_B1093-*
	!BYTE	$6A			; LAW	_D101+0
_F1397 	!WORD	_D101+0		
	!BYTE	$68			; LAB	_D100+0
_F1398 	!WORD	_D100+0		
	!BYTE	$54			; CALL	_C057
_F1399 	!WORD	_C057		
_B1093 
_B1094 
; toolsrc/parse.pla: 1168:         scan
; toolsrc/parse.pla: 1169:         while parse_vars(EXTERN_TYPE, ignore_emit); nextln; loop
	!BYTE	$54			; CALL	_C076
_F1400 	!WORD	_C076		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B1097
	!WORD	_B1097-*
_B1095 
	!BYTE	$54			; CALL	_C079
_F1401 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B1097 
	!BYTE	$2C,$00,$04		; CW	1024
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$54			; CALL	_C099
_F1402 	!WORD	_C099		
	!BYTE	$4E			; BRTRU	_B1095
	!WORD	_B1095-*
_B1096 
; toolsrc/parse.pla: 1170:         if token <> END_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_STATE); fin
	!BYTE	$68			; LAB	_D098+0
_F1403 	!WORD	_D098+0		
	!BYTE	$2A,$87			; CB	135
	!BYTE	$22			; BREQ	_B1098
	!WORD	_B1098-*
	!BYTE	$2C,$28,$10		; CW	4136
	!BYTE	$54			; CALL	_C002
_F1404 	!WORD	_C002		
_B1098 
_B1099 
; toolsrc/parse.pla: 1171:         scan
; toolsrc/parse.pla: 1172:     fin
	!BYTE	$54			; CALL	_C076
_F1405 	!WORD	_C076		
	!BYTE	$30			; DROP 
_B1082 
_B1083 
; toolsrc/parse.pla: 1173:     return token == EOL_TKN
	!BYTE	$68			; LAB	_D098+0
_F1406 	!WORD	_D098+0		
	!BYTE	$04			; CN	2
	!BYTE	$40			; ISEQ
	!BYTE	$5A,$02			; LEAVE	2
; toolsrc/parse.pla: 1174: end
; toolsrc/parse.pla: 1175: def parse_lambda
_P004 					; parse_lambda()
_C101 					; parse_lambda()
; toolsrc/parse.pla: 1176:     word func_tag
					; func_tag -> [0]
; toolsrc/parse.pla: 1177:     byte cfnparms
					; cfnparms -> [2]
; toolsrc/parse.pla: 1178:     byte lambda_id[4]
					; lambda_id -> [3]
; toolsrc/parse.pla: 1179: 
; toolsrc/parse.pla: 1180:     if not infunc; exit_err(ERR_INVAL|ERR_STATE); fin
	!BYTE	$58,$07,$00		; ENTER	7,0
	!BYTE	$68			; LAB	_D107+0
_F1407 	!WORD	_D107+0		
	!BYTE	$4E			; BRTRU	_B1100
	!WORD	_B1100-*
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1408 	!WORD	_C002		
_B1100 
_B1101 
; toolsrc/parse.pla: 1181:     if inlambda; puts("Nested lambdas!\n"); exit_err(0); fin
	!BYTE	$68			; LAB	_D108+0
_F1409 	!WORD	_D108+0		
	!BYTE	$4C			; BRFLS	_B1102
	!WORD	_B1102-*
	!BYTE	$2E			; CS
	!BYTE	$10
	!BYTE	$4E,$65,$73,$74,$65,$64,$20,$6C
	!BYTE	$61,$6D,$62,$64,$61,$73,$21,$0D
	!BYTE	$54			; CALL	_X004
_F1410 	!WORD	0		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C002
_F1411 	!WORD	_C002		
_B1102 
_B1103 
; toolsrc/parse.pla: 1182:     //
; toolsrc/parse.pla: 1183:     // Parse parameters and return value count
; toolsrc/parse.pla: 1184:     //
; toolsrc/parse.pla: 1185:     save_idlocal
; toolsrc/parse.pla: 1186:     init_idlocal
; toolsrc/parse.pla: 1187:     cfnparms = 0
; toolsrc/parse.pla: 1188:     inlambda = TRUE
; toolsrc/parse.pla: 1189:     if scan == OPEN_PAREN_TKN
; toolsrc/parse.pla: 1190:         repeat
	!BYTE	$54			; CALL	_C055
_F1412 	!WORD	_C055		
	!BYTE	$54			; CALL	_C054
_F1413 	!WORD	_C054		
	!BYTE	$00			; CN	0
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$20			; MINUS ONE
	!BYTE	$78			; SAB	_D108+0
_F1414 	!WORD	_D108+0		
	!BYTE	$54			; CALL	_C076
_F1415 	!WORD	_C076		
	!BYTE	$2A,$A8			; CB	168
	!BYTE	$24			; BRNE	_B1104
	!WORD	_B1104-*
_B1107 
; toolsrc/parse.pla: 1191:             if scan == ID_TKN
; toolsrc/parse.pla: 1192:                 cfnparms++
	!BYTE	$54			; CALL	_C076
_F1416 	!WORD	_C076		
	!BYTE	$2A,$D6			; CB	214
	!BYTE	$24			; BRNE	_B1109
	!WORD	_B1109-*
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 1193:                 new_idlocal(tknptr, tknlen, WORD_TYPE, 2)
; toolsrc/parse.pla: 1194:                 scan
; toolsrc/parse.pla: 1195:             fin
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$6A			; LAW	_D101+0
_F1417 	!WORD	_D101+0		
	!BYTE	$68			; LAB	_D100+0
_F1418 	!WORD	_D100+0		
	!BYTE	$08			; CN	4
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C053
_F1419 	!WORD	_C053		
	!BYTE	$54			; CALL	_C076
_F1420 	!WORD	_C076		
	!BYTE	$30			; DROP 
_B1109 
_B1110 
; toolsrc/parse.pla: 1196:         until token <> COMMA_TKN
_B1108 
	!BYTE	$68			; LAB	_D098+0
_F1421 	!WORD	_D098+0		
	!BYTE	$2A,$AC			; CB	172
	!BYTE	$22			; BREQ	_B1107
	!WORD	_B1107-*
_B1106 
; toolsrc/parse.pla: 1197:         if token <> CLOSE_PAREN_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_SYNTAX); fin
	!BYTE	$68			; LAB	_D098+0
_F1422 	!WORD	_D098+0		
	!BYTE	$2A,$A9			; CB	169
	!BYTE	$22			; BREQ	_B1111
	!WORD	_B1111-*
	!BYTE	$2C,$28,$80		; CW	32808
	!BYTE	$54			; CALL	_C002
_F1423 	!WORD	_C002		
_B1111 
_B1112 
; toolsrc/parse.pla: 1198:     else
	!BYTE	$50			; BRNCH	_B1105
	!WORD	_B1105-*
_B1104 
; toolsrc/parse.pla: 1199:         exit_err(ERR_MISS|ERR_ID)
; toolsrc/parse.pla: 1200:     fin
	!BYTE	$2C,$08,$02		; CW	520
	!BYTE	$54			; CALL	_C002
_F1424 	!WORD	_C002		
_B1105 
; toolsrc/parse.pla: 1201:     if lookahead == OPEN_PAREN_TKN
; toolsrc/parse.pla: 1202:         scan
; toolsrc/parse.pla: 1203:         lambda_seq[lambda_cnt], drop = parse_list
; toolsrc/parse.pla: 1204:         if token <> CLOSE_PAREN_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_SYNTAX); fin
	!BYTE	$54			; CALL	_C078
_F1425 	!WORD	_C078		
	!BYTE	$2A,$A8			; CB	168
	!BYTE	$24			; BRNE	_B1113
	!WORD	_B1113-*
	!BYTE	$54			; CALL	_C076
_F1426 	!WORD	_C076		
	!BYTE	$30			; DROP 
	!BYTE	$54			; CALL	_C091
_F1427 	!WORD	_C091		
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D117+0
_F1428 	!WORD	_D117+0		
	!BYTE	$BC			; IDXAB	_D114+0
_F1429 	!WORD	_D114+0		
	!BYTE	$72			; SW
	!BYTE	$68			; LAB	_D098+0
_F1430 	!WORD	_D098+0		
	!BYTE	$2A,$A9			; CB	169
	!BYTE	$22			; BREQ	_B1115
	!WORD	_B1115-*
	!BYTE	$2C,$28,$80		; CW	32808
	!BYTE	$54			; CALL	_C002
_F1431 	!WORD	_C002		
_B1115 
_B1116 
; toolsrc/parse.pla: 1205:     else
	!BYTE	$50			; BRNCH	_B1114
	!WORD	_B1114-*
_B1113 
; toolsrc/parse.pla: 1206:         lambda_seq[lambda_cnt], drop = parse_expr(NULL)
; toolsrc/parse.pla: 1207:         rewind(tknptr)
; toolsrc/parse.pla: 1208:     fin
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C094
_F1432 	!WORD	_C094		
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D117+0
_F1433 	!WORD	_D117+0		
	!BYTE	$BC			; IDXAB	_D114+0
_F1434 	!WORD	_D114+0		
	!BYTE	$72			; SW
	!BYTE	$6A			; LAW	_D101+0
_F1435 	!WORD	_D101+0		
	!BYTE	$54			; CALL	_C077
_F1436 	!WORD	_C077		
_B1114 
; toolsrc/parse.pla: 1209:     //
; toolsrc/parse.pla: 1210:     // Build an anonymous ID string for the Lambda function
; toolsrc/parse.pla: 1211:     //
; toolsrc/parse.pla: 1212:     lambda_id:0 = 3 | ('&' << 8)
; toolsrc/parse.pla: 1213:     lambda_id.2 = ((lambda_num >> 3) & $07) + '0'
; toolsrc/parse.pla: 1214:     lambda_id.3 =  (lambda_num       & $07) + '0'
; toolsrc/parse.pla: 1215:     lambda_num++
	!BYTE	$2C,$03,$26		; CW	9731
	!BYTE	$76,$03			; SLW	[3]
	!BYTE	$68			; LAB	_D115+0
_F1437 	!WORD	_D115+0		
	!BYTE	$06			; CN	3
	!BYTE	$9C			; SHR
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$38,$30			; ADDI	48
	!BYTE	$74,$05			; SLB	[5]
	!BYTE	$68			; LAB	_D115+0
_F1438 	!WORD	_D115+0		
	!BYTE	$3C,$07			; ANDI	7
	!BYTE	$38,$30			; ADDI	48
	!BYTE	$74,$06			; SLB	[6]
	!BYTE	$68			; LAB	_D115+0
_F1439 	!WORD	_D115+0		
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 1216:     if lookup_idglobal(@lambda_id.1, 3)
; toolsrc/parse.pla: 1217:         //
; toolsrc/parse.pla: 1218:         // Lambda ID already exists (from failed scanning for '=')
; toolsrc/parse.pla: 1219:         //
; toolsrc/parse.pla: 1220:         func_tag = lambda_tag[lambda_cnt]
; toolsrc/parse.pla: 1221:         set_idfunc(@lambda_id.1, 3, func_tag, cfnparms, 1) // Override any predef type & tag
; toolsrc/parse.pla: 1222:     else
	!BYTE	$78			; SAB	_D115+0
_F1440 	!WORD	_D115+0		
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$06			; CN	3
	!BYTE	$54			; CALL	_C045
_F1441 	!WORD	_C045		
	!BYTE	$4C			; BRFLS	_B1117
	!WORD	_B1117-*
	!BYTE	$26			; LA	_D118+0
_F1442 	!WORD	_D118+0		
	!BYTE	$BC			; IDXAB	_D114+0
_F1443 	!WORD	_D114+0		
	!BYTE	$62			; LW
	!BYTE	$76,$00			; SLW	[0]
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$06			; CN	3
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C051
_F1444 	!WORD	_C051		
	!BYTE	$50			; BRNCH	_B1118
	!WORD	_B1118-*
_B1117 
; toolsrc/parse.pla: 1223:         //
; toolsrc/parse.pla: 1224:         // Creat new Lambda ID
; toolsrc/parse.pla: 1225:         //
; toolsrc/parse.pla: 1226:         func_tag                  = new_tag(WORD_FIXUP)
; toolsrc/parse.pla: 1227:         lambda_tag[lambda_cnt]    = func_tag
; toolsrc/parse.pla: 1228:         lambda_cparms[lambda_cnt] = cfnparms
; toolsrc/parse.pla: 1229:         new_idfunc(@lambda_id.1, 3, FUNC_TYPE, func_tag, cfnparms, 1)
; toolsrc/parse.pla: 1230:     fin
	!BYTE	$2A,$80			; CB	128
	!BYTE	$54			; CALL	_C004
_F1445 	!WORD	_C004		
	!BYTE	$6E,$00			; DLW	[0]
	!BYTE	$26			; LA	_D118+0
_F1446 	!WORD	_D118+0		
	!BYTE	$BC			; IDXAB	_D114+0
_F1447 	!WORD	_D114+0		
	!BYTE	$72			; SW
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$26			; LA	_D116+0
_F1448 	!WORD	_D116+0		
	!BYTE	$B4			; ADDAB	_D114+0
_F1449 	!WORD	_D114+0		
	!BYTE	$70			; SB
	!BYTE	$28,$04			; LLA	[4]
	!BYTE	$06			; CN	3
	!BYTE	$10			; CN	8
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$64,$02			; LLB	[2]
	!BYTE	$02			; CN	1
	!BYTE	$54			; CALL	_C050
_F1450 	!WORD	_C050		
_B1118 
; toolsrc/parse.pla: 1231:     lambda_cnt++
	!BYTE	$68			; LAB	_D114+0
_F1451 	!WORD	_D114+0		
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 1232:     if lambda_cnt >= LAMBDANUM; parse_warn("Lambda function overflow"); fin
	!BYTE	$7C			; DAB	_D114+0
_F1452 	!WORD	_D114+0		
	!BYTE	$2A,$10			; CB	16
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B1119
	!WORD	_B1119-*
	!BYTE	$2E			; CS
	!BYTE	$18
	!BYTE	$4C,$61,$6D,$62,$64,$61,$20,$66
	!BYTE	$75,$6E,$63,$74,$69,$6F,$6E,$20
	!BYTE	$6F,$76,$65,$72,$66,$6C,$6F,$77
	!BYTE	$54			; CALL	_C003
_F1453 	!WORD	_C003		
_B1119 
_B1120 
; toolsrc/parse.pla: 1233:     inlambda = FALSE
; toolsrc/parse.pla: 1234:     restore_idlocal
; toolsrc/parse.pla: 1235:     return func_tag
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D108+0
_F1454 	!WORD	_D108+0		
	!BYTE	$54			; CALL	_C056
_F1455 	!WORD	_C056		
	!BYTE	$66,$00			; LLW	[0]
	!BYTE	$5A,$07			; LEAVE	7
; toolsrc/parse.pla: 1236: end
; toolsrc/parse.pla: 1237: def parse_defs
_C102 					; parse_defs()
; toolsrc/parse.pla: 1238:     byte idlen, cfnparms, cfnvals, defstr[17]
					; idlen -> [0]
					; cfnparms -> [1]
					; cfnvals -> [2]
					; defstr -> [3]
; toolsrc/parse.pla: 1239:     word type, idstr, func_tag, idptr, defcodeptr
					; type -> [20]
					; idstr -> [22]
					; func_tag -> [24]
					; idptr -> [26]
					; defcodeptr -> [28]
; toolsrc/parse.pla: 1240:     type = FUNC_TYPE
	!BYTE	$58,$1E,$00		; ENTER	30,0
; toolsrc/parse.pla: 1241:     when token
	!BYTE	$10			; CN	8
	!BYTE	$76,$14			; SLW	[20]
	!BYTE	$68			; LAB	_D098+0
_F1456 	!WORD	_D098+0		
	!BYTE	$52			; SEL
	!WORD	_B1122-*
; toolsrc/parse.pla: 1242:         is CONST_TKN
_B1123 
; toolsrc/parse.pla: 1243:         is STRUC_TKN
_B1124 
; toolsrc/parse.pla: 1244:             return parse_vars(GLOBAL_TYPE, FALSE)
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C099
_F1457 	!WORD	_C099		
	!BYTE	$5A,$1E			; LEAVE	30
; toolsrc/parse.pla: 1245:         is EXPORT_TKN
_B1125 
; toolsrc/parse.pla: 1246:             if scan <> DEF_TKN; exit_err(ERR_INVAL|ERR_STATE); fin
	!BYTE	$54			; CALL	_C076
_F1458 	!WORD	_C076		
	!BYTE	$2A,$95			; CB	149
	!BYTE	$22			; BREQ	_B1126
	!WORD	_B1126-*
	!BYTE	$2C,$04,$10		; CW	4100
	!BYTE	$54			; CALL	_C002
_F1459 	!WORD	_C002		
_B1126 
_B1127 
; toolsrc/parse.pla: 1247:             type = type | EXPORT_TYPE
; toolsrc/parse.pla: 1248:         is DEF_TKN
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$2C,$00,$02		; CW	512
	!BYTE	$96			; OR 
	!BYTE	$76,$14			; SLW	[20]
_B1128 
; toolsrc/parse.pla: 1249:             if scan <> ID_TKN; exit_err(ERR_INVAL|ERR_ID); fin
	!BYTE	$54			; CALL	_C076
_F1460 	!WORD	_C076		
	!BYTE	$2A,$D6			; CB	214
	!BYTE	$22			; BREQ	_B1129
	!WORD	_B1129-*
	!BYTE	$2C,$04,$02		; CW	516
	!BYTE	$54			; CALL	_C002
_F1461 	!WORD	_C002		
_B1129 
_B1130 
; toolsrc/parse.pla: 1250:             lambda_cnt = 0
; toolsrc/parse.pla: 1251:             cfnparms   = 0
; toolsrc/parse.pla: 1252:             infuncvals = 1
; toolsrc/parse.pla: 1253:             infunc     = TRUE
; toolsrc/parse.pla: 1254:             idstr      = tknptr
; toolsrc/parse.pla: 1255:             idlen      = tknlen
; toolsrc/parse.pla: 1256:             init_idlocal
; toolsrc/parse.pla: 1257:             if scan == OPEN_PAREN_TKN
; toolsrc/parse.pla: 1258:                 repeat
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D114+0
_F1462 	!WORD	_D114+0		
	!BYTE	$00			; CN	0
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$02			; CN	1
	!BYTE	$7A			; SAW	_D111+0
_F1463 	!WORD	_D111+0		
	!BYTE	$20			; MINUS ONE
	!BYTE	$78			; SAB	_D107+0
_F1464 	!WORD	_D107+0		
	!BYTE	$6A			; LAW	_D101+0
_F1465 	!WORD	_D101+0		
	!BYTE	$76,$16			; SLW	[22]
	!BYTE	$68			; LAB	_D100+0
_F1466 	!WORD	_D100+0		
	!BYTE	$74,$00			; SLB	[0]
	!BYTE	$54			; CALL	_C054
_F1467 	!WORD	_C054		
	!BYTE	$54			; CALL	_C076
_F1468 	!WORD	_C076		
	!BYTE	$2A,$A8			; CB	168
	!BYTE	$24			; BRNE	_B1131
	!WORD	_B1131-*
_B1134 
; toolsrc/parse.pla: 1259:                     if scan == ID_TKN
; toolsrc/parse.pla: 1260:                         cfnparms++
	!BYTE	$54			; CALL	_C076
_F1469 	!WORD	_C076		
	!BYTE	$2A,$D6			; CB	214
	!BYTE	$24			; BRNE	_B1136
	!WORD	_B1136-*
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$8C			; INCR
; toolsrc/parse.pla: 1261:                         new_idlocal(tknptr, tknlen, WORD_TYPE, 2)
; toolsrc/parse.pla: 1262:                         scan
; toolsrc/parse.pla: 1263:                     fin
	!BYTE	$74,$01			; SLB	[1]
	!BYTE	$6A			; LAW	_D101+0
_F1470 	!WORD	_D101+0		
	!BYTE	$68			; LAB	_D100+0
_F1471 	!WORD	_D100+0		
	!BYTE	$08			; CN	4
	!BYTE	$04			; CN	2
	!BYTE	$54			; CALL	_C053
_F1472 	!WORD	_C053		
	!BYTE	$54			; CALL	_C076
_F1473 	!WORD	_C076		
	!BYTE	$30			; DROP 
_B1136 
_B1137 
; toolsrc/parse.pla: 1264:                 until token <> COMMA_TKN
_B1135 
	!BYTE	$68			; LAB	_D098+0
_F1474 	!WORD	_D098+0		
	!BYTE	$2A,$AC			; CB	172
	!BYTE	$22			; BREQ	_B1134
	!WORD	_B1134-*
_B1133 
; toolsrc/parse.pla: 1265:                 if token <> CLOSE_PAREN_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_SYNTAX); fin
	!BYTE	$68			; LAB	_D098+0
_F1475 	!WORD	_D098+0		
	!BYTE	$2A,$A9			; CB	169
	!BYTE	$22			; BREQ	_B1138
	!WORD	_B1138-*
	!BYTE	$2C,$28,$80		; CW	32808
	!BYTE	$54			; CALL	_C002
_F1476 	!WORD	_C002		
_B1138 
_B1139 
; toolsrc/parse.pla: 1266:                 scan
; toolsrc/parse.pla: 1267:             fin
	!BYTE	$54			; CALL	_C076
_F1477 	!WORD	_C076		
	!BYTE	$30			; DROP 
_B1131 
_B1132 
; toolsrc/parse.pla: 1268:             if token == POUND_TKN
; toolsrc/parse.pla: 1269:                 if not parse_const(@infuncvals); exit_err(ERR_INVAL|ERR_CONST); fin
	!BYTE	$68			; LAB	_D098+0
_F1478 	!WORD	_D098+0		
	!BYTE	$2A,$A3			; CB	163
	!BYTE	$24			; BRNE	_B1140
	!WORD	_B1140-*
	!BYTE	$26			; LA	_D111+0
_F1479 	!WORD	_D111+0		
	!BYTE	$54			; CALL	_C090
_F1480 	!WORD	_C090		
	!BYTE	$4E			; BRTRU	_B1142
	!WORD	_B1142-*
	!BYTE	$2C,$04,$04		; CW	1028
	!BYTE	$54			; CALL	_C002
_F1481 	!WORD	_C002		
_B1142 
_B1143 
; toolsrc/parse.pla: 1270:                 scan
; toolsrc/parse.pla: 1271:             fin
	!BYTE	$54			; CALL	_C076
_F1482 	!WORD	_C076		
	!BYTE	$30			; DROP 
_B1140 
_B1141 
; toolsrc/parse.pla: 1272:             idptr = lookup_idglobal(idstr, idlen)
; toolsrc/parse.pla: 1273:             if idptr
; toolsrc/parse.pla: 1274:                 if not idptr=>idtype & PREDEF_TYPE; exit_err(ERR_DUP|ERR_ID); fin
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$54			; CALL	_C045
_F1483 	!WORD	_C045		
	!BYTE	$6E,$1A			; DLW	[26]
	!BYTE	$4C			; BRFLS	_B1144
	!WORD	_B1144-*
	!BYTE	$66,$1A			; LLW	[26]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$80			; NOT
	!BYTE	$2C,$00,$01		; CW	256
	!BYTE	$94			; AND 
	!BYTE	$4C			; BRFLS	_B1146
	!WORD	_B1146-*
	!BYTE	$2C,$01,$02		; CW	513
	!BYTE	$54			; CALL	_C002
_F1484 	!WORD	_C002		
_B1146 
_B1147 
; toolsrc/parse.pla: 1275:                 if idptr->funcparms <> cfnparms or idptr->funcvals <> infuncvals; exit_err(ERR_DUP|ERR_CODE|ERR_ID); fin
	!BYTE	$66,$1A			; LLW	[26]
	!BYTE	$38,$04			; ADDI	4
	!BYTE	$60			; LB
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$42			; ISNE
	!BYTE	$AE			; BROR	_B1148
	!WORD	_B1148-*
	!BYTE	$66,$1A			; LLW	[26]
	!BYTE	$38,$05			; ADDI	5
	!BYTE	$60			; LB
	!BYTE	$6A			; LAW	_D111+0
_F1485 	!WORD	_D111+0		
	!BYTE	$42			; ISNE
_B1148 
	!BYTE	$4C			; BRFLS	_B1149
	!WORD	_B1149-*
	!BYTE	$2C,$01,$03		; CW	769
	!BYTE	$54			; CALL	_C002
_F1486 	!WORD	_C002		
_B1149 
_B1150 
; toolsrc/parse.pla: 1276:                 func_tag = idptr=>idval
; toolsrc/parse.pla: 1277:                 idptr=>idtype = idptr=>idtype | type
; toolsrc/parse.pla: 1278:             else
	!BYTE	$66,$1A			; LLW	[26]
	!BYTE	$62			; LW
	!BYTE	$76,$18			; SLW	[24]
	!BYTE	$66,$1A			; LLW	[26]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$62			; LW
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$96			; OR 
	!BYTE	$66,$1A			; LLW	[26]
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$72			; SW
	!BYTE	$50			; BRNCH	_B1145
	!WORD	_B1145-*
_B1144 
; toolsrc/parse.pla: 1279:                 func_tag = new_tag(WORD_FIXUP)
; toolsrc/parse.pla: 1280:                 new_idfunc(idstr, idlen, type, func_tag, cfnparms, infuncvals)
; toolsrc/parse.pla: 1281:             fin
	!BYTE	$2A,$80			; CB	128
	!BYTE	$54			; CALL	_C004
_F1487 	!WORD	_C004		
	!BYTE	$76,$18			; SLW	[24]
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$66,$14			; LLW	[20]
	!BYTE	$66,$18			; LLW	[24]
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$6A			; LAW	_D111+0
_F1488 	!WORD	_D111+0		
	!BYTE	$54			; CALL	_C050
_F1489 	!WORD	_C050		
_B1145 
; toolsrc/parse.pla: 1282:             //
; toolsrc/parse.pla: 1283:             // Print def name
; toolsrc/parse.pla: 1284:             //
; toolsrc/parse.pla: 1285:             nametostr(idstr, idlen > 16 ?? 16 :: idlen, @defstr); puts(@defstr); putc(':')
; toolsrc/parse.pla: 1286:             defcodeptr = codeptr
; toolsrc/parse.pla: 1287:             emit_tag(func_tag)
; toolsrc/parse.pla: 1288:             new_dfd(func_tag)
; toolsrc/parse.pla: 1289:             while parse_vars(LOCAL_TYPE, FALSE); nextln; loop
	!BYTE	$66,$16			; LLW	[22]
	!BYTE	$64,$00			; LLB	[0]
	!BYTE	$2A,$10			; CB	16
	!BYTE	$44			; ISGT
	!BYTE	$4C			; BRFLS	_B1153
	!WORD	_B1153-*
	!BYTE	$2A,$10			; CB	16
	!BYTE	$50			; BRNCH	_B1154
	!WORD	_B1154-*
_B1153 
	!BYTE	$64,$00			; LLB	[0]
_B1154 
	!BYTE	$28,$03			; LLA	[3]
	!BYTE	$54			; CALL	_C000
_F1490 	!WORD	_C000		
	!BYTE	$28,$03			; LLA	[3]
	!BYTE	$54			; CALL	_X004
_F1491 	!WORD	0		
	!BYTE	$2A,$3A			; CB	58
	!BYTE	$54			; CALL	_X002
_F1492 	!WORD	0		
	!BYTE	$6A			; LAW	_D075+0
_F1493 	!WORD	_D075+0		
	!BYTE	$76,$1C			; SLW	[28]
	!BYTE	$66,$18			; LLW	[24]
	!BYTE	$54			; CALL	_C039
_F1494 	!WORD	_C039		
	!BYTE	$66,$18			; LLW	[24]
	!BYTE	$54			; CALL	_C058
_F1495 	!WORD	_C058		
	!BYTE	$50			; BRNCH	_B1157
	!WORD	_B1157-*
_B1155 
	!BYTE	$54			; CALL	_C079
_F1496 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B1157 
	!BYTE	$2A,$10			; CB	16
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C099
_F1497 	!WORD	_C099		
	!BYTE	$4E			; BRTRU	_B1155
	!WORD	_B1155-*
_B1156 
; toolsrc/parse.pla: 1290:             emit_enter(cfnparms)
; toolsrc/parse.pla: 1291:             prevstmnt = 0
; toolsrc/parse.pla: 1292:             while parse_stmnt; nextln; loop
	!BYTE	$64,$01			; LLB	[1]
	!BYTE	$54			; CALL	_C038
_F1498 	!WORD	_C038		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D110+0
_F1499 	!WORD	_D110+0		
	!BYTE	$50			; BRNCH	_B1160
	!WORD	_B1160-*
_B1158 
	!BYTE	$54			; CALL	_C079
_F1500 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B1160 
	!BYTE	$54			; CALL	_C096
_F1501 	!WORD	_C096		
	!BYTE	$4E			; BRTRU	_B1158
	!WORD	_B1158-*
_B1159 
; toolsrc/parse.pla: 1293:             infunc = FALSE
; toolsrc/parse.pla: 1294:             if token <> END_TKN; exit_err(ERR_MISS|ERR_CLOSE|ERR_STATE); fin
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D107+0
_F1502 	!WORD	_D107+0		
	!BYTE	$68			; LAB	_D098+0
_F1503 	!WORD	_D098+0		
	!BYTE	$2A,$87			; CB	135
	!BYTE	$22			; BREQ	_B1161
	!WORD	_B1161-*
	!BYTE	$2C,$28,$10		; CW	4136
	!BYTE	$54			; CALL	_C002
_F1504 	!WORD	_C002		
_B1161 
_B1162 
; toolsrc/parse.pla: 1295:             scan
; toolsrc/parse.pla: 1296:             if prevstmnt <> RETURN_TKN
; toolsrc/parse.pla: 1297:                 if infuncvals; parse_warn("No return values"); fin
	!BYTE	$54			; CALL	_C076
_F1505 	!WORD	_C076		
	!BYTE	$30			; DROP 
	!BYTE	$68			; LAB	_D110+0
_F1506 	!WORD	_D110+0		
	!BYTE	$2A,$99			; CB	153
	!BYTE	$22			; BREQ	_B1163
	!WORD	_B1163-*
	!BYTE	$6A			; LAW	_D111+0
_F1507 	!WORD	_D111+0		
	!BYTE	$4C			; BRFLS	_B1165
	!WORD	_B1165-*
	!BYTE	$2E			; CS
	!BYTE	$10
	!BYTE	$4E,$6F,$20,$72,$65,$74,$75,$72
	!BYTE	$6E,$20,$76,$61,$6C,$75,$65,$73
	!BYTE	$54			; CALL	_C003
_F1508 	!WORD	_C003		
_B1165 
_B1166 
; toolsrc/parse.pla: 1298:                 for cfnvals = infuncvals - 1 downto 0
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D111+0
_F1509 	!WORD	_D111+0		
	!BYTE	$8E			; DECR
	!BYTE	$A2			; BRLT	_B1167
	!WORD	_B1167-*
_B1168 
	!BYTE	$6C,$02			; DLB	[2]
; toolsrc/parse.pla: 1299:                     emit_const(0)
; toolsrc/parse.pla: 1300:                 next
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C016
_F1510 	!WORD	_C016		
_B1169 
	!BYTE	$A8			; DECBRGE	_B1168
	!WORD	_B1168-*
_B1167 
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$30			; DROP 
; toolsrc/parse.pla: 1301:                 emit_leave
; toolsrc/parse.pla: 1302:             fin
	!BYTE	$54			; CALL	_C037
_F1511 	!WORD	_C037		
_B1163 
_B1164 
; toolsrc/parse.pla: 1303:             for cfnvals = 0 to lambda_cnt-1
	!BYTE	$68			; LAB	_D114+0
_F1512 	!WORD	_D114+0		
	!BYTE	$8E			; DECR
	!BYTE	$00			; CN	0
	!BYTE	$A0			; BRGT	_B1170
	!WORD	_B1170-*
_B1171 
	!BYTE	$6C,$02			; DLB	[2]
; toolsrc/parse.pla: 1304:                 emit_lambdafunc(lambda_tag[cfnvals], lambda_cparms[cfnvals], lambda_seq[cfnvals])
; toolsrc/parse.pla: 1305:                 new_dfd(lambda_tag[cfnvals])
; toolsrc/parse.pla: 1306:             next
	!BYTE	$26			; LA	_D118+0
_F1513 	!WORD	_D118+0		
	!BYTE	$B8,$02			; IDXLB	[2]
	!BYTE	$62			; LW
	!BYTE	$26			; LA	_D116+0
_F1514 	!WORD	_D116+0		
	!BYTE	$B0,$02			; ADDLB	[2]
	!BYTE	$60			; LB
	!BYTE	$26			; LA	_D117+0
_F1515 	!WORD	_D117+0		
	!BYTE	$B8,$02			; IDXLB	[2]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C042
_F1516 	!WORD	_C042		
	!BYTE	$26			; LA	_D118+0
_F1517 	!WORD	_D118+0		
	!BYTE	$B8,$02			; IDXLB	[2]
	!BYTE	$62			; LW
	!BYTE	$54			; CALL	_C058
_F1518 	!WORD	_C058		
_B1172 
	!BYTE	$A4			; INCBRLE	_B1171
	!WORD	_B1171-*
_B1170 
	!BYTE	$74,$02			; SLB	[2]
	!BYTE	$30			; DROP 
; toolsrc/parse.pla: 1307:             puti(codeptr - defcodeptr); puts(@bytesln)
; toolsrc/parse.pla: 1308: 
; toolsrc/parse.pla: 1309:     wend
	!BYTE	$6A			; LAW	_D075+0
_F1519 	!WORD	_D075+0		
	!BYTE	$66,$1C			; LLW	[28]
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X005
_F1520 	!WORD	0		
	!BYTE	$26			; LA	_D122+0
_F1521 	!WORD	_D122+0		
	!BYTE	$54			; CALL	_X004
_F1522 	!WORD	0		
	!BYTE	$50			; BRNCH	_B1121
	!WORD	_B1121-*
_B1122 
	!BYTE	$04			; CASEBLOCK
	!WORD	$0080
	!WORD	_B1123-*
	!WORD	$0095
	!WORD	_B1128-*
	!WORD	$0096
	!WORD	_B1124-*
	!WORD	$009E
	!WORD	_B1125-*
_B1121 
; toolsrc/parse.pla: 1310:     return token == EOL_TKN ?? TRUE :: FALSE
	!BYTE	$68			; LAB	_D098+0
_F1523 	!WORD	_D098+0		
	!BYTE	$04			; CN	2
	!BYTE	$24			; BRNE	_B1173
	!WORD	_B1173-*
	!BYTE	$20			; MINUS ONE
	!BYTE	$50			; BRNCH	_B1174
	!WORD	_B1174-*
_B1173 
	!BYTE	$00			; CN	0
_B1174 
	!BYTE	$5A,$1E			; LEAVE	30
; toolsrc/parse.pla: 1311: end
; toolsrc/parse.pla: 1312: def parse_module#0
_C103 					; parse_module()
; toolsrc/parse.pla: 1313:     init_idglobal
; toolsrc/parse.pla: 1314:     init_idlocal
; toolsrc/parse.pla: 1315:     puts("Data+Code buffer size = "); puti(codebufsz); putln; putln
	!BYTE	$54			; CALL	_C052
_F1524 	!WORD	_C052		
	!BYTE	$54			; CALL	_C054
_F1525 	!WORD	_C054		
	!BYTE	$2E			; CS
	!BYTE	$18
	!BYTE	$44,$61,$74,$61,$2B,$43,$6F,$64
	!BYTE	$65,$20,$62,$75,$66,$66,$65,$72
	!BYTE	$20,$73,$69,$7A,$65,$20,$3D,$20
	!BYTE	$54			; CALL	_X004
_F1526 	!WORD	0		
; toolsrc/parse.pla: 1316:     puts(@modfile); putln
; toolsrc/parse.pla: 1317:     if nextln
; toolsrc/parse.pla: 1318:         //
; toolsrc/parse.pla: 1319:         // Compile module
; toolsrc/parse.pla: 1320:         //
; toolsrc/parse.pla: 1321:         puts("DATA:");
	!BYTE	$6A			; LAW	_D068+0
_F1527 	!WORD	_D068+0		
	!BYTE	$54			; CALL	_X005
_F1528 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F1529 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F1530 	!WORD	0		
	!BYTE	$26			; LA	_D092+0
_F1531 	!WORD	_D092+0		
	!BYTE	$54			; CALL	_X004
_F1532 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F1533 	!WORD	0		
	!BYTE	$54			; CALL	_C079
_F1534 	!WORD	_C079		
	!BYTE	$4C			; BRFLS	_B1175
	!WORD	_B1175-*
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$44,$41,$54,$41,$3A
	!BYTE	$54			; CALL	_X004
_F1535 	!WORD	0		
; toolsrc/parse.pla: 1322:         while parse_mods;              nextln; loop
	!BYTE	$50			; BRNCH	_B1179
	!WORD	_B1179-*
_B1177 
	!BYTE	$54			; CALL	_C079
_F1536 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B1179 
	!BYTE	$54			; CALL	_C100
_F1537 	!WORD	_C100		
	!BYTE	$4E			; BRTRU	_B1177
	!WORD	_B1177-*
_B1178 
; toolsrc/parse.pla: 1323:         while parse_vars(GLOBAL_TYPE, FALSE); nextln; loop
	!BYTE	$50			; BRNCH	_B1182
	!WORD	_B1182-*
_B1180 
	!BYTE	$54			; CALL	_C079
_F1538 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B1182 
	!BYTE	$00			; CN	0
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C099
_F1539 	!WORD	_C099		
	!BYTE	$4E			; BRTRU	_B1180
	!WORD	_B1180-*
_B1181 
; toolsrc/parse.pla: 1324:         emit_codeseg
; toolsrc/parse.pla: 1325:         puti(codeptr - codebuff); puts(@bytesln)
; toolsrc/parse.pla: 1326:         while parse_defs;              nextln; loop
	!BYTE	$54			; CALL	_C015
_F1540 	!WORD	_C015		
	!BYTE	$6A			; LAW	_D075+0
_F1541 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D074+0
_F1542 	!WORD	_D074+0		
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X005
_F1543 	!WORD	0		
	!BYTE	$26			; LA	_D122+0
_F1544 	!WORD	_D122+0		
	!BYTE	$54			; CALL	_X004
_F1545 	!WORD	0		
	!BYTE	$50			; BRNCH	_B1185
	!WORD	_B1185-*
_B1183 
	!BYTE	$54			; CALL	_C079
_F1546 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B1185 
	!BYTE	$54			; CALL	_C102
_F1547 	!WORD	_C102		
	!BYTE	$4E			; BRTRU	_B1183
	!WORD	_B1183-*
_B1184 
; toolsrc/parse.pla: 1327:         puts("INIT:");
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$49,$4E,$49,$54,$3A
	!BYTE	$54			; CALL	_X004
_F1548 	!WORD	0		
; toolsrc/parse.pla: 1328:         entrypoint = codeptr
; toolsrc/parse.pla: 1329:         prevstmnt  = 0
; toolsrc/parse.pla: 1330:         init_idlocal
; toolsrc/parse.pla: 1331:         emit_enter(0)
; toolsrc/parse.pla: 1332:         if token <> DONE_TKN
; toolsrc/parse.pla: 1333:             while parse_stmnt; nextln; loop
	!BYTE	$6A			; LAW	_D075+0
_F1549 	!WORD	_D075+0		
	!BYTE	$7A			; SAW	_D076+0
_F1550 	!WORD	_D076+0		
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D110+0
_F1551 	!WORD	_D110+0		
	!BYTE	$54			; CALL	_C054
_F1552 	!WORD	_C054		
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C038
_F1553 	!WORD	_C038		
	!BYTE	$68			; LAB	_D098+0
_F1554 	!WORD	_D098+0		
	!BYTE	$2A,$98			; CB	152
	!BYTE	$22			; BREQ	_B1186
	!WORD	_B1186-*
	!BYTE	$50			; BRNCH	_B1190
	!WORD	_B1190-*
_B1188 
	!BYTE	$54			; CALL	_C079
_F1555 	!WORD	_C079		
	!BYTE	$30			; DROP 
_B1190 
	!BYTE	$54			; CALL	_C096
_F1556 	!WORD	_C096		
	!BYTE	$4E			; BRTRU	_B1188
	!WORD	_B1188-*
_B1189 
; toolsrc/parse.pla: 1334:         fin
_B1186 
_B1187 
; toolsrc/parse.pla: 1335:         if prevstmnt <> RETURN_TKN
; toolsrc/parse.pla: 1336:             emit_const(0)
; toolsrc/parse.pla: 1337:             emit_leave
; toolsrc/parse.pla: 1338:         fin
	!BYTE	$68			; LAB	_D110+0
_F1557 	!WORD	_D110+0		
	!BYTE	$2A,$99			; CB	153
	!BYTE	$22			; BREQ	_B1191
	!WORD	_B1191-*
	!BYTE	$00			; CN	0
	!BYTE	$54			; CALL	_C016
_F1558 	!WORD	_C016		
	!BYTE	$54			; CALL	_C037
_F1559 	!WORD	_C037		
_B1191 
_B1192 
; toolsrc/parse.pla: 1339:         puti(codeptr - entrypoint); puts(@bytesln)
; toolsrc/parse.pla: 1340:         puts("\nTotal bytes compiled: "); puti(codeptr - codebuff); putln
	!BYTE	$6A			; LAW	_D075+0
_F1560 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D076+0
_F1561 	!WORD	_D076+0		
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X005
_F1562 	!WORD	0		
	!BYTE	$26			; LA	_D122+0
_F1563 	!WORD	_D122+0		
	!BYTE	$54			; CALL	_X004
_F1564 	!WORD	0		
	!BYTE	$2E			; CS
	!BYTE	$17
	!BYTE	$0D,$54,$6F,$74,$61,$6C,$20,$62
	!BYTE	$79,$74,$65,$73,$20,$63,$6F,$6D
	!BYTE	$70,$69,$6C,$65,$64,$3A,$20
	!BYTE	$54			; CALL	_X004
_F1565 	!WORD	0		
; toolsrc/parse.pla: 1341:         if token <> DONE_TKN; parse_warn("Missing DONE\n"); fin
	!BYTE	$6A			; LAW	_D075+0
_F1566 	!WORD	_D075+0		
	!BYTE	$6A			; LAW	_D074+0
_F1567 	!WORD	_D074+0		
	!BYTE	$84			; SUB 
	!BYTE	$54			; CALL	_X005
_F1568 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F1569 	!WORD	0		
	!BYTE	$68			; LAB	_D098+0
_F1570 	!WORD	_D098+0		
	!BYTE	$2A,$98			; CB	152
	!BYTE	$22			; BREQ	_B1193
	!WORD	_B1193-*
	!BYTE	$2E			; CS
	!BYTE	$0D
	!BYTE	$4D,$69,$73,$73,$69,$6E,$67,$20
	!BYTE	$44,$4F,$4E,$45,$0D
	!BYTE	$54			; CALL	_C003
_F1571 	!WORD	_C003		
_B1193 
_B1194 
; toolsrc/parse.pla: 1342:         //dumpsym(idglobal_tbl, globals)
; toolsrc/parse.pla: 1343:     fin
_B1175 
_B1176 
; toolsrc/parse.pla: 1344: end
	!BYTE	$5C			; RET
; toolsrc/plasm.pla: 0507: 
; toolsrc/plasm.pla: 0508: //
; toolsrc/plasm.pla: 0509: // Look at command line arguments and compile module
; toolsrc/plasm.pla: 0510: //
; toolsrc/plasm.pla: 0511: puts("PLASMA Compiler, Version 2.0\n")
_INIT 
	!BYTE	$2E			; CS
	!BYTE	$1D
	!BYTE	$50,$4C,$41,$53,$4D,$41,$20,$43
	!BYTE	$6F,$6D,$70,$69,$6C,$65,$72,$2C
	!BYTE	$20,$56,$65,$72,$73,$69,$6F,$6E
	!BYTE	$20,$32,$2E,$30,$0D
	!BYTE	$54			; CALL	_X004
_F1572 	!WORD	0		
; toolsrc/plasm.pla: 0512: arg = argNext(argFirst)
; toolsrc/plasm.pla: 0513: if ^arg and ^(arg + 1) == '-'
; toolsrc/plasm.pla: 0514:     opt = arg + 2
; toolsrc/plasm.pla: 0515:     while TRUE
	!BYTE	$54			; CALL	_X029
_F1573 	!WORD	0		
	!BYTE	$54			; CALL	_X030
_F1574 	!WORD	0		
	!BYTE	$7A			; SAW	_D123+0
_F1575 	!WORD	_D123+0		
	!BYTE	$6A			; LAW	_D123+0
_F1576 	!WORD	_D123+0		
	!BYTE	$60			; LB
	!BYTE	$AC			; BRAND	_B1195
	!WORD	_B1195-*
	!BYTE	$6A			; LAW	_D123+0
_F1577 	!WORD	_D123+0		
	!BYTE	$8C			; INCR
	!BYTE	$60			; LB
	!BYTE	$2A,$2D			; CB	45
	!BYTE	$40			; ISEQ
_B1195 
	!BYTE	$4C			; BRFLS	_B1196
	!WORD	_B1196-*
	!BYTE	$6A			; LAW	_D123+0
_F1578 	!WORD	_D123+0		
	!BYTE	$38,$02			; ADDI	2
	!BYTE	$7A			; SAW	_D124+0
_F1579 	!WORD	_D124+0		
	!BYTE	$50			; BRNCH	_B1200
	!WORD	_B1200-*
_B1198 
; toolsrc/plasm.pla: 0516:         if toupper(^opt) == 'O'
; toolsrc/plasm.pla: 0517:             //
; toolsrc/plasm.pla: 0518:             // Load optimizer module here
; toolsrc/plasm.pla: 0519:             //
; toolsrc/plasm.pla: 0520:             if cmdsys:modexec("CODEOPT") >= 0
	!BYTE	$6A			; LAW	_D124+0
_F1580 	!WORD	_D124+0		
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F1581 	!WORD	0		
	!BYTE	$2A,$4F			; CB	79
	!BYTE	$24			; BRNE	_B1201
	!WORD	_B1201-*
	!BYTE	$2E			; CS
	!BYTE	$07
	!BYTE	$43,$4F,$44,$45,$4F,$50,$54
	!BYTE	$6A			; LAW	_X000+6
_F1582 	!WORD	0+6		
	!BYTE	$56			; ICAL
	!BYTE	$00			; CN	0
	!BYTE	$48			; ISGE
	!BYTE	$4C			; BRFLS	_B1203
	!WORD	_B1203-*
; toolsrc/plasm.pla: 0521:                 outflags = outflags | OPTIMIZE
; toolsrc/plasm.pla: 0522:             fin
	!BYTE	$68			; LAB	_D085+0
_F1583 	!WORD	_D085+0		
	!BYTE	$3E,$01			; ORI	1
	!BYTE	$78			; SAB	_D085+0
_F1584 	!WORD	_D085+0		
_B1203 
_B1204 
; toolsrc/plasm.pla: 0523:             if not (outflags & OPTIMIZE)
; toolsrc/plasm.pla: 0524:                 puts("\nOptimizer disabled\n")
	!BYTE	$68			; LAB	_D085+0
_F1585 	!WORD	_D085+0		
	!BYTE	$3C,$01			; ANDI	1
	!BYTE	$4E			; BRTRU	_B1205
	!WORD	_B1205-*
	!BYTE	$2E			; CS
	!BYTE	$14
	!BYTE	$0D,$4F,$70,$74,$69,$6D,$69,$7A
	!BYTE	$65,$72,$20,$64,$69,$73,$61,$62
	!BYTE	$6C,$65,$64,$0D
	!BYTE	$54			; CALL	_X004
_F1586 	!WORD	0		
; toolsrc/plasm.pla: 0525:             fin
_B1205 
_B1206 
; toolsrc/plasm.pla: 0526:             opt++
	!BYTE	$6A			; LAW	_D124+0
_F1587 	!WORD	_D124+0		
	!BYTE	$8C			; INCR
; toolsrc/plasm.pla: 0527:             if ^opt == '2'
; toolsrc/plasm.pla: 0528:                 outflags = outflags | OPTIMIZE2
; toolsrc/plasm.pla: 0529:                 opt++
	!BYTE	$7A			; SAW	_D124+0
_F1588 	!WORD	_D124+0		
	!BYTE	$6A			; LAW	_D124+0
_F1589 	!WORD	_D124+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$32			; CB	50
	!BYTE	$24			; BRNE	_B1207
	!WORD	_B1207-*
	!BYTE	$68			; LAB	_D085+0
_F1590 	!WORD	_D085+0		
	!BYTE	$3E,$02			; ORI	2
	!BYTE	$78			; SAB	_D085+0
_F1591 	!WORD	_D085+0		
	!BYTE	$6A			; LAW	_D124+0
_F1592 	!WORD	_D124+0		
	!BYTE	$8C			; INCR
; toolsrc/plasm.pla: 0530:             fin
	!BYTE	$7A			; SAW	_D124+0
_F1593 	!WORD	_D124+0		
_B1207 
_B1208 
; toolsrc/plasm.pla: 0531:         elsif toupper(^opt) == 'N'
	!BYTE	$50			; BRNCH	_B1202
	!WORD	_B1202-*
_B1201 
; toolsrc/plasm.pla: 0532:             outflags = outflags | NO_COMBINE
; toolsrc/plasm.pla: 0533:             opt++
	!BYTE	$6A			; LAW	_D124+0
_F1594 	!WORD	_D124+0		
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F1595 	!WORD	0		
	!BYTE	$2A,$4E			; CB	78
	!BYTE	$24			; BRNE	_B1209
	!WORD	_B1209-*
	!BYTE	$68			; LAB	_D085+0
_F1596 	!WORD	_D085+0		
	!BYTE	$3E,$04			; ORI	4
	!BYTE	$78			; SAB	_D085+0
_F1597 	!WORD	_D085+0		
	!BYTE	$6A			; LAW	_D124+0
_F1598 	!WORD	_D124+0		
	!BYTE	$8C			; INCR
; toolsrc/plasm.pla: 0534:         elsif toupper(^opt) == 'W'
	!BYTE	$7A			; SAW	_D124+0
_F1599 	!WORD	_D124+0		
	!BYTE	$50			; BRNCH	_B1202
	!WORD	_B1202-*
_B1209 
; toolsrc/plasm.pla: 0535:             outflags = outflags | WARNINGS
; toolsrc/plasm.pla: 0536:             opt++
	!BYTE	$6A			; LAW	_D124+0
_F1600 	!WORD	_D124+0		
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F1601 	!WORD	0		
	!BYTE	$2A,$57			; CB	87
	!BYTE	$24			; BRNE	_B1210
	!WORD	_B1210-*
	!BYTE	$68			; LAB	_D085+0
_F1602 	!WORD	_D085+0		
	!BYTE	$3E,$08			; ORI	8
	!BYTE	$78			; SAB	_D085+0
_F1603 	!WORD	_D085+0		
	!BYTE	$6A			; LAW	_D124+0
_F1604 	!WORD	_D124+0		
	!BYTE	$8C			; INCR
; toolsrc/plasm.pla: 0537:         else
	!BYTE	$7A			; SAW	_D124+0
_F1605 	!WORD	_D124+0		
	!BYTE	$50			; BRNCH	_B1202
	!WORD	_B1202-*
_B1210 
; toolsrc/plasm.pla: 0538:             break
	!BYTE	$50			; BRNCH	_B1199
	!WORD	_B1199-*
; toolsrc/plasm.pla: 0539:         fin
_B1202 
; toolsrc/plasm.pla: 0540:     loop
_B1200 
	!BYTE	$50			; BRNCH	_B1198
	!WORD	_B1198-*
_B1199 
; toolsrc/plasm.pla: 0541:     arg = argNext(arg)
; toolsrc/plasm.pla: 0542: fin
	!BYTE	$6A			; LAW	_D123+0
_F1606 	!WORD	_D123+0		
	!BYTE	$54			; CALL	_X030
_F1607 	!WORD	0		
	!BYTE	$7A			; SAW	_D123+0
_F1608 	!WORD	_D123+0		
_B1196 
_B1197 
; toolsrc/plasm.pla: 0543: if ^arg
; toolsrc/plasm.pla: 0544:     strcpy(@srcfile, arg)
; toolsrc/plasm.pla: 0545:     arg = argNext(arg)
; toolsrc/plasm.pla: 0546:     if ^arg
; toolsrc/plasm.pla: 0547:         strcpy(@relfile, arg)
; toolsrc/plasm.pla: 0548:     else
	!BYTE	$6A			; LAW	_D123+0
_F1609 	!WORD	_D123+0		
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B1211
	!WORD	_B1211-*
	!BYTE	$26			; LA	_D089+0
_F1610 	!WORD	_D089+0		
	!BYTE	$6A			; LAW	_D123+0
_F1611 	!WORD	_D123+0		
	!BYTE	$54			; CALL	_X019
_F1612 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$6A			; LAW	_D123+0
_F1613 	!WORD	_D123+0		
	!BYTE	$54			; CALL	_X030
_F1614 	!WORD	0		
	!BYTE	$7A			; SAW	_D123+0
_F1615 	!WORD	_D123+0		
	!BYTE	$6A			; LAW	_D123+0
_F1616 	!WORD	_D123+0		
	!BYTE	$60			; LB
	!BYTE	$4C			; BRFLS	_B1213
	!WORD	_B1213-*
	!BYTE	$26			; LA	_D091+0
_F1617 	!WORD	_D091+0		
	!BYTE	$6A			; LAW	_D123+0
_F1618 	!WORD	_D123+0		
	!BYTE	$54			; CALL	_X019
_F1619 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B1214
	!WORD	_B1214-*
_B1213 
; toolsrc/plasm.pla: 0549:         strcpy(@relfile, @srcfile)
; toolsrc/plasm.pla: 0550:         //
; toolsrc/plasm.pla: 0551:         // Strip trailing extension
; toolsrc/plasm.pla: 0552:         //
; toolsrc/plasm.pla: 0553:         while relfile and relfile[relfile] <> '.'
	!BYTE	$26			; LA	_D091+0
_F1620 	!WORD	_D091+0		
	!BYTE	$26			; LA	_D089+0
_F1621 	!WORD	_D089+0		
	!BYTE	$54			; CALL	_X019
_F1622 	!WORD	0		
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B1217
	!WORD	_B1217-*
_B1215 
; toolsrc/plasm.pla: 0554:             relfile--
	!BYTE	$68			; LAB	_D091+0
_F1623 	!WORD	_D091+0		
	!BYTE	$8E			; DECR
; toolsrc/plasm.pla: 0555:         loop
	!BYTE	$78			; SAB	_D091+0
_F1624 	!WORD	_D091+0		
_B1217 
	!BYTE	$68			; LAB	_D091+0
_F1625 	!WORD	_D091+0		
	!BYTE	$AC			; BRAND	_B1218
	!WORD	_B1218-*
	!BYTE	$26			; LA	_D091+0
_F1626 	!WORD	_D091+0		
	!BYTE	$B4			; ADDAB	_D091+0
_F1627 	!WORD	_D091+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$2E			; CB	46
	!BYTE	$42			; ISNE
_B1218 
	!BYTE	$4E			; BRTRU	_B1215
	!WORD	_B1215-*
_B1216 
; toolsrc/plasm.pla: 0556:         if relfile; relfile--; fin // Strip '.'
	!BYTE	$68			; LAB	_D091+0
_F1628 	!WORD	_D091+0		
	!BYTE	$4C			; BRFLS	_B1219
	!WORD	_B1219-*
	!BYTE	$68			; LAB	_D091+0
_F1629 	!WORD	_D091+0		
	!BYTE	$8E			; DECR
	!BYTE	$78			; SAB	_D091+0
_F1630 	!WORD	_D091+0		
_B1219 
_B1220 
; toolsrc/plasm.pla: 0557:         if not relfile
; toolsrc/plasm.pla: 0558:             //
; toolsrc/plasm.pla: 0559:             // Copy default name over
; toolsrc/plasm.pla: 0560:             //
; toolsrc/plasm.pla: 0561:             strcpy(@relfile, "A.OUT")
	!BYTE	$68			; LAB	_D091+0
_F1631 	!WORD	_D091+0		
	!BYTE	$4E			; BRTRU	_B1221
	!WORD	_B1221-*
	!BYTE	$26			; LA	_D091+0
_F1632 	!WORD	_D091+0		
	!BYTE	$2E			; CS
	!BYTE	$05
	!BYTE	$41,$2E,$4F,$55,$54
	!BYTE	$54			; CALL	_X019
_F1633 	!WORD	0		
	!BYTE	$30			; DROP 
; toolsrc/plasm.pla: 0562:         fin
_B1221 
_B1222 
; toolsrc/plasm.pla: 0563:         modfile = 0
; toolsrc/plasm.pla: 0564:         for srcref = 1 to relfile
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D092+0
_F1634 	!WORD	_D092+0		
	!BYTE	$68			; LAB	_D091+0
_F1635 	!WORD	_D091+0		
	!BYTE	$02			; CN	1
	!BYTE	$A0			; BRGT	_B1223
	!WORD	_B1223-*
_B1224 
	!BYTE	$7C			; DAB	_D087+0
_F1636 	!WORD	_D087+0		
; toolsrc/plasm.pla: 0565:             if relfile[srcref] == '/'
; toolsrc/plasm.pla: 0566:                 modfile = 0
; toolsrc/plasm.pla: 0567:             else
	!BYTE	$26			; LA	_D091+0
_F1637 	!WORD	_D091+0		
	!BYTE	$B4			; ADDAB	_D087+0
_F1638 	!WORD	_D087+0		
	!BYTE	$60			; LB
	!BYTE	$2A,$2F			; CB	47
	!BYTE	$24			; BRNE	_B1226
	!WORD	_B1226-*
	!BYTE	$00			; CN	0
	!BYTE	$78			; SAB	_D092+0
_F1639 	!WORD	_D092+0		
	!BYTE	$50			; BRNCH	_B1227
	!WORD	_B1227-*
_B1226 
; toolsrc/plasm.pla: 0568:                 modfile++
	!BYTE	$68			; LAB	_D092+0
_F1640 	!WORD	_D092+0		
	!BYTE	$8C			; INCR
; toolsrc/plasm.pla: 0569:                 modfile[modfile] = toupper(relfile[srcref])
; toolsrc/plasm.pla: 0570:             fin
	!BYTE	$78			; SAB	_D092+0
_F1641 	!WORD	_D092+0		
	!BYTE	$26			; LA	_D091+0
_F1642 	!WORD	_D091+0		
	!BYTE	$B4			; ADDAB	_D087+0
_F1643 	!WORD	_D087+0		
	!BYTE	$60			; LB
	!BYTE	$54			; CALL	_X021
_F1644 	!WORD	0		
	!BYTE	$26			; LA	_D092+0
_F1645 	!WORD	_D092+0		
	!BYTE	$B4			; ADDAB	_D092+0
_F1646 	!WORD	_D092+0		
	!BYTE	$70			; SB
_B1227 
; toolsrc/plasm.pla: 0571:         next
_B1225 
	!BYTE	$A4			; INCBRLE	_B1224
	!WORD	_B1224-*
_B1223 
	!BYTE	$78			; SAB	_D087+0
_F1647 	!WORD	_D087+0		
	!BYTE	$30			; DROP 
; toolsrc/plasm.pla: 0572:     fin
_B1214 
; toolsrc/plasm.pla: 0573: fin
_B1211 
_B1212 
; toolsrc/plasm.pla: 0574: if srcfile and relfile
; toolsrc/plasm.pla: 0575:     fileio:iobufalloc(2) // Reserve two I/O buffers
; toolsrc/plasm.pla: 0576:     srcref = fileio:open(@srcfile)
; toolsrc/plasm.pla: 0577:     if srcref
; toolsrc/plasm.pla: 0578:         fileio:newline(srcref, $7F, $0D)
; toolsrc/plasm.pla: 0579:         refnum       = srcref
; toolsrc/plasm.pla: 0580:         parsefile    = @srcfile
; toolsrc/plasm.pla: 0581:         strconstbuff = heapalloc(80)
; toolsrc/plasm.pla: 0582:         instr        = cmdsys:cmdline
; toolsrc/plasm.pla: 0583:         inbuff       = instr + 1
; toolsrc/plasm.pla: 0584:         scanptr      = inbuff
; toolsrc/plasm.pla: 0585:         *instr       = NULL
; toolsrc/plasm.pla: 0586:         exit         = heapalloc(t_except)
; toolsrc/plasm.pla: 0587:         if not except(exit)
; toolsrc/plasm.pla: 0588:             //
; toolsrc/plasm.pla: 0589:             // Parse source code module
; toolsrc/plasm.pla: 0590:             //
; toolsrc/plasm.pla: 0591:             parse_module
; toolsrc/plasm.pla: 0592:             fileio:close(srcref)
; toolsrc/plasm.pla: 0593:             //
; toolsrc/plasm.pla: 0594:             // Write REL file
; toolsrc/plasm.pla: 0595:             //
; toolsrc/plasm.pla: 0596:             fileio:destroy(@relfile)
; toolsrc/plasm.pla: 0597:             fileio:create(@relfile, $FE, $1000) // full access, REL file
; toolsrc/plasm.pla: 0598:             srcref = fileio:open(@relfile)
; toolsrc/plasm.pla: 0599:             if srcref
; toolsrc/plasm.pla: 0600:                 writemodule(srcref)
; toolsrc/plasm.pla: 0601:                 fileio:close(srcref)
; toolsrc/plasm.pla: 0602:             else
	!BYTE	$68			; LAB	_D089+0
_F1648 	!WORD	_D089+0		
	!BYTE	$AC			; BRAND	_B1228
	!WORD	_B1228-*
	!BYTE	$68			; LAB	_D091+0
_F1649 	!WORD	_D091+0		
_B1228 
	!BYTE	$4C			; BRFLS	_B1229
	!WORD	_B1229-*
	!BYTE	$04			; CN	2
	!BYTE	$6A			; LAW	_X031+12
_F1650 	!WORD	0+12		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D089+0
_F1651 	!WORD	_D089+0		
	!BYTE	$6A			; LAW	_X031+14
_F1652 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$7C			; DAB	_D087+0
_F1653 	!WORD	_D087+0		
	!BYTE	$4C			; BRFLS	_B1231
	!WORD	_B1231-*
	!BYTE	$68			; LAB	_D087+0
_F1654 	!WORD	_D087+0		
	!BYTE	$2A,$7F			; CB	127
	!BYTE	$1A			; CN	13
	!BYTE	$6A			; LAW	_X031+28
_F1655 	!WORD	0+28		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$68			; LAB	_D087+0
_F1656 	!WORD	_D087+0		
	!BYTE	$78			; SAB	_D086+0
_F1657 	!WORD	_D086+0		
	!BYTE	$26			; LA	_D089+0
_F1658 	!WORD	_D089+0		
	!BYTE	$7A			; SAW	_D093+0
_F1659 	!WORD	_D093+0		
	!BYTE	$2A,$50			; CB	80
	!BYTE	$54			; CALL	_X014
_F1660 	!WORD	0		
	!BYTE	$7A			; SAW	_D105+0
_F1661 	!WORD	_D105+0		
	!BYTE	$6A			; LAW	_X000+4
_F1662 	!WORD	0+4		
	!BYTE	$7E			; DAW	_D095+0
_F1663 	!WORD	_D095+0		
	!BYTE	$8C			; INCR
	!BYTE	$7E			; DAW	_D096+0
_F1664 	!WORD	_D096+0		
	!BYTE	$7A			; SAW	_D097+0
_F1665 	!WORD	_D097+0		
	!BYTE	$00			; CN	0
	!BYTE	$6A			; LAW	_D095+0
_F1666 	!WORD	_D095+0		
	!BYTE	$72			; SW
	!BYTE	$2C,$40,$01		; CW	320
	!BYTE	$54			; CALL	_X014
_F1667 	!WORD	0		
	!BYTE	$7E			; DAW	_D125+0
_F1668 	!WORD	_D125+0		
	!BYTE	$54			; CALL	_X034
_F1669 	!WORD	0		
	!BYTE	$4E			; BRTRU	_B1233
	!WORD	_B1233-*
	!BYTE	$54			; CALL	_C103
_F1670 	!WORD	_C103		
	!BYTE	$68			; LAB	_D087+0
_F1671 	!WORD	_D087+0		
	!BYTE	$6A			; LAW	_X031+16
_F1672 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D091+0
_F1673 	!WORD	_D091+0		
	!BYTE	$6A			; LAW	_X031+24
_F1674 	!WORD	0+24		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D091+0
_F1675 	!WORD	_D091+0		
	!BYTE	$2A,$FE			; CB	254
	!BYTE	$2C,$00,$10		; CW	4096
	!BYTE	$6A			; LAW	_X031+22
_F1676 	!WORD	0+22		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$26			; LA	_D091+0
_F1677 	!WORD	_D091+0		
	!BYTE	$6A			; LAW	_X031+14
_F1678 	!WORD	0+14		
	!BYTE	$56			; ICAL
	!BYTE	$7C			; DAB	_D087+0
_F1679 	!WORD	_D087+0		
	!BYTE	$4C			; BRFLS	_B1235
	!WORD	_B1235-*
	!BYTE	$68			; LAB	_D087+0
_F1680 	!WORD	_D087+0		
	!BYTE	$54			; CALL	_C074
_F1681 	!WORD	_C074		
	!BYTE	$68			; LAB	_D087+0
_F1682 	!WORD	_D087+0		
	!BYTE	$6A			; LAW	_X031+16
_F1683 	!WORD	0+16		
	!BYTE	$56			; ICAL
	!BYTE	$30			; DROP 
	!BYTE	$50			; BRNCH	_B1236
	!WORD	_B1236-*
_B1235 
; toolsrc/plasm.pla: 0603:                 puts("\nError opening: "); puts(@relfile); putln
	!BYTE	$2E			; CS
	!BYTE	$10
	!BYTE	$0D,$45,$72,$72,$6F,$72,$20,$6F
	!BYTE	$70,$65,$6E,$69,$6E,$67,$3A,$20
	!BYTE	$54			; CALL	_X004
_F1684 	!WORD	0		
; toolsrc/plasm.pla: 0604:             fin
	!BYTE	$26			; LA	_D091+0
_F1685 	!WORD	_D091+0		
	!BYTE	$54			; CALL	_X004
_F1686 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F1687 	!WORD	0		
_B1236 
; toolsrc/plasm.pla: 0605:         fin
_B1233 
_B1234 
; toolsrc/plasm.pla: 0606:     else
	!BYTE	$50			; BRNCH	_B1232
	!WORD	_B1232-*
_B1231 
; toolsrc/plasm.pla: 0607:         puts("\nError opening: "); puts(@srcfile); putln
	!BYTE	$2E			; CS
	!BYTE	$10
	!BYTE	$0D,$45,$72,$72,$6F,$72,$20,$6F
	!BYTE	$70,$65,$6E,$69,$6E,$67,$3A,$20
	!BYTE	$54			; CALL	_X004
_F1688 	!WORD	0		
; toolsrc/plasm.pla: 0608:     fin
	!BYTE	$26			; LA	_D089+0
_F1689 	!WORD	_D089+0		
	!BYTE	$54			; CALL	_X004
_F1690 	!WORD	0		
	!BYTE	$54			; CALL	_X003
_F1691 	!WORD	0		
_B1232 
; toolsrc/plasm.pla: 0609: else
	!BYTE	$50			; BRNCH	_B1230
	!WORD	_B1230-*
_B1229 
; toolsrc/plasm.pla: 0610:     puts("Usage:+PLASM [-[W][O[2]][N]] <src> [out]\n")
	!BYTE	$2E			; CS
	!BYTE	$29
	!BYTE	$55,$73,$61,$67,$65,$3A,$2B,$50
	!BYTE	$4C,$41,$53,$4D,$20,$5B,$2D,$5B
	!BYTE	$57,$5D,$5B,$4F,$5B,$32,$5D,$5D
	!BYTE	$5B,$4E,$5D,$5D,$20,$3C,$73,$72
	!BYTE	$63,$3E,$20,$5B,$6F,$75,$74,$5D
	!BYTE	$0D
	!BYTE	$54			; CALL	_X004
_F1692 	!WORD	0		
; toolsrc/plasm.pla: 0611: fin
_B1230 
; toolsrc/plasm.pla: 0612: done
	!BYTE	$00			; CN	0
	!BYTE	$5C			; RET
_SYSFLAGS	=	0
_DEFCNT	=	105
_SEGEND 
;
; RE-LOCATEABLE DICTIONARY
;
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C000		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C001		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C002		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C003		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C004		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C005		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C006		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C007		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C008		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C009		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C010		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C011		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C012		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C013		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C014		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C015		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C016		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C017		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C018		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C019		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C020		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C021		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C022		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C023		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C024		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C025		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C026		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C027		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C028		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C029		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C030		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C031		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C032		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C033		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C034		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C035		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C036		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C037		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C038		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C039		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C040		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C041		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C042		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C043		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C044		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C045		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C046		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C047		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C048		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C049		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C050		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C051		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C052		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C053		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C054		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C055		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C056		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C057		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C058		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C059		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C060		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C061		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C062		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C063		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C064		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C065		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C066		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C067		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C068		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C069		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C070		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C071		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C072		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C073		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C074		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C075		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C076		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C077		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C078		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C079		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C080		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C081		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C082		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C083		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C084		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C085		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C086		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C087		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C088		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C089		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C090		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C091		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C092		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C093		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C094		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C095		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C096		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C097		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C098		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C099		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C100		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C101		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C102		
	!BYTE	$00
	!BYTE	$02			; CODE TABLE FIXUP
	!WORD	_C103		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F000-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F001-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F002-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F003-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F004-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F006-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F007-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F008-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F009-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F010-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F011-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F013-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F014-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F015-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F016-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F017-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F018-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F019-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F020-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F021-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F022-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F023-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F024-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F025-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F026-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F027-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F028-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F029-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F030-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F031-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F032-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F033-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F034-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F035-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F036-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F037-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F038-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F039-_SEGBEGIN		
	!BYTE	35			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F040-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F041-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F042-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F043-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F044-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F045-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F046-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F047-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F048-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F049-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F050-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F051-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F052-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F054-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F055-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F057-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F058-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F059-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F060-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F061-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F062-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F063-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F064-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F065-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F066-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F068-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F069-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F070-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F071-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F072-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F073-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F074-_SEGBEGIN		
	!BYTE	17			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F075-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F076-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F077-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F078-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F079-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F080-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F081-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F083-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F084-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F085-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F086-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F087-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F088-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F089-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F090-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F091-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F092-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F093-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F094-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F095-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F096-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F097-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F098-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F099-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F100-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F101-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F102-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F103-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F104-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F105-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F106-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F107-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F108-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F109-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F110-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F111-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F112-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F113-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F114-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F115-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F116-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F117-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F118-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F119-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F120-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F121-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F122-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F123-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F124-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F125-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F126-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F127-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F128-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F129-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F130-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F131-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F132-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F133-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F134-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F135-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F136-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F137-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F138-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F139-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F140-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F141-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F142-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F143-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F144-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F145-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F146-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F147-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F148-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F149-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F150-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F151-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F152-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F153-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F154-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F155-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F156-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F157-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F158-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F159-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F160-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F161-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F162-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F163-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F164-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F165-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F166-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F167-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F168-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F169-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F170-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F171-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F172-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F173-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F174-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F175-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F176-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F177-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F178-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F179-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F180-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F181-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F182-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F183-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F184-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F185-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F186-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F187-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F188-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F189-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F190-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F191-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F192-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F193-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F194-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F195-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F196-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F197-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F198-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F199-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F200-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F201-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F202-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F203-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F204-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F205-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F206-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F207-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F208-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F209-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F210-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F211-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F212-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F213-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F214-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F215-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F216-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F217-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F218-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F219-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F220-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F221-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F222-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F223-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F224-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F225-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F226-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F227-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F228-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F229-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F230-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F231-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F232-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F233-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F234-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F235-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F236-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F237-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F238-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F239-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F240-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F241-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F242-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F243-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F244-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F245-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F246-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F247-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F248-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F249-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F250-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F251-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F252-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F253-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F254-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F255-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F256-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F257-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F258-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F259-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F260-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F261-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F262-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F263-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F264-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F265-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F266-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F267-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F268-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F269-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F270-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F271-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F272-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F273-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F274-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F275-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F276-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F277-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F278-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F279-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F280-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F281-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F282-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F283-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F284-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F285-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F286-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F287-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F288-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F289-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F290-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F291-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F292-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F293-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F294-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F295-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F296-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F297-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F298-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F299-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F300-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F301-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F302-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F303-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F304-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F305-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F306-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F307-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F308-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F309-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F310-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F311-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F312-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F313-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F314-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F315-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F316-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F317-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F318-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F319-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F320-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F321-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F322-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F323-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F324-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F325-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F326-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F327-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F328-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F329-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F330-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F331-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F332-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F333-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F334-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F335-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F336-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F337-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F338-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F339-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F340-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F341-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F342-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F343-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F344-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F345-_SEGBEGIN		
	!BYTE	16			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F346-_SEGBEGIN		
	!BYTE	26			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F347-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F348-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F349-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F350-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F351-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F352-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F353-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F354-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F355-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F356-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F357-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F358-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F359-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F360-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F361-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F362-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F363-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F364-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F365-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F366-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F367-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F368-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F369-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F370-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F371-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F372-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F373-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F374-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F375-_SEGBEGIN		
	!BYTE	16			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F376-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F377-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F378-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F379-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F380-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F381-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F382-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F383-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F384-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F385-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F386-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F387-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F388-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F389-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F390-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F391-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F392-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F393-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F394-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F395-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F396-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F397-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F398-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F399-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F400-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F401-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F402-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F403-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F404-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F405-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F406-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F407-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F408-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F409-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F410-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F411-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F412-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F413-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F414-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F415-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F416-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F417-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F418-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F419-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F420-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F421-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F422-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F423-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F424-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F425-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F426-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F427-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F428-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F429-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F430-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F431-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F432-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F433-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F434-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F435-_SEGBEGIN		
	!BYTE	18			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F436-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F437-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F438-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F439-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F440-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F441-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F442-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F443-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F444-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F445-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F446-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F447-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F448-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F449-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F450-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F451-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F452-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F453-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F454-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F455-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F456-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F457-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F458-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F459-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F460-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F461-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F462-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F463-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F464-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F465-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F466-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F467-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F468-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F469-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F470-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F471-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F472-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F473-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F474-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F475-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F476-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F477-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F478-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F479-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F480-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F481-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F482-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F483-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F484-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F485-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F486-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F487-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F488-_SEGBEGIN		
	!BYTE	16			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F489-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F490-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F491-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F492-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F493-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F494-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F495-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F496-_SEGBEGIN		
	!BYTE	16			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F497-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F498-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F499-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F500-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F501-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F502-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F503-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F504-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F505-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F506-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F507-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F508-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F509-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F510-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F511-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F512-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F513-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F514-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F515-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F516-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F517-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F518-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F519-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F520-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F521-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F522-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F523-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F524-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F525-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F526-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F527-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F528-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F529-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F530-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F531-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F532-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F533-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F534-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F535-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F536-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F537-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F538-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F539-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F540-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F541-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F542-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F543-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F544-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F545-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F546-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F547-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F548-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F549-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F550-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F551-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F552-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F553-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F554-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F555-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F556-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F557-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F558-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F559-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F560-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F561-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F562-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F563-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F564-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F565-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F566-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F567-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F568-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F569-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F570-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F571-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F572-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F573-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F574-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F575-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F576-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F577-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F578-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F579-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F580-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F581-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F582-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F583-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F584-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F585-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F586-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F587-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F588-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F589-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F590-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F591-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F592-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F593-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F594-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F595-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F596-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F597-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F598-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F599-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F600-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F601-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F602-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F603-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F604-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F605-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F606-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F607-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F608-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F609-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F610-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F611-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F612-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F613-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F614-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F615-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F616-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F617-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F618-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F619-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F620-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F621-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F622-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F623-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F624-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F625-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F626-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F627-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F628-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F629-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F630-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F631-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F632-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F633-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F634-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F635-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F636-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F637-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F638-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F639-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F640-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F641-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F642-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F643-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F644-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F645-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F646-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F647-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F648-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F649-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F650-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F651-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F652-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F653-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F654-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F655-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F656-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F657-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F658-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F659-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F660-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F661-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F662-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F663-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F664-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F665-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F666-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F667-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F668-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F669-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F670-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F671-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F672-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F673-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F674-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F675-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F676-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F677-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F678-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F679-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F680-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F681-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F682-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F683-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F684-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F685-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F686-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F687-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F688-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F689-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F690-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F691-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F692-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F693-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F694-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F695-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F696-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F697-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F698-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F699-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F700-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F701-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F702-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F703-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F704-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F705-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F706-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F707-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F708-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F709-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F710-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F711-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F712-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F713-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F714-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F715-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F716-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F717-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F718-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F719-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F720-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F721-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F722-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F723-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F724-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F725-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F726-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F727-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F728-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F729-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F730-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F731-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F732-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F733-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F734-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F735-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F736-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F737-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F738-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F739-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F740-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F741-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F742-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F743-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F744-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F745-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F746-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F747-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F748-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F749-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F750-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F751-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F752-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F753-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F754-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F755-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F756-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F757-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F758-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F759-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F760-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F761-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F762-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F763-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F764-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F765-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F766-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F767-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F768-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F769-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F770-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F771-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F772-_SEGBEGIN		
	!BYTE	19			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F773-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F774-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F775-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F776-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F777-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F778-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F779-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F780-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F781-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F782-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F783-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F784-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F785-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F786-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F787-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F788-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F789-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F790-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F791-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F792-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F793-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F794-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F795-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F796-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F797-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F798-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F799-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F800-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F801-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F802-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F803-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F804-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F805-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F806-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F807-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F808-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F809-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F810-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F811-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F812-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F813-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F814-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F815-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F816-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F817-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F818-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F819-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F820-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F821-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F822-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F823-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F824-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F825-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F826-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F827-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F828-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F829-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F830-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F831-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F832-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F833-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F834-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F835-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F836-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F837-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F838-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F839-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F840-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F841-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F842-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F843-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F844-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F845-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F846-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F847-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F848-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F849-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F850-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F851-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F852-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F853-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F854-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F855-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F856-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F857-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F858-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F859-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F860-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F861-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F862-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F863-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F864-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F865-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F866-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F867-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F868-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F869-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F870-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F871-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F872-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F873-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F874-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F875-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F876-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F877-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F878-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F879-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F880-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F881-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F882-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F883-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F884-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F885-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F886-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F887-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F888-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F889-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F890-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F891-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F892-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F893-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F894-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F895-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F896-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F897-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F898-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F899-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F900-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F901-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F902-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F903-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F904-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F905-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F906-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F907-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F908-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F909-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F910-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F911-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F912-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F913-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F914-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F915-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F916-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F917-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F918-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F919-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F920-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F921-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F922-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F923-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F924-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F925-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F926-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F927-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F928-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F929-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F930-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F931-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F932-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F933-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F934-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F935-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F936-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F937-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F938-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F939-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F940-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F941-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F942-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F943-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F944-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F945-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F946-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F947-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F948-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F949-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F950-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F951-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F952-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F953-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F954-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F955-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F956-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F957-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F958-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F959-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F960-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F961-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F962-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F963-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F964-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F965-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F966-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F967-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F968-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F969-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F970-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F971-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F972-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F973-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F974-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F975-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F976-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F977-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F978-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F979-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F980-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F981-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F982-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F983-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F984-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F985-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F986-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F987-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F988-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F989-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F990-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F991-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F992-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F993-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F994-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F995-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F996-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F997-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F998-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F999-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1000-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1001-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1002-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1003-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1004-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1005-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1006-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1007-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1008-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1009-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1010-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1011-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1012-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1013-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1014-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1015-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1016-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1017-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1018-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1019-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1020-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1021-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1022-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1023-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1024-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1025-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1026-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1027-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1028-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1029-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1030-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1031-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1032-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1033-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1034-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1035-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1036-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1037-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1038-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1039-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1040-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1041-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1042-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1043-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1044-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1045-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1046-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1047-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1048-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1049-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1050-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1051-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1052-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1053-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1054-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1055-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1056-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1057-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1058-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1059-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1060-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1061-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1062-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1063-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1064-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1065-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1066-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1067-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1068-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1069-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1070-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1071-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1072-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1073-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1074-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1075-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1076-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1077-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1078-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1079-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1080-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1081-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1082-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1083-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1084-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1085-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1086-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1087-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1088-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1089-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1090-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1091-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1092-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1093-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1094-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1095-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1096-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1097-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1098-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1099-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1100-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1101-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1102-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1103-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1104-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1105-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1106-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1107-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1108-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1109-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1110-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1111-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1112-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1113-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1114-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1115-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1116-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1117-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1118-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1119-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1120-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1121-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1122-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1123-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1124-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1125-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1126-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1127-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1128-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1129-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1130-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1131-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1132-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1133-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1134-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1135-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1136-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1137-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1138-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1139-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1140-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1141-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1142-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1143-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1144-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1145-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1146-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1147-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1148-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1149-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1150-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1151-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1152-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1153-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1154-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1155-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1156-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1157-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1158-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1159-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1160-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1161-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1162-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1163-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1164-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1165-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1166-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1167-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1168-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1169-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1170-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1171-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1172-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1173-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1174-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1175-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1176-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1177-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1178-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1179-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1180-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1181-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1182-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1183-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1184-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1185-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1186-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1187-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1188-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1189-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1190-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1191-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1192-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1193-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1194-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1195-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1196-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1197-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1198-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1199-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1200-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1201-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1202-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1203-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1204-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1205-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1206-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1207-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1208-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1209-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1210-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1211-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1212-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1213-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1214-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1215-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1216-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1217-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1218-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1219-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1220-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1221-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1222-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1223-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1224-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1225-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1226-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1227-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1228-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1229-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1230-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1231-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1232-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1233-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1234-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1235-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1236-_SEGBEGIN		
	!BYTE	15			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1237-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1238-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1239-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1240-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1241-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1242-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1243-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1244-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1245-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1246-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1247-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1248-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1249-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1250-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1251-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1252-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1253-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1254-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1255-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1256-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1257-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1258-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1259-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1260-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1261-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1262-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1263-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1264-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1265-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1266-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1267-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1268-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1269-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1270-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1271-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1272-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1273-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1274-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1275-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1276-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1277-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1278-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1279-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1280-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1281-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1282-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1283-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1284-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1285-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1286-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1287-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1288-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1289-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1290-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1291-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1292-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1293-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1294-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1295-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1296-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1297-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1298-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1299-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1300-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1301-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1302-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1303-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1304-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1305-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1306-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1307-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1308-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1309-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1310-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1311-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1312-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1313-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1314-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1315-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1316-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1317-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1318-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1319-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1320-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1321-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1322-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1323-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1324-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1325-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1326-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1327-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1328-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1329-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1330-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1331-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1332-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1333-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1334-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1335-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1336-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1337-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1338-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1339-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1340-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1341-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1342-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1343-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1344-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1345-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1346-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1347-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1348-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1349-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1350-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1351-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1352-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1353-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1354-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1355-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1356-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1357-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1358-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1359-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1360-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1361-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1362-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1363-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1364-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1365-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1366-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1367-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1368-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1369-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1370-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1371-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1372-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1373-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1374-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1375-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1376-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1377-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1378-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1379-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1380-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1381-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1382-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1383-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1384-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1385-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1386-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1387-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1388-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1389-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1390-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1391-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1392-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1393-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1394-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1395-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1396-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1397-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1398-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1399-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1400-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1401-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1402-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1403-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1404-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1405-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1406-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1407-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1408-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1409-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1410-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1411-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1412-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1413-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1414-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1415-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1416-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1417-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1418-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1419-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1420-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1421-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1422-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1423-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1424-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1425-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1426-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1427-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1428-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1429-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1430-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1431-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1432-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1433-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1434-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1435-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1436-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1437-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1438-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1439-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1440-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1441-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1442-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1443-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1444-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1445-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1446-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1447-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1448-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1449-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1450-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1451-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1452-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1453-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1454-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1455-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1456-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1457-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1458-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1459-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1460-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1461-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1462-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1463-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1464-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1465-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1466-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1467-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1468-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1469-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1470-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1471-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1472-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1473-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1474-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1475-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1476-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1477-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1478-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1479-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1480-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1481-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1482-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1483-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1484-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1485-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1486-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1487-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1488-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1489-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1490-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1491-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1492-_SEGBEGIN		
	!BYTE	2			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1493-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1494-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1495-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1496-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1497-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1498-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1499-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1500-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1501-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1502-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1503-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1504-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1505-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1506-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1507-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1508-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1509-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1510-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1511-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1512-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1513-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1514-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1515-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1516-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1517-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1518-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1519-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1520-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1521-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1522-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1523-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1524-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1525-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1526-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1527-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1528-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1529-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1530-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1531-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1532-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1533-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1534-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1535-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1536-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1537-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1538-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1539-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1540-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1541-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1542-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1543-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1544-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1545-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1546-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1547-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1548-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1549-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1550-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1551-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1552-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1553-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1554-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1555-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1556-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1557-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1558-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1559-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1560-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1561-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1562-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1563-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1564-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1565-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1566-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1567-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1568-_SEGBEGIN		
	!BYTE	5			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1569-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1570-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1571-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1572-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1573-_SEGBEGIN		
	!BYTE	29			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1574-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1575-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1576-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1577-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1578-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1579-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1580-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1581-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1582-_SEGBEGIN		
	!BYTE	0			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1583-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1584-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1585-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1586-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1587-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1588-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1589-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1590-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1591-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1592-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1593-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1594-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1595-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1596-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1597-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1598-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1599-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1600-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1601-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1602-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1603-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1604-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1605-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1606-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1607-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1608-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1609-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1610-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1611-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1612-_SEGBEGIN		
	!BYTE	19			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1613-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1614-_SEGBEGIN		
	!BYTE	30			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1615-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1616-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1617-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1618-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1619-_SEGBEGIN		
	!BYTE	19			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1620-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1621-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1622-_SEGBEGIN		
	!BYTE	19			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1623-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1624-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1625-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1626-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1627-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1628-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1629-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1630-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1631-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1632-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1633-_SEGBEGIN		
	!BYTE	19			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1634-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1635-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1636-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1637-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1638-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1639-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1640-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1641-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1642-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1643-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1644-_SEGBEGIN		
	!BYTE	21			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1645-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1646-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1647-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1648-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1649-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1650-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1651-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1652-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1653-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1654-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1655-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1656-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1657-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1658-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1659-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1660-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1661-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1662-_SEGBEGIN		
	!BYTE	0			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1663-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1664-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1665-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1666-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1667-_SEGBEGIN		
	!BYTE	14			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1668-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1669-_SEGBEGIN		
	!BYTE	34			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1670-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1671-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1672-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1673-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1674-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1675-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1676-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1677-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1678-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1679-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1680-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1681-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1682-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1683-_SEGBEGIN		
	!BYTE	31			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1684-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1685-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1686-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1687-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1688-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$81			; INTERNAL FIXUP
	!WORD	_F1689-_SEGBEGIN		
	!BYTE	$00
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1690-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1691-_SEGBEGIN		
	!BYTE	3			; ESD INDEX
	!BYTE	$91			; EXTERNAL FIXUP
	!WORD	_F1692-_SEGBEGIN		
	!BYTE	4			; ESD INDEX
	!BYTE	$00			; END OF RLD
;
; EXTERNAL/ENTRY SYMBOL DICTIONARY
;
	; DCI STRING: CMDSYS
	!BYTE	$C3,$CD,$C4,$D3,$D9,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	0			; ESD INDEX
	; DCI STRING: PUTC
	!BYTE	$D0,$D5,$D4,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	2			; ESD INDEX
	; DCI STRING: PUTLN
	!BYTE	$D0,$D5,$D4,$CC,$4E
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	3			; ESD INDEX
	; DCI STRING: PUTS
	!BYTE	$D0,$D5,$D4,$53
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	4			; ESD INDEX
	; DCI STRING: PUTI
	!BYTE	$D0,$D5,$D4,$49
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	5			; ESD INDEX
	; DCI STRING: HEAPALLOC
	!BYTE	$C8,$C5,$C1,$D0,$C1,$CC,$CC,$CF,$43
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	14			; ESD INDEX
	; DCI STRING: HEAPRELEASE
	!BYTE	$C8,$C5,$C1,$D0,$D2,$C5,$CC,$C5,$C1,$D3,$45
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	15			; ESD INDEX
	; DCI STRING: HEAPAVAIL
	!BYTE	$C8,$C5,$C1,$D0,$C1,$D6,$C1,$C9,$4C
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	16			; ESD INDEX
	; DCI STRING: MEMSET
	!BYTE	$CD,$C5,$CD,$D3,$C5,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	17			; ESD INDEX
	; DCI STRING: MEMCPY
	!BYTE	$CD,$C5,$CD,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	18			; ESD INDEX
	; DCI STRING: STRCPY
	!BYTE	$D3,$D4,$D2,$C3,$D0,$59
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	19			; ESD INDEX
	; DCI STRING: TOUPPER
	!BYTE	$D4,$CF,$D5,$D0,$D0,$C5,$52
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	21			; ESD INDEX
	; DCI STRING: ISULT
	!BYTE	$C9,$D3,$D5,$CC,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	26			; ESD INDEX
	; DCI STRING: ARGFIRST
	!BYTE	$C1,$D2,$C7,$C6,$C9,$D2,$D3,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	29			; ESD INDEX
	; DCI STRING: ARGNEXT
	!BYTE	$C1,$D2,$C7,$CE,$C5,$D8,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	30			; ESD INDEX
	; DCI STRING: FILEIO
	!BYTE	$C6,$C9,$CC,$C5,$C9,$4F
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	31			; ESD INDEX
	; DCI STRING: EXCEPT
	!BYTE	$C5,$D8,$C3,$C5,$D0,$54
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	34			; ESD INDEX
	; DCI STRING: THROW
	!BYTE	$D4,$C8,$D2,$CF,$57
	!BYTE	$10			; EXTERNAL SYMBOL FLAG
	!WORD	35			; ESD INDEX
	; DCI STRING: FREEOP_LST
	!BYTE	$C6,$D2,$C5,$C5,$CF,$D0,$DF,$CC,$D3,$54
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D083		
	; DCI STRING: OPTIMIZE_SEQ
	!BYTE	$CF,$D0,$D4,$C9,$CD,$C9,$DA,$C5,$DF,$D3,$C5,$51
	!BYTE	$08			; ENTRY SYMBOL FLAG
	!WORD	_D084		
	!BYTE	$00			; END OF ESD
