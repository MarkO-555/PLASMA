include "inc/cmdsys.plh"
include "inc/args.plh"
include "inc/fileio.plh"
include "inc/conio.plh"
include "inc/longjmp.plh"
//
// FORTH dictionary layout
//
//  bytes   usage
//  -----   -----
// [1]      name length
// [1..255] name
// [1]      FFA (flag field address)
// [2]      LFA (link field address)
// [2]      CFA (code field address)
// [2..]    PFA (param field address)
//

//
// Mask and flags for dictionary entries
//
const param_flag    = $02
const itc_flag      = $04
const inline_flag   = $08
const inlinew_flag  = $10
const imm_flag      = $20
const componly_flag = $40
const hidden_flag   = $80
//
// Predefine instrinsics
//
predef _drop_(a)#0, _swap_(a,b)#2, _dup_(a)#2, _dashdup_(a)#1, _over_(a,b,c)#4, _rot_(a,b,c)#3
predef _add_(a,b)#1, _inc_(a)#1, _inc2_(a)#1, _sub_(a,b)#1, _mul_(a,b)#1, _div_(a,b)#1
predef _neg_(a)#1, _and_(a,b)#1, _or_(a,b)#1, _xor_(a,b)#1, _not_(a)#1
predef _mod_(a,b)#1, _abs_(a)#1, _max_(a,b)#1, _min_(a,b)#1
predef _lshift_(a,b)#1, _rshift_(a,b)#1
predef _cset_(a,b)#0, _cget_(a)#1, _wset_(a,b)#0, _wplusset_(a,b)#0, _wget_(a)#1
predef _ffa_(a)#1, _lfa_(a)#1, _cfa_(a)#1, _pfa_(a)#1, _allot_(a)#0
predef _eq_(a,b)#1, _gt_(a,b)#1, _lt_(a,b)#1, _0lt_(a)#1, _0eq_(a)#1
predef _branch_#0, _0branch_(a)#0, _if_#0, _else_#0, _then_#0
predef _begin_#0, _again_#0, _until_#0, _while_#0, _repeat_#0
predef _case_#0, _of_#0, _endof_#0, _endcase_#0, _literal_(a)#0
predef _do_#0, _doloop_#0, _doplusloop_(a)#0, _plusloop_#0, _loop_#0, _leave_#0, _j_#1
predef _create_#0, _itcdoes_(a)#0, _does_#0
predef pfillw(a)#0, pfillb(a)#0, _colon_#0, _semi_#0
predef _tors_(a)#0, _fromrs_#1, _toprs_#1, _execute_(a)#0, _lookup_#1
predef _cmove_(a,b,c)#0, _move_(a,b,c)#0, _fill_(a,b,c)#0, _plasma_(a)#0
predef _var_(a)#0, _const_(a)#0, _lit_#1, _slit_#1, _tick_#1, _forget_#0
predef _terminal_#1, _prat_(a)#0, _str_#0, _prstr_#0, _src_#0
predef _vlist_#0, _tron_#0, _troff_#0, _itc_#0, _pbc_#0, _comment_#0
predef _brkout_#0, _brkon_#0, _brkoff_#0, _word_(a)#1
predef _space_#0, _spaces_(a)#0, _show_#0, _showstack_#0, _showrstack_#0
predef _cont_#0, _restart_#0, _bye_#0, _quit_#0, _abort_#0
// DROP
char d_drop = "DROP"
byte = inline_flag
word = 0, @_drop_, $30
// SWAP
char d_swap = "SWAP"
byte = 0
word = @d_drop, @_swap_
// DUP
char d_dup = "DUP"
byte = inline_flag
word = @d_swap, @_dup_, $34
// -DUP
char d_dashdup = "-DUP"
byte = 0
word = @d_dup, @_dashdup_
// OVER
word d_over = "OVER"
byte = 0
word = @d_dashdup, @_over_
// ROT
word d_rot = "ROT"
byte = 0
word = @d_over, @_rot_
// ADD
char d_add = "+"
byte = inline_flag
word = @d_rot, @_add_, $82
// ONE PLUS
char d_inc = "1+"
byte = inline_flag
word = @d_add, @_inc_, $8C
// TWO PLUS
char d_inc2 = "2+"
byte = inlinew_flag
word = @d_inc, @_inc2_, $8C8C
// SUB
char d_sub = "-"
byte = inline_flag
word = @d_inc2, @_sub_, $84
// MUL
char d_mul = "*"
byte = inline_flag
word = @d_sub, @_mul_, $86
// DIV
char d_div = "/"
byte = inline_flag
word = @d_mul, @_div_, $88
// DIVMOD
char d_divmod = "/MOD"
byte = inline_flag
word = @d_div, @divmod, $36
// MOD
char d_mod = "MOD"
byte = inline_flag
word = @d_divmod, @_mod_, $8A
// NEG
char d_neg = "NEG"
byte = inline_flag
word = @d_mod, @_neg_, $90
// AND
char d_and = "AND"
byte = inline_flag
word = @d_neg, @_and_, $94
// OR
char d_or = "OR"
byte = inline_flag
word = @d_and, @_or_, $96
// XOR
char d_xor = "XOR"
byte = inline_flag
word = @d_or, @_xor_, $98
// NOT
char d_not = "NOT"
byte = inline_flag
word = @d_xor, @_not_, $92
// LEFT SHIFT
char d_lshift = "LSHIFT"
byte = inline_flag
word = @d_not, @_lshift_, $9A
// RIGHT SHIFT
char d_rshift = "RSHIFT"
byte = inline_flag
word = @d_lshift, @_rshift_, $9C
// EQUALS
char d_eq = "="
byte = inline_flag
word = @d_rshift, @_eq_, $40
// GREATER THAN
char d_gt = ">"
byte = inline_flag
word = @d_eq, @_gt_, $44
// LESS THAN
char d_lt = "<"
byte = inline_flag
word = @d_gt, @_lt_, $46
// LESS THAN ZERO
char d_0lt = "0<"
byte = inlinew_flag
word = @d_lt, @_0lt_, $4600 // ZERO ISLT
// EQUALS ZERO
char d_0eq = "0="
byte = inlinew_flag
word = @d_0lt, @_0eq_, $4000 // ZERO ISEQ
// ABS
char d_abs = "ABS"
byte = 0
word = @d_0eq, @_abs_
// MIN
char d_min = "MIN"
byte = 0
word = @d_abs, @_min_
// MAX
char d_max = "MAX"
byte = 0
word = @d_min, @_max_
// CHAR PUT
char d_cset = "C!"
byte = inline_flag
word = @d_max, @_cset_, $70
// WORD PUT
char d_wset = "!"
byte = inline_flag
word = @d_cset, @_wset_, $72
// WORD PLUS PUT
char d_wplusset = "+!"
byte = 0
word = @d_wset, @_wplusset_
// CHAR GET
char d_cget = "C@"
byte = inline_flag
word = @d_wplusset, @_cget_, $60
// WORD SET
char d_wget = "@"
byte = inline_flag
word = @d_cget, @_wget_, $62
// EXECUTE
char d_execute = "EXECUTE"
byte = inline_flag
word = @d_wget, @_execute_, $56 // ICAL
// TO RSTACK
char d_torstk = ">R"
byte = 0
word = @d_execute, @_tors_
// FROM RSTACK
char d_fromrstk = "R>"
byte = 0
word = @d_torstk, @_fromrs_
// TOP OF RSTACK
char d_toprstk = "R@"
byte = 0
word = @d_fromrstk, @_toprs_
// PLASMA SYMBOL LOOKUP
char d_lookup = "LOOKUP"
byte = imm_flag
word = @d_toprstk, @_lookup_
// PLASMA LINKEAGE
char d_plasma = "PLASMA"
byte = 0
word = @d_lookup, @_plasma_
// VARIABLE
char d_var = "VARIABLE"
byte = 0
word = @d_plasma, @_var_
// CONSTANT
char d_const = "CONSTANT"
byte = 0
word = @d_var, @_const_
// CMOVE
char d_cmove = "CMOVE"
byte = 0
word = @d_const, @_cmove_
// MOVE
char d_move = "MOVE"
byte = 0
word = @d_cmove, @_move_
// FILL
char d_fill = "FILL"
byte = 0
word = @d_move, @_fill_
// HERE
char d_here = "HERE"
byte = 0
word = @d_fill, @heapmark
// ALLOT
char d_allot = "ALLOT"
byte = 0
word = @d_here, @_allot_
// BRANCH
char d_branch = "(BRANCH)"
byte = componly_flag | param_flag
word = @d_allot, @_branch_
// BRANCH IF 0
char d_0branch = "(0BRANCH)"
byte = componly_flag | param_flag
word = @d_branch, @_0branch_
// IF
char d_if = "IF"
byte = imm_flag
word = @d_0branch, @_if_
// ELSE
char d_else = "ELSE"
byte = imm_flag
word = @d_if, @_else_
// THEN
char d_then = "THEN"
byte = imm_flag
word = @d_else, @_then_
// CASE
char d_case = "CASE"
byte = imm_flag
word = @d_then, @_case_
// OF
char d_of = "OF"
byte = imm_flag
word = @d_case, @_of_
// ENDOF
char d_endof = "ENDOF"
byte = imm_flag
word = @d_of, @_endof_
// ENDCASE
char d_endcase = "ENDCASE"
byte = imm_flag
word = @d_endof, @_endcase_
// DO
char d_do = "DO"
byte = imm_flag
word = @d_endcase, @_do_
// LEAVE
char d_leave = "LEAVE"
byte = componly_flag
word = @d_do, @_leave_
// COMPILED LOOP
char d_doloop = "(DOLOOP)"
byte = componly_flag | param_flag
word = @d_leave, @_doloop_
// LOOP
char d_loop = "LOOP"
byte = imm_flag
word = @d_doloop, @_loop_
// COMPILED LOOP+
char d_doplusloop = "(+DOLOOP)"
byte = componly_flag | param_flag
word = @d_loop, @_doplusloop_
// LOOP
char d_plusloop = "+LOOP"
byte = imm_flag
word = @d_doplusloop, @_plusloop_
// I
char d_i = "I"
byte = componly_flag
word = @d_plusloop, @_toprs_
// J
char d_j = "J"
byte = componly_flag
word = @d_i, @_j_
// BEGIN
char d_begin = "BEGIN"
byte = imm_flag
word = @d_j, @_begin_
// AGAIN
char d_again = "AGAIN"
byte = imm_flag
word = @d_begin, @_again_
// UNTIL
char d_until = "UNTIL"
byte = imm_flag
word = @d_again, @_until_
// WHILE
char d_while = "WHILE"
byte = imm_flag
word = @d_until, @_while_
// REPEAT
char d_repeat = "REPEAT"
byte = imm_flag
word = @d_while, @_repeat_
// FORGET
char d_forget = "FORGET"
byte = 0
word = @d_repeat, @_forget_
// CREATE
char d_create = "CREATE"
byte = 0
word = @d_forget, @_create_
// BUILDS
char d_builds = "<BUILDS"
byte = 0
word = @d_create, @_create_
// RECREATE/DOES COMPILE TIME
char d_createdoes = "(CREATEDOES)"
byte = componly_flag
word = @d_builds, @_itcdoes_
// DOES
char d_does = "DOES>"
byte = imm_flag
word = @d_createdoes, @_does_
// COMMA
char d_comma = ","
byte = 0
word = @d_does, @pfillw
// COMMA
char d_commab = "C,"
byte = 0
word = @d_comma, @pfillb
// COLON
char d_colon = ":"
byte = 0
word = @d_commab, @_colon_
// SEMI
char d_semi = ";"
byte = imm_flag
word = @d_colon, @_semi_
// TICK
char d_tick = "'"
byte = 0
word = @d_semi, @_tick_
// INLINE LITERAL NUMBER
char d_lit = "LIT"
byte = param_flag
word = @d_tick, @_lit_
// COMPILED LITERAL NUMBER
char d_literal = "LITERAL"
byte = imm_flag
word = @d_lit, @_literal_
// ?TERMINAL
char d_terminal = "?TERMINAL"
byte = 0
word = @d_lit, @_terminal_
// KEY
char d_key = "KEY"
byte = 0
word = @d_terminal, @getc
// WORD
char d_word = "WORD"
byte = 0
word = @d_key, @_word_
// PRINT @TOS
char d_prat = "?"
byte = 0
word = @d_word, @_prat_
// PRINT TOS
char d_prtos = "."
byte = 0
word = @d_prat, @puti
// PRINT TOS HEX
char d_prtoshex = ".$"
byte = 0
word = @d_prtos, @puth
// PRINT TOS HEX
char d_prtosbyte = ".C$"
byte = 0
word = @d_prtoshex, @putb
// EMIT
char d_emit = "EMIT"
byte = 0
word = @d_prtosbyte, @putc
// CR
char d_cr = "CR"
byte = 0
word = @d_emit, @putln
// SPACE
char d_space = "SPACE"
byte = 0
word = @d_cr, @_space_
// SPACES
char d_spaces = "SPACES"
byte = 0
word = @d_space, @_spaces_
// STRING
char d_str = "\""
byte = imm_flag
word = @d_spaces, @_str_
// LITERAL STRING
char d_slit = "SLIT"
byte = param_flag
word = @d_str, @_slit_
// COMPILED PRINT STRING
char d_doprstr = "(.\")"
byte = 0
word = @d_slit, @puts
// PRINT STRING
char d_prstr = ".\""
byte = imm_flag
word = @d_doprstr, @_prstr_
// SOURCE FILE
char d_prsrc = "SRC\""
byte = 0
word = @d_prstr, @_src_
// CONT
char d_cont = "CONT"
byte = 0
word = @d_prsrc, @_cont_
// QUIT
char d_quit = "QUIT"
byte = 0
word = @d_cont, @_quit_
// ABORT
char d_abort = "ABORT"
byte = 0
word = @d_quit, @_abort_
// RESTART
char d_restart = "RESTART"
byte = 0
word = @d_abort, @_restart_
// BYE
char d_bye = "BYE"
byte = 0
word = @d_restart, @_bye_
// SHOW DEFINITION
char d_show = "SHOW"
byte = 0
word = @d_bye, @_show_
// SHOW STACK
char d_showstack = "SHOWSTACK"
byte = 0
word = @d_show, @_showstack_
// SHOW RSTACK
char d_showrstack = "SHOWRSTACK"
byte = 0
word = @d_showstack, @_showrstack_
// TRACE ON
char d_tron = "TRON"
byte = 0
word = @d_showrstack, @_tron_
// TRACE OFF
char d_troff = "TROFF"
byte = 0
word = @d_tron, @_troff_
// BREAK OUT
char d_brkout = "BRKOUT"
byte = 0
word = @d_troff, @_brkout_
// BREAK ON
char d_brkon = "BRKON"
byte = 0
word = @d_brkout, @_brkon_
// BREAK OFF
char d_brkoff = "BRKOFF"
byte = 0
word = @d_brkon, @_brkoff_
//  COMPILE USING ITC
char d_itc = "ITC"
byte = 0
word = @d_brkoff, @_itc_
// COMPILE USING PLASMA BYTECODES
char d_pbc = "PBC"
byte = 0
word = @d_itc, @_pbc_
// COMMENT
char d_comment = "("
byte = imm_flag
word = @d_pbc, @_comment_
// LIST VOCAB
char d_vlist = "VLIST"
byte = 0
word = @d_comment, @_vlist_
//
// Internal variables
//
word  vlist = @d_vlist
word  startheap, arg, infunc, inptr, IIP, W, exit
const keyinbuf = $1FF
const SRCREFS    = 2
const INBUF_SIZE = 81
byte  srclevel   = 0
byte  inref[SRCREFS]
word  previnptr[SRCREFS]
char  inbuf[SRCREFS * INBUF_SIZE]
word  inbufptr
//
// RSTACK
//
const RSTK_SIZE = 16
byte RSP = RSTK_SIZE
word RSTACK[RSTK_SIZE]
//
// State flags
//
const exit_flag     = $01
const trace_flag    = $02
const comp_itc_flag = $10
const comp_pbc_flag = $20
const comp_flag     = comp_itc_flag | comp_pbc_flag
//
// Mode and state
//
byte comp_mode = comp_itc_flag
byte state     = 0
byte brk       = 0
word brkentry  = 0
word brkcfa    = 0
byte _get_estack   = $8A           // TXA
byte               = $49, $FF      // EOR #$FF
byte               = $38           // SEC
byte               = $69, $10      // ADC #$10
byte               = $C9, $11      // CMP #$11
byte               = $90, $02      // BCC +2
byte               = $A2, $10      // LDX #ESTKSZ/2
byte               = $CA           // DEX
byte               = $95           // STA
byte _estkl        = $D0           // ESTKL,X
byte               = $A9, $00      // LDA #$00
byte               = $95           // STA
byte _estkh        = $C0           // ESTKH,X
byte               = $60           // RTS
byte _reset_estack = $A2, $10      // LDX #ESTKSZ/2
byte               = $60           // RTS
//
// Helper routines
//
predef interpret#0
//
// Input routines
//
def keyin#0
  byte i

  repeat
    if state & comp_flag
      inptr = gets(']'|$80) // Compilation continuation prompt
    else
      if brk
        puts(" BRK("); puti(brk); putc(')')
      else
        puts(" OK")
      fin
      inptr = gets('\n'|$80)
    fin
  until ^inptr
  ^(inptr + ^inptr + 1) = 0 // NULL terminate
  inptr++
end
def filein#0
  byte len
  repeat
      len = fileio:read(inref[srclevel-1], inbufptr, INBUF_SIZE-1)
      if len
        len-- // Remove trailing carriage return
        ^(inbufptr + len) = 0 // NULL terminate
        inptr             = inbufptr
      else
        srclevel--
        fileio:close(inref[srclevel]) // EOF
        inref[srclevel] = 0
        inbufptr        = inbufptr - INBUF_SIZE
        inptr           = previnptr[srclevel]
        if srclevel == 0              // - switch back to keyboard input
            infunc = @keyin
            keyin
            return
        fin
      fin
    until len
end
def nextword(delim)#2
  word wordptr
  byte len

  repeat
    if !^inptr
      infunc()#0
    fin
    while ^inptr == delim // Skip leading delimiter
      inptr++
    loop
  until ^inptr
  wordptr = inptr
  while ^inptr and ^inptr <> delim // Tokenize characters
    inptr++
  loop
  len = inptr - wordptr
  if ^inptr // Skip trailing delimiter
    inptr++
  fin
  return wordptr, len
end
//
// Find match in dictionary
//
def find(matchchars, matchlen)#1
  word dentry
  byte i

  matchchars--
  dentry = vlist
  while dentry
    if ^dentry == matchlen
      for i = 1 to ^dentry
        if ^(matchchars+i) <> ^(dentry+i)
          break
        fin
      next
      if i > ^dentry
        return dentry
      fin
    fin
    dentry = *(dentry + ^dentry + 2)
  loop
  // Not found
  return 0
end
//
// Convert input into number
//
def isnum(numchars, numlen)#2
  word num, sign
  byte numchar

  sign = 1
  if ^numchars == '-'
    sign = -1
    numchars++
    numlen--
    if numlen == 0
      return 0, 0
    fin
  fin
  num = 0
  if ^numchars == '$'
    numchars++
    numlen--
    if numlen == 0
      return 0, 0
    fin
    while numlen
      numchar = toupper(^numchars)
      if numchar >= '0' and numchar <= '9'
        num = num * 16 + numchar - '0'
      elsif numchar >= 'A' and numchar <= 'F'
        num = num * 16 + numchar - 'A' + 10
      else
        break
      fin
      numchars++
      numlen--
    loop
  else
    while numlen
      numchar = ^numchars
      if numchar < '0' or numchar > '9'
        break
      fin
      num = num * 10 + numchar - '0'
      numchars++
      numlen--
    loop
  fin
  return num * sign, numlen == 0
end
//
// Break handler
//
def showtrace(dentry)#0
    puts("\n[ "); _showstack_; puts("] "); puts(dentry); puts(": ")
end
def brkhandle(dentry)#0
  word brk_infn, brk_inptr, brk_iip
  byte brk_state

  showtrace(dentry)
  brk++
  brk_state = state
  brk_iip   = IIP
  brk_infn  = infunc
  brk_inptr = inptr
  state  = 0
  infunc = @keyin
  inptr  = keyinbuf
  ^inptr = 0
  interpret
  state  = brk_state
  IIP    = brk_iip
  infunc = brk_infn
  inptr  = brk_inptr
  brk--
end
//
// Execute code in CFA
//
def execword(dentry)#0

  when conio:keypressed()
    is $83 // CTRL-C
      getc // Clear KB
      brkhandle(dentry)
      break
    is $94 // CTRL-T
      getc // Clear KB strobe
      state = state ^ trace_flag
      break
  wend
  if state & trace_flag
    showtrace(dentry)
  fin
  W = _cfa_(dentry)
  (*W)()#0
  if (@_get_estack)()#1 > 16
    puts("Stack over/underflow\n")
    _abort_
  fin
end
def execwords(wlist)#0
  word prevIP, dentry

  prevIP = IIP
  IIP    = wlist
  dentry = *IIP
  while dentry
    IIP    = IIP + 2
    execword(dentry)
    dentry = *IIP
  loop
  IIP = prevIP
end
def push(a)#1 // Stack hack - call as (@push)(a)#0 to leave a on eval stack
  return a
end
def pfillw(a)#0
  *(heapalloc(2)) = a
end
def pfillb(a)#0
  *(heapalloc(1)) = a
end
//
// Warm start
//
def warmstart#0
  (@_reset_estack)()#0
  brk    = 0
  RSP    = RSTK_SIZE
  infunc = @keyin
  inptr  = keyinbuf
  ^inptr = 0
  if state & comp_flag // Undo compilation state
    heaprelease(vlist)
    vlist = *_lfa_(vlist)
  fin
  state = 0
  while srclevel
    srclevel--
    fileio:close(inref[srclevel])
    inref[srclevel] = 0
  loop
end
//
// Cold start
//
def coldstart#0
  vlist = @d_vlist
  heaprelease(startheap)
  warmstart
end
def interpret#0
  word inchars, dentry, value
  byte inlen, valid

  //
  // Set flags on words
  //
  repeat
    inchars, inlen = nextword(' ')
    dentry = find(inchars, inlen)
    if dentry
      if (not (state & comp_flag)) or (^_ffa_(dentry) & imm_flag)
        if ^_ffa_(dentry) & componly_flag
          inchars--
          ^inchars = inlen
          puts(inchars)
          puts(" : Compile ony word\n")
          _abort_
        fin
        execword(dentry)
      elsif state & comp_itc_flag
        pfillw(dentry)
      elsif state & comp_pbc_flag
        if ^_ffa_(dentry) & itc_flag // Check if calling ITC word
          pfillb($2C)    // CONSTANT WORD
          pfillw(dentry) // Pointer to dictionary entry
          pfillb($54)    // CALL execword
          pfillw(@execword)
        elsif ^_ffa_(dentry) & inline_flag // inline bytecode
          pfillb(^_pfa_(dentry))
        elsif ^_ffa_(dentry) & inlinew_flag // inline 2 bytecodes
          pfillw(*_pfa_(dentry))
        else
          pfillb($54) // CALL CFA directly
          pfillw(*_cfa_(dentry))
        fin
      fin
    else
      value, valid = isnum(inchars, inlen)
      if not valid
        inchars--
        ^inchars = inlen
        puts(inchars)
        puts(" ? No match\n")
        warmstart
      else
        if state & comp_flag
          if state & comp_itc_flag
            pfillw(@d_lit)
            pfillw(value) // Poke literal value into dictionary
          else // comp_pbc_flag
            if value >= 0 and value <= 15
              pfillb(value << 1) // CONSTANT NIBBLE
            elsif value == -1
              pfillb($20) // CONSTANT MINUS_ONE
            else
              pfillb($2C) // CONSTANT WORD
              pfillw(value) // Poke literal value into dictionary
            fin
          fin
        else
          (@push)(value)#0
        fin
      fin
    fin
  until state & exit_flag
end
//
// Intrinsics
//
def _drop_(a)#0
  return
end
def _swap_(a,b)#2
  return b,a
end
def _dup_(a)#2
  return a,a
end
def _dashdup_(a)#1
  if a; (@push)(a)#0; fin
  return a
end
def _over_(a,b,c)#4
  return a,b,c,a
end
def _rot_(a,b,c)#3
  return b,c,a
end
def _add_(a,b)#1
  return a+b
end
def _inc_(a)
  return a + 1
end
def _inc2_(a)
  return a + 2
end
def _sub_(a,b)#1
  return a-b
end
def _mul_(a,b)#1
  return a*b
end
def _div_(a,b)#1
  return a/b
end
def _mod_(a,b)#1
    return a%b
end
def _neg_(a)#1
  return -a
end
def _lshift_(a,b)#1
    return a<<b
end
def _rshift_(a,b)#1
    return a>>b
end
def _and_(a,b)#1
  return a & b
end
def _or_(a,b)#1
  return a | b
end
def _xor_(a,b)#1
  return a ^ b
end
def _not_(a)#1
  return ~a
end
def _eq_(a,b)#1
  return a == b
end
def _gt_(a,b)#1
  return a > b
end
def _lt_(a,b)#1
  return a < b
end
def _0lt_(a)#1
  return a < 0
end
def _0eq_(a)#1
  return a == 0
end
def _cset_(a,b)#0
  ^b = a
end
def _wset_(a,b)#0
  *b = a
end
def _wplusset_(a,b)#0
  *b = *b + a
end
def _abs_(a)#1
  return a < 0 ?? -a :: a
end
def _min_(a,b)#1
  return a > b ?? b :: a
end
def _max_(a,b)
  return a > b ?? a :: b
end
def _cget_(a)#1
  return ^a
end
def _wget_(a)#1
  return *a
end
def _execute_(a)#0
  a()#0
end
def _ffa_(dentry)#1
  return dentry + ^dentry + 1
end
def _lfa_(dentry)#1
  return dentry + ^dentry + 2
end
def _cfa_(dentry)#1
 return dentry + ^dentry + 4
end
def _pfa_(dentry)#1
 return dentry + ^dentry + 6
end
def _tors_(a)#0
  if RSP == 0
    puts("Return stack overflow\n")
    _abort_
  fin
  RSP--
  RSTACK[RSP] = a
end
def _fromrs_#1
  if RSP == RSTK_SIZE
    puts("Return stack underflow\n")
    _abort_
  fin
  RSP++
  return RSTACK[RSP - 1]
end
def _toprs_#1
  return RSTACK[RSP]
end
def _lit_#1
  word lit

  lit = *IIP
  IIP = IIP + 2
  return lit
end
def _slit_#1
  word slit

  slit = IIP
  IIP  = IIP + ^IIP + 1
  return slit
end
def _allot_(a)#0
  heapalloc(a)
end
def _cmove_(a,b,c)#0
  memcpy(b, a, c)
end
def _move_(a,b,c)#0
  memcpy(b, a, c * 2)
end
def _fill_(a,b,c)#0
  memset(a, c | (c << 8), b)
end
def stodci(str, dci)
  byte len, c

  len = ^str
  if len == 0
    ^dci = 0
    return dci
  fin
  c = toupper(^(str + len)) & $7F
  len--
  ^(dci + len) = c
  while len
    c = toupper(^(str + len)) | $80
    len--
    ^(dci + len) = c
  loop
  return dci
end
def _lookup_#1
  word symname
  char symlen, dci[31]

  symname, symlen = nextword(' ')
  symname--
  ^symname = symlen
  return cmdsys:lookupsym(stodci(symname, @dci))
end
def newdict#0
  word bldptr, plist, namechars, namelen

  namechars, namelen = nextword(' ')
  plist  = vlist
  vlist  = heapmark
  ^vlist = namelen
  bldptr = vlist + 1
  while namelen
    ^bldptr = ^namechars
    bldptr++
    namechars++
    namelen--
  loop
  ^bldptr = 0           // Flags
  bldptr++
  *bldptr = plist;      // Link ptr
  bldptr  = bldptr + 2
  *bldptr = bldptr + 2 b// Point CFA to PFA
  heapalloc(bldptr - vlist + 2)
end
def _plasma_(a)#0
  newdict
  *(_cfa_(vlist)) = a  // PLASMA code address
end
def _var_(a)#0
  newdict
  pfillb(^(@divmod))   // Hack - get VM entry vector from divmod
  pfillw(*(@divmod + 1))
  pfillb($2C)          // CONSTANT WORD
  pfillw(heapmark + 3) // Poiner to variable in PFA
  pfillb($5C)          // RET
  pfillw(a)            // Variable storage
end
def _const_(a)#0
  newdict
  pfillb(^(@divmod))   // Hack - get VM entry vector from divmod
  pfillw(*(@divmod + 1))
  pfillb($2C)          // CONSTANT WORD
  pfillw(a)
  pfillb($5C)          // RET
end
def _create_#0
  newdict
  pfillb(^(@divmod))   // Hack - get VM entry vector from divmod
  pfillw(*(@divmod + 1))
  pfillb($2C)          // CONSTANT WORD
  pfillw(heapmark + 6) // Pointer to rest of PFA
  pfillb($5C)          // RET
  // Reserve following in case of DOES>
  pfillw(0)            // reserved word for DOES>
  pfillb(0)            // Reserved byte for DOES>
  //
  // 10 bytes after PFA, data follows...
  //
end
def _dodoes_#0
  (@push)(W + 12)#0   // Pointer to PFA storage
  execwords(*(W + 2)) // Exec PFA ptr
end
def _itcdoes_(a)#0
  //
  // Overwrite CREATE as ITC words
  //
  ^(_ffa_(vlist))     = itc_flag
  *(_cfa_(vlist))     = @_dodoes_
  *(_pfa_(vlist))     = a // Fill in DOES code address
end
def _pbcdoes_(a)#0
  //
  // Rewrite the end of CREATE
  //
  ^(_pfa_(vlist) + 6) = $54    // CALL DOES> directly
  *(_pfa_(vlist) + 7) = a
  ^(_pfa_(vlist) + 9) = $5C    // RET
end
def _does_#0
  if state & comp_itc_flag
    pfillw(@d_lit)
    pfillw(heapmark + 6) // Pointer to DOES code
    pfillw(@d_createdoes)
    pfillw(0)
    // End of <BUILDS, beginning of DOES>
  else // comp_pbc_flag
    pfillb($2C)           // CONSTANT WORD
    pfillw(heapmark + 6)  // Pointer to DOES code
    pfillb($54)           // CALL
    pfillw(@_pbcdoes_)      // Fills in code address reserved in _compbuilds_
    pfillb($5C)           // RET
    // End of BUILDS, beginning of DOES> code
    pfillb(^(@divmod))    // Hack - get VM entry vector from divmod
    pfillw(*(@divmod + 1))
  fin
end
def _literal_(a)#0
  if state & comp_flag
    if state & comp_itc_flag
      pfillw(@d_lit)
      pfillw(a) // Poke literal value into dictionary
    else // comp_pbc_flag
      if a >= 0 and a <= 15
        pfillb(a << 1) // CONSTANT NIBBLE
      elsif a == -1
        pfillb($20)    // CONSTANT MINUS_ONE
      else
        pfillb($2C)    // CONSTANT WORD
        pfillw(a)      // Poke literal value into dictionary
      fin
    fin
  else
    pfillw(a) // Not really sure what to do here
  fin
end
def _docolon_#0
  execwords(W + 2) // Exec PFA
end
def _colon_#0
  newdict
  state = state | comp_mode
  if state & comp_itc_flag
    ^(_ffa_(vlist)) = itc_flag
    *(_cfa_(vlist)) = @_docolon_
  else // comp_pbc_flag
    pfillb(^(@divmod)) // Hack - get VM entry vector from divmod
    pfillw(*(@divmod + 1))
  fin
end
def _semi_#0
  if state & comp_itc_flag
    pfillw(0)
  elsif state & comp_pbc_flag
    pfillb($5C) // RET
  else
    puts("; Not compiling\n")
    _abort_
  fin
  state = state & ~comp_flag
end
def _immediate_#0
  ^_ffa_(vlist) = ^_ffa_(vlist) | imm_flag
end
def _branch_#0
  IIP = *IIP
end
def _0branch_(a)#0
  if a
    IIP = IIP + 2
  else
    IIP = *IIP
  fin
end
def _if_#0
  if state & comp_itc_flag
    pfillw(@d_0branch)
  else // comp_pbc_flag
    pfillb($4C) // BRFLS
  fin
  _tors_(heapalloc(2)) // Save backfill address
end
def _else_#0
  word backref

  backref = _fromrs_
  if state & comp_itc_flag
    pfillw(@d_branch)
    _tors_(heapalloc(2))
    *backref = heapmark
  else // comp_pbc_flag
    pfillb($50) // BRNCH
    _tors_(heapalloc(2))
    *backref = heapmark - backref // Relative branch
  fin
end
def _then_#0
  word backref

  backref = _fromrs_
  if state & comp_itc_flag
    *backref = heapmark
  else // comp_pbc_flag
    *backref = heapmark - backref // Relative branch
  fin
end
def _case_#0
  if state & comp_itc_flag
    pfillw(@d_dup)
  else // comp_pbc_flag
    pfillb($34) // DUP
  fin
  _tors_(0) // Linked address list
end
def _of_#0
  if state & comp_itc_flag
    pfillw(@d_eq)
    pfillw(@d_0branch)
  else // comp_pbc_flag
    pfillb($24) // BRNE
  fin
  _tors_(heapalloc(2)) // Save backfill address
end
def _endof_#0
  word backref, link

  backref = _fromrs_
  link    = _fromrs_
  if state & comp_itc_flag
    pfillw(@d_branch)
    _tors_(heapmark)
    pfillw(link)
    *backref = heapmark
    pfillw(@d_dup)
  else // comp_pbc_flag
    pfillb($50) // BRNCH
    _tors_(heapmark)
    pfillw(link)
    *backref = heapmark - backref // Relative branch
    pfillb($34) // DUP
  fin
end
def _endcase_#0
  word backref, link

  if state & comp_itc_flag
    pfillw(@d_drop)
  else // comp_pbc_flag
    pfillb($30) // DROP
  fin
  backref = _fromrs_
  while backref
    link = *backref
    if state & comp_itc_flag
      *backref = heapmark
    else // comp_pbc_flag
      *backref = heapmark - backref // Relative branch
    fin
    backref = link
  loop
  if state & comp_itc_flag
    pfillw(@d_drop)
  else // comp_pbc_flag
    pfillb($30) // DROP
  fin
end
def _do_#0
  if state & comp_itc_flag
    pfillw(@d_swap)
    pfillw(@d_torstk)
    pfillw(@d_torstk)
  else // comp_pbc_flag
    pfillb($54) // CALL
    pfillw(@_swap_)
    pfillb($54) // CALL
    pfillw(@_tors_)
    pfillb($54) // CALL
    pfillw(@_tors_)
  fin
  _tors_(heapmark)
end
def _leave_#0
  RSTACK[RSP] = RSTACK[RSP + 1] - 1
end
def _doloop_#0
  RSTACK[RSP]++
  if RSTACK[RSP] == RSTACK[RSP + 1]
    RSP = RSP + 2
    IIP = IIP + 2
  else
    IIP = *IIP
  fin
end
def _dopbcloop_#1
  RSTACK[RSP]++
  if RSTACK[RSP] == RSTACK[RSP + 1]
    RSP = RSP + 2
    return TRUE
  fin
  return FALSE
end
def _doplusloop_(a)#0
  RSTACK[RSP] = RSTACK[RSP] + a
  if (a >= 0 and RSTACK[RSP] >= RSTACK[RSP + 1]) or (a < 0 and RSTACK[RSP] <= RSTACK[RSP + 1])
    RSP = RSP + 2
    IIP = IIP + 2
  else
    IIP = *IIP
  fin
end
def _dopbcplusloop_(a)#1
  RSTACK[RSP] = RSTACK[RSP] + a
  if (a >= 0 and RSTACK[RSP] >= RSTACK[RSP + 1]) or (a < 0 and RSTACK[RSP] <= RSTACK[RSP + 1])
    RSP = RSP + 2
    return TRUE
  fin
  return FALSE
end
def _loop_#0
  if state & comp_itc_flag
    pfillw(@d_doloop)
    pfillw(_fromrs_)
  else // comp_pbc_flag
    pfillb($54) // CALL
    pfillw(@_dopbcloop_)
    pfillb($4C) // BRFLS
    pfillw(_fromrs_ - heapmark)
  fin
end
def _plusloop_#0
  if state & comp_itc_flag
    pfillw(@d_doplusloop)
    pfillw(_fromrs_)
  else // comp_pbc_flag
    pfillb($54) // CALL
    pfillw(@_dopbcplusloop_)
    pfillb($4C) // BRFLS
    pfillw(_fromrs_ - heapmark)
  fin
end
def _j_#1
  return RSTACK[RSP + 2]
end
def _begin_#0
  _tors_(heapmark)
end
def _again_#0
  if state & comp_itc_flag
    pfillw(@d_branch)
    pfillw(_fromrs_)
  else // comp_pbc_flag
    pfillb($50) // BRNCH
    pfillw(_fromrs_ - heapmark)
  fin
end
def _until_#0
  if state & comp_itc_flag
    pfillw(@d_0branch)
    pfillw(_fromrs_)
  else // comp_pbc_flag
    pfillb($4C) // BRFLS
    pfillw(_fromrs_ - heapmark)
  fin
end
def _while_#0
  if state & comp_itc_flag
    pfillw(@d_0branch)
  else // comp_pbc_flag
    pfillb($4C) // BRFLS
  fin
  _tors_(heapalloc(2)) // Save backfill address
end
def _repeat_#0
  word backref

  backref = _fromrs_ // Backref from WHILE
  if state & comp_itc_flag
    pfillw(@d_branch)
    pfillw(_fromrs_)
    *backref = heapmark // Backref to BEGIN
  else // comp_pbc_flag
    pfillb($50) // BRNCH
    pfillw(_fromrs_ - heapmark)
    *backref = heapmark - backref // Backref to BEGIN
  fin
end
def _tick_#1
  return find(nextword(' '))
end
def _forget_#0
  word dentry

  dentry = find(nextword(' '))
  if dentry
    vlist = *_lfa_(dentry)
    heaprelease(dentry)
  fin
end
def _cont_#0
  if brk
    state = exit_flag
  else
    putc('?')
  fin
end
def _terminal_#1
  return ^$C000 > 127
end
def _word_(a)#1
  word wordptr
  byte len

  wordptr, len = nextword(a)
  wordptr--
  ^wordptr = len
  return wordptr
end
def _prat_(a)#0
  puti(*a)
end
def _space_#0
    putc(' ')
end
def _spaces_(a)#0
    while a
        putc(' ')
        a--
    loop
end
def _str_#0
  word str
  byte len

  str, len = nextword('"')
  str--
  ^str = len
  len++
  if state & comp_itc_flag
    pfillw(@d_slit)
  elsif state & comp_pbc_flag
    pfillb($2E) // CONSTANT STRING
  else
    (@push)(heapmark)#0
  fin
  memcpy(heapalloc(len), str, len)
end
def _prstr_#0
  word str
  byte len

  if state & comp_flag
    _str_
    if state & comp_itc_flag
      pfillw(@d_doprstr)
    else // comp_pbc_flag
      pfillb($54) // CALL
      pfillw(@puts)
    fin
  else
    str, len = nextword('"')
    str--
    ^str = len
    puts(str)
  fin
end
def _src_#0
  word filename
  byte len

  filename, len = nextword('"')
  filename--
  ^filename = len
  if srclevel >= SRCREFS
    puts("Too many nested SRC\"")
    _abort_
  fin
  inref[srclevel] = fileio:open(filename)
  if inref[srclevel]
    fileio:newline(inref[srclevel], $7F, $0D)
    infunc               = @filein
    inbufptr             = @inbuf + srclevel * INBUF_SIZE
    previnptr[srclevel]  = inptr
    inptr                = inbufptr
    ^inptr               = 0
    srclevel++
  else
    puts("Failed to open "); puts(filename); putln
  fin
end
def _show_#0
  word dentry, pfa, w

  dentry = find(nextword(' '))
  if dentry
    if ^_ffa_(dentry) & itc_flag // Only show ITC words
      if *_cfa_(dentry) == @_docolon_
        pfa = _pfa_(dentry)
      else // @d_dodoes
        pfa = *_pfa_(dentry)
      fin
      w = *pfa
      while w
        puts("  ")
        if ^_ffa_(w) & param_flag
          pfa = pfa + 2
        fin
        if w == @d_slit
          putc('"')
          puts(pfa)
          putc('"')
          pfa = pfa + ^pfa - 1
        elsif w == @d_lit
          puti(*pfa)
        else
          puts(w)
        fin
        putln
        pfa = pfa + 2
        w = *pfa
      loop
    fin
  fin
end
def _showstack_#0
  word val
  byte depth

  for depth = 1 to (@_get_estack)()#1
    val = ^(_estkl + 16 - depth) | (^(_estkh + 16 - depth) << 8)
    puti(val); putc(' ')
  next
end
def _showrstack_#0
  byte depth

  depth = RSTK_SIZE - 1
  while depth >= RSP
    puti(RSTACK[depth]); putc(' ')
    depth--
  loop
end
def _tron_#0
  state = state | trace_flag
end
def _troff_#0
  state = state & ~trace_flag
end
def brkpoint#0
  brkhandle(brkentry)
  W = _cfa_(brkentry)
  if brkcfa
    brkcfa()#0
  else // Breakpoint was cleared
    (*_cfa_(brkentry))()#0
  fin
end
def _brkout_#0
  brkhandle(@d_brkout)
end
def _brkon_#0
  word dentry

  if brkcfa
    puts("Breakpoint already enabled\n")
  else
    dentry = find(nextword(' '))
    if dentry
      brkentry = dentry
      brkcfa = *_cfa_(dentry)
      *_cfa_(dentry) = @brkpoint
    else
      puts("No match\n")
    fin
  fin
end
def _brkoff_#0
  *_cfa_(brkentry) = brkcfa
  brkcfa           = 0
end
def _itc_#0
  comp_mode = comp_itc_flag
end
def _pbc_#0
  comp_mode = comp_pbc_flag
end
def _comment_#0
  nextword(')')
end
def _vlist_#0
  word d

  d = vlist
  while d
    puts(d); puts("  ")
    d = *_lfa_(d)
  loop
end
//
// Quit
//
def _quit_#0
  state = 0
  warmstart
  throw(exit, FALSE)
end
//
// Abort
//
def _abort_#0
  puts("Abort\n")
  _quit_
end
//
// Restart
//
def _restart_#0
  coldstart
  warmstart
  throw(exit, FALSE)
end
//
// Leave FORTH
//
def _bye_#0
  throw(exit, TRUE)
end

puts("PLFORTH WIP\n")
if cmdsys:sysver < $0201
  puts("PLASMA >= 2.01 required\n")
  return
fin
warmstart
fileio:iobufalloc(4) // Allocate a bunch of file buffers
_estkl    = ^(@syscall + 1) // Hack to fill in parameter stack locations
_estkh    = ^(@syscall + 3)
inptr     = argNext(argFirst)
exit      = heapalloc(t_except)
startheap = heapmark
if not except(exit)
  if ^inptr; inptr++; _src_; fin
  interpret
fin
done
