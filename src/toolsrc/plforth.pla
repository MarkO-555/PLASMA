include "inc/cmdsys.plh"
include "inc/args.plh"
include "inc/fileio.plh"
include "inc/conio.plh"
include "inc/longjmp.plh"
//
// Internal variables
//
word  vlist
word  startheap, arg, infunc, inptr, IIP, W
word  keyinbuf   = $1FF
const SRCREFS    = 2
const INBUF_SIZE = 128
byte  srclevel   = 0
word  inbufptr
byte  inref[SRCREFS]
word  previnptr[SRCREFS]
//
// Internal buffers
//
res[SRCREFS * INBUF_SIZE] inbuf
res[t_except]             exitforth
//
// RSTACK
//
const RSTK_SIZE = 16
byte RSP = RSTK_SIZE
word RSTACK[RSTK_SIZE]
//
// Vocabulary hash table
//
const HASH_SIZE = 64 // Must be power of two!
const HASH_MASK = HASH_SIZE-1
word hashtbl[HASH_SIZE]
//
// State flags
//
const exit_flag     = $01
const trace_flag    = $02
const step_flag     = $04
const comp_itc_flag = $10
const comp_pbc_flag = $20
const comp_flag     = comp_itc_flag | comp_pbc_flag
//
// Mode and state
//
byte comp_mode = comp_itc_flag
byte state     = 0
byte savestate = 0
word brkentry  = 0
word brkcfa    = 0
byte brk       = 0
byte _get_estack   = $8A           // TXA
byte               = $49, $FF      // EOR #$FF
byte               = $38           // SEC
byte               = $69, $10      // ADC #$10
byte               = $C9, $11      // CMP #$11
byte               = $90, $02      // BCC +2
byte               = $A2, $10      // LDX #ESTKSZ/2
byte               = $CA           // DEX
byte               = $95           // STA
byte _estkl        = $D0           // ESTKL,X
byte               = $A9, $00      // LDA #$00
byte               = $95           // STA
byte _estkh        = $C0           // ESTKH,X
byte               = $60           // RTS
byte _reset_estack = $A2, $10      // LDX #ESTKSZ/2
byte               = $60           // RTS
//
// FORTH dictionary layout
//
//  bytes   usage
//  -----   -----
// [1]      name length
// [1..255] name
// [1]      FFA (flag field address)
// [2]      LFA (link field address)
// [2]      HFA (hash field address)
// [2]      CFA (code field address)
// [2..]    PFA (param field address)
//
//
// Mask and flags for dictionary entries
//
const inline_flag     = $01
const inlinew_flag    = $02
const param_flag      = $04
const itc_flag        = $10
const imm_flag        = $20
const componly_flag   = $40
const interponly_flag = $80
//
// Predefine instrinsics
//
predef _drop_(a)#0, _swap_(a,b)#2, _dup_(a)#2, _dashdup_(a)#1, _over_(a,b,c)#4, _rot_(a,b,c)#3
predef _add_(a,b)#1, _inc_(a)#1, _inc2_(a)#1, _dec_(a)#1, _dec2_(a)#1
predef _sub_(a,b)#1, _mul_(a,b)#1, _div_(a,b)#1
predef _neg_(a)#1, _and_(a,b)#1, _or_(a,b)#1, _xor_(a,b)#1, _complement_(a)#1, _not_(a)#1
predef _mod_(a,b)#1, _abs_(a)#1, _max_(a,b)#1, _min_(a,b)#1
predef _lshift_(a,b)#1, _rshift_(a,b)#1
predef _cset_(a,b)#0, _cget_(a)#1, _wset_(a,b)#0, _wplusset_(a,b)#0, _wget_(a)#1
predef _ffa_(a)#1, _lfa_(a)#1, _hfa_(a)#1, _cfa_(a)#1, _pfa_(a)#1, _allot_(a)#0
predef _eq_(a,b)#1, _gt_(a,b)#1, _lt_(a,b)#1, _0lt_(a)#1, _0eq_(a)#1
predef _branch_#0, _0branch_(a)#0, _if_#0, _else_#0, _then_#0
predef _begin_#0, _again_#0, _until_#0, _while_#0, _repeat_#0
predef _case_#0, _of_#0, _endof_#0, _endcase_#0, _literal_(a)#0
predef _dodo_(a,b)#0, _do_#0, _doloop_#0, _doplusloop_(a)#0, _plusloop_#0, _loop_#0, _leave_#0, _j_#1
predef _create_#0, _itcdoes_(a)#0, _does_#0, _compoff_#0, _compon_#0
predef _compile_#0, pfillw(a)#0, pfillb(a)#0, _colon_#0, _semi_#0
predef _componly_#0, _interponly_#0, _immediate_#0, _exit_#0, _pad_#1, _trailing_(a,b)#2
predef _tors_(a)#0, _fromrs_#1, _toprs_#1, _lookup_#1
predef _move_(a,b,c)#0, _fill_(a,b,c)#0, _plasma_(a)#0
predef _var_(a)#0, _const_(a)#0, _lit_#1, _slit_#1, _find_(a)#2
predef _tick_#0, _forget_#0, _terminal_#1, _prat_(a)#0
predef _blank_#0, _char_#0, _str_#0, _prstr_#0, _prpstr_#0
predef _prval_(a)#0, _prbyte_(a)#0, _prhex_(a)#0
predef _accept_(a,b)#1, _query_#0, _type_(a,b)#0
predef _vlist_#0, _tron_#0, _troff_#0, _stepon_#0, _stepoff_#0
predef _itc_#0, _pbc_#0, _comment_#0, _src_(a)#0, _srcstr_#0, _endsrc_(a)#0
predef _brk_#0, _brkon_#0, _brkoff_#0, _word_(a)#1, _count_(a)#2
predef _space_#0, _spaces_(a)#0, _show_#0, _showstack_#0, _showrstack_#0
predef _cont_#0, _restart_#0, _bye_#0, _quit_#0
predef _abort_(a)#0, _doabortstr_(a,b)#0, _abortstr_#0
predef compword(dentry)#0, execword(dentry)#0, isnum(a,b)#2
// DROP
char d_drop = "DROP"
byte = inline_flag
word = 0, 0, @_drop_, $30
// SWAP
char d_swap = "SWAP"
byte = 0
word = @d_drop, 0, @_swap_
// DUP
char d_dup = "DUP"
byte = inline_flag
word = @d_swap, 0, @_dup_, $34
// -DUP
char d_dashdup = "-DUP"
byte = 0
word = @d_dup, 0, @_dashdup_
// OVER
word d_over = "OVER"
byte = 0
word = @d_dashdup, 0, @_over_
// ROT
word d_rot = "ROT"
byte = 0
word = @d_over, 0, @_rot_
// ADD
char d_add = "+"
byte = inline_flag
word = @d_rot, 0, @_add_, $82
// ONE PLUS
char d_inc = "1+"
byte = inline_flag
word = @d_add, 0, @_inc_, $8C
// TWO PLUS
char d_inc2 = "2+"
byte = inlinew_flag
word = @d_inc, 0, @_inc2_, $8C8C
// ONE MINUS
char d_dec = "1-"
byte = inline_flag
word = @d_inc2, 0, @_dec_, $8E
// TWO MINUS
char d_dec2 = "2-"
byte = inlinew_flag
word = @d_dec, 0, @_dec2_, $8E8E
// SUB
char d_sub = "-"
byte = inline_flag
word = @d_dec2, 0, @_sub_, $84
// MUL
char d_mul = "*"
byte = inline_flag
word = @d_sub, 0, @_mul_, $86
// DIV
char d_div = "/"
byte = inline_flag
word = @d_mul, 0, @_div_, $88
// DIVMOD
char d_divmod = "/MOD"
byte = inline_flag
word = @d_div, 0, @divmod, $36
// MOD
char d_mod = "MOD"
byte = inline_flag
word = @d_divmod, 0, @_mod_, $8A
// NEG
char d_neg = "NEGATE"
byte = inline_flag
word = @d_mod, 0, @_neg_, $90
// AND
char d_and = "AND"
byte = inline_flag
word = @d_neg, 0, @_and_, $94
// OR
char d_or = "OR"
byte = inline_flag
word = @d_and, 0, @_or_, $96
// XOR
char d_xor = "XOR"
byte = inline_flag
word = @d_or, 0, @_xor_, $98
// COMPLEMENT
char d_complement = "COMPLEMENT"
byte = inline_flag
word = @d_xor, 0, @_complement_, $92
// NOT
char d_not = "NOT"
byte = inline_flag
word = @d_complement, 0, @_not_, $80
// LEFT SHIFT
char d_lshift = "LSHIFT"
byte = inline_flag
word = @d_not, 0, @_lshift_, $9A
// RIGHT SHIFT
char d_rshift = "RSHIFT"
byte = inline_flag
word = @d_lshift, 0, @_rshift_, $9C
// EQUALS
char d_eq = "="
byte = inline_flag
word = @d_rshift, 0, @_eq_, $40
// GREATER THAN
char d_gt = ">"
byte = inline_flag
word = @d_eq, 0, @_gt_, $44
// LESS THAN
char d_lt = "<"
byte = inline_flag
word = @d_gt, 0, @_lt_, $46
// UNSIGNED GREATER THAN
char d_ugt = "U>"
byte = 0
word = @d_lt, 0, @isugt
// UNSIGNED LESS THAN
char d_ult = "U<"
byte = 0
word = @d_ugt, 0, @isult
// LESS THAN ZERO
char d_0lt = "0<"
byte = inlinew_flag
word = @d_ult, 0, @_0lt_, $4600 // ZERO ISLT
// EQUALS ZERO
char d_0eq = "0="
byte = inlinew_flag
word = @d_0lt, 0, @_0eq_, $4000 // ZERO ISEQ
// ABS
char d_abs = "ABS"
byte = 0
word = @d_0eq, 0, @_abs_
// MIN
char d_min = "MIN"
byte = 0
word = @d_abs, 0, @_min_
// MAX
char d_max = "MAX"
byte = 0
word = @d_min, 0, @_max_
// CHAR PUT
char d_cset = "C!"
byte = inline_flag
word = @d_max, 0, @_cset_, $70
// WORD PUT
char d_wset = "!"
byte = inline_flag
word = @d_cset, 0, @_wset_, $72
// WORD PLUS PUT
char d_wplusset = "+!"
byte = 0
word = @d_wset, 0, @_wplusset_
// CHAR GET
char d_cget = "C@"
byte = inline_flag
word = @d_wplusset, 0, @_cget_, $60
// WORD SET
char d_wget = "@"
byte = inline_flag
word = @d_cget, 0, @_wget_, $62
// EXECUTE
char d_execute = "EXECUTE"
byte = 0
word = @d_wget, 0, @execword
// TO RSTACK
char d_torstk = ">R"
byte = 0
word = @d_execute, 0, @_tors_
// FROM RSTACK
char d_fromrstk = "R>"
byte = 0
word = @d_torstk, 0, @_fromrs_
// TOP OF RSTACK
char d_toprstk = "R@"
byte = 0
word = @d_fromrstk, 0, @_toprs_
// PLASMA SYMBOL LOOKUP
char d_lookup = "LOOKUP"
byte = 0
word = @d_toprstk, 0, @_lookup_
// PLASMA LINKEAGE
char d_plasma = "PLASMA"
byte = imm_flag
word = @d_lookup, 0, @_plasma_
// VARIABLE
char d_var = "VARIABLE"
byte = imm_flag
word = @d_plasma, 0, @_var_
// CONSTANT
char d_const = "CONSTANT"
byte = imm_flag
word = @d_var, 0, @_const_
// MOVE
char d_move = "MOVE"
byte = 0
word = @d_const, 0, @_move_
// FILL
char d_fill = "FILL"
byte = 0
word = @d_move, 0, @_fill_
// HERE
char d_here = "HERE"
byte = 0
word = @d_fill, 0, @heapmark
// PAD
char d_pad = "PAD"
byte = 0
word = @d_here, 0, @_pad_
// ALLOT
char d_allot = "ALLOT"
byte = 0
word = @d_pad, 0, @_allot_
// BRANCH ( not in vocabulary )
char d_branch = "(BRANCH)"
byte = param_flag | inline_flag
word = 0, 0, @_branch_, $C4
// BRANCH IF 0 ( not in vocabulary )
char d_0branch = "(0BRANCH)"
byte = param_flag | inline_flag
word = 0, 0, @_0branch_, $C2
// IF
char d_if = "IF"
byte = imm_flag | componly_flag
word = @d_allot, 0, @_if_
// ELSE
char d_else = "ELSE"
byte = imm_flag | componly_flag
word = @d_if, 0, @_else_
// THEN
char d_then = "THEN"
byte = imm_flag | componly_flag
word = @d_else, 0, @_then_
// CASE
char d_case = "CASE"
byte = imm_flag | componly_flag
word = @d_then, 0, @_case_
// OF
char d_of = "OF"
byte = imm_flag | componly_flag
word = @d_case, 0, @_of_
// ENDOF
char d_endof = "ENDOF"
byte = imm_flag | componly_flag
word = @d_of, 0, @_endof_
// ENDCASE
char d_endcase = "ENDCASE"
byte = imm_flag | componly_flag
word = @d_endof, 0, @_endcase_
// COMPILED DO ( not in vocabulary )
char d_dodo = "(DO)"
byte = 0
word = 0, 0, @_dodo_
// DO
char d_do = "DO"
byte = imm_flag | componly_flag
word = @d_endcase, 0, @_do_
// LEAVE
char d_leave = "LEAVE"
byte = componly_flag
word = @d_do, 0, @_leave_
// COMPILED LOOP ( not in vocabulary )
char d_doloop = "(DOLOOP)"
byte = param_flag
word = 0, 0, @_doloop_
// LOOP
char d_loop = "LOOP"
byte = imm_flag | componly_flag
word = @d_leave, 0, @_loop_
// COMPILED LOOP+ ( not in vocabulary )
char d_doplusloop = "(+DOLOOP)"
byte = param_flag
word = 0, 0, @_doplusloop_
// LOOP
char d_plusloop = "+LOOP"
byte = imm_flag | componly_flag
word = @d_loop, 0, @_plusloop_
// I
char d_i = "I"
byte = componly_flag
word = @d_plusloop, 0, @_toprs_
// J
char d_j = "J"
byte = componly_flag
word = @d_i, 0, @_j_
// BEGIN
char d_begin = "BEGIN"
byte = imm_flag | componly_flag
word = @d_j, 0, @_begin_
// AGAIN
char d_again = "AGAIN"
byte = imm_flag | componly_flag
word = @d_begin, 0, @_again_
// UNTIL
char d_until = "UNTIL"
byte = imm_flag | componly_flag
word = @d_again, 0, @_until_
// WHILE
char d_while = "WHILE"
byte = imm_flag | componly_flag
word = @d_until, 0, @_while_
// REPEAT
char d_repeat = "REPEAT"
byte = imm_flag | componly_flag
word = @d_while, 0, @_repeat_
// FORGET
char d_forget = "FORGET"
byte = 0
word = @d_repeat, 0, @_forget_
// CREATE
char d_create = "CREATE"
byte = 0
word = @d_forget, 0, @_create_
// RECREATE/DOES COMPILE TIME ( not in vocabulary )
char d_createdoes = "(CREATEDOES)"
byte = 0
word = 0, 0, @_itcdoes_
// DOES
char d_does = "DOES>"
byte = imm_flag | componly_flag
word = @d_create, 0, @_does_
// COMMA
char d_comma = ","
byte = 0
word = @d_does, 0, @pfillw
// COMMA
char d_commab = "C,"
byte = 0
word = @d_comma, 0, @pfillb
// COLON
char d_colon = ":"
byte = interponly_flag
word = @d_commab, 0, @_colon_
// COMP OFF
char d_compoff = "["
byte = imm_flag | componly_flag
word = @d_colon, 0, @_compoff_
// COMP ON
char d_compon = "]"
byte = interponly_flag
word = @d_compoff, 0, @_compon_
// COMPILE NEXT WORD
char d_compile = "[COMPILE]"
byte = imm_flag | componly_flag
word = @d_compon, 0, @_compile_
// COMPILE ONLY
char d_componly = "COMPONLY"
byte = imm_flag
word = @d_compile, 0, @_componly_
// INTERPRET ONLY
char d_interponly = "INTERPONLY"
byte = imm_flag
word = @d_componly, 0, @_interponly_
// IMMEDIATE
char d_immediate = "IMMEDIATE"
byte = imm_flag
word = @d_interponly, 0, @_immediate_
// EXIT
char d_exit = "EXIT"
byte = imm_flag | componly_flag
word = @d_immediate, 0, @_exit_
// SEMI
char d_semi = ";"
byte = imm_flag | componly_flag
word = @d_exit, 0, @_semi_
// COUNT
char d_count = "COUNT"
byte = 0
word = @d_semi, 0, @_count_
// FIND
char d_find = "FIND"
byte = 0
word = @d_count, 0, @_find_
// TICK
char d_tick = "'"
byte = imm_flag
word = @d_find, 0, @_tick_
// INLINE LITERAL NUMBER ( not in vocabulary )
char d_lit = "LIT"
byte = param_flag
word = 0, 0, @_lit_
// COMPILED LITERAL VALUE FROM STACK
char d_literal = "LITERAL"
byte = imm_flag
word = @d_tick, 0, @_literal_
// ?TERMINAL
char d_terminal = "?TERMINAL"
byte = 0
word = @d_literal, 0, @_terminal_
// KEY
char d_key = "KEY"
byte = 0
word = @d_terminal, 0, @getc
// QUERY
char d_query = "QUERY"
byte = 0
word = @d_key, 0, @_query_
// ACCEPT
char d_accept = "ACCEPT"
byte = 0
word = @d_query, 0, @_accept_
// WORD
char d_word = "WORD"
byte = 0
word = @d_accept, 0, @_word_
// ISNUM
char d_isnum = "?NUM"
byte = 0
word = @d_word, 0, @isnum
// -TRAILING
char d_trailing = "-TRAILING"
byte = 0
word = @d_isnum, 0, @_trailing_
// PRINT @TOS
char d_prat = "?"
byte = 0
word = @d_trailing, 0, @_prat_
// PRINT TOS
char d_prtos = "."
byte = 0
word = @d_prat, 0, @_prval_
// PRINT TOS HEX
char d_prtoshex = "$."
byte = 0
word = @d_prtos, 0, @_prhex_
// PRINT TOS HEX BYTE
char d_prtosbyte = "C$."
byte = 0
word = @d_prtoshex, 0, @_prbyte_
// EMIT
char d_emit = "EMIT"
byte = 0
word = @d_prtosbyte, 0, @putc
// CR
char d_cr = "CR"
byte = 0
word = @d_emit, 0, @putln
// SPACE
char d_space = "SPACE"
byte = 0
word = @d_cr, 0, @_space_
// SPACES
char d_spaces = "SPACES"
byte = 0
word = @d_space, 0, @_spaces_
// TYPE
char d_type = "TYPE"
byte = 0
word = @d_spaces, 0, @_type_
// BLANK
char d_blank = "BL"
byte = imm_flag
word = @d_type, 0, @_blank_
// CHAR
char d_char = "CHAR"
byte = imm_flag
word = @d_blank, 0, @_char_
// STRING
char d_str = "\""
byte = imm_flag
word = @d_char, 0, @_str_
// LITERAL STRING ( not in vocabulary )
char d_slit = "SLIT"
byte = param_flag | inline_flag
word = 0, 0, @_slit_, $2E
// PRINT STRING FROM STACK
char d_doprstr = "(.\")"
byte = 0
word = @d_str, 0, @puts
// PRINT STRING
char d_prstr = ".\""
byte = imm_flag
word = @d_doprstr, 0, @_prstr_
// PRINT PAREN STRING
char d_prpstr = ".("
byte = imm_flag
word = @d_prstr, 0, @_prpstr_
// READ SOURCE FILE FROM STACK
char d_src = "SRC"
byte = 0
word = @d_prpstr, 0, @_src_
// READ SOURCE FILE FROM INPUT
char d_srcstr = "SRC\""
byte = imm_flag
word = @d_src, 0, @_srcstr_
// END SOURCE FILE
char d_endsrc = "ENDSRC"
byte = 0
word = @d_srcstr, 0, @_endsrc_
// CONTINUE AFTER BRK
char d_cont = "CONT"
byte = interponly_flag
word = @d_endsrc, 0, @_cont_
// QUIT
char d_quit = "QUIT"
byte = 0
word = @d_cont, 0, @_quit_
// ABORT IF <> 0
char d_abort = "ABORT"
byte = 0
word = @d_quit, 0, @_abort_
// DOABORTSTR
char d_doabortstr = "(ABORT\")"
byte = 0
word = @d_abort, 0, @_doabortstr_
// ABORTSTR
char d_abortstr = "ABORT\""
byte = imm_flag
word = @d_doabortstr, 0, @_abortstr_
// COLD exitforth
char d_exitforth = "COLD"
byte = 0
word = @d_abortstr, 0, @_restart_
// COMMENT
char d_comment = "("
byte = imm_flag
word = @d_exitforth, 0, @_comment_
//
// PLFORTH custom words
//
// BYE
char d_bye = "BYE"
byte = 0
word = @d_comment, 0, @_bye_
// SHOW DEFINITION
char d_show = "SHOW"
byte = interponly_flag
word = @d_bye, 0, @_show_
// SHOW STACK
char d_showstack = "SHOWSTACK"
byte = 0
word = @d_show, 0, @_showstack_
// SHOW RSTACK
char d_showrstack = "SHOWRSTACK"
byte = 0
word = @d_showstack, 0, @_showrstack_
// TRACE ON
char d_tron = "TRON"
byte = 0
word = @d_showrstack, 0, @_tron_
// TRACE OFF
char d_troff = "TROFF"
byte = 0
word = @d_tron, 0, @_troff_
// SINGLE STEP ON
char d_stepon = "STEPON"
byte = 0
word = @d_troff, 0, @_stepon_
// SINGLE STEP OFF
char d_stepoff = "STEPOFF"
byte = 0
word = @d_stepon, 0, @_stepoff_
// BREAK OUT
char d_brk = "BRK"
byte = 0
word = @d_stepoff, 0, @_brk_
// BREAK ON
char d_brkon = "BRKON"
byte = imm_flag
word = @d_brk, 0, @_brkon_
// BREAK OFF
char d_brkoff = "BRKOFF"
byte = 0
word = @d_brkon, 0, @_brkoff_
//  COMPILE USING ITC
char d_itc = "ITC"
byte = interponly_flag
word = @d_brkoff, 0, @_itc_
// COMPILE USING PLASMA BYTECODES
char d_pbc = "PBC"
byte = interponly_flag
word = @d_itc, 0, @_pbc_
//
// Start of vocabulary
//
// LIST VOCAB
char d_vlist = "VLIST"
byte = 0
word = @d_pbc, 0, @_vlist_
//
// Helper routines
//
predef interpret#0
def push(a)#1 // Stack hack - call as (@push)(a)#0 to leave a on eval stack
  return a
end
def pfillw(a)#0
  *(heapalloc(2)) = a
end
def pfillb(a)#0
  *(heapalloc(1)) = a
end
//
// Input routines
//
def keyin#0
  byte i

  repeat
    puts(brk ?? " BRK\n" :: " OK\n")
    inptr    = gets(state & comp_flag ?? ']'|$80 :: '>'|$80)
    keyinbuf = inptr // Save if needed
  until ^inptr
  ^(inptr + ^inptr + 1) = 0 // NULL terminate
  inptr++
end
def endsrc#1
  if srclevel > 0
    srclevel--
    fileio:close(inref[srclevel]) // EOF
    inref[srclevel] = 0
    inbufptr        = inbufptr - INBUF_SIZE
    inptr           = previnptr[srclevel]
    if srclevel == 0              // - switch back to keyboard input
        infunc = @keyin
        keyin
    fin
  fin
  return srclevel == 0
end
def filein#0
  byte len
  repeat
      len = fileio:read(inref[srclevel-1], inbufptr, INBUF_SIZE-1)
      if len
        if ^(inbufptr + len - 1) == $0D
          len-- // Remove trailing carriage return
        fin
        ^(inbufptr + len) = 0 // NULL terminate
        inptr             = inbufptr
      else
        if endsrc
          return
        fin
      fin
    until len
end
def nextword(delim)#2
  word wordptr
  byte len

  repeat
    if !^inptr
      infunc()#0
    fin
    while ^inptr == delim // Skip leading delimiter
      inptr++
    loop
  until ^inptr
  wordptr = inptr
  while ^inptr and ^inptr <> delim // Tokenize characters
    inptr++
  loop
  len = inptr - wordptr
  if ^inptr // Skip trailing delimiter
    inptr++
  fin
  return wordptr, len
end
//
// Hash table routines
//
def hashname(chars, len)#1
  return (len ^ ((^chars << 1) ^ ^(chars + len / 2) << 2)) & HASH_MASK
end
def addhash(dentry)#0
  byte hash

  hash           = hashname(dentry + 1, ^dentry)
  *_hfa_(dentry) = hashtbl[hash])
  hashtbl[hash]  = dentry
end
def buildhashtbl#0
  word dentry
  byte i, hash

  for i = 0 to HASH_MASK
    hashtbl[i] = 0
  next
  dentry = vlist
  while dentry
    hash           = hashname(dentry + 1, ^dentry)
    *_hfa_(dentry) = hashtbl[hash])
    hashtbl[hash]  = dentry
    dentry         = *(dentry + ^dentry + 2)
  loop
end
//
// Warm start
//
def warmstart#0
  (@_reset_estack)()#0
  brk    = 0
  brkcfa = 0
  RSP    = RSTK_SIZE
  if state & comp_flag // Undo compilation state
    heaprelease(vlist)
    vlist = *_lfa_(vlist)
  fin
  state = 0
  while !endsrc; loop
  infunc = @keyin
  inptr  = keyinbuf
  ^inptr = 0
end
//
// Cold start
//
def coldstart#0
  warmstart
  vlist = @d_vlist
  heaprelease(startheap)
  buildhashtbl
end
//
// Find match in dictionary
//
def find(matchchars, matchlen)#1
  word dentry
  byte i

  dentry = hashtbl[hashname(matchchars, matchlen)]
  matchchars--
  while dentry
    if ^dentry == matchlen

      for i = matchlen downto 1
        if ^(matchchars + i) <> ^(dentry + i)
          break
        fin
      next
      if i == 0
        return dentry
      fin
    fin
    dentry = *(dentry + ^dentry + 4)
  loop
  return 0 // Not found
end
//
// Convert input into number
//
def isnum(numchars, numlen)#2
  word num, sign
  byte numchar

  sign = 1
  if ^numchars == '-'
    sign = -1
    numchars++
    numlen--
    if numlen == 0
      return 0, 0
    fin
  fin
  num = 0
  if ^numchars == '$'
    numchars++
    numlen--
    if numlen == 0
      return 0, 0
    fin
    while numlen
      numchar = toupper(^numchars)
      if numchar >= '0' and numchar <= '9'
        num = num * 16 + numchar - '0'
      elsif numchar >= 'A' and numchar <= 'F'
        num = num * 16 + numchar - 'A' + 10
      else
        break
      fin
      numchars++
      numlen--
    loop
  else
    while numlen
      numchar = ^numchars
      if numchar < '0' or numchar > '9'
        break
      fin
      num = num * 10 + numchar - '0'
      numchars++
      numlen--
    loop
  fin
  return num * sign, numlen == 0
end
//
// Break handler
//
def showtrace(dentry)#0
    puts("\n( "); _showstack_; puts(") "); puts(dentry); putc(' ')
end
def brkhandle(dentry)#0
  word brk_infn, brk_inptr, brk_iip
  byte brk_state

  showtrace(dentry)
  brk_iip   = IIP
  brk_infn  = infunc
  brk_inptr = inptr
  infunc    = @keyin
  inptr     = keyinbuf
  ^inptr    = 0
  brk_state = state &  comp_flag
  state     = state & ~comp_flag
  brk++
  interpret
  brk--
  state     = brk_state | state
  IIP       = brk_iip
  infunc    = brk_infn
  inptr     = brk_inptr
end
//
// Execute code in CFA
//
def execword(dentry)#0
  when conio:keypressed()
    is $83 // CTRL-C
      getc // Clear KB
      brkhandle(dentry)
      break
    is $94 // CTRL-T
      getc // Clear KB strobe
      state = state ^ trace_flag
      break
  wend
  if state & trace_flag
    showtrace(dentry)
    if state & step_flag
      if getc == $03 // CTRL-C
        brkhandle(dentry)
      fin
    fin
  fin
  W = _cfa_(dentry)
  (*W)()#0
  if (@_get_estack)()#1 > 16
    puts("Stack over/underflow\n")
    _quit_
  fin
end
def execwords(wlist)#0
  word prevIP, dentry

  prevIP = IIP
  IIP    = wlist
  dentry = *IIP
  while dentry
    IIP    = IIP + 2
    execword(dentry)
    dentry = *IIP
  loop
  IIP = prevIP
end
//
// Compile a word/literal into the dictionary: ITC and PBC
//
def compword(dentry)#0
  if ^_ffa_(dentry) & interponly_flag
    puts("INTERP only word\n")
    _quit_
  elsif state & comp_itc_flag
    pfillw(dentry)
  elsif state & comp_pbc_flag
    if ^_ffa_(dentry) & itc_flag // Check if calling ITC word
      pfillb($2C)    // CONSTANT WORD
      pfillw(dentry) // Pointer to dictionary entry
      pfillb($54)    // CALL execword
      pfillw(@execword)
    elsif ^_ffa_(dentry) & inline_flag // inline bytecode
      pfillb(^_pfa_(dentry))
    elsif ^_ffa_(dentry) & inlinew_flag // inline 2 bytecodes
      pfillw(*_pfa_(dentry))
    else
      pfillb($54) // CALL CFA directly
      pfillw(*_cfa_(dentry))
    fin
  fin
  if state & trace_flag
    putc('['); puts(dentry); puts("] ")
  fin
end
def compliteral(value)#0
  if state & comp_itc_flag
    pfillw(@d_lit)
    pfillw(value) // Poke literal value into dictionary
  else // comp_pbc_flag
    if value >= 0 and value <= 255
      if value <= 15
        pfillb(value << 1) // CONSTANT NIBBLE
      else
        pfillb($2A) // CONSTANT BYTE
        pfillb(value) // Poke literal value into dictionary
      fin
    elsif value < 0 and value >= -256
      if value == -1
        pfillb($20) // CONSTANT MINUS_ONE
      else
        pfillb($5E) // CONSTANT NEGATIVE BYTE
        pfillb(value) // Poke literal value into dictionary
      fin
    else
      pfillb($2C) // CONSTANT WORD
      pfillw(value) // Poke literal value into dictionary
    fin
  fin
end
def interpret#0
  word inchars, dentry, value
  byte inlen, valid

  //
  // Set flags on words
  //
  repeat
    inchars, inlen = nextword(' ')
    dentry = find(inchars, inlen)
    if dentry
      if ^_ffa_(dentry) & imm_flag or not (state & comp_flag)
        if ^_ffa_(dentry) & componly_flag and not (state & comp_flag)
          puts(dentry)
          puts(" : Compile only word\n")
          _quit_
        fin
        execword(dentry)
      else
        compword(dentry)
      fin
    else
      value, valid = isnum(inchars, inlen)
      if not valid
        inchars--
        ^inchars = inlen
        puts(inchars)
        puts(" ? No match\n")
        warmstart
      else
        if state & comp_flag
          compliteral(value)
        else
          (@push)(value)#0
        fin
      fin
    fin
  until state & exit_flag
  state = state & ~exit_flag
end
//
// Intrinsics
//
def _drop_(a)#0
  return
end
def _swap_(a,b)#2
  return b,a
end
def _dup_(a)#2
  return a,a
end
def _dashdup_(a)#1
  if a; (@push)(a)#0; fin
  return a
end
def _over_(a,b,c)#4
  return a,b,c,a
end
def _rot_(a,b,c)#3
  return b,c,a
end
def _add_(a,b)#1
  return a+b
end
def _inc_(a)
  return a + 1
end
def _inc2_(a)
  return a + 2
end
def _dec_(a)
  return a - 1
end
def _dec2_(a)
  return a - 2
end
def _sub_(a,b)#1
  return a-b
end
def _mul_(a,b)#1
  return a*b
end
def _div_(a,b)#1
  return a/b
end
def _mod_(a,b)#1
    return a%b
end
def _neg_(a)#1
  return -a
end
def _lshift_(a,b)#1
    return a<<b
end
def _rshift_(a,b)#1
    return a>>b
end
def _and_(a,b)#1
  return a & b
end
def _or_(a,b)#1
  return a | b
end
def _xor_(a,b)#1
  return a ^ b
end
def _complement_(a)#1
  return ~a
end
def _not_(a)#1
  return not a
end
def _eq_(a,b)#1
  return a == b
end
def _gt_(a,b)#1
  return a > b
end
def _lt_(a,b)#1
  return a < b
end
def _0lt_(a)#1
  return a < 0
end
def _0eq_(a)#1
  return a == 0
end
def _cset_(a,b)#0
  ^b = a
end
def _wset_(a,b)#0
  *b = a
end
def _wplusset_(a,b)#0
  *b = *b + a
end
def _abs_(a)#1
  return a < 0 ?? -a :: a
end
def _min_(a,b)#1
  return a > b ?? b :: a
end
def _max_(a,b)
  return a > b ?? a :: b
end
def _cget_(a)#1
  return ^a
end
def _wget_(a)#1
  return *a
end
def _ffa_(dentry)#1
  return dentry + ^dentry + 1
end
def _lfa_(dentry)#1
  return dentry + ^dentry + 2
end
def _hfa_(dentry)#1
  return dentry + ^dentry + 4
end
def _cfa_(dentry)#1
  return dentry + ^dentry + 6
end
def _pfa_(dentry)#1
  return dentry + ^dentry + 8
end
def _tors_(a)#0
  if RSP == 0
    puts("Return stack overflow\n")
    _quit_
  fin
  RSP--
  RSTACK[RSP] = a
end
def _fromrs_#1
  if RSP == RSTK_SIZE
    puts("Return stack underflow\n")
    _quit_
  fin
  RSP++
  return RSTACK[RSP - 1]
end
def _toprs_#1
  return RSTACK[RSP]
end
def _lit_#1
  word lit

  lit = *IIP
  IIP = IIP + 2
  return lit
end
def _slit_#1
  word slit

  slit = IIP
  IIP  = IIP + ^IIP + 1
  return slit
end
def _allot_(a)#0
  heapalloc(a)
end
def _cmove_(a,b,c)#0
  memcpy(b, a, c)
end
def _move_(a,b,c)#0
  memcpy(b, a, c * 2)
end
def _fill_(a,b,c)#0
  memset(a, c | (c << 8), b)
end
def _pad_#1
  return heapmark + 128
end
def _trailing_(a,b)#2
  while b and ^(a + b) == ' '
    b--
  loop
  return a, b
end
def newdict#0
  word bldptr, plist, namechars, namelen

  namechars, namelen = nextword(' ')
  plist  = vlist
  vlist  = heapmark
  ^vlist = namelen
  bldptr = vlist + 1
  while namelen
    ^bldptr = ^namechars
    bldptr++
    namechars++
    namelen--
  loop
  ^bldptr = 0          // Flags
  bldptr++
  *bldptr = plist;      // Link ptr
  bldptr  = bldptr + 2
  *bldptr = 0;          // Hash ptr
  bldptr  = bldptr + 2
  *bldptr = bldptr + 2  // Point CFA to PFA
  heapalloc(bldptr - vlist + 2)
end
def _plasma_(a)#0
  newdict
  *(_cfa_(vlist)) = a  // PLASMA code address
  addhash(vlist)
end
def _var_(a)#0
  newdict
  pfillb($20)          // Hack - get VM entry vector from divmod
  pfillw(*(@divmod + 1))
  pfillb($2C)          // CONSTANT WORD
  pfillw(heapmark + 3) // Poiner to variable in PFA
  pfillb($5C)          // RET
  pfillw(a)            // Variable storage
  addhash(vlist)
end
def _const_(a)#0
  newdict
  pfillb($20)          // Hack - get VM entry vector from divmod
  pfillw(*(@divmod + 1))
  pfillb($2C)          // CONSTANT WORD
  pfillw(a)
  pfillb($5C)          // RET
  addhash(vlist)
end
def _create_#0
  newdict
  pfillb($20)          // Hack - get VM entry vector from divmod
  pfillw(*(@divmod + 1))
  pfillb($2C)          // CONSTANT WORD
  pfillw(heapmark + 5) // Pointer to rest of PFA
  pfillb($5C)          // RET
  pfillw(0)            // reserved word for DOES>
  //
  // 9 bytes after PFA, data follows...
  //
end
def _dodoes_#0
  (@push)(W + 11)#0   // Pointer to PFA storage
  execwords(*(W + 2)) // Exec PFA ptr
end
def _itcdoes_(a)#0
  //
  // Overwrite CREATE as ITC words
  //
  ^(_ffa_(vlist))     = ^(_ffa_(vlist)) | itc_flag
  *(_cfa_(vlist))     = @_dodoes_
  *(_pfa_(vlist))     = a // Fill in DOES code address
  addhash(vlist)
end
def _pbcdoes_(a)#0
  //
  // Rewrite the end of CREATE
  //
  ^(_pfa_(vlist) + 6) = $C4    // JUMP DOES> directly
  *(_pfa_(vlist) + 7) = a
  addhash(vlist)
end
def _does_#0
  if state & comp_itc_flag
    pfillw(@d_lit)
    pfillw(heapmark + 6) // Pointer to DOES code
    pfillw(@d_createdoes)
    pfillw(0)
    // End of <BUILDS, beginning of DOES>
  else // comp_pbc_flag
    pfillb($2C)           // CONSTANT WORD
    pfillw(heapmark + 6)  // Pointer to DOES code
    pfillb($54)           // CALL
    pfillw(@_pbcdoes_)    // Fills in code address reserved in _compbuilds_
    pfillb($5C)           // RET
    // End of BUILDS, beginning of DOES> code
  fin
end
def _literal_(a)#0
  compliteral(a)
end
def _docolon_#0
  execwords(W + 2) // Exec PFA
end
def _colon_#0
  newdict
  state = state | comp_mode
  if state & comp_itc_flag
    ^(_ffa_(vlist)) = itc_flag
    *(_cfa_(vlist)) = @_docolon_
  else // comp_pbc_flag
    pfillb($20)            // Hack - get VM entry vector from divmod
    pfillw(*(@divmod + 1))
  fin
  if state & trace_flag
    puts(vlist); putc(' ')
  fin
end
def _exit_#0
  if state & comp_itc_flag
    pfillw(0)
  elsif state & comp_pbc_flag
    pfillb($5C) // RET
  else
    puts("; Not compiling\n")
    _quit_
  fin
end
def _semi_#0
  _exit_
  addhash(vlist)
  state = state & ~comp_flag
end
def _compile_#0
  word dentry

  dentry = find(nextword(' '))
  if dentry
    compword(dentry)
  else
    puts("No match\n")
    _quit_
  fin
end
def _compoff_#0
  if state & comp_flag
    savestate = state &  comp_flag
    state     = state & ~comp_flag
  else
    puts("[ Not compiling\n")
    _quit_
  fin
end
def _compon_#0
  state     = state | savestate
  savestate = 0
  if not (state & comp_flag)
    puts("[ Not compiling\n")
    _quit_
  fin
end
def _componly_#0
  ^_ffa_(vlist) = ^_ffa_(vlist) | componly_flag
end
def _interponly_#0
  ^_ffa_(vlist) = ^_ffa_(vlist) | interponly_flag
end
def _immediate_#0
  ^_ffa_(vlist) = ^_ffa_(vlist) | imm_flag
end
def _branch_#0
  IIP = *IIP
end
def _0branch_(a)#0
  if a
    IIP = IIP + 2
  else
    IIP = *IIP
  fin
end
def _if_#0
  compword(@d_0branch)
  _tors_(heapalloc(2)) // Save backfill address
end
def _else_#0
  word backref

  backref = _fromrs_
  compword(@d_branch)
  _tors_(heapalloc(2))
  *backref = heapmark
end
def _then_#0
  *_fromrs_ = heapmark
end
def _case_#0
  compword(@d_dup)
  _tors_(0) // Linked address list
end
def _of_#0
  if state & comp_itc_flag
    pfillw(@d_eq)
    pfillw(@d_0branch)
  else // comp_pbc_flag
    pfillb($24) // BRNE
  fin
  _tors_(heapalloc(2)) // Save backfill address
end
def _endof_#0
  word backref, link

  backref = _fromrs_
  link    = _fromrs_
  compword(@d_branch)
  _tors_(heapmark)
  pfillw(link)
  if state & comp_itc_flag
    *backref = heapmark
  else // comp_pbc_flag
    *backref = heapmark - backref // Relative branch
  fin
  compword(@d_dup)
end
def _endcase_#0
  word backref, link

  compword(@d_drop)
  backref = _fromrs_
  while backref
    link     = *backref
    *backref = heapmark
    backref  = link
  loop
  compword(@d_drop)
end
def _dodo_(a,b)#0
  if RSP < 2
    puts("Return stack overflow\n")
    _quit_
  fin
  RSP             = RSP - 2
  RSTACK[RSP + 1] = a
  RSTACK[RSP]     = b
end
def _do_#0
  compword(@d_dodo)
  _tors_(heapmark)
end
def _leave_#0
  RSTACK[RSP] = RSTACK[RSP + 1] - 1
end
def _doloop_#0
  RSTACK[RSP]++
  if RSTACK[RSP] == RSTACK[RSP + 1]
    RSP = RSP + 2
    IIP = IIP + 2
  else
    IIP = *IIP
  fin
end
def _dopbcloop_#1
  RSTACK[RSP]++
  if RSTACK[RSP] == RSTACK[RSP + 1]
    RSP = RSP + 2
    return TRUE
  fin
  return FALSE
end
def _doplusloop_(a)#0
  RSTACK[RSP] = RSTACK[RSP] + a
  if (a >= 0 and RSTACK[RSP] >= RSTACK[RSP + 1]) or (a < 0 and RSTACK[RSP] <= RSTACK[RSP + 1])
    RSP = RSP + 2
    IIP = IIP + 2
  else
    IIP = *IIP
  fin
end
def _dopbcplusloop_(a)#1
  RSTACK[RSP] = RSTACK[RSP] + a
  if (a >= 0 and RSTACK[RSP] >= RSTACK[RSP + 1]) or (a < 0 and RSTACK[RSP] <= RSTACK[RSP + 1])
    RSP = RSP + 2
    return TRUE
  fin
  return FALSE
end
def _loop_#0
  if state & comp_itc_flag
    pfillw(@d_doloop)
  else // comp_pbc_flag
    pfillb($54) // CALL
    pfillw(@_dopbcloop_)
    pfillb($C2) // JUMPZ
  fin
    pfillw(_fromrs_)
end
def _plusloop_#0
  if state & comp_itc_flag
    pfillw(@d_doplusloop)
  else // comp_pbc_flag
    pfillb($54) // CALL
    pfillw(@_dopbcplusloop_)
    pfillb($C2) // JUMPZ
  fin
    pfillw(_fromrs_)
end
def _j_#1
  return RSTACK[RSP + 2]
end
def _begin_#0
  _tors_(heapmark)
end
def _again_#0
  compword(@d_branch)
  pfillw(_fromrs_)
end
def _until_#0
  compword(@d_0branch)
  pfillw(_fromrs_)
end
def _while_#0
  compword(@d_0branch)
  _tors_(heapalloc(2)) // Save backfill address
end
def _repeat_#0
  word backref

  backref = _fromrs_ // Backref from WHILE
  compword(@d_branch)
  pfillw(_fromrs_)
  *backref = heapmark // Backref to BEGIN
end
def _count_(a)#2
  return a + 1, ^a
end
def _find_(a)#2
  word dentry

  dentry = find(_count_(a))
  if dentry
    return dentry, ^_ffa_(dentry) & imm_flag ?? 1 :: -1
  fin
  return a, 0
end
def _tick_#0
  word dentry

  dentry = find(nextword(' '))
  if state & comp_flag
    compliteral(dentry)
  else
    (@push)(dentry)#0
  fin
end
def _forget_#0
  word dentry

  dentry = find(nextword(' '))
  if dentry
    if isult(dentry, startheap)
      vlist = @d_vlist
      dentry = startheap
    else
      vlist = *_lfa_(dentry)
    fin
    heaprelease(dentry)
    buildhashtbl
  else
    puts("No match\n")
    _quit_
  fin
end
def _query_#0
  inptr                 = gets('?'|$80)
  ^(inptr + ^inptr + 1) = 0
  inptr++
end
def _accept_(a,b)#1
  word saveinptr
  byte len

  saveinptr = inptr
  memcpy(heapmark + 256, keyinbuf, 80)
  inptr = gets('?'|$80)
  len = ^inptr
  if len > b
    len = b
  fin
  ^(inptr + len + 1) = 0
  memcpy(a, inptr + 1, len)
  memcpy(keyinbuf, heapmark + 256, 80)
  inptr = saveinptr
  return len
end
def _terminal_#1
  return ^$C000 > 127
end
def _word_(a)#1
  word wordptr
  byte len

  wordptr, len = nextword(a)
  wordptr--
  ^wordptr = len
  return wordptr
end
def _space_#0
    putc(' ')
end
def _spaces_(a)#0
    while a
        putc(' ')
        a--
    loop
end
def _prval_(a)#0
  puti(a); putc(' ')
end
def _prbyte_(a)#0
  putc('$'); putb(a); putc(' ')
end
def _prhex_(a)#0
  putc('$'); puth(a); putc(' ')
end
def _prat_(a)#0
  puti(*a); putc(' ')
end
def _blank_#0
  if state & comp_flag
    compliteral(32)
  else
    (@push)(32)#0
  fin
end
def _char_#0
  word str
  byte len

  str, len = nextword(' ')
  if state & comp_flag
    compliteral(^str)
  else
    (@push)(^str)#0
  fin
end
def _str_#0
  word str
  byte len

  str, len = nextword('"')
  str--
  ^str = len
  len++
  if state & comp_flag
    compword(@d_slit)
    memcpy(heapalloc(len), str, len) // Add to dictionary
  else
    (@push)(heapmark)#0
    memcpy(heapmark, str, len) // Copy to HERE
  fin
end
def _type_(a,b)#0
  while b and ^a
    putc(^a)
    a++
    b--
  loop
end
def _prstr_#0
  word str
  byte len

  if state & comp_flag
    _str_
    compword(@d_doprstr)
  else
    str, len = nextword('"')
    str--
    ^str = len
    puts(str)
  fin
end
def _prpstr_#0
  word str
  byte len

  if state & comp_flag
    _str_
    compword(@d_doprstr)
  else
    str, len = nextword(')')
    str--
    ^str = len
    puts(str)
  fin
end
def stodci(str, dci)
  byte len, c

  len = ^str
  if len == 0
    ^dci = 0
    return dci
  fin
  c = toupper(^(str + len)) & $7F
  len--
  ^(dci + len) = c
  while len
    c = toupper(^(str + len)) | $80
    len--
    ^(dci + len) = c
  loop
  return dci
end
def _lookup_#1
  word symname
  char symlen, dci[31]

  symname, symlen = nextword(' ')
  symname--
  ^symname = symlen
  return cmdsys:lookupsym(stodci(symname, @dci))
end
def _src_(a)#0
  char[64] syssrc

  if srclevel >= SRCREFS
    puts("Too many nested SRC")
    _quit_
  fin
  inref[srclevel] = fileio:open(a)
  if !inref[srclevel] and ^a < 16
    strcpy(@syssrc, cmdsys:syspath)
    strcat(@syssrc, "scripts/")
    strcat(@syssrc, a)
    inref[srclevel] = fileio:open(@syssrc)
  fin
  if inref[srclevel]
    fileio:newline(inref[srclevel], $7F, $0D)
    infunc               = @filein
    inbufptr             = @inbuf + srclevel * INBUF_SIZE
    previnptr[srclevel]  = inptr
    inptr                = inbufptr
    ^inptr               = 0
    srclevel++
  else
    puts("Failed to open "); puts(a); putln
  fin
end
def _srcstr_#0
  word filename
  byte len

  if state & comp_flag
    _str_
    compword(@d_src)
  else
    filename, len = nextword('"')
    filename--
    ^filename = len
    _src_(filename)
  fin
end
def _endsrc_(a)#0
  if a
    endsrc
  fin
end
def _show_#0
  word dentry, pfa, w

  dentry = find(nextword(' '))
  if dentry and ^_ffa_(dentry) & itc_flag // Only show ITC words
    if *_cfa_(dentry) == @_docolon_
      pfa = _pfa_(dentry)
    else // @d_dodoes
      pfa = *_pfa_(dentry)
    fin
    w = *pfa
    while w
      puts("  ")
      if ^_ffa_(w) & param_flag
        pfa = pfa + 2
      fin
      if w == @d_slit
        putc('"')
        puts(pfa)
        putc('"')
        pfa = pfa + ^pfa - 1
      elsif w == @d_lit
        puti(*pfa)
      else
        puts(w)
      fin
      putln
      pfa = pfa + 2
      w = *pfa
    loop
  fin
end
def _showstack_#0
  word val
  byte depth

  for depth = 1 to (@_get_estack)()#1
    val = ^(_estkl + 16 - depth) | (^(_estkh + 16 - depth) << 8)
    puti(val); putc(' ')
  next
end
def _showrstack_#0
  byte depth

  depth = RSTK_SIZE - 1
  while depth >= RSP
    puti(RSTACK[depth]); putc(' ')
    depth--
  loop
end
def _tron_#0
  state = state | trace_flag
end
def _troff_#0
  state = state & ~(trace_flag | step_flag)
end
def _stepon_#0
  state = state | step_flag | trace_flag
end
def _stepoff_#0
  state = state & ~step_flag
end
def brkpoint#0
  brkhandle(brkentry)
  W = _cfa_(brkentry)
  if brkcfa
    brkcfa()#0
  else // Breakpoint was cleared
    (*_cfa_(brkentry))()#0
  fin
end
def _brk_#0
  brkhandle(@d_brk)
end
def _brkon_#0
  word dentry

  if brkcfa
    puts("Breakpoint already enabled\n")
  else
    dentry = find(nextword(' '))
    if dentry
      brkentry = dentry
      brkcfa = *_cfa_(dentry)
      *_cfa_(dentry) = @brkpoint
    else
      puts("No match\n")
    fin
  fin
end
def _brkoff_#0
  *_cfa_(brkentry) = brkcfa
  brkcfa           = 0
end
def _cont_#0
  if brk
    state = state | exit_flag
  else
    putc('?')
  fin
end
def _itc_#0
  comp_mode = comp_itc_flag
end
def _pbc_#0
  comp_mode = comp_pbc_flag
end
def _comment_#0
  nextword(')')
end
def _vlist_#0
  word d

  d = vlist
  while d
    puts(d); puts("  ")
    if conio:keypressed()
      getc; getc
    fin
    d = *_lfa_(d)
  loop
end
//
// Quit
//
def _quit_#0
  warmstart
  throw(@exitforth, FALSE)
end
//
// Abort
//
def _abort_(a)#0
  if a
    puts("Abort\n")
    _quit_
  fin
end
def _doabortstr_(a,b)#0
  if a
    puts("Abort: "); puts(b); putln
    _quit_
  fin
end
def _abortstr_#0
  word str
  byte len

  _str_
  if state & comp_flag
    compword(@d_doabortstr)
  else
    (@_doabortstr_)()#0
  fin
end
//
// Restart FORTH
//
def _restart_#0
  coldstart
  throw(@exitforth, FALSE)
end
//
// Leave FORTH
//
def _bye_#0
  throw(@exitforth, TRUE)
end

puts("FORTH WIP for PLASMA 2.1\n")
if cmdsys:sysver < $0201
  puts("PLASMA >= 2.01 required\n")
  return
fin
_estkl = ^(@syscall + 1) // Hack to fill in parameter stack locations
_estkh = ^(@syscall + 3)
fileio:iobufalloc(4) // Allocate a bunch of file buffers
startheap = heapmark
coldstart
inptr = argNext(argFirst)
if not except(@exitforth)
  if ^inptr; inptr++; _srcstr_; fin
  interpret
fin
done
