include "inc/cmdsys.plh"
include "inc/args.plh"
include "inc/longjmp.plh"
//
// FORTH dictionary layout
//
//  bytes   usage
//  -----   -----
// [1]      name length
// [1..255] name
// [1]      FFA (flag field address)
// [2]      LFA (link field address)
// [2]      CFA (code field address)
// [2..]    PFA (param field address)
//

//
// Mask and flags for dictionary entries
//
const param_flag    = $02
const itc_flag      = $04
const inline_flag   = $08
const inlinew_flag  = $10
const imm_flag      = $20
const componly_flag = $40
const hidden_flag   = $80
//
// Predefine instrinsics
//
predef _drop_(a)#0, _swap_(a,b)#2, _dup_(a)#2, _dashdup_(a)#1, _over_(a,b,c)#4, _rot_(a,b,c)#3
predef _add_(a,b)#1, _inc_(a)#1, _inc2_(a)#1, _sub_(a,b)#1, _mul_(a,b)#1, _div_(a,b)#1
predef _neg_(a)#1, _and_(a,b)#1, _or_(a,b)#1, _xor_(a,b)#1, _not_(a)#1
predef _abs_(a)#1, _max_(a,b)#1, _min_(a,b)#1
predef _cset_(a,b)#0, _cget_(a)#1, _wset_(a,b)#0, _wplusset_(a,b)#0, _wget_(a)#1
predef _ffa_(a)#1, _lfa_(a)#1, _cfa_(a)#1, _pfa_(a)#1, _allot_(a)#0
predef _eq_(a,b)#1, _gt_(a,b)#1, _lt_(a,b)#1, _0lt_(a)#1, _0eq_(a)#1
predef _branch_#0, _0branch_(a)#0, _if_#0, _else_#0, _then_#0
predef _begin_#0, _again_#0, _until_#0, _while_#0, _repeat_#0
predef _do_#0, _doloop_#0, _doplusloop_(a)#0, _plusloop_#0, _loop_#0, _leave_#0, _j_#1
predef _buildcreate_#0, _builds_#0, _dodoes_#0, _filldoes_#0, _does_#0
predef pfillw(a)#0, pfillb(a)#0, _colon_#0, _semi_#0
predef _tors_(a)#0, _fromrs_#1, _toprs_#1, _execute_(a)#0, _lookup_#1
predef _cmove_(a,b,c)#0, _move_(a,b,c)#0, _fill_(a,b,c)#0, _plasma_#0
predef _var_(a)#0, _const_(a)#0, _lit_#1, _slit_#1, _tick_#1, _forget_#0
predef _terminal_#1, _prat_(a)#0, _str_#0, _prstr_#0, _src_#0
predef _vlist_#0, _tron_#0, _troff_#0, _itc_#0, _pbc_#0
predef _brkout_#0, _brkon_#0, _brkoff_#0
predef _show_#0, _showstack_#0, _showrstack_#0
predef _cont_#0, _restart_#0, _bye_#0, _quit_#0, _abort_#0
// DROP
char d_drop = "DROP"
byte = inline_flag
word = 0, @_drop_, $30
// SWAP
char d_swap = "SWAP"
byte = 0
word = @d_drop, @_swap_, 0
// DUP
char d_dup = "DUP"
byte = inline_flag
word = @d_swap, @_dup_, $34
// -DUP
char d_dashdup = "-DUP"
byte = 0
word = @d_dup, @_dashdup_, 0
// OVER
word d_over = "OVER"
byte = 0
word = @d_dashdup, @_over_, 0
// ROT
word d_rot = "ROT"
byte = 0
word = @d_over, @_rot_, 0
// ADD
char d_add = "+"
byte = inline_flag
word = @d_rot, @_add_, $82
// ONE PLUS
char d_inc = "1+"
byte = inline_flag
word = @d_add, @_inc_, $8C
// TWO PLUS
char d_inc2 = "2+"
byte = inlinew_flag
word = @d_inc, @_inc2_, $8C8C
// SUB
char d_sub = "-"
byte = inline_flag
word = @d_inc2, @_sub_, $84
// MUL
char d_mul = "*"
byte = inline_flag
word = @d_sub, @_mul_, $86
// DIV
char d_div = "/"
byte = inline_flag
word = @d_mul, @_div_, $88
// NEG
char d_neg = "NEG"
byte = inline_flag
word = @d_div, @_neg_, $90
// AND
char d_and = "AND"
byte = inline_flag
word = @d_neg, @_and_, $94
// OR
char d_or = "OR"
byte = inline_flag
word = @d_and, @_or_, $96
// XOR
char d_xor = "XOR"
byte = inline_flag
word = @d_or, @_xor_, $98
// NOT
char d_not = "NOT"
byte = inline_flag
word = @d_xor, @_not_, $92
// EQUALS
char d_eq = "="
byte = inline_flag
word = @d_not, @_eq_, $40
// GREATER THAN
char d_gt = ">"
byte = inline_flag
word = @d_eq, @_gt_, $44
// LESS THAN
char d_lt = "<"
byte = inline_flag
word = @d_gt, @_lt_, $46
// LESS THAN ZERO
char d_0lt = "0<"
byte = inlinew_flag
word = @d_lt, @_0lt_, $4600 // ZERO ISLT
// EQUALS ZERO
char d_0eq = "0="
byte = inlinew_flag
word = @d_0lt, @_0eq_, $4000 // ZERO ISEQ
// ABS
char d_abs = "ABS"
byte = 0
word = @d_0eq, @_abs_, 0
// MIN
char d_min = "MIN"
byte = 0
word = @d_abs, @_min_, 0
// MAX
char d_max = "MAX"
byte = 0
word = @d_min, @_max_, 0
// CHAR PUT
char d_cset = "C!"
byte = inline_flag
word = @d_max, @_cset_, $70
// WORD PUT
char d_wset = "!"
byte = inline_flag
word = @d_cset, @_wset_, $72
// WORD PLUS PUT
char d_wplusset = "+!"
byte = 0
word = @d_wset, @_wplusset_, 0
// CHAR GET
char d_cget = "C@"
byte = inline_flag
word = @d_wplusset, @_cget_, $60
// WORD SET
char d_wget = "@"
byte = inline_flag
word = @d_cget, @_wget_, $62
// EXECUTE
char d_execute = "EXECUTE"
byte = inline_flag
word = @d_wget, @_execute_, $56 // ICAL
// TO RSTACK
char d_torstk = ">R"
byte = 0
word = @d_execute, @_tors_, 0
// FROM RSTACK
char d_fromrstk = "R>"
byte = 0
word = @d_torstk, @_fromrs_, 0
// TOP OF RSTACK
char d_toprstk = "R@"
byte = 0
word = @d_fromrstk, @_toprs_, 0
// PLASMA SYMBOL LOOKUP
char d_lookup = "LOOKUP"
byte = imm_flag
word = @d_toprstk, @_lookup_, 0
// PLASMA LINKEAGE
char d_plasma = "PLASMA"
byte = 0
word = @d_lookup, @_plasma_, 0
// VARIABLE
char d_var = "VARIABLE"
byte = 0
word = @d_plasma, @_var_, 0
// CONSTANT
char d_const = "CONSTANT"
byte = 0
word = @d_var, @_const_, 0
// CMOVE
char d_cmove = "CMOVE"
byte = 0
word = @d_const, @_cmove_, 0
// MOVE
char d_move = "MOVE"
byte = 0
word = @d_cmove, @_move_, 0
// FILL
char d_fill = "FILL"
byte = 0
word = @d_move, @_fill_, 0
// HERE
char d_here = "HERE"
byte = 0
word = @d_fill, @heapmark, 0
// ALLOT
char d_allot = "ALLOT"
byte = 0
word = @d_here, @_allot_, 0
// BRANCH
char d_branch = "(BRANCH)"
byte = param_flag
word = @d_allot, @_branch_, 0
// BRANCH IF 0
char d_0branch = "(0BRANCH)"
byte = param_flag
word = @d_branch, @_0branch_, 0
// IF
char d_if = "IF"
byte = componly_flag | imm_flag
word = @d_0branch, @_if_, 0
// ELSE
char d_else = "ELSE"
byte = componly_flag | imm_flag
word = @d_if, @_else_, 0
// THEN
char d_then = "THEN"
byte = componly_flag | imm_flag
word = @d_else, @_then_, 0
// DO
char d_do = "DO"
byte = componly_flag | imm_flag
word = @d_then, @_do_, 0
// LEAVE
char d_leave = "LEAVE"
byte = componly_flag
word = @d_do, @_leave_, 0
// COMPILED LOOP
char d_doloop = "(DOLOOP)"
byte = param_flag
word = @d_leave, @_doloop_, 0
// LOOP
char d_loop = "LOOP"
byte = componly_flag | imm_flag
word = @d_doloop, @_loop_, 0
// COMPILED LOOP+
char d_doplusloop = "(+DOLOOP)"
byte = param_flag
word = @d_loop, @_doplusloop_, 0
// LOOP
char d_plusloop = "+LOOP"
byte = componly_flag | imm_flag
word = @d_doplusloop, @_plusloop_, 0
// I
char d_i = "I"
byte = componly_flag
word = @d_plusloop, @_toprs_, 0
// J
char d_j = "J"
byte = componly_flag
word = @d_i, @_j_, 0
// BEGIN
char d_begin = "BEGIN"
byte = componly_flag | imm_flag
word = @d_j, @_begin_, 0
// AGAIN
char d_again = "AGAIN"
byte = componly_flag | imm_flag
word = @d_begin, @_again_, 0
// UNTIL
char d_until = "UNTIL"
byte = componly_flag | imm_flag
word = @d_again, @_until_, 0
// WHILE
char d_while = "WHILE"
byte = componly_flag | imm_flag
word = @d_until, @_while_, 0
// REPEAT
char d_repeat = "REPEAT"
byte = componly_flag | imm_flag
word = @d_while, @_repeat_, 0
// FORGET
char d_forget = "FORGET"
byte = 0
word = @d_repeat, @_forget_, 0
// CREATE
char d_create = "CREATE"
byte = imm_flag
word = @d_forget, @_buildcreate_, 0
// BUILDS
char d_builds = "<BUILDS"
byte = imm_flag
word = @d_create, @_builds_, 0
// FILL DOES COMPILE TIME
char d_filldoes = "(FILLDOES)"
byte = 0
word = @d_builds, @_filldoes_, 0
// DO DOES RUN TIME
char d_dodoes = "(DODOES)"
byte = 0
word = @d_filldoes, @_dodoes_, 0
// DOES
char d_does = "DOES>"
byte = imm_flag
word = @d_dodoes, @_does_, 0
// COMMA
char d_comma = ","
byte = 0
word = @d_does, @pfillw, 0
// COMMA
char d_commab = "C,"
byte = 0
word = @d_comma, @pfillb, 0
// COLON
char d_colon = ":"
byte = 0
word = @d_commab, @_colon_, 0
// SEMI
char d_semi = ";"
byte = imm_flag
word = @d_colon, @_semi_, 0
// TICK
char d_tick = "'"
byte = 0
word = @d_semi, @_tick_, 0
// LITERAL NUMBER
char d_lit = "LIT"
byte = param_flag
word = @d_tick, @_lit_, 0
// ?TERMINAL
char d_terminal = "?TERMINAL"
byte = 0
word = @d_lit, @_terminal_, 0
// KEY
char d_key = "KEY"
byte = 0
word = @d_terminal, @getc, 0
// PRINT @TOS
char d_prat = "?"
byte = 0
word = @d_key, @_prat_, 0
// PRINT TOS
char d_prtos = "."
byte = 0
word = @d_prat, @puti, 0
// PRINT TOS HEX
char d_prtoshex = ".$"
byte = 0
word = @d_prtos, @puth, 0
// PRINT TOS HEX
char d_prtosbyte = ".C$"
byte = 0
word = @d_prtoshex, @putb, 0
// EMIT
char d_emit = "EMIT"
byte = 0
word = @d_prtosbyte, @putc, 0
// CR
char d_cr = "CR"
byte = 0
word = @d_emit, @putln, 0
// STRING
char d_str = "\""
byte = imm_flag
word = @d_cr, @_str_, 0
// LITERAL STRING
char d_slit = "SLIT"
byte = param_flag
word = @d_str, @_slit_, 0
// COMPILED PRINT STRING
char d_doprstr = "(.\")"
byte = 0
word = @d_slit, @puts, 0
// PRINT STRING
char d_prstr = ".\""
byte = imm_flag
word = @d_doprstr, @_prstr_, 0
// SOURCE FILE
char d_prsrc = "SRC\""
byte = 0
word = @d_prstr, @_src_, 0
// CONT
char d_cont = "CONT"
byte = 0
word = @d_prsrc, @_cont_, 0
// QUIT
char d_quit = "QUIT"
byte = 0
word = @d_cont, @_quit_, 0
// ABORT
char d_abort = "ABORT"
byte = 0
word = @d_quit, @_abort_, 0
// RESTART
char d_restart = "RESTART"
byte = 0
word = @d_abort, @_restart_, 0
// BYE
char d_bye = "BYE"
byte = 0
word = @d_restart, @_bye_, 0
// CALL 6502
char d_call = "CALL"
byte = 0
word = @d_bye, @call, 0
// SHOW DEFINITION
char d_show = "SHOW"
byte = 0
word = @d_call, @_show_, 0
// SHOW STACK
char d_showstack = "SHOWSTACK"
byte = 0
word = @d_show, @_showstack_, 0
// SHOW RSTACK
char d_showrstack = "SHOWRSTACK"
byte = 0
word = @d_showstack, @_showrstack_, 0
// TRACE ON
char d_tron = "TRON"
byte = 0
word = @d_showrstack, @_tron_, 0
// TRACE OFF
char d_troff = "TROFF"
byte = 0
word = @d_tron, @_troff_, 0
// BREAK OUT
char d_brkout = "BRKOUT"
byte = 0
word = @d_troff, @_brkout_, 0
// BREAK ON
char d_brkon = "BRKON"
byte = 0
word = @d_brkout, @_brkon_, 0
// BREAK OFF
char d_brkoff = "BRKOFF"
byte = 0
word = @d_brkon, @_brkoff_, 0
//  COMPILE USING ITC
char d_itc = "ITC"
byte = 0
word = @d_brkoff, @_itc_, 0
// COMPILE USING PLASMA BYTECODES
char d_pbc = "PBC"
byte = 0
word = @d_itc, @_pbc_, 0
// LIST VOCAB
char d_vlist = "VLIST"
byte = 0
word = @d_pbc, @_vlist_, 0
//
// Internal variables
//
word vlist = @d_vlist
word startheap, arg, infunc, inref, IIP, W, exit
const INBUF_SIZE = 80
char inbuf[INBUF_SIZE + 2]
const keyinbuf = $1FF
word inptr = @inbuf
//
// RSTACK
//
const RSTK_SIZE = 16
byte RSP = RSTK_SIZE
word RSTACK[RSTK_SIZE]
//
// State flags
//
const exit_flag     = $01
const trace_flag    = $02
const comp_itc_flag = $10
const comp_pbc_flag = $20
const comp_flag     = comp_itc_flag | comp_pbc_flag
//
// Mode and state
//
byte comp_mode = comp_itc_flag
byte state     = 0
byte brk       = 0
word brkentry  = 0
word brkcfa    = 0
byte _get_estack   = $8A           // TXA
byte               = $49, $FF      // EOR #$FF
byte               = $38           // SEC
byte               = $69, $10      // ADC #$10
byte               = $C9, $11      // CMP #$11
byte               = $90, $02      // BCC +2
byte               = $A2, $10      // LDX #ESTKSZ/2
byte               = $CA           // DEX
byte               = $95           // STA
byte _estkl        = $D0           // ESTKL,X
byte               = $A9, $00      // LDA #$00
byte               = $95           // STA
byte _estkh        = $C0           // ESTKH,X
byte               = $60           // RTS
byte _reset_estack = $A2, $10      // LDX #ESTKSZ/2
byte               = $60           // RTS
//
// Helper routines
//
predef interpret#0

//
// Input routines
//
def keyin#0
  byte i

  repeat
    if state & comp_flag
      inptr = gets('>'|$80) // Compilation continuation prompt
    else
      if brk
        puts(" BRK("); puti(brk); putc(')')
      else
        puts(" OK")
      fin
      inptr = gets('\n'|$80)
    fin
  until ^inptr
  ^(inptr + ^inptr + 1) = 0 // NULL terminate
  inptr++
end
def filein#0
  inbuf = cmdsys:sysread(inref, @inbuf + 1, INBUF_SIZE)
  if inbuf
    inbuf[inbuf + 1] = 0 // NULL terminate
    inptr            = @inbuf + 1
  else
    cmdsys:sysclose(inref) // EOF - switch back to keyboard input
    inref  = 0
    infunc = @keyin
    keyin
  fin
end
def toknext#2
  word tokptr
  byte len, comment

  comment = 0
  repeat
    repeat
      if !^inptr
        infunc()#0
      fin
      while ^inptr and ^inptr <= ' ' // Skip whitespace
        inptr++
      loop
    until ^inptr
    len = 0
    while ^(inptr + len) > ' ' // Tokenize characters
      len++
    loop
    if len == 1 and ^inptr == '(' // Check for nested comment
      comment++
    fin
    if comment
      if len == 1 and ^inptr == ')' // Check for nested uncomment
        comment--
      fin
      inptr = inptr + len
      len   = 0
    fin
  until len
  tokptr = inptr
  inptr  = inptr + len
  return tokptr, len
end
def delimit(a)#2
  word delim
  byte len

  if ^inptr == ' '
    inptr++
  fin
  delim = inptr
  while ^inptr and ^inptr <> a // Find delimiter
    inptr++
  loop
  len = inptr - delim
  if ^inptr == a
    inptr++
  fin
  return delim, len
end
//
// Find match in dictionary
//
def find(matchchars, matchlen)#1
  word dentry
  byte i

  matchchars--
  dentry = vlist
  while dentry
    if ^dentry == matchlen
      for i = 1 to ^dentry
        if ^(matchchars+i) <> ^(dentry+i)
          break
        fin
      next
      if i > ^dentry
        return dentry
      fin
    fin
    dentry = *(dentry + ^dentry + 2)
  loop
  // Not found
  return 0
end
//
// Convert input into number
//
def isnum(numchars, numlen)#2
  word num, sign
  byte numchar

  sign = 1
  if ^numchars == '-'
    sign = -1
    numchars++
    numlen--
    if numlen == 0
      return 0, 0
    fin
  fin
  num = 0
  if ^numchars == '$'
    numchars++
    numlen--
    if numlen == 0
      return 0, 0
    fin
    while numlen
      numchar = toupper(^numchars)
      if numchar >= '0' and numchar <= '9'
        num = num * 16 + numchar - '0'
      elsif numchar >= 'A' and numchar <= 'F'
        num = num * 16 + numchar - 'A' + 10
      else
        break
      fin
      numchars++
      numlen--
    loop
  else
    while numlen
      numchar = ^numchars
      if numchar < '0' or numchar > '9'
        break
      fin
      num = num * 10 + numchar - '0'
      numchars++
      numlen--
    loop
  fin
  return num * sign, numlen == 0
end
//
// Break handler
//
def showtrace(dentry)#0
    puts("\n[ "); _showstack_; puts("] "); puts(dentry); puts(": ")
end
def brkhandle(dentry)#0
  word brk_infn, brk_inptr, brk_iip
  byte brk_state

  showtrace(dentry)
  brk++
  brk_state = state
  brk_iip   = IIP
  brk_infn  = infunc
  brk_inptr = inptr
  state  = 0
  infunc = @keyin
  inptr  = keyinbuf
  ^inptr = 0
  interpret
  state  = brk_state
  IIP    = brk_iip
  infunc = brk_infn
  inptr  = brk_inptr
  brk--
end
//
// Execute code in CFA
//
def execword(dentry)#0

  if ^$C000 == $83 // CTRL-C
    ^$C010 // Clear KB strobe
    brkhandle(dentry)
  fin
  if ^$C000 == $94 // CTRL-T
    ^$C010 // Clear KB strobe
    state = state ^ trace_flag
  fin
  if state & trace_flag
    showtrace(dentry)
  fin
  W = _cfa_(dentry)
  (*W)()#0
  if (@_get_estack)()#1 > 16
    puts("Stack over/underflow\n")
    _abort_
  fin
end
def execwords(wlist)#0
  word prevIP, dentry

  prevIP = IIP
  IIP    = wlist
  dentry = *IIP
  while dentry
    IIP    = IIP + 2
    execword(dentry)
    dentry = *IIP
  loop
  IIP = prevIP
end
def push(a)#1 // Stack hack - call as (@push)(a)#0 to leave a on eval stack
  return a
end
def pfillw(a)#0
  *(heapalloc(2)) = a
end
def pfillb(a)#0
  *(heapalloc(1)) = a
end
//
// Warm start
//
def warmstart#0
  (@_reset_estack)()#0
  brk    = 0
  RSP    = RSTK_SIZE
  infunc = @keyin
  inptr  = keyinbuf
  ^inptr = 0
  if state & comp_flag // Undo compilation state
    heaprelease(vlist)
    vlist = *_lfa_(vlist)
  fin
  state = 0
  if inref
    cmdsys:sysclose(inref)
    inref = 0
  fin
end
//
// Cold start
//
def coldstart#0
  vlist = @d_vlist
  heaprelease(startheap)
  warmstart
end
def interpret#0
  word inchars, dentry, value
  byte inlen, valid

  //
  // Set flags on words
  //
  repeat
    inchars, inlen = toknext
    dentry = find(inchars, inlen)
    if dentry
      if (not (state & comp_flag)) or (^_ffa_(dentry) & imm_flag)
        execword(dentry)
      elsif state & comp_itc_flag
        pfillw(dentry)
      elsif state & comp_pbc_flag
        if ^_ffa_(dentry) & itc_flag // Check if calling ITC word
          pfillb($2C)    // CONSTANT WORD
          pfillw(dentry) // Pointer to dictionary entry
          pfillb($54)    // CALL execword
          pfillw(@execword)
        elsif ^_ffa_(dentry) & inline_flag // inline bytecode
          pfillb(^_pfa_(dentry))
        elsif ^_ffa_(dentry) & inlinew_flag // inline 2 bytecodes
          pfillw(*_pfa_(dentry))
        else
          pfillb($54) // CALL CFA directly
          pfillw(*_cfa_(dentry))
        fin
      fin
    else
      value, valid = isnum(inchars, inlen)
      if not valid
        warmstart
        puts("? No match\n")
      else
        if state & comp_flag
          if state & comp_itc_flag
            pfillw(@d_lit)
            pfillw(value) // Poke literal value into PFA
          else // comp_pbc_flag
            if value >= 0 and value <= 15
              pfillb(value << 1) // CONSTANT NIBBLE
            elsif value == -1
              pfillb($20) // CONSTANT MINUS_ONE
            else
              pfillb($2C) // CONSTANT WORD
              pfillw(value) // Poke literal value into PFA
            fin
          fin
        else
          (@push)(value)#0
        fin
      fin
    fin
  until state & exit_flag
end
//
// Intrinsics
//
def _drop_(a)#0
  return
end
def _swap_(a,b)#2
  return b,a
end
def _dup_(a)#2
  return a,a
end
def _dashdup_(a)#1
  if a; (@push)(a)#0; fin
  return a
end
def _over_(a,b,c)#4
  return a,b,c,a
end
def _rot_(a,b,c)#3
  return b,c,a
end
def _add_(a,b)#1
  return a+b
end
def _inc_(a)
  return a + 1
end
def _inc2_(a)
  return a + 2
end
def _sub_(a,b)#1
  return a-b
end
def _mul_(a,b)#1
  return a*b
end
def _div_(a,b)#1
  return a/b
end
def _neg_(a)#1
  return -a
end
def _and_(a,b)#1
  return a & b
end
def _or_(a,b)#1
  return a | b
end
def _xor_(a,b)#1
  return a ^ b
end
def _not_(a)#1
  return ~a
end
def _eq_(a,b)#1
  return a == b
end
def _gt_(a,b)#1
  return a > b
end
def _lt_(a,b)#1
  return a < b
end
def _0lt_(a)#1
  return a < 0
end
def _0eq_(a)#1
  return a == 0
end
def _cset_(a,b)#0
  ^b = a
end
def _wset_(a,b)#0
  *b = a
end
def _wplusset_(a,b)#0
  *b = *b + a
end
def _abs_(a)#1
  return a < 0 ?? -a :: a
end
def _min_(a,b)#1
  return a > b ?? b :: a
end
def _max_(a,b)
  return a > b ?? a :: b
end
def _cget_(a)#1
  return ^a
end
def _wget_(a)#1
  return *a
end
def _execute_(a)#0
  a()#0
end
def _ffa_(dentry)#1
  return dentry + ^dentry + 1
end
def _lfa_(dentry)#1
  return dentry + ^dentry + 2
end
def _cfa_(dentry)#1
 return dentry + ^dentry + 4
end
def _pfa_(dentry)#1
 return dentry + ^dentry + 6
end
def _tors_(a)#0
  if RSP == 0
    puts("Return stack overflow\n")
    _abort_
  fin
  RSP--
  RSTACK[RSP] = a
end
def _fromrs_#1
  if RSP == RSTK_SIZE
    puts("Return stack underflow\n")
    _abort_
  fin
  RSP++
  return RSTACK[RSP - 1]
end
def _toprs_#1
  return RSTACK[RSP]
end
def _lit_#1
  word lit

  lit = *IIP
  IIP = IIP + 2
  return lit
end
def _slit_#1
  word slit

  slit = IIP
  IIP  = IIP + ^IIP + 1
  return slit
end
def _allot_(a)#0
  heapalloc(a)
end
def _cmove_(a,b,c)#0
  memcpy(b, a, c)
end
def _move_(a,b,c)#0
  memcpy(b, a, c * 2)
end
def _fill_(a,b,c)#0
  memset(a, c | (c << 8), b)
end
def _create_#0
  word bldptr, plist, namechars, namelen

  if state & comp_flag
    puts(" Already compiling\n")
    _abort_
  fin
  namechars, namelen = toknext
  plist  = vlist
  vlist  = heapmark
  ^vlist = namelen
  bldptr = vlist + 1
  while namelen
    ^bldptr = ^namechars
    bldptr++
    namechars++
    namelen--
  loop
  state   = state | comp_mode
  ^bldptr = state & comp_itc_flag ?? itc_flag :: 0  // Flags
  bldptr++
  *bldptr = plist;      // Link ptr
  bldptr  = bldptr + 2
  *bldptr = bldptr + 2; // Code ptr linked to PFA
  heapalloc(bldptr - vlist + 2)
end
def _buildcreate_#0
  _create_
  pfillw(0) // Allocate space for LFA
end
def stodci(str, dci)
  byte len, c

  len = ^str
  if len == 0
    ^dci = 0
    return dci
  fin
  c = toupper(^(str + len)) & $7F
  len--
  ^(dci + len) = c
  while len
    c = toupper(^(str + len)) | $80
    len--
    ^(dci + len) = c
  loop
  return dci
end
def _lookup_#1
  word symname
  char symlen, dci[31]

  symname, symlen = toknext
  symname--
  ^symname = symlen
  return cmdsys:lookupsym(stodci(symname, @dci))
end
def _plasma_#0
  word addr
  char dci[31]

  _create_
  addr = cmdsys:lookupsym(stodci(vlist, @dci))
  if not addr
    puts("PLASMA symbol "); puts(vlist); puts(" not found\n")
    _abort_
  fin
  ^(_ffa_(vlist)) = 0    // Always compiled
  *(_cfa_(vlist)) = addr // Symbol address
  state = state & ~comp_flag
end
def _var_(a)#0
  _create_
  ^(_ffa_(vlist)) = 0 // Always compiled
  pfillb(^(@divmod)) // Hack - get VM entry vector from divmod
  pfillw(*(@divmod + 1))
  pfillb($2C) // CONSTANT WORD
  pfillw(heapmark + 3)
  pfillb($5C) // RET
  pfillw(a)   // Variable storage
  state = state & ~comp_flag
end
def _const_(a)#0
  _create_
  ^(_ffa_(vlist)) = 0 // Always compiled
  pfillb(^(@divmod)) // Hack - get VM entry vector from divmod
  pfillw(*(@divmod + 1))
  pfillb($2C) // CONSTANT WORD
  pfillw(a)
  pfillb($5C) // RET
  state = state & ~comp_flag
end
def _docolon_#0
  execwords(W + 2) // Exec PFA
end
def _colon_#0
  _create_
  if state & comp_itc_flag
    *(_cfa_(vlist)) = @_docolon_
  else // comp_pbc_flag
    pfillb(^(@divmod)) // Hack - get VM entry vector from divmod
    pfillw(*(@divmod + 1))
  fin
end
def _compbuilds_#0
  pfillb(^(@divmod))   // Hack - get VM entry vector from divmod
  pfillw(*(@divmod + 1))
  pfillb($2C)          // CONSTANT WORD
  pfillw(heapmark + 6) // Pointer to PFA storage
  pfillb($54)          // CALL
  pfillw(0)            // Filled in later during _compdoes_
  pfillb($5C)          // RET
end
def _builds_#0
  if state & comp_itc_flag
    pfillw(@d_create)
  else // comp_pbc_flag
    pfillb($54) // CALL
    pfillw(@_create_)
    pfillb($54) // CALL
    pfillw(@_compbuilds_)
  fin
end
def _dodoes_#0
  (@push)(W + 4)#0    // Pointer to PFA storage
  execwords(*(W + 2)) // Exec PFA ptr
end
def _filldoes_#0
  *(_cfa_(vlist)) = @_dodoes_
  *(_pfa_(vlist)) = IIP + 2
  state           = state & ~comp_flag
end
def _compdoes_(does)#0
  *(_pfa_(vlist) + 7) = does // Fill in DOES code address
  state               = state & ~comp_flag
end
def _does_#0
  if state & comp_itc_flag
    pfillw(@d_filldoes)
    pfillw(0)
  else // comp_pbc_flag
    pfillb($2C)          // CONSTANT WORD
    pfillw(heapmark + 6) // Pointer to DOES code
    pfillb($54)          // CALL
    pfillw(@_compdoes_)  // Fills in code address reserved in _compbuilds_
    pfillb($5C)          // RET
    // End of BUILDS, beginning of DOES code
    pfillb(^(@divmod))   // Hack - get VM entry vector from divmod
    pfillw(*(@divmod + 1))
  fin
end
def _semi_#0
  if state & comp_itc_flag
    pfillw(0)
  elsif state & comp_pbc_flag
    pfillb($5C) // RET
  else
    puts(" Not compiling\n")
    _abort_
  fin
  state = state & ~comp_flag
end
def _immediate_#0
  ^_ffa_(vlist) = ^_ffa_(vlist) | imm_flag
end
def _branch_#0
  IIP = *IIP
end
def _0branch_(a)#0
  if a
    IIP = IIP + 2
  else
    IIP = *IIP
  fin
end
def _if_#0
  if state & comp_itc_flag
    pfillw(@d_0branch)
  else // comp_pbc_flag
    pfillb($4C) // BRFLS
  fin
  _tors_(heapalloc(2)) // Save backfill address
end
def _else_#0
  word backref

  backref = _fromrs_
  if state & comp_itc_flag
    pfillw(@d_branch)
    _tors_(heapalloc(2))
    *backref = heapmark
  else // comp_pbc_flag
    pfillb($50) // BRNCH
    _tors_(heapalloc(2))
    *backref = heapmark - backref // Relative branch
  fin
end
def _then_#0
  word backref

  backref = _fromrs_
  if state & comp_itc_flag
    *backref = heapmark
  else // comp_pbc_flag
    *backref = heapmark - backref // Relative branch
  fin
end
def _do_#0
  if state & comp_itc_flag
    pfillw(@d_swap)
    pfillw(@d_torstk)
    pfillw(@d_torstk)
  else // comp_pbc_flag
    pfillb($54) // CALL
    pfillw(@_swap_)
    pfillb($54) // CALL
    pfillw(@_tors_)
    pfillb($54) // CALL
    pfillw(@_tors_)
  fin
  _tors_(heapmark)
end
def _leave_#0
  RSTACK[RSP] = RSTACK[RSP + 1] - 1
end
def _doloop_#0
  RSTACK[RSP]++
  if RSTACK[RSP] == RSTACK[RSP + 1]
    RSP = RSP + 2
    IIP = IIP + 2
  else
    IIP = *IIP
  fin
end
def _dopbcloop_#1
  RSTACK[RSP]++
  if RSTACK[RSP] == RSTACK[RSP + 1]
    RSP = RSP + 2
    return TRUE
  fin
  return FALSE
end
def _doplusloop_(a)#0
  RSTACK[RSP] = RSTACK[RSP] + a
  if (a >= 0 and RSTACK[RSP] >= RSTACK[RSP + 1]) or (a < 0 and RSTACK[RSP] <= RSTACK[RSP + 1])
    RSP = RSP + 2
    IIP = IIP + 2
  else
    IIP = *IIP
  fin
end
def _dopbcplusloop_(a)#1
  RSTACK[RSP] = RSTACK[RSP] + a
  if (a >= 0 and RSTACK[RSP] >= RSTACK[RSP + 1]) or (a < 0 and RSTACK[RSP] <= RSTACK[RSP + 1])
    RSP = RSP + 2
    return TRUE
  fin
  return FALSE
end
def _loop_#0
  if state & comp_itc_flag
    pfillw(@d_doloop)
    pfillw(_fromrs_)
  else // comp_pbc_flag
    pfillb($54) // CALL
    pfillw(@_dopbcloop_)
    pfillb($4C) // BRFLS
    pfillw(_fromrs_ - heapmark)
  fin
end
def _plusloop_#0
  if state & comp_itc_flag
    pfillw(@d_doplusloop)
    pfillw(_fromrs_)
  else // comp_pbc_flag
    pfillb($54) // CALL
    pfillw(@_dopbcplusloop_)
    pfillb($4C) // BRFLS
    pfillw(_fromrs_ - heapmark)
  fin
end
def _j_#1
  return RSTACK[RSP + 2]
end
def _begin_#0
  _tors_(heapmark)
end
def _again_#0
  if state & comp_itc_flag
    pfillw(@d_branch)
    pfillw(_fromrs_)
  else // comp_pbc_flag
    pfillb($50) // BRNCH
    pfillw(_fromrs_ - heapmark)
  fin
end
def _until_#0
  if state & comp_itc_flag
    pfillw(@d_0branch)
    pfillw(_fromrs_)
  else // comp_pbc_flag
    pfillb($4C) // BRFLS
    pfillw(_fromrs_ - heapmark)
  fin
end
def _while_#0
  if state & comp_itc_flag
    pfillw(@d_0branch)
  else // comp_pbc_flag
    pfillb($4C) // BRFLS
  fin
  _tors_(heapalloc(2)) // Save backfill address
end
def _repeat_#0
  word backref

  backref = _fromrs_ // Backref from WHILE

  if state & comp_itc_flag
    pfillw(@d_branch)
    pfillw(_fromrs_)
    *backref = heapmark // Backref to BEGIN
  else // comp_pbc_flag
    pfillb($50) // BRNCH
    pfillw(_fromrs_ - heapmark)
    *backref = heapmark - backref // Backref to BEGIN
  fin
end
def _tick_#1
  return find(toknext)
end
def _forget_#0
  word dentry

  dentry = find(toknext)
  if dentry
    vlist = *_lfa_(dentry)
    heaprelease(dentry)
  fin
end
def _cont_#0
  if brk
    state = exit_flag
  else
    putc('?')
  fin
end
def _terminal_#1
  return ^$C000 > 127
end
def _prat_(a)#0
  puti(*a)
end
def _str_#0
  word str
  byte len

  str, len = delimit('"')
  str--
  ^str = len
  len++
  if state & comp_itc_flag
    pfillw(@d_slit)
  elsif state & comp_pbc_flag
    pfillb($2E) // CONSTANT STRING
  else
    (@push)(heapmark)#0
  fin
  memcpy(heapalloc(len), str, len)
end
def _prstr_#0
  word str
  byte len

  if state & comp_flag
    _str_
    if state & comp_itc_flag
      pfillw(@d_doprstr)
    else // comp_pbc_flag
      pfillb($54) // CALL
      pfillw(@puts)
    fin
  else
    str, len = delimit('"')
    str--
    ^str = len
    puts(str)
  fin
end
def _src_#0
  word filename
  byte len
  byte params[4]

  filename, len = delimit('"')
  filename--
  ^filename = len
  inref = cmdsys:sysopen(filename)
  if inref
    params.0 = 3
    params.1 = inref // refnum
    params.2 = $7F   // mask
    params.3 = $0D   // nlchar
    syscall($C9, @params)
    infunc = @filein
    inptr  = @inbuf
    inbuf  = 0
  else
    puts("Failed to open "); puts(filename); putln
  fin
end
def _show_#0
  word dentry, pfa, w

  dentry = find(toknext)
  if dentry
    if ^_ffa_(dentry) & itc_flag // Only show ITC words
      if *_cfa_(dentry) == @_docolon_
        pfa = _pfa_(dentry)
      else // @d_dodoes
        pfa = *_pfa_(dentry)
      fin
      w = *pfa
      while w
        puts("  ")
        if ^_ffa_(w) & param_flag
          pfa = pfa + 2
        fin
        if w == @d_slit
          putc('"')
          puts(pfa)
          putc('"')
          pfa = pfa + ^pfa - 1
        elsif w == @d_lit
          puti(*pfa)
        else
          puts(w)
        fin
        putln
        pfa = pfa + 2
        w = *pfa
      loop
    fin
  fin
end
def _showstack_#0
  word val
  byte depth

  for depth = 1 to (@_get_estack)()#1
    val = ^(_estkl + 16 - depth) | (^(_estkh + 16 - depth) << 8)
    puti(val); putc(' ')
  next
end
def _showrstack_#0
  byte depth

  depth = RSTK_SIZE - 1
  while depth >= RSP
    puti(RSTACK[depth]); putc(' ')
    depth--
  loop
end
def _tron_#0
  state = state | trace_flag
end
def _troff_#0
  state = state & ~trace_flag
end
def brkpoint#0
  brkhandle(brkentry)
  W = _cfa_(brkentry)
  if brkcfa
    brkcfa()#0
  else // Breakpoint was cleared
    (*_cfa_(brkentry))()#0
  fin
end
def _brkout_#0
  brkhandle(@d_brkout)
end
def _brkon_#0
  word inchars, dentry
  byte inlen

  if brkcfa
    puts("Breakpoint already enabled\n")
  else
    inchars, inlen = toknext
    dentry = find(inchars, inlen)
    if dentry
      brkentry = dentry
      brkcfa = *_cfa_(dentry)
      *_cfa_(dentry) = @brkpoint
    else
      puts("No match\n")
    fin
  fin
end
def _brkoff_#0
  *_cfa_(brkentry) = brkcfa
  brkcfa           = 0
end
def _itc_#0
  comp_mode = comp_itc_flag
end
def _pbc_#0
  comp_mode = comp_pbc_flag
end
def _vlist_#0
  word d

  d = vlist
  while d
    puts(d); puts("  ")
    d = *_lfa_(d)
  loop
end
//
// Quit
//
def _quit_#0
  state = 0
  throw(exit, FALSE)
end
//
// Abort
//
def _abort_#0
  puts("Abort\n")
  warmstart
  throw(exit, FALSE)
end
//
// Restart
//
def _restart_#0
  coldstart
  warmstart
  throw(exit, FALSE)
end
//
// Leave FORTH
//
def _bye_#0
  throw(exit, TRUE)
end

puts("PLFORTH WIP\n")
if cmdsys:sysver < $0201
  puts("PLASMA >= 2.01 required\n")
  return
fin
startheap = heapmark
_estkl    = ^(@syscall + 1) // Hack to fill in parameter stack locations
_estkh    = ^(@syscall + 3)
warmstart
inptr = argNext(argFirst)
exit  = heapalloc(t_except)
if not except(exit)
  if ^inptr; inptr++; _src_; fin
  interpret
fin
done
