include "inc/cmdsys.plh"

//
// FORTH dictionary layout
//
//  bytes   usage
//  -----   -----
// [1]     name lenght and flags
// [1..31] name string
// [2]     LFA (link field address)
// [2]     CFA (code field address)
// [2]     PFA (param field address)
//

//
// Mask and flags for dictionary entries
//
const len_mask    = $1F
const imm_flag    = $20
const hidden_flag = $80
//
// Predefine instrinsics
//
predef _drop_(a)#0, _swap_(a,b)#2, _dup_(a)#2
predef _add_(a,b)#1, _sub_(a,b)#1, _mul_(a,b)#1, _div_(a,b)#1
predef _cset_(a,b)#0, _cget_(a)#1, _wset_(a,b)#0, _wget_(a)#1
predef _cfa_(a)#1, _lfa_(a)#1
predef _create_#0, _dodoes_(words)#0, _filldoes_#0, _does_#0, _pset_(a)#0, _colon_#0, _semi_#0
predef _tors_(a)#0, _fromrs_#1, _toprs_#1
predef _var_(a)#0, _const_(a)#0,_lit_#1, _tick_#1, _forget_#0
predef _vlist_#0, _tron_#0, _troff_#0, _show_#0, _bye_#0, _abort_#0
// DROP
char d_drop = "DROP"
word = 0, @_drop_, 0
// SWAP
char d_swap = "SWAP"
word = @d_drop, @_swap_, 0
// DUP
char d_dup = "DUP"
word = @d_swap, @_dup_, 0
// ADD
char d_add = "+"
word = @d_dup, @_add_, 0
// SUB
char d_sub = "-"
word = @d_add, @_sub_, 0
// MUL
char d_mul = "*"
word = @d_sub, @_mul_, 0
// DIV
char d_div = "/"
word = @d_mul, @_div_, 0
// CHAR SET
char d_cset = "C!"
word = @d_div, @_cset_, 0
// WORD SET
char d_wset = "!"
word = @d_cset, @_wset_, 0
// CHAR GET
char d_cget = "C@"
word = @d_wset, @_cget_, 0
// WORD SET
char d_wget = "@"
word = @d_cget, @_wget_, 0
// TO RSTACK
char d_torstk = ">R"
word = @d_wget, @_tors_, 0
// FROM RSTACK
char d_fromrstk = "R>"
word = @d_torstk, @_fromrs_, 0
// TOP OF RSTACK
char d_toprstk = "R@"
word = @d_fromrstk, @_toprs_, 0
// VARIABLE
char d_var = "VARIABLE"
word = @d_toprstk, @_var_, 0
// CONSTANT
char d_const = "CONSTANT"
word = @d_var, @_const_, 0
// HERE
char d_here = "HERE"
word = @d_const, @heapmark, 0
// ALLOT
char d_allot = "ALLOT"
word = @d_here, @heapalloc, 0
// FORGET
char d_forget = "FORGET"
word = @d_allot, @_forget_, 0
// BUILDS
char d_builds = "<BUILDS"
word = @d_forget, @_create_, 0
// FILL DOES COMPILE TIME
char d_filldoes = "FILLDOES"
word = @d_builds, @_filldoes_, 0
// DO DOES RUN TIME
char d_dodoes = "DODOES>"
word = @d_filldoes, @_dodoes_, 0
// DOES
char d_does = "DOES>"
word = @d_dodoes, @_does_, 0
// COMMA
char d_comma = ","
word = @d_does, @_pset_, 0
// COLON
char d_colon = ":"
word = @d_comma, @_colon_, 0
// SEMI
char d_semi = ";"
word = @d_colon, @_semi_, 0
// TICK
char d_tick = "'"
word = @d_semi, @_tick_, 0
// LITERAL
char d_lit = "LIT"
word = @d_tick, @_lit_, 0
// PRINT TOS
char d_prtos = "."
word = @d_lit, @puti, 0
// PRINT TOS HEX
char d_prtoshex = ".$"
word = @d_prtos, @puth, 0
// EXIT
char d_bye = "BYE"
word = @d_prtoshex, @_bye_, 0
// SHOW DEFINITION
char d_show = "SHOW"
word = @d_bye, @_show_, 0
// TRACE ON
char d_tron = "TRON"
word = @d_show, @_tron_, 0
// TRACE OFF
char d_troff = "TROFF"
word = @d_tron, @_troff_, 0
// LIST VOCAB
char d_vlist = "VLIST"
word = @d_troff, @_vlist_, 0
//
// Internal variables
//
word vlist = @d_vlist
word startheap, infunc, inptr, IIP, W
//
// RSTACK
//
const RSTK_SIZE = 16
byte RSP = RSTK_SIZE
word RSTACK[RSTK_SIZE]
//
// State flags
//
const comp_flag   = $01
const build_flag  = $02
const exit_flag   = $80
char state = 0
char trace = 0
byte _reset_stacks = $A2, $FE // LDX #$FE
byte               = $9A      // TXS
byte _reset_estack = $A2, $10 // LDX ESTKSZ/2
byte               = $60      // RTS
//
// Helper routines
//
def keyin#0
  byte i

  repeat
    puts(" OK")
    inptr = gets('\n'|$80)
  until ^inptr
  ^(inptr + ^inptr + 1) = 0 // NULL terminate
  inptr++
end
def filein#0
end
def toknext#2
  word tokptr
  byte len, comment

  comment = 0
  repeat
    repeat
      if !^inptr
        infunc()#0
      fin
      while ^inptr and ^inptr <= ' ' // Skip whitespace
        inptr++
      loop
    until ^inptr
    len = 0
    while ^(inptr + len) > ' ' // Tokenize characters
      len++
    loop
    if len == 1 and ^inptr == '(' // Check for nested comment
      comment++
    fin
    if comment
      if len == 1 and ^inptr == ')' // Check for nested uncomment
        comment--
      fin
      inptr = inptr + len
      len   = 0
    fin
  until len
  tokptr = inptr
  inptr  = inptr + len
  return tokptr, len
end
//
// Find match in dictionary
//
def find(matchchars, matchlen)#1
  word dentry
  byte len, i

  matchchars--
  dentry = vlist
  while dentry
    len = ^dentry & len_mask
    if len == matchlen
      for i = 1 to len
        if ^(matchchars+i) <> ^(dentry+i)
          break
        fin
      next
      if i > len
        //puts("[Found name = "); puts(dentry); puts("]\n")
        return dentry
      fin
    fin
    dentry = *(dentry + len + 1)
  loop
  // Not found
  return 0
end
//
// Convert input into number
//
def isnum(numchars, numlen)#2
  word num, sign
  byte numchar

  sign = 1
  if ^numchars == '-'
    sign = -1
    numchars++
    numlen--
    if numlen == 0
      return 0, 0
    fin
  fin
  num = 0
  if ^numchars == '$'
    numchars++
    numlen--
    if numlen == 0
      return 0, 0
    fin
    while numlen
      numchar = toupper(^numchars)
      if numchar >= '0' and numchar <= '9'
        num = num * 16 + numchar - '0'
      elsif numchar >= 'A' and numchar <= 'F'
        num = num * 16 + numchar - 'A' + 10
      else
        break
      fin
      numchars++
      numlen--
    loop
  else
    while numlen
      numchar = ^numchars
      if numchar < '0' or numchar > '9'
        break
      fin
      num = num * 10 + numchar - '0'
      numchars++
      numlen--
    loop
  fin
  //puts("[Found number = "); puti(num); puts("]\n")
  return num * sign, numlen == 0
end
//
// Execute code in CFA
//
def execword(dentry)#0
  char l

  if ^$C000 == $83 // CTRL-C
    _abort_
  fin
  if trace
    l = ^dentry
    ^dentry = l & len_mask
    puts(": "); puts(dentry); putln
    ^dentry = l
  fin
  W = _cfa_(dentry)
  (*W)()#0
end
def execwords(wlist)#0
  word prevIP

  prevIP = IIP
  IIP = wlist
  while *IIP
    execword(*IIP)
    IIP = IIP + 2
  loop
  IIP = prevIP
end
//
// Word entry routines
//
def _dovar_#1
  return W + 2
end
def _doconst_#1
  return *(W + 2)
end
def _docolon_#0
  //puts("DOCOLON:\n")
  execwords(W + 2)
end
def _pushPFA_#1
  return W + 2
end
def _dodoes_(words)#0
  //puts("DODOES:\n")
  (@_pushPFA_)()#0 // Stack hacks
  execwords(words)
end
//
// Intrinsics
//
def _drop_(a)#0
  return
end
def _swap_(a,b)#2
  return b,a
end
def _dup_(a)#2
  return a,a
end
def _add_(a,b)#1
  return a+b
end
def _sub_(a,b)#1
  return a-b
end
def _mul_(a,b)#1
  return a*b
end
def _div_(a,b)#1
  return a/b
end
def _cset_(a,b)#0
  ^b=a
end
def _wset_(a,b)#0
  *b=a
end
def _cget_(a)#1
  return ^a
end
def _wget_(a)#1
  return *a
end
def _lfa_(dentry)#1
  char l

  l = ^dentry & len_mask
  return dentry + l + 1
end
def _cfa_(dentry)#1
   char l

  l = ^dentry & len_mask
 return dentry + l + 3
end
def _pfa_(dentry)#1
   char l

  l = ^dentry & len_mask
 return dentry + l + 5
end
def _tors_(a)#0
  RSP--
  RSTACK[RSP] = a
end
def _fromrs_#1
  RSP++
  return RSTACK[RSP - 1]
end
def _toprs_#1
  return RSTACK[RSP]
end
def _filldoes_#0
  *(_cfa_(vlist)) = IIP + 4
end
def _lit_#1
  IIP = IIP + 2
  return *IIP
end
def _create_#0
  word bldptr, plist, namechars, namelen

  namechars, namelen = toknext
  plist = vlist
  vlist  = heapmark
  ^vlist = namelen
  bldptr = vlist + 1
  while namelen
    ^bldptr = ^namechars
    bldptr++
    namechars++
    namelen--
  loop
  *bldptr = plist;
  bldptr  = bldptr + 2
  heapalloc(bldptr - vlist + 2)
end
def _does_#0
  *(heapalloc(2)) = @d_filldoes
  *(heapalloc(2)) = 0
  // Build PLASMA bytecode routine
  ^(heapalloc(1)) = (@divmod)->0 // JSR INTERP
  *(heapalloc(2)) = (@divmod)=>1
  ^(heapalloc(1)) = $2C        // CONSTANT WORD
  *(heapalloc(2)) = heapmark + 6
  ^(heapalloc(1)) = $54        // CALL _dodoes_
  *(heapalloc(2)) = @_dodoes_
  ^(heapalloc(1)) = $5C        // RET
end
def _pset_(a)#0
  *(heapalloc(2)) = a
end
def _var_(a)#0
  _create_
  *(_cfa_(vlist)) = @_dovar_
  *(heapalloc(2)) = a
end
def _const_(a)#0
  _create_
  *(_cfa_(vlist)) = @_doconst_
  *(heapalloc(2)) = a
end
def _colon_#0
  state = comp_flag
  _create_
  *(_cfa_(vlist)) = @_docolon_
end
def _semi_#0
  if state == comp_flag
    *(heapalloc(2)) = 0
    state = 0
  fin
end
def _immediate_#0
  ^vlist = ^vlist | imm_flag
end
def _tick_#1
  return find(toknext)
end
def _forget_#0
  word dentry

  dentry = find(toknext)
  if dentry
    heaprelease(dentry)
  fin
end
def _bye_#0
  state = state | exit_flag
end
def _show_#0
  word dentry, pfa, w
  char l, f

  dentry = find(toknext)
  if dentry
    if *_cfa_(dentry) == @_docolon_
      pfa = _pfa_(dentry)
    else
      pfa = *_cfa_(dentry) + 10
    fin
    w = *pfa
    while w
      f = ^w
      l = f & len_mask
      ^w = l
      puts("  "); puts(w); putln
      ^w = f
      pfa = pfa + 2
      w = *pfa
    loop
  fin
end
def _tron_#0
  trace = 1
end
def _troff_#0
  trace = 0
end
def _vlist_#0
  word d
  char f, l

  d = vlist
  while d
    f = ^d
    l = f & len_mask
    ^d = l
    puts(d); puts("  ")
    ^d = f
    d = *(d + l + 1)
  loop
end
//
// Warm start
//
def _warmstart_#0
  (@_reset_estack)()#0
  RSP = RSTK_SIZE
  ^inptr = 0
  infunc = @keyin
  if state // Undo compilation state
    heaprelease(vlist)
    vlist = *_lfa_(vlist)
    state = 0
  fin
end
//
// Cold start
//
def _coldstart_#0
  vlist = @d_vlist
  state = 0
  heaprelease(startheap)
  _warmstart_
end
//
// Quit and look for user input
//
def _quit_#0
  word dentry, __isnum
  word inchars
  byte inlen, i

  __isnum = @isnum
  //
  // Set flags on words
  //
  d_semi = d_semi | imm_flag
  d_does = d_does | imm_flag
  repeat
    inchars, inlen = toknext
    dentry = find(inchars, inlen)
    if dentry
      if (not state & comp_flag) or (^dentry & imm_flag)
        execword(dentry)
      else
        _pset_(dentry)
      fin
    elsif not __isnum(inchars, inlen)#1
      _warmstart_
      puts("? No match\n")
    elsif state & comp_flag
      _pset_(@d_lit)
      (*(@_pset_))()#0 // Poke literal value on stack into PFA
    fin
  until state & exit_flag
end
//
// Abort
//
def _abort_#0
  _warmstart_
  puts("Abort\n")
  _quit_
end

puts("PLFORTH WIP")
startheap = heapmark
_warmstart_
_quit_
done
